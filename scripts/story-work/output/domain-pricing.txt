‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
DOMAIN: pricing
Total Stories: 10
Generated: dim. 18 janv. 2026 12:03:02 EST
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #107: [FRONTEND] [STORY] Rules: Enforce Location Restrictions and Service Rules for Products ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/107
File: ./scripts/story-work/frontend/107/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:pricing
- status:draft

### Recommended
- agent:pricing-domain-agent
- agent:story-authoring

### Blocking / Risk
- risk:incomplete-requirements

**Rewrite Variant:** pricing-strict

---

# 1. Story Header

## Title
[FRONTEND] [STORY] Enforce Product Restriction Rules by Location/Service Context with Override Modal (Pricing)

## Primary Persona
Service Advisor (primary); Shop Manager (for overrides and rule management)

## Business Value
Prevent unsafe/incompatible/regulatory-noncompliant products from being added/finalized in POS flows, while enabling controlled exceptions with auditable override records.

---

# 2. Story Intent

## As a / I want / So that
**As a** Service Advisor,  
**I want** the POS UI to evaluate product restriction rules when I add or finalize items,  
**so that** restricted products are blocked (or require a manager override) and all decisions are traceable.

## In-scope
- Frontend integration with Pricing restriction evaluation API when adding/editing line items and when finalizing/committing.
- UI handling of restriction decisions per line item: `ALLOW`, `BLOCK`, `ALLOW_WITH_OVERRIDE`, and degraded state `RESTRICTION_UNKNOWN`.
- Override modal flow (permission-gated) calling Pricing override API and storing `overrideId` onto the line item context (frontend state + submission payload to downstream flow where applicable).
- Rule management screens for Shop Manager: create/view/update/deactivate `RestrictionRule` via Pricing service (Moqui screens/forms/transitions).
- Display rule match reasons (`reasonCodes`, `ruleIds`) in user-facing messages (non-sensitive).

## Out-of-scope
- Authoring/maintaining the ‚Äúinitial enum sets‚Äù for location/service tags beyond consuming them.
- Implementing backend rule evaluation, override approval, or audit/event emission (assumed provided by Pricing service).
- Workexec backend changes (this story only ensures frontend passes context and consumes responses).
- Caching restriction rules client-side (backend allows optional caching; frontend will not implement rule cache beyond normal HTTP caching semantics).

---

# 3. Actors & Stakeholders
- **Service Advisor:** adds products to estimate/quote/work order/invoice; sees blocks/warnings and cannot finalize when restricted/unknown.
- **Shop Manager:** can override restrictions (permission `pricing:restriction:override`), and manages restriction rules (create/update/deactivate).
- **Pricing Service (SoR):** owns `RestrictionRule` and `OverrideRecord`; provides evaluation + override APIs.
- **Workexec (consumer):** receives line items + `overrideId` (where applicable) and may provide optional service context tags.

---

# 4. Preconditions & Dependencies
- User is authenticated; roles/permissions are available to frontend (Moqui user context / permissions).
- Current operational context is available in UI state:
  - `tenantId`, `locationId`
  - service context tag (`serviceTag`) depending on flow (ESTIMATE/WORKORDER/INVOICE/POS_SALE/DELIVERY)
  - optional `customerAccountId`
  - optional context info (`vehicleType`, `workType`, `salesChannel`) if available in the POS flow
- Pricing service endpoints available:
  - `POST /pricing/v1/restrictions:evaluate`
  - `POST /pricing/v1/restrictions:override`
  - CRUD endpoints for restriction rules (exact paths TBD; see Open Questions)
- Product line item contains or can derive: `productId`, `quantity`, `uom`, `unitPrice` for evaluation request.

---

# 5. UX Summary (Moqui-Oriented)

## Entry points
1. **POS transaction flows** (estimate/quote builder, work order editor, invoice finalize, counter sale cart):
   - On ‚ÄúAdd item‚Äù and ‚ÄúEdit quantity/price/uom‚Äù actions.
   - On ‚ÄúFinalize/Commit‚Äù actions (invoice finalize / checkout / commit sale).
2. **Admin/Manager area**:
   - ‚ÄúPricing ‚Üí Restriction Rules‚Äù list screen
   - ‚ÄúCreate Restriction Rule‚Äù screen
   - ‚ÄúEdit Restriction Rule‚Äù screen (including deactivate)

## Screens to create/modify (Moqui)
- **Modify existing transaction screens** (names depend on repo conventions):
  - Add restriction status indicator and actions per line item.
  - Hook transitions to call evaluation service on relevant triggers.
- **New screen set** (suggested pathing):
  - `apps/pos/screen/pricing/restriction/RestrictionRuleList.xml`
  - `apps/pos/screen/pricing/restriction/RestrictionRuleDetail.xml`
  - `apps/pos/screen/pricing/restriction/RestrictionRuleEdit.xml`
  - `apps/pos/screen/pricing/restriction/RestrictionRuleCreate.xml`
- **Modal**:
  - Override modal component used from transaction line item UI when decision allows/needs override.

## Navigation context
- POS transaction area remains primary context; restriction checks should not navigate away.
- Manager rule management screens live under Pricing admin navigation, require manage permission (see Business Rules).

## User workflows
### Happy path (ALLOW)
1. Service Advisor adds product.
2. UI calls evaluate API with context + items.
3. Response `ALLOW`: item remains in cart/quote; no extra UI required.

### Blocked path (BLOCK)
1. Service Advisor adds product.
2. Evaluate returns `BLOCK` with reasons.
3. UI prevents item addition OR marks item blocked and disallows proceeding (see Functional Behavior).
4. If override is allowed by backend semantics, UI may show ‚ÄúRequest override‚Äù action but only if user has permission.

### Override path (ALLOW_WITH_OVERRIDE or BLOCK with override allowed)
1. UI shows restriction message and ‚ÄúOverride‚Äù action.
2. Shop Manager opens modal, enters reason code + notes (+ second approver if required).
3. UI calls override API; on `APPROVED` receives `overrideId`.
4. UI updates line item to allowed state and stores `overrideId` on line item metadata.

### Degraded path (evaluation unavailable in non-commit flows)
1. Evaluate fails due to timeout/error.
2. UI allows adding item but marks `RESTRICTION_UNKNOWN`.
3. Finalize action is blocked until evaluation succeeds.

---

# 6. Functional Behavior

## Triggers
- **T1 Add line item**: when user adds a product to cart/quote/work order.
- **T2 Edit line item**: quantity/uom/unitPrice changes for existing item.
- **T3 Pre-finalize/commit**: when user clicks finalize/commit (invoice finalize / checkout / commit sale).
- **T4 Manager rule CRUD**: list/create/update/deactivate restriction rules.

## UI actions
### Transaction line item evaluation
- On T1/T2:
  - Call evaluate API with current context and the affected item(s).
  - Update each line item with:
    - `restrictionDecision` (ALLOW/BLOCK/ALLOW_WITH_OVERRIDE/RESTRICTION_UNKNOWN)
    - `restrictionReasonCodes[]`
    - `restrictionRuleIds[]`
    - `restrictionPolicyVersion` (if returned)
    - `restrictionConfidence` (if returned; otherwise `AUTHORITATIVE` assumed only if call succeeded)
- If decision is `BLOCK`:
  - UI must prevent finalize.
  - UI must clearly indicate why (message including reason codes).
  - UI must not silently remove item without informing user.
- If decision is `ALLOW_WITH_OVERRIDE`:
  - UI must prevent finalize until override is approved OR item removed.
  - Show ‚ÄúOverride‚Äù action only if user has permission `pricing:restriction:override`.
- If decision is `ALLOW`:
  - UI proceeds normally.

### Override modal
- Launch condition: line item decision `ALLOW_WITH_OVERRIDE` (and optionally `BLOCK` where backend indicates override possible; see Open Questions).
- Fields collected:
  - `overrideReasonCode` (required; from enum list supplied by backend or configured list‚Äîsee Open Questions)
  - `notes` (required free text)
  - `secondApprover` (optional; shown only if required by API response / rule metadata‚Äîsee Open Questions)
- On submit:
  - Call override API.
  - On `APPROVED`:
    - attach `overrideId` to line item
    - set decision to `ALLOW` (but retain audit display info: ruleIds/reasonCodes/overrideId)
  - On `DENIED` or error: keep item restricted and show error.

### Pre-finalize/commit behavior
- On T3, UI must ensure **authoritative evaluation** was performed successfully for all line items:
  - If any item is `RESTRICTION_UNKNOWN` ‚Üí block finalize with message: ‚ÄúRestrictions must be evaluated before finalizing.‚Äù
  - If any item is `BLOCK` ‚Üí block finalize.
  - If any item is `ALLOW_WITH_OVERRIDE` without `overrideId` ‚Üí block finalize.
- If evaluation API is unavailable during T3:
  - Fail closed: block finalize and show message per backend guidance: ‚ÄúRestriction service unavailable; cannot complete transaction.‚Äù

### Rule management (Shop Manager)
- List rules with filters: active/inactive, conditionType, conditionValue, effective date.
- Create rule:
  - select conditionType, conditionValue (from allowed enums)
  - choose one or more productIds (product picker)
  - set active flag and effectiveFrom/effectiveTo
  - save via Pricing service
- Edit rule:
  - update fields per backend constraints (historical/versioning handled by backend)
  - deactivate rule (set inactive)

## State changes (frontend-owned)
- Line item local state gains restriction metadata + overrideId.
- Transaction-level ‚ÄúcanFinalize‚Äù derived from line item restriction states.

## Service interactions
- Evaluate: `POST /pricing/v1/restrictions:evaluate`
- Override: `POST /pricing/v1/restrictions:override`
- Rule CRUD: Pricing service endpoints (TBD).

---

# 7. Business Rules (Translated to UI Behavior)

## Validation
- Do not allow override submission unless:
  - user has permission `pricing:restriction:override`
  - `overrideReasonCode` is provided
  - `notes` is non-empty (trimmed length > 0)
  - `secondApprover` provided if backend indicates required
- When creating/editing restriction rules:
  - enforce required fields client-side (name, conditionType, conditionValue, product list, effectiveFrom)
  - conditionType/value must be selected from enumerated sets (no free-form)
  - effectiveFrom <= effectiveTo when effectiveTo present

## Enable/disable rules
- Disable ‚ÄúFinalize‚Äù when any line item state is not finalizable as described in Functional Behavior.
- Disable ‚ÄúOverride‚Äù action when user lacks permission or line item decision is not override-eligible.

## Visibility rules
- Restriction reason message visible when decision != ALLOW.
- Override modal action visible only when override-eligible and user has permission.
- Rule management screens visible only to users with `pricing:pricebook:manage` or a dedicated permission for restriction rules (see Open Questions).

## Error messaging expectations
- BLOCK/ALLOW_WITH_OVERRIDE must show a clear message including product identifier/name and reason codes.
- Service unavailable messages must match backend-specified text on commit paths.

---

# 8. Data Requirements

## Entities involved (frontend perspective)
- Pricing-owned:
  - `RestrictionRule`
  - `OverrideRecord` (read-only display / returned by override)
  - `AuditLog` (read-only; may be exposed via Pricing service)
- Transaction line item (Workexec/POS context): stores `overrideId` reference.

## Fields
### Restriction evaluation request (per backend reference)
- `tenantId` (UUID, required)
- `locationId` (UUID, required)
- `serviceTag` (enum string, required)
- `customerAccountId` (UUID, optional)
- `items[]` (required, non-empty)
  - `productId` (UUID, required)
  - `quantity` (decimal, required > 0)
  - `uom` (string, required)
  - `unitPrice` (decimal, required; do not assume rounding)
- `context` (object, optional)
  - `vehicleType` (string, optional)
  - `workType` (string, optional)
  - `salesChannel` (string, optional)

### Restriction evaluation response (minimum needed)
Per item:
- `decision` enum: `ALLOW` | `BLOCK` | `ALLOW_WITH_OVERRIDE`
- `ruleIds[]` (UUIDs)
- `reasonCodes[]` (strings/enums)
- optional: `confidence`, `policyVersion`

### Override request
- `tenantId`, `locationId` (if required by backend; TBD)
- `transactionId` (UUID, required)
- `productId` (UUID, required)
- `ruleId` (UUID, required if overriding specific rule; TBD if multiple)
- `overrideReasonCode` (enum string, required)
- `notes` (string, required)
- `secondApprover` (UUID, optional/conditional)
- `policyVersion` (int, optional/conditional)

### Override response
- `status` enum: `APPROVED` | `DENIED`
- `overrideId` (UUID) when approved

## Read-only vs editable
- In transaction UI, restriction decision fields are read-only (derived from service).
- `overrideId` is set by UI after approved override; cannot be manually edited.

## Derived/calculated fields
- `transaction.canFinalize = all(lineItems.finalizable)`
- `lineItem.finalizable` derived:
  - `ALLOW` => true
  - `BLOCK` => false
  - `ALLOW_WITH_OVERRIDE` => true only if `overrideId` present
  - `RESTRICTION_UNKNOWN` => false

---

# 9. Service Contracts (Frontend Perspective)

## Load/view calls
- On transaction screen load: may optionally evaluate all existing items (recommended) to populate restriction states.
- Rule list/detail: call Pricing rule list/get endpoints (TBD).

## Create/update calls
- Create restriction rule: POST to Pricing rule endpoint (TBD).
- Update restriction rule: PUT/PATCH (TBD).
- Deactivate: PATCH `isActive=false` or a deactivate endpoint (TBD).

## Submit/transition calls
- Evaluate restrictions:
  - Endpoint: `POST /pricing/v1/restrictions:evaluate`
  - Timeout handling: treat >800ms as unavailable for UX purposes; no synchronous retries on commit path.
- Override:
  - Endpoint: `POST /pricing/v1/restrictions:override`
  - On success: update UI and attach overrideId to line item.

## Error handling expectations
- HTTP 4xx: show validation/permission error; keep item in restricted state.
- HTTP 503/timeout:
  - Non-commit: set `RESTRICTION_UNKNOWN`, allow adding/editing but block finalize.
  - Commit: block action with message ‚ÄúRestriction service unavailable; cannot complete transaction.‚Äù
- Conflict between cached/previous evaluation and authoritative: always use latest API result.

---

# 10. State Model & Transitions

## Allowed states (line item restriction state)
- `ALLOW`
- `BLOCK`
- `ALLOW_WITH_OVERRIDE`
- `RESTRICTION_UNKNOWN` (frontend-local degraded state)

## Role-based transitions
- Service Advisor:
  - can trigger evaluation
  - cannot override without permission
- Shop Manager (or anyone with `pricing:restriction:override`):
  - can transition `ALLOW_WITH_OVERRIDE` ‚Üí `ALLOW` by creating an approved override (overrideId stored)
- Admin/Shop Manager with rule manage permission:
  - can create/update/deactivate restriction rules (separate screen set)

## UI behavior per state
- `ALLOW`: normal
- `BLOCK`: highlight as blocked; disallow finalize; show remove item action
- `ALLOW_WITH_OVERRIDE`: show ‚ÄúOverride‚Äù action if permitted; disallow finalize until override approved
- `RESTRICTION_UNKNOWN`: warning state; disallow finalize; show ‚ÄúRetry evaluation‚Äù action

---

# 11. Alternate / Error Flows

## Validation failures
- Override submitted without reason/notes ‚Üí inline field errors; do not call API.
- Rule create/edit missing required fields ‚Üí inline errors.

## Concurrency conflicts
- If rule updated between evaluation and override and backend rejects due to policyVersion mismatch:
  - show error ‚ÄúRestriction policy changed; re-evaluate required.‚Äù
  - force re-evaluate before allowing another override attempt.

## Unauthorized access
- If user without permission attempts override:
  - UI hides action; if forced (deep link) then backend 403 shown; keep blocked.

## Empty states
- Rule list empty: show ‚ÄúNo restriction rules found‚Äù and CTA ‚ÄúCreate rule‚Äù (if permitted).
- Evaluation returns no rules and ALLOW: no special UI.

---

# 12. Acceptance Criteria

```gherkin
Scenario: Line item is blocked due to a location-based restriction
  Given I am a Service Advisor in a location tagged "RETAIL_STORE"
  And the current serviceTag is "ESTIMATE"
  When I add a product to the estimate
  And the frontend calls POST /pricing/v1/restrictions:evaluate with tenantId, locationId, serviceTag, and the product line item
  Then the UI reflects the returned decision "BLOCK" for that line item
  And the UI shows a user-facing restriction message including the reasonCodes
  And the UI prevents finalizing the estimate while the blocked item remains

Scenario: Line item is allowed when no restriction applies
  Given I am a Service Advisor in a location tagged "WAREHOUSE"
  When I add a product to the estimate
  And the evaluation response decision is "ALLOW"
  Then the item remains added with restriction state "ALLOW"
  And the UI allows finalizing provided all other items are finalizable

Scenario: Override modal is available only to authorized users
  Given a line item has decision "ALLOW_WITH_OVERRIDE"
  And I am logged in without permission "pricing:restriction:override"
  Then the UI does not show the Override action
  And attempting to proceed to finalize remains blocked due to the override-required item

Scenario: Authorized user successfully overrides a restriction and overrideId is stored
  Given a line item has decision "ALLOW_WITH_OVERRIDE"
  And I am logged in with permission "pricing:restriction:override"
  When I open the override modal
  And I enter overrideReasonCode "MANAGER_APPROVAL" and notes "Customer approved special order"
  And I submit and the frontend calls POST /pricing/v1/restrictions:override
  And the override response returns status "APPROVED" and an overrideId
  Then the UI stores overrideId on the line item
  And the line item becomes finalizable
  And the UI allows finalizing if no other line items are blocking

Scenario: Evaluation service unavailable during quote building marks item as unknown and blocks finalize
  Given I am building an estimate (non-commit path)
  When the frontend calls POST /pricing/v1/restrictions:evaluate and receives a timeout or 503
  Then the UI allows the item to remain in the estimate
  And marks the line item restriction state as "RESTRICTION_UNKNOWN"
  And the UI blocks finalizing until a successful evaluation occurs

Scenario: Evaluation service unavailable during commit fails closed
  Given I am finalizing an invoice (commit path)
  When the frontend attempts to evaluate restrictions and receives a timeout or 503
  Then the UI blocks the finalize action
  And displays the message "Restriction service unavailable; cannot complete transaction."

Scenario: Shop Manager can manage restriction rules
  Given I am logged in with the restriction rule manage permission
  When I navigate to Pricing > Restriction Rules
  Then I can view a list of RestrictionRules
  And I can create a new rule by selecting conditionType/value from enums and selecting one or more products
  And saving calls the Pricing service rule create endpoint and shows the new rule in the list
```

---

# 13. Audit & Observability

## User-visible audit data
- On line item with restriction decision != ALLOW, user can view:
  - decision
  - reasonCodes
  - ruleIds
  - (if overridden) overrideId and override status

## Status history
- Rule management screens show (if provided by API):
  - createdAt/createdBy, updatedAt/updatedBy, policyVersion, isActive, effectiveFrom/effectiveTo

## Traceability expectations
- Frontend includes correlation/request ID headers per workspace convention (if established) when calling Pricing APIs.
- Log (frontend console/logger) structured events for:
  - `restriction.evaluate.requested` / `.succeeded` / `.failed`
  - `restriction.override.requested` / `.succeeded` / `.failed`
  - include transactionId, productId(s), decision, and error category (avoid PII in notes)

---

# 14. Non-Functional UI Requirements
- **Performance:** evaluation call should not block UI thread; show loading indicator per line item; commit path must surface timeout quickly (<= ~800ms + UI overhead).
- **Accessibility:** modal fields labeled; errors announced; keyboard navigable; focus trapping in modal.
- **Responsiveness:** works on tablet widths typical for POS.
- **i18n/timezone/currency:** do not hardcode tag labels; display enum labels via mapping table; no assumptions on currency formatting for unitPrice beyond existing POS formatting.

---

# 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Rule list shows standard empty state with permitted CTA; qualifies as safe UI ergonomics; impacts UX Summary, Alternate/Empty states.
- SD-UX-LOADING-INDICATOR: Per-line-item loading state during evaluation; safe ergonomics; impacts Functional Behavior, Error Flows.
- SD-ERR-HTTP-GENERIC: Map unknown 5xx to generic ‚ÄúService unavailable‚Äù while preserving backend message when provided; safe error-handling; impacts Service Contracts, Alternate/Error Flows.

---

# 16. Open Questions
1. What are the exact Pricing service endpoints for `RestrictionRule` CRUD (list/get/create/update/deactivate), including request/response schemas?
2. What permission(s) gate restriction rule management screens? (Backend doc lists several pricing permissions but not a dedicated `pricing:restriction:manage`.)
3. For overrides: can `BLOCK` ever be override-eligible, or is override only via `ALLOW_WITH_OVERRIDE`? If `BLOCK` can be overridden, how does the evaluate response indicate that?
4. What is the authoritative list of `overrideReasonCode` values and how should the UI fetch it (enum endpoint vs static config)?
5. Override API request shape: does it require `ruleId` when multiple rules match a product? If so, does UI choose one, or does backend accept multiple ruleIds?
6. Where in the POS frontend is `transactionId` guaranteed to exist at add-item time (estimate draft vs persisted)? If not persisted yet, should override be disabled until transaction is persisted?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Rules: Enforce Location Restrictions and Service Rules for Products ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/107

Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Rules: Enforce Location Restrictions and Service Rules for Products

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Shop Manager**, I want restriction rules so that unsafe or incompatible items are not sold/installed.

## Details
- Block based on location tags or service type.
- Override requires permission + rationale.

## Acceptance Criteria
- Restrictions enforced in pricing/quote APIs.
- Override permission required.
- Decision recorded in trace.

## Integrations
- Workexec receives warnings/errors; shopmgr provides service context tags (optional).

## Data / Entities
- RestrictionRule, OverrideRecord, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Product / Parts Management


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #114: [FRONTEND] [STORY] Workexec: Persist Immutable Pricing Snapshot for Estimate/WO Line ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/114
File: ./scripts/story-work/frontend/114/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:pricing
- status:draft

### Recommended
- agent:pricing-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** pricing-strict

STOP: Clarification required before finalization

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Pricing: View Immutable Pricing Snapshot Drilldown from Estimate/WO Line (Moqui UI)

### Primary Persona
Service Advisor (primary), Accountant/Auditor (secondary, read-only)

### Business Value
Enable users to **inspect and explain historical line pricing** via an immutable snapshot drilldown so that later pricing rule changes do not create confusion, disputes, or audit gaps.

---

## 2. Story Intent

### As a / I want / So that
- **As a** Service Advisor  
- **I want** to open a read-only ‚ÄúPricing Snapshot‚Äù drilldown from an Estimate/Work Order line  
- **So that** I can explain how the price was calculated at the time the line was created and trust that the data is immutable.

### In-scope
- Moqui frontend screens to **retrieve and display** a `PricingSnapshot` by `snapshotId`.
- A drilldown entry point from an Estimate line and/or Work Order line UI (link/button) that opens the snapshot view.
- Read-only presentation of snapshot fields: prices at time, cost-at-time, MSRP-at-time, applied rules trace, timestamps, policy identifiers/versioning.
- Error handling UX when snapshot cannot be loaded (not found, unauthorized, service down).
- Basic permission gating in UI (show/hide drilldown action and handle 403).

### Out-of-scope
- Creating snapshots (triggered on quote/booking) and enforcing immutability (backend responsibility).
- Editing/updating/deleting snapshots (explicitly forbidden).
- Workexec line creation flow changes (e.g., ‚Äúhard-fail add line if snapshot creation fails‚Äù) unless already implemented elsewhere.
- Any visualization beyond structured read-only drilldown (charts, exports) unless specified.
- Accounting reporting consumption.

---

## 3. Actors & Stakeholders
- **Service Advisor:** needs to understand and justify line price.
- **Shop Manager:** may review overrides/rules applied.
- **Accountant/Auditor (read-only):** needs traceability for audits.
- **System (Pricing service via Moqui):** serves snapshot data.

---

## 4. Preconditions & Dependencies
- An Estimate or Work Order line exists in Workexec UI and has a non-empty `pricingSnapshotId` (aka `snapshotId`) associated.
- Pricing backend exposes a snapshot retrieval endpoint (reference backend story indicates):  
  `GET /pricing/v1/snapshots/{snapshotId}` returning full breakdown.
- Authentication is configured for Moqui to call the Pricing API.
- Authorization policy exists for who may view snapshots (permission name TBD; see Open Questions).

Dependencies:
- Pricing backend story: `[BACKEND] [STORY] Workexec: Persist Immutable Pricing Snapshot for Estimate/WO Line` (durion-positivity-backend #50) for API semantics and response shape.

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- From **Estimate detail** screen: each line item row exposes an action ‚ÄúView pricing snapshot‚Äù.
- From **Work Order detail** screen: each line item row exposes an action ‚ÄúView pricing snapshot‚Äù.

### Screens to create/modify
1. **New Screen:** `apps/pos/screen/pricing/snapshot/PricingSnapshotView.xml` (or workspace-standard path)  
   - Purpose: read-only drilldown for a single snapshot.
2. **Modify Screen(s):**
   - Estimate detail screen (Workexec) to add drilldown action if `pricingSnapshotId` present.
   - Work Order detail screen (Workexec) to add drilldown action if `pricingSnapshotId` present.

> Note: exact screen locations/paths in this repo are unknown from inputs; implementer should align with existing Durion frontend Moqui screen structure.

### Navigation context
- Drilldown opens either:
  - in a **dialog** (preferred for quick return), or
  - in a dedicated route `/pricing/snapshots/{snapshotId}` with ‚ÄúBack to document‚Äù navigation.
- The view must display document context if provided by the API (`sourceContext` JSON) but must not require it.

### User workflows
**Happy path**
1. User views an estimate/WO.
2. User clicks ‚ÄúView pricing snapshot‚Äù on a line.
3. System loads snapshot.
4. User sees immutable pricing breakdown and applied rule trace.

**Alternate paths**
- If line has no snapshot ID: action hidden/disabled with tooltip ‚ÄúNo snapshot available‚Äù.
- If API returns 404: show ‚ÄúSnapshot not found‚Äù and guidance to contact support.
- If 403: show ‚ÄúNot authorized to view pricing details‚Äù.
- If network/service unavailable: show ‚ÄúPricing snapshot service unavailable; try again‚Äù.

---

## 6. Functional Behavior

### Triggers
- User clicks drilldown action for a document line with `pricingSnapshotId`.

### UI actions
- Fetch snapshot by `snapshotId`.
- Render read-only sections:
  - Snapshot metadata
  - Price components
  - Applied rules trace
  - Policy/version identifiers
  - Raw context (optional collapsible JSON)

### State changes
- No domain state changes (read-only).  
- Local UI state: loading, loaded, error.

### Service interactions
- Moqui calls Pricing API to retrieve snapshot (see Service Contracts).
- No caching policy specified (safe default: allow short-lived client-side caching within the view instance only).

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- `snapshotId` must be present and non-empty before attempting drilldown call.
- `snapshotId` must be treated as opaque identifier (no parsing).

### Enable/disable rules
- Drilldown action:
  - **Enabled** only when `pricingSnapshotId` exists on the line.
  - **Disabled/hidden** when missing.

### Visibility rules
- If user lacks required permission (TBD), hide the action or show disabled with ‚ÄúInsufficient permissions‚Äù.
- On 403 from API, display an authorization error regardless of UI gating (defense in depth).

### Error messaging expectations
- Errors must be actionable and non-technical:
  - 404 ‚Üí ‚ÄúPricing snapshot not found.‚Äù
  - 403 ‚Üí ‚ÄúYou don‚Äôt have permission to view this pricing snapshot.‚Äù
  - 5xx/timeout ‚Üí ‚ÄúPricing snapshot service is unavailable right now. Please try again.‚Äù

---

## 8. Data Requirements

### Entities involved (frontend perspective)
- **Workexec Document Line** (EstimateLine / WorkOrderLine or equivalent)
  - Must contain `pricingSnapshotId` (string/UUID).
- **PricingSnapshot** (from Pricing API)
  - `snapshotId` (UUID/string)
  - `createdAt` (timestamp with timezone)
  - `sourceContext` (JSON object; optional)
  - `itemIdentifier` (string; SKU/part#/labor op)
  - `quantity` (number)
  - `prices` (JSON object; must include at least `finalPrice`; may include `msrp`, `cost`, etc.)
  - `appliedRules` (array of rule trace objects)
  - `policyVersion` (string)
  - Currency fields: **unclear** whether returned inside `prices` or separately (see Open Questions)

### Fields (type, required, defaults)
Because the frontend contract is API-driven and response schema is not fully specified in inputs, the UI must:
- Treat unknown fields as optional.
- Render required minimum:
  - `snapshotId` (required to view)
  - `createdAt` (required; if missing display ‚ÄúUnknown‚Äù)
  - `prices.finalPrice` (required; if missing show ‚ÄúUnavailable‚Äù and log client error)

### Read-only vs editable
- All snapshot fields are strictly **read-only**.

### Derived/calculated fields
- Extended price display (`unit * quantity`) must **not** be calculated unless explicitly provided by API (pricing formulas are denylisted for safe defaults). If API provides both unit and extended, display both; otherwise display only provided values.

---

## 9. Service Contracts (Frontend Perspective)

### Load/view calls
- **Operation:** Retrieve snapshot
- **HTTP:** `GET /pricing/v1/snapshots/{snapshotId}`
- **Inputs:**
  - `snapshotId` (path)
- **Success (200):**
  - Response JSON representing snapshot including pricing breakdown, rule outcomes, versioning, timestamps (per backend reference).
- **Not Found (404):**
  - Show snapshot-not-found UX.
- **Unauthorized/Forbidden (401/403):**
  - 401 ‚Üí prompt re-auth (existing app behavior)
  - 403 ‚Üí show not-authorized message; do not retry automatically.
- **Transient failure (408/5xx/network):**
  - Show service unavailable message with ‚ÄúRetry‚Äù action.

### Create/update calls
- None (out of scope; snapshots immutable).

### Submit/transition calls
- None.

### Error handling expectations
- Must propagate correlation/request IDs if Moqui provides them (log in console/server logs per project convention).
- Do not display raw stack traces or technical payloads to user.

---

## 10. State Model & Transitions

### Allowed states
UI state machine for snapshot view:
- `idle` (no snapshot selected)
- `loading`
- `loaded`
- `error:notFound`
- `error:forbidden`
- `error:unavailable`

### Role-based transitions
- If user lacks permission, transition directly to `error:forbidden` upon API response.

### UI behavior per state
- `loading`: show spinner/skeleton; disable close/back only if modal pattern requires.
- `loaded`: show content.
- `error:*`: show message + actions:
  - notFound: close/back
  - forbidden: close/back
  - unavailable: retry + close/back

---

## 11. Alternate / Error Flows

### Validation failures
- Missing `snapshotId` on line:
  - Drilldown action hidden/disabled.
  - If user somehow navigates directly to view with missing/invalid ID, show ‚ÄúInvalid snapshot reference‚Äù and do not call API.

### Concurrency conflicts
- Not applicable (read-only). If snapshot deleted (should not happen), treat as 404.

### Unauthorized access
- 401/403 handled as in Service Contracts; ensure no data renders from prior snapshot after a forbidden response (clear state on error).

### Empty states
- `appliedRules` empty or missing: show ‚ÄúNo pricing rules were applied‚Äù (wording must not imply discount policies).
- Missing optional fields: display ‚ÄúNot provided‚Äù rather than guessing.

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: Open snapshot drilldown from a Work Order line (happy path)
**Given** I am an authenticated Service Advisor  
**And** a Work Order line displays a non-empty `pricingSnapshotId`  
**When** I select ‚ÄúView pricing snapshot‚Äù for that line  
**Then** the system requests `GET /pricing/v1/snapshots/{pricingSnapshotId}`  
**And** I see the snapshot‚Äôs `snapshotId` and `createdAt`  
**And** I see the snapshot‚Äôs final price value as provided by the API  
**And** I see an applied rules section showing each returned rule trace item (or an empty-state message if none)

### Scenario 2: Drilldown action is unavailable when a line has no snapshot id
**Given** I am viewing an Estimate with line items  
**And** a line item has an empty or null `pricingSnapshotId`  
**Then** the ‚ÄúView pricing snapshot‚Äù action for that line is not available (hidden or disabled)  
**And** the UI does not attempt to call the snapshot API for that line

### Scenario 3: Snapshot not found (404)
**Given** I navigate to the snapshot view for snapshotId `S-DOES-NOT-EXIST`  
**When** the Pricing API responds with HTTP 404  
**Then** the UI shows a ‚ÄúPricing snapshot not found‚Äù error state  
**And** no stale snapshot data is displayed

### Scenario 4: Not authorized (403)
**Given** I attempt to view a pricing snapshot  
**When** the Pricing API responds with HTTP 403  
**Then** the UI shows a ‚ÄúNot authorized to view pricing snapshot‚Äù message  
**And** the UI does not show any snapshot details

### Scenario 5: Pricing service unavailable (timeout/5xx)
**Given** I attempt to view a pricing snapshot  
**When** the snapshot request times out or returns HTTP 5xx  
**Then** the UI shows ‚ÄúPricing snapshot service unavailable‚Äù  
**And** I can retry the request  
**And** on retry success the snapshot details render

---

## 13. Audit & Observability

### User-visible audit data
- Display `createdAt` and `policyVersion` (and any other version identifiers returned) as audit context.

### Status history
- Not applicable (snapshot is immutable; no lifecycle in UI).

### Traceability expectations
- Log (frontend/Moqui server logs per convention):
  - `snapshotId`
  - calling document context (estimateId/workOrderId, lineId) if available in UI state
  - HTTP status for failures
- Ensure correlation ID propagation if available from Moqui request context.

---

## 14. Non-Functional UI Requirements
- **Performance:** snapshot view should render within 1s after API response; show loading indicator immediately.
- **Accessibility:** drilldown action reachable via keyboard; dialog/screen has accessible title; error states announced to screen readers.
- **Responsiveness:** snapshot view usable on tablet widths typical for POS.
- **i18n/timezone/currency:**  
  - Display timestamps in user‚Äôs locale/timezone per app standard.  
  - Currency formatting must use currency code from API; if absent, do not guess currency (see Open Questions).

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide explicit empty-state messaging for missing `appliedRules` and optional fields; safe because it does not alter domain logic. Impacted sections: UX Summary, Error Flows, Acceptance Criteria.
- SD-UX-LOADING-STATE: Standard loading indicator during API call; safe UI ergonomics only. Impacted sections: State Model, UX Summary.
- SD-ERR-HTTP-MAP: Map 401/403/404/5xx to standard user-safe messages; safe because it follows HTTP semantics without inventing business rules. Impacted sections: Service Contracts, Error Flows.

---

## 16. Open Questions
1. **API schema:** What is the exact response payload for `GET /pricing/v1/snapshots/{snapshotId}` (field names and currency representation)? Specifically: are prices `unitPrice` vs `extendedPrice` provided, and what is the currency code field name?
2. **Permissions:** What permission/role gates viewing a snapshot in the UI? Is it a dedicated permission (e.g., `pricing:snapshot:view`) or inherited from document access?
3. **Entry point scope:** Should the drilldown be added to **both** Estimate and Work Order line UIs in this story, or only one (and which is priority)?
4. **Navigation pattern:** Should snapshot drilldown open as a modal dialog or a dedicated route/screen? Is there an existing project convention for drilldowns in this repo?
5. **Source context rendering:** Should `sourceContext` be shown to end users (collapsed) or hidden behind an ‚ÄúAdvanced‚Äù toggle, or omitted entirely?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Workexec: Persist Immutable Pricing Snapshot for Estimate/WO Line ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/114

====================================================================================================

FRONTEND STORY (FULL CONTEXT)

====================================================================================================

Title: [FRONTEND] [STORY] Workexec: Persist Immutable Pricing Snapshot for Estimate/WO Line  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/114  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Workexec: Persist Immutable Pricing Snapshot for Estimate/WO Line

**Domain**: user

### Story Description

/kiro  
# User Story  
## Narrative  
As a **System**, I want an immutable pricing snapshot per document line so that later price changes don‚Äôt alter history.

## Details  
- Snapshot includes price, cost-at-time, MSRP-at-time, applied rules, timestamp, policy decisions.

## Acceptance Criteria  
- Snapshot written on quote and/or booking.  
- Immutable.  
- Drilldown supported.

## Integrations  
- Workexec stores snapshotId on lines; Accounting may consume for margin reporting (optional).

## Data / Entities  
- PricingSnapshot, DocumentLineRef, PricingRuleTrace

## Classification (confirm labels)  
- Type: Story  
- Layer: Domain  
- Domain: Product / Parts Management

### Frontend Requirements
- Implement Vue.js 3 components with TypeScript  
- Use Quasar framework for UI components  
- Integrate with Moqui Framework backend  
- Ensure responsive design and accessibility

### Technical Stack
- Vue.js 3 with Composition API  
- TypeScript 5.x  
- Quasar v2.x  
- Moqui Framework integration

---  
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #115: [FRONTEND] [STORY] Workexec: Price Product for Estimate Line (Location + Customer Tier) ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/115
File: ./scripts/story-work/frontend/115/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:pricing
- status:draft

### Recommended
- agent:pricing-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** pricing-strict

STOP: Clarification required before finalization

---

# 1. Story Header

### Title
[FRONTEND] [STORY] Workexec: Price Product for Estimate Line (Location + Customer Tier)

### Primary Persona
Service Advisor

### Business Value
Ensure estimate line pricing shown in the POS/Workexec estimate builder is accurate, deterministic, and transparent (breakdown + warnings), so customers receive reliable quotes and advisors can proceed without manual recalculation.

---

# 2. Story Intent

### As a / I want / So that
- **As a** Service Advisor  
- **I want** the UI to retrieve and display an accurate price quote for a product line using location + customer tier context  
- **So that** estimate line pricing reflects applicable rules (base MSRP ‚Üí location override ‚Üí customer tier ‚Üí rounding) with a clear breakdown and any warnings.

### In-scope
- Frontend (Moqui screens) support to request a **Price Quote** for an estimate line item using:
  - `productId`, `quantity`, `locationId`, `customerTierId`, optional `effectiveTimestamp`
- Display returned:
  - MSRP, unit price, extended price
  - breakdown trace (ordered)
  - warnings
  - price source indicator (e.g., MSRP fallback)
- Error-handling UI for 400/404/500 from pricing quote.
- Performance-friendly UX patterns (debounce/retry messaging) without changing domain logic.

### Out-of-scope
- Creating/editing pricing rules, overrides, promotions, rounding policy.
- Inventory availability checks in the same call (explicitly discouraged in backend reference).
- Persisting pricing snapshots to an estimate/work order (that is a Workexec lifecycle concern; this story is quote retrieval/display only unless clarified).
- Customer tier management.

---

# 3. Actors & Stakeholders

- **Primary actor:** Service Advisor (POS user building an estimate)
- **System actors:**
  - Moqui frontend (this repo) as the UI layer
  - Pricing service/API (authoritative pricing calculation; system of record)
  - Workexec context provider (estimate builder flow provides estimateId, customer/location context) ‚Äî exact SoR unclear in frontend story input
- **Stakeholders:** Customer, dealership management, finance/audit teams (need traceable pricing)

---

# 4. Preconditions & Dependencies

### Preconditions
- User is authenticated in the POS UI.
- The estimate builder context provides (or can derive) the following before quoting:
  - `productId` selected for the line
  - `quantity` entered (>0)
  - `locationId`
  - `customerTierId`
  - optional `effectiveTimestamp` (if supported by UI flow)

### Dependencies
- **Pricing API** endpoint available: `POST /v1/price-quotes` (from backend story reference #51)
- Known error semantics:
  - `404 Not Found` for invalid product or no base price
  - `400 Bad Request` for invalid context/payload
  - `500` for server error
- Moqui frontend must have an HTTP client mechanism consistent with repo conventions (not provided in inputs).
- Workexec estimate UI location/route where line items are added/edited (not provided in inputs).

---

# 5. UX Summary (Moqui-Oriented)

### Entry points
- From Estimate Builder / Estimate Detail UI when:
  - adding a new estimate line item
  - editing an existing estimate line item‚Äôs product and/or quantity

### Screens to create/modify (Moqui)
- **Modify** the Estimate line edit/add screen(s) to:
  - Trigger a price quote fetch when product/qty/context changes
  - Render quote results, breakdown, and warnings
- **Potential new sub-screen/widget** (recommended for reuse):
  - `component://.../screen/Quote/PriceQuotePanel.xml` (name TBD by repo conventions)
  - Used inside line add/edit forms to show pricing results and diagnostics

> Open question: actual screen names/locations and component paths depend on existing repo structure and routing conventions (not included in provided inputs).

### Navigation context
- User remains on estimate line editor; quoting should not navigate away.
- Quote panel updates in-place.

### User workflows
**Happy path**
1. Service Advisor selects a product and enters quantity.
2. UI calls pricing quote API with productId/qty/locationId/customerTierId/effectiveTimestamp.
3. UI displays:
   - MSRP, unit price, extended price
   - priceSource (if present)
   - ordered breakdown entries
   - warnings (non-blocking)
4. Advisor saves/continues estimate editing (save is outside this story unless clarified).

**Alternate paths**
- Change quantity after quote ‚Üí UI refreshes quote.
- Missing/invalid context (e.g., no customer tier selected) ‚Üí UI blocks quote call and prompts user to fix input (exact behavior depends on whether customer tier is always available).
- API returns MSRP fallback indicator ‚Üí UI shows non-blocking notice.

---

# 6. Functional Behavior

### Triggers
- On line item form input changes:
  - `productId` change
  - `quantity` change
  - `locationId` change (if selectable in UI)
  - `customerTierId` change (if selectable/derived)
  - `effectiveTimestamp` change (if exposed)

### UI actions
- Validate required inputs locally before calling API:
  - productId present
  - quantity integer > 0
  - locationId present
  - customerTierId present
- Call price quote endpoint.
- Show loading state while awaiting response.
- On success:
  - Update displayed unit/ext price fields (read-only display)
  - Display breakdown list in returned order
  - Display warnings list (if any)
- On failure:
  - Show inline error banner with actionable message
  - Keep previous quote visible but marked ‚Äústale‚Äù OR clear it (must be clarified; see Open Questions)

### State changes (frontend)
- `quoteStatus`: idle | loading | success | error
- `quoteRequestHash`: derived from request fields to avoid racing responses (recommended)
- `quoteData`: last successful response
- `quoteError`: last error payload

### Service interactions
- Synchronous HTTP POST to pricing service:
  - `POST /v1/price-quotes`
- No other domain calls in this story.

---

# 7. Business Rules (Translated to UI Behavior)

> Pricing logic is authoritative in Pricing domain; UI must reflect it and not re-implement formulas.

### Validation
- Quantity must be an integer > 0:
  - Disable ‚ÄúGet price‚Äù (if a manual button exists) and/or skip auto-quote until valid.
- If required context missing (locationId/customerTierId):
  - UI must prevent calling API and display a clear prompt indicating what is missing.

### Enable/disable rules
- Quote fetch is enabled only when all required request fields are present and valid.
- While `loading`, disable repeated triggers (debounce) to avoid flooding API.

### Visibility rules
- Breakdown panel visible only after at least one successful quote OR when in error state with an explanatory message.
- Warnings visible only when provided and non-empty.

### Error messaging expectations
Map backend response classes to user-visible text:
- **400**: ‚ÄúCannot price this line: <validation message>‚Äù (display server-provided message if safe)
- **404**: ‚ÄúNo price found for this product in the current context.‚Äù Distinguish:
  - invalid product vs no base price if backend message indicates (do not guess otherwise)
- **500/Network**: ‚ÄúPricing service is currently unavailable. Try again.‚Äù

---

# 8. Data Requirements

### Entities involved (frontend view models)
- `PriceQuoteRequest` (request DTO)
- `PriceQuoteResponse` (response DTO)
- Optional: `PricingRuleTrace` (if represented as breakdown items)

### Fields (type, required, defaults)

**PriceQuoteRequest (UI ‚Üí API)**
- `productId: UUID` (required)
- `quantity: integer` (required, >0)
- `locationId: UUID` (required)
- `customerTierId: UUID` (required)
- `effectiveTimestamp: ISO-8601 datetime UTC` (optional; default omitted to let backend use now)

**PriceQuoteResponse (API ‚Üí UI)**
- `productId: UUID` (required)
- `quantity: integer` (required)
- `msrp.amount: decimal` (required)
- `msrp.currency: string (ISO 4217)` (required)
- `unitPrice.amount: decimal` (required)
- `unitPrice.currency: string` (required)
- `extendedPrice.amount: decimal` (required)
- `extendedPrice.currency: string` (required)
- `pricingBreakdown: array` (required, may be empty but backend implies at least BASE_PRICE)
  - `ruleName: string`
  - `ruleType: string` (e.g., BASE_PRICE, LOCATION_OVERRIDE)
  - `adjustment.amount: decimal`
  - `adjustment.currency: string`
  - `resultingValue.amount: decimal`
  - `resultingValue.currency: string`
- `warnings: string[]` (optional/empty)
- `priceSource: string` (required if backend includes per RQ4; UI must render if present)

### Read-only vs editable
- Request fields come from editable form inputs (productId, quantity) and context selectors (location/customer).
- Response fields are **read-only display**.

### Derived/calculated fields (frontend)
- `extendedPriceDisplay` computed from response (do not recompute for correctness; display response)
- `isStale` derived if current form inputs do not match last response request hash

---

# 9. Service Contracts (Frontend Perspective)

> Contract is based on backend story reference #51; frontend must align with actual implementation once available.

### Load/view calls
- None required beyond pricing quote call (estimate/product search is out-of-scope here).

### Create/update calls
- None (quote retrieval only).

### Submit/transition calls
- **POST** `/v1/price-quotes`
  - Request JSON matches `PriceQuoteRequest`
  - Success: `200 OK` with `PriceQuoteResponse`

### Error handling expectations
- **400**: parse JSON error response; display field-level error if structure supports it, else show banner
- **404**: show ‚Äúnot found/no price‚Äù message; do not crash line editor
- **500**: show retry message
- Timeouts: treat as unavailable; allow user retry
- Correlation ID: if response headers include it, log it to console/logger for support (do not display unless instructed)

---

# 10. State Model & Transitions

### Allowed states (frontend quote state)
- `IDLE`: no quote attempted yet
- `LOADING`: quote request in-flight
- `SUCCESS`: quote displayed, consistent with current inputs
- `STALE`: quote displayed but inputs changed since last quote (optional state; see Open Questions)
- `ERROR`: last attempt failed

### Role-based transitions
- No special role logic specified for UI quoting. (Authorization happens server-side.)

### UI behavior per state
- IDLE: show ‚ÄúEnter product and quantity to see price‚Äù
- LOADING: show spinner and disable repeated calls
- SUCCESS: show price, breakdown, warnings
- STALE (if implemented): show prior price dimmed with ‚ÄúRecalculate pricing‚Äù prompt
- ERROR: show error banner + retry action

---

# 11. Alternate / Error Flows

### Validation failures (client-side)
- Quantity missing/0/negative/non-integer:
  - No API call; show inline validation on quantity field
- Missing locationId/customerTierId:
  - No API call; show inline message indicating missing context

### Server-side validation failures (400)
- Display server message; if server returns field errors, map to the corresponding inputs.

### Not found (404)
- If invalid productId: prompt user to reselect product
- If no price found: show message and prevent saving priced totals (save rules out-of-scope; at minimum do not populate price)

### Concurrency/race conditions
- If user changes quantity quickly:
  - Debounce requests and ignore out-of-order responses using request hash or incrementing requestId.

### Unauthorized access (401/403)
- 401: redirect to login (standard app behavior)
- 403: show ‚ÄúYou don‚Äôt have permission to view pricing.‚Äù and block quote panel

### Empty states
- Breakdown empty or missing: show ‚ÄúNo breakdown available‚Äù (should not happen per backend rule BR2; treat as warning and log)

---

# 12. Acceptance Criteria

### Scenario 1: Quote pricing for valid line (happy path)
**Given** I am a Service Advisor editing an estimate line  
**And** I have selected a productId  
**And** I have entered quantity `2`  
**And** the estimate context includes locationId and customerTierId  
**When** the UI requests a price quote  
**Then** the UI sends `POST /v1/price-quotes` with productId, quantity, locationId, customerTierId  
**And** the UI displays msrp, unitPrice, and extendedPrice from the response  
**And** the UI displays pricingBreakdown entries in the order returned by the API  
**And** the UI displays any warnings returned.

### Scenario 2: Do not call API when quantity is invalid
**Given** I am editing an estimate line  
**And** I have selected a productId  
**When** I enter quantity `0` (or blank)  
**Then** the UI shows a validation error ‚ÄúQuantity must be greater than 0‚Äù  
**And** the UI does not call `POST /v1/price-quotes`.

### Scenario 3: Handle 404 (product not found / no price)
**Given** I am editing an estimate line with a productId that pricing cannot price  
**When** the UI requests a price quote  
**And** the API returns `404 Not Found`  
**Then** the UI shows an inline error indicating no price was found for the product/context  
**And** the UI does not display a misleading price.

### Scenario 4: Handle 400 (invalid context)
**Given** I am editing an estimate line  
**When** the UI requests a price quote with an invalid customerTierId  
**And** the API returns `400 Bad Request` with a descriptive message  
**Then** the UI displays the message to the user  
**And** allows retry after the context is corrected.

### Scenario 5: Race condition protection on rapid quantity changes
**Given** I rapidly change quantity from 1 to 2 to 3  
**When** multiple quote requests are triggered  
**Then** only the latest response is shown in the UI  
**And** earlier responses are ignored if they return after the latest request.

### Scenario 6: Render MSRP fallback indicator (if provided)
**Given** the API response includes `priceSource = "MSRP_FALLBACK"`  
**When** the UI displays the quote  
**Then** the UI shows a non-blocking notice that MSRP fallback pricing is being used.

---

# 13. Audit & Observability

### User-visible audit data
- Show ‚ÄúPricing as of <effectiveTimestamp or now>‚Äù if effective timestamp is provided/known.
- Show breakdown entries (ruleName/type, adjustment, resulting value) to support explainability.

### Status history
- Not required to persist history, but UI should keep last successful quote in-memory until line editor is closed.

### Traceability expectations
- Frontend should log (app logger) quote request metadata:
  - productId, quantity, locationId, customerTierId
  - requestId/hash
  - response status code
  - correlationId header if present
- Do not log customer PII.

---

# 14. Non-Functional UI Requirements

- **Performance:** UI should feel responsive; debounce quote calls (e.g., 250‚Äì400ms) on quantity typing to avoid excessive API traffic.
- **Accessibility:** All error messages must be screen-reader accessible; use ARIA-live region for async error banners.
- **Responsiveness:** Quote panel must render appropriately on tablet-sized screens used at POS counters.
- **i18n/timezone/currency:**
  - Currency: display using ISO currency from response; do not assume USD.
  - Timezone: effectiveTimestamp uses UTC; if displayed, convert to user locale with clear timezone indicator (needs clarification on desired display).

---

# 15. Applied Safe Defaults

- SD-UX-01 (Debounced input-triggered calls): Assumed debounce on quantity/product changes to reduce API load and improve UX; qualifies as UI ergonomics and does not change business logic; impacts UX Summary, Functional Behavior, Acceptance Criteria, Error Flows.
- SD-ERR-01 (Standard HTTP error mapping): Assumed conventional mapping of 400/404/500 to inline banner + field validation where possible; qualifies as standard error-handling mapping; impacts Business Rules, Service Contracts, Alternate/Error Flows.
- SD-OBS-01 (Client-side requestId/hash for race protection): Assumed request sequencing to avoid stale updates; qualifies as frontend reliability/ergonomics; impacts Functional Behavior, Alternate/Error Flows, Acceptance Criteria.

---

# 16. Open Questions

1. **Where in the Moqui screen hierarchy does estimate line add/edit live (screen path, parameters, routing)?** Provide the target screen(s) to modify and the route params available (estimateId, locationId, customerId, etc.).  
2. **Source of `customerTierId`:** Is customer tier always present on the estimate/customer context, or must the Service Advisor select it? If selectable, where is it stored and how is it validated?  
3. **What should the UI do with quote results‚Äîdisplay-only or also populate editable line fields that will be saved?** If it populates fields, which fields on the estimate line entity are authoritative (unitPrice, extendedPrice, msrp, priceSource, snapshotId, etc.)?  
4. **Stale quote behavior:** When inputs change after a successful quote, should the UI (a) clear the quote, (b) keep it but mark ‚Äústale‚Äù, or (c) automatically re-quote on every change? (Auto re-quote is preferred but confirm.)  
5. **Exact API base URL / auth mechanism in Moqui frontend:** Is `/v1/price-quotes` proxied through Moqui, or called directly to the pricing service? Provide the expected Moqui service name or HTTP client configuration pattern used in this repo.  
6. **Error response schema:** For 400/404/500, what JSON structure is returned (message field name, fieldErrors array, error codes)? Needed to implement consistent UI parsing.  
7. **Should `effectiveTimestamp` be passed from the UI?** If yes, what value should it use (estimate created time, quote time, scheduled service time), and should the user be able to change it?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Workexec: Price Product for Estimate Line (Location + Customer Tier) ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/115

====================================================================================================

FRONTEND STORY (FULL CONTEXT)

====================================================================================================

Title: [FRONTEND] [STORY] Workexec: Price Product for Estimate Line (Location + Customer Tier)
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/115
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Workexec: Price Product for Estimate Line (Location + Customer Tier)

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Service Advisor**, I want correct pricing on estimate lines so that customers receive accurate quotes.

## Details
- Request: productId, qty, locationId, customer tier, effective time.
- Response: unit/ext price, MSRP, breakdown, policy flags.

## Acceptance Criteria
- Deterministic evaluation order (base‚Üístore override‚Üírounding).
- Returns breakdown + warnings.
- SLA suitable for UI.

## Integrations
- Workexec ‚Üí Product PriceQuote API; optional availability in same response.

## Data / Entities
- PriceQuoteRequest, PriceQuoteResponse, PricingRuleTrace

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Product / Parts Management


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

====================================================================================================

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #116: [FRONTEND] [STORY] StorePrice: Set Location Store Price Override within Guardrails  
File: ./scripts/story-work/frontend/116/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:pricing
- status:draft

### Recommended
- agent:pricing-domain-agent
- agent:story-authoring

### Blocking / Risk
- none

**Rewrite Variant:** pricing-strict

---

# 1. Story Header

## Title
[FRONTEND] [STORY] StorePrice: Set Location Store Price Override within Guardrails

## Primary Persona
Store Manager

## Business Value
Enable Store Managers to respond to local market pricing while enforcing centrally-defined pricing guardrails and approval workflow, ensuring pricing is compliant, auditable, and safe.

---

# 2. Story Intent

## As a / I want / So that
**As a** Store Manager  
**I want** to create or update a location-specific store price override for a product  
**So that** I can compete locally while the system enforces guardrails and routes approvals when required.

## In-scope
- Moqui/Vue/Quasar frontend screens to:
  - Search/select a product and location context
  - View base price and any existing override
  - Propose an override price
  - Submit override for activation (auto-approved) or for approval (pending)
  - View current override status and approval details
- Frontend handling of guardrail/approval outcomes returned by backend services:
  - ACTIVE vs PENDING_APPROVAL vs validation failure
- Display user-visible audit/status history for overrides (as exposed by backend)
- Authorization-aware UI behavior (hide/disable actions when user lacks permission)

## Out-of-scope
- Defining guardrail policy values and formulas (owned by backend/pricing domain logic)
- Approver-side approval/rejection UI (unless already part of frontend scope elsewhere)
- Workexec consumption/reporting implementation (downstream systems)
- Bulk override upload/import

---

# 3. Actors & Stakeholders
- **Store Manager (Primary)**: Creates/updates override for their assigned location(s).
- **Pricing System (Backend, System Actor)**: Computes base price, enforces guardrails, determines approval requirement, persists override.
- **Approver (Secondary)**: Approves/rejects pending overrides (handled outside this story unless an existing screen exists).
- **Regional Pricing Manager / Pricing Desk (Stakeholders)**: Operational owners of approvals and guardrail enforcement.
- **Reporting/Analytics (Stakeholder)**: Consumes override state and audit trail (out of scope for UI beyond visibility).

---

# 4. Preconditions & Dependencies
1. User is authenticated in the Moqui app.
2. User has permission to manage overrides:
   - Required permission: `pricing:override:manage`
3. User is scoped to one or more locations; override actions must be limited to authorized locations.
4. Backend endpoints/services exist (or will exist) consistent with backend story #52:
   - Retrieve base price + cost (if available) + current override for (locationId, productId)
   - Submit override and receive resulting status (ACTIVE or PENDING_APPROVAL) or validation errors
   - Retrieve override details including approval request (if pending) and audit/history
5. GuardrailPolicy exists for the location/region (backend enforces; frontend displays error if missing).

---

# 5. UX Summary (Moqui-Oriented)

## Entry points
- Pricing / Store Price Overrides navigation item (new menu entry) **OR**
- Product detail (if existing) ‚Üí ‚ÄúSet Store Price Override‚Äù action (must include location context)

(If project conventions require a single entry point, prefer Pricing module menu entry; otherwise support both where feasible.)

## Screens to create/modify
1. **New Screen:** `apps/pos/screen/pricing/StorePriceOverrideList.xml` (name indicative)
   - Location selector (limited to authorized locations)
   - Product search/select
   - List existing overrides for selected location (optional but recommended for usability)
2. **New Screen:** `apps/pos/screen/pricing/StorePriceOverrideDetail.xml`
   - View base price, current effective price, existing override state
   - Form to submit a new override price or update existing (where allowed)
   - Read-only approval/audit panel (status history)
3. **Optional Dialog Component (Vue/Quasar):**
   - ‚ÄúPropose Override Price‚Äù modal with confirmation summary (base price, proposed price, computed discount/margin if backend returns)

## Navigation context
- `Pricing > Store Price Overrides` (list)
- Selecting a row navigates to detail:
  - `.../pricing/store-price-override/detail?locationId=...&productId=...`
- From detail, back navigates to list preserving filters (location/product search)

## User workflows
### Happy path: auto-approved
1. Store Manager selects location + product.
2. System loads base price + current override info.
3. Store Manager enters `overridePrice` and submits.
4. UI shows success and status `ACTIVE`; effective price updates to override.

### Alternate path: requires approval
1. Submit override that is within hard guardrails but exceeds auto-approval threshold.
2. UI shows status `PENDING_APPROVAL` and displays assigned approver info (if provided).

### Alternate path: guardrail violation
1. Submit override that violates hard guardrails.
2. UI shows inline validation error message(s); no record created/updated.

---

# 6. Functional Behavior

## Triggers
- Enter list screen: initialize location from user‚Äôs default location (if available) and load overrides (optional).
- Select location/product: load pricing context (base price, cost if available, existing override).
- Submit override: call backend to validate and persist; update UI based on response.

## UI actions
- **Select Location**
  - Dropdown/search constrained to authorized locationIds
- **Select Product**
  - Product lookup (by SKU/name); selection yields `productId`
- **View Pricing Context**
  - Display:
    - base price (read-only)
    - cost (read-only, if returned and permitted)
    - current effective price (read-only)
    - any active/pending override (read-only summary)
- **Enter Override Price**
  - Monetary input, currency display (currency comes from backend context if provided)
- **Submit**
  - Disabled until required inputs present and valid format
  - On submit:
    - show confirmation including base vs override and any backend-provided computed values
    - call submit service
- **Post-submit display**
  - If ACTIVE: show ‚ÄúOverride active‚Äù
  - If PENDING_APPROVAL: show ‚ÄúSubmitted for approval‚Äù plus approval request summary
  - If validation error: show message(s) mapped to field/global

## State changes (frontend-visible)
- `LocationPriceOverride.status` transitions as returned by backend:
  - Created/updated to `ACTIVE` or `PENDING_APPROVAL`
- If an override is `REJECTED` or `INACTIVE`, detail screen shows read-only record with status and history; edit/submit behavior depends on backend allowance (see State Model section).

## Service interactions
- Load context service on selection/navigation
- Create/update override submit service
- Load audit/history service (or included in context payload)

---

# 7. Business Rules (Translated to UI Behavior)

> Pricing formulas/guardrail evaluation are owned by backend. Frontend must not re-implement calculation logic; it may display computed values returned by backend.

## Validation
- `overridePrice`:
  - Required for submit
  - Must be a valid monetary amount (> 0)
  - Precision/rounding: accept up to 4 decimal places (DECIMAL(19,4)) in input; display formatting per currency
- Location/product must be selected and valid UUIDs.

## Enable/disable rules
- Submit button disabled when:
  - missing locationId/productId/overridePrice
  - overridePrice is not parseable or <= 0
- Edit fields disabled when:
  - user lacks `pricing:override:manage`
  - override status is `REJECTED` (immutable) (frontend enforces read-only; backend must also enforce)
- If backend responds `403`, show unauthorized message and disable further edits.

## Visibility rules
- Show approval panel only if response includes `ApprovalRequest` or status `PENDING_APPROVAL/REJECTED`.
- Show cost only if backend includes it (do not assume it is always available).

## Error messaging expectations
- Guardrail violation errors must be displayed as actionable messages, e.g.:
  - ‚ÄúDiscount exceeds maximum allowed‚Äù
  - ‚ÄúMargin below minimum allowed‚Äù
- Missing policy / missing base data errors displayed as blocking banners:
  - ‚ÄúUnable to evaluate override: guardrail policy missing for this location‚Äù
  - ‚ÄúUnable to compute base price for this product at this location‚Äù

---

# 8. Data Requirements

## Entities involved (frontend-facing)
- `LocationPriceOverride`
- `GuardrailPolicy` (read-only, optional to display summary if backend provides)
- `ApprovalRequest` (read-only summary)
- `AuditLog` / status history (read-only)

## Fields (type, required, defaults)

### LocationPriceOverride (as displayed/edited)
- `overrideId` (UUID, read-only)
- `locationId` (UUID, required, read-only after selection)
- `productId` (UUID, required, read-only after selection)
- `overridePrice` (Decimal(19,4), required for submit, editable when allowed)
- `status` (Enum: `ACTIVE`, `PENDING_APPROVAL`, `REJECTED`, `INACTIVE`; read-only)
- `createdByUserId` (UUID, read-only)
- `createdAt` (datetime, read-only)
- `approvedByUserId` (UUID nullable, read-only)
- `resolvedAt` (datetime nullable, read-only)
- Rejection fields (read-only):
  - `rejectedBy` (UUID)
  - `rejectedAt` (datetime)
  - `rejectionReasonCode` (string)
  - `rejectionNotes` (string)

### GuardrailPolicy (if returned for display)
- `policyId` (UUID, read-only)
- `scope` (string/enum, read-only)
- `scopeId` (UUID/string, read-only)
- `min_margin_percent` (decimal, read-only)
- `max_discount_percent` (decimal, read-only)
- `auto_approval_threshold_percent` (decimal, read-only)

### ApprovalRequest (if pending)
- `requestId` (UUID, read-only)
- `overrideId` (UUID, read-only)
- `status` (`PENDING`, `APPROVED`, `REJECTED`; read-only)
- `assignedApproverId` (UUID, read-only)
- `assignmentStrategy` (string, read-only)

## Read-only vs editable by state/role
- Store Manager with `pricing:override:manage`:
  - Can submit new override for (locationId, productId)
  - Can update overridePrice only if backend allows updates for current status (assume only when `ACTIVE` or no override exists; if `PENDING_APPROVAL`, treat as read-only unless backend explicitly supports ‚Äúreplace pending‚Äù)
- Any user without permission: all fields read-only.

## Derived/calculated fields (display only if backend returns)
- `basePrice` (money)
- `effectivePrice` (money)
- `discountPercent` (decimal)
- `marginPercent` (decimal; only when cost available)

---

# 9. Service Contracts (Frontend Perspective)

> Endpoint names are placeholders; implement using Moqui services/transitions consistent with project conventions. Frontend must integrate via Moqui screens/services, not direct DB.

## Load/view calls
1. **Get pricing context**
   - Input: `locationId`, `productId`
   - Output:
     - `basePrice`, `effectivePrice`, optional `cost`
     - existing `LocationPriceOverride` (if any)
     - optional `GuardrailPolicy` summary
     - optional `ApprovalRequest` (if pending)
     - optional `currencyUomId`
   - Error handling:
     - 404 product not found ‚Üí show ‚ÄúProduct not found‚Äù
     - 403 unauthorized location ‚Üí show unauthorized banner
     - 409/422 missing base data/policy ‚Üí show blocking banner (no submit)

2. **Get override audit/history**
   - Input: `overrideId`
   - Output: list of status changes/audit entries
   - If backend includes audit within context, this call is optional.

## Create/update calls
1. **Submit override**
   - Input:
     - `locationId` (UUID)
     - `productId` (UUID)
     - `overridePrice` (Decimal)
   - Output:
     - `overrideId`
     - `status` (`ACTIVE` or `PENDING_APPROVAL`)
     - if pending: `ApprovalRequest` summary
     - updated `effectivePrice`
   - Error handling:
     - Guardrail violations: field/global errors with codes/messages; do not persist
     - 403 unauthorized
     - 404 invalid product
     - 409 conflict if concurrent update detected (see Error Flows)

## Submit/transition calls
- If Moqui uses transitions:
  - `transition` from detail form submit to `submitStorePriceOverride` service
  - On success, redirect to same detail with updated data; on error, remain on form with messages.

## Error handling expectations
- Map backend validation errors to:
  - field-level error on `overridePrice` when applicable
  - global banner for policy/base-data/system errors
- Preserve user input on validation failure.

---

# 10. State Model & Transitions

## Allowed states (as displayed)
- `ACTIVE`
- `PENDING_APPROVAL`
- `REJECTED`
- `INACTIVE`

## Role-based transitions (frontend)
- Store Manager (`pricing:override:manage`):
  - Can create/submit override ‚Üí results in `ACTIVE` or `PENDING_APPROVAL` (backend decision)
  - Cannot directly set `REJECTED`/`INACTIVE` via UI in this story (unless backend exposes deactivation; not specified)
- Approver (`pricing:override:approve`):
  - Approval/rejection transitions are out of scope for this frontend story unless existing screens already handle them.

## UI behavior per state
- **ACTIVE**
  - Show active override and effective price = overridePrice
  - Allow proposing a new overridePrice (submit creates new record or updates; depends on backend contract‚Äîsee Open Questions if not supported)
- **PENDING_APPROVAL**
  - Show pending status and assignedApproverId
  - Override editing disabled by default; provide informational text ‚ÄúPending approval‚Äù
- **REJECTED**
  - Show rejection reason code/notes and who/when
  - Entire record read-only
- **INACTIVE**
  - Show inactive status; submit new override allowed (treated like create)

---

# 11. Alternate / Error Flows

## Validation failures
- Override price violates min margin/max discount:
  - Display backend-provided message(s)
  - Keep user on screen with entered price preserved
  - No status change shown

## Concurrency conflicts
- If backend returns conflict (e.g., override changed since load):
  - Show banner ‚ÄúThis override was updated by another user. Reloading latest values.‚Äù
  - Re-load context and show latest status/values
  - Do not auto-resubmit

## Unauthorized access
- If user tries to access detail for a location they are not authorized for:
  - Show 403 page or banner
  - Do not show sensitive data (cost, guardrails)
  - Provide navigation back to list

## Empty states
- No override exists for selected product/location:
  - Show base price and ‚ÄúNo active override‚Äù
  - Allow submit

## Backend dependency failure
- If pricing context service unavailable:
  - Show error state with retry
  - Disable submit (fail closed)

---

# 12. Acceptance Criteria (Gherkin)

## Scenario 1: Load pricing context for product/location
**Given** I am a Store Manager with `pricing:override:manage` for location `L1`  
**When** I navigate to the Store Price Override detail for product `P1` at location `L1`  
**Then** the UI loads and displays the base price and effective price for `P1` at `L1`  
**And** if an override exists, its status and override price are displayed  

## Scenario 2: Submit override within auto-approval thresholds (ACTIVE)
**Given** base price and guardrails allow auto-approval for my proposed override  
**When** I enter a valid overridePrice and submit  
**Then** the UI shows a success message  
**And** the override status is `ACTIVE`  
**And** the effective price displayed equals the submitted overridePrice  

## Scenario 3: Submit override requiring approval (PENDING_APPROVAL)
**Given** my proposed override is within hard guardrails but requires manual approval  
**When** I submit the overridePrice  
**Then** the UI shows status `PENDING_APPROVAL`  
**And** the UI displays assigned approver information when provided by the backend  
**And** the effective price displayed remains the base price (or the backend-provided effective price that excludes the pending override)  

## Scenario 4: Submit override that violates hard guardrails (validation error)
**Given** my proposed override violates a hard guardrail  
**When** I submit the overridePrice  
**Then** the UI displays a validation error message explaining the violated rule  
**And** the override is not created/updated (no new overrideId returned)  
**And** my entered overridePrice remains in the input field  

## Scenario 5: Unauthorized location access blocked
**Given** I do not have access to location `L2`  
**When** I attempt to view or submit an override for location `L2`  
**Then** the UI shows an unauthorized error state  
**And** no override submission is performed  

## Scenario 6: Concurrency conflict handled
**Given** I loaded an override detail page  
**And** another user updates the override before I submit  
**When** I submit my overridePrice  
**Then** the UI shows a conflict message  
**And** reloads the latest override data  
**And** does not apply my submission without my re-confirmation  

---

# 13. Audit & Observability

## User-visible audit data
- Detail screen shows:
  - createdBy/createdAt
  - current status
  - approvedBy/resolvedAt when applicable
  - rejection details when applicable
  - status history/audit entries if backend provides them

## Status history
- Display as a chronological list with:
  - timestamp
  - actor (userId or display name if available)
  - transition (e.g., SUBMITTED ‚Üí ACTIVE)
  - notes (e.g., rejection reason)

## Traceability expectations
- Frontend must include correlation/request ID in logs if provided by Moqui response headers.
- On submit/load failures, log:
  - locationId, productId (no prices in logs if considered sensitive; do not log cost)
  - overrideId when available
  - error code/status

---

# 14. Non-Functional UI Requirements

## Performance
- Pricing context load should render initial skeleton/loading state within 200ms and complete when backend responds.
- Avoid repeated calls: debounce product search; cache last loaded context per (locationId, productId) in-session if consistent with app patterns.

## Accessibility
- All form inputs labeled.
- Error messages announced to screen readers (aria-live region for banners).
- Keyboard navigable (tab order, enter to submit where appropriate).

## Responsiveness
- Works on tablet resolutions used in-store.
- Forms must be usable without horizontal scrolling.

## i18n/timezone/currency
- Display currency symbol/format based on backend-provided currency (if available) or app default.
- Display timestamps in user‚Äôs locale/timezone per app standard.

---

# 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide explicit empty-state messaging when no override exists; qualifies as safe UI ergonomics. Impacted sections: UX Summary, Alternate / Error Flows.
- SD-UX-DEBOUNCE-SEARCH: Debounce product search input to reduce backend load; qualifies as safe UI ergonomics/performance. Impacted sections: Non-Functional UI Requirements, Functional Behavior.
- SD-ERR-STD-MAPPING: Map HTTP 403/404/409/422 into standard banner/field errors without changing domain logic; qualifies as safe error-handling mapping. Impacted sections: Service Contracts, Alternate / Error Flows.

---

# 16. Open Questions
- none

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] StorePrice: Set Location Store Price Override within Guardrails  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/116  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] StorePrice: Set Location Store Price Override within Guardrails

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Store Manager**, I want to set store price overrides so that I can compete locally within policy.

## Details
- Override layered over base price.
- Guardrails: min margin %, max discount %, approval thresholds.

## Acceptance Criteria
- Override created/updated.
- Guardrails enforced with approvals.
- Audited.

## Integrations
- Workexec receives store price for that location; reporting tracks override usage.

## Data / Entities
- LocationPriceOverride, GuardrailPolicy, ApprovalRecord, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Product / Parts Management


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #118: [FRONTEND] [STORY] Pricing: Define Base Company Price Book Rules ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/118
File: ./scripts/story-work/frontend/118/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:pricing
- status:draft

### Recommended
- agent:pricing-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** pricing-strict

STOP: Clarification required before finalization

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Pricing: Define Base Company Price Book Rules (Moqui Screens)

### Primary Persona
Pricing Analyst / Pricing Administrator

### Business Value
Enable consistent, auditable company-wide pricing configuration (base price books + rules) so downstream quoting uses deterministic rule evaluation and controlled variation by location and customer tier.

---

## 2. Story Intent

### As a / I want / So that
**As a** Pricing Analyst (authorized pricing admin),  
**I want** to create and manage base company price books and their effective-dated pricing rules (global/category/SKU, optional tier/location conditions),  
**so that** pricing is consistent across stores, deterministically evaluated, and all changes are auditable.

### In-scope
- Moqui UI to:
  - List/search base Price Books
  - View a Price Book and its Rules
  - Create/update/deactivate Price Books (within allowed fields)
  - Create/update/deactivate Price Book Rules with effective dating, priority, and targeting
  - View audit history for rule changes (read-only)
- Frontend validation aligned to pricing-domain rules where possible (date windows, required fields, immutability indicators).
- Integration wiring from Moqui screens/forms to Moqui services/endpoints for CRUD + audit retrieval.

### Out-of-scope
- Price quote calculation UI (Workexec ‚ÄúPriceQuote‚Äù consumer flows)
- Store/location override workflows (explicitly referenced as layered after base; handled elsewhere)
- Building/maintaining product, category taxonomy, customer tier, inventory cost, or MSRP (owned by other domains)
- Defining the backend pricing formula implementation (frontend only config + display)

---

## 3. Actors & Stakeholders
- **Pricing Analyst / Pricing Administrator (primary user):** creates and maintains base books and rules.
- **Store Manager (indirect):** depends on consistent base pricing; may later apply overrides.
- **Workexec users (indirect):** rely on deterministic price outputs from configured rules.
- **Compliance/Audit (stakeholder):** requires change traceability and immutability of historical rules.
- **System Admin/Security (stakeholder):** ensures only authorized users can change pricing.

---

## 4. Preconditions & Dependencies
- User is authenticated in the frontend shell and has permission to manage pricing rules (exact permission string must match backend; see Open Questions).
- Backend services/entities exist (or will exist per backend story #54) for:
  - `PriceBook` and `PriceBookRule` CRUD
  - conflict detection on overlapping effective windows
  - audit log retrieval for create/update/deactivate operations
- Reference data dependencies for selectors:
  - Product (SKU/productId) lookup
  - Category taxonomy lookup
  - Location lookup
  - Customer tier list/lookup
- Timezone handling: effective timestamps must be interpreted consistently between UI and backend (see Open Questions).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main navigation: **Pricing ‚Üí Base Price Books**
- Deep links:
  - `/pricing/base-price-books` (list)
  - `/pricing/base-price-books/{priceBookId}` (detail)
  - `/pricing/base-price-books/{priceBookId}/rules/new` (new rule)
  - `/pricing/base-price-books/{priceBookId}/rules/{ruleId}` (rule detail/edit)
  - `/pricing/base-price-books/{priceBookId}/audit` (audit timeline/list)

### Screens to create/modify (Moqui)
Create screens under a consistent root (example):
- `screens/pricing/BasePriceBookList.xml`
- `screens/pricing/BasePriceBookDetail.xml`
- `screens/pricing/PriceBookRuleEdit.xml`
- `screens/pricing/PriceBookAudit.xml`

(Exact folder naming must align with repo conventions; see Open Questions.)

### Navigation context
- List ‚Üí select a PriceBook ‚Üí view tabs:
  - **Rules**
  - **Details**
  - **Audit**
- Rule edit is reachable from Rules tab (Create) and from a rule row (Edit/View).

### User workflows
**Happy path: create a base price book rule**
1. Navigate to Base Price Books list.
2. Open a specific Price Book (company default or scoped).
3. Click ‚ÄúAdd Rule‚Äù.
4. Select target type (Global / Category / SKU).
5. Provide target id if needed (categoryId/productId).
6. Choose pricing logic type (Markup over cost / Discount from MSRP / Fixed price).
7. Optionally set condition (customer tier and/or location ‚Äî see Open Questions because backend story defines a single conditionType/value).
8. Set priority and effective start/end.
9. Save ‚Üí rule appears in Rules table, status ACTIVE (or INACTIVE if end date in past / explicitly set).
10. View audit entry created.

**Alternate path: deactivate rule**
- From rule detail: set status INACTIVE or set effectiveEndAt to a past time (backend supports either; UI supports both per Open Questions) ‚Üí save ‚Üí rule no longer affects pricing but remains visible.

**Alternate path: view conflicts**
- If overlapping/conflicting rule exists, save fails with a validation error showing the conflicting rule(s); UI highlights the conflicting dimensions (target + condition + window).

---

## 6. Functional Behavior

### Triggers
- User opens list/detail screens
- User submits create/update forms
- User attempts edits on immutable historical rules

### UI actions
- List PriceBooks with filters (status, scope, isDefault, locationId/tierCode where applicable).
- Create PriceBook:
  - fields: name, scope, scopeId (nullable), isDefault, status
- Update PriceBook (limited to allowed fields; if backend restricts, UI must enforce).
- Rules tab:
  - table columns (minimum): targetType, targetId (display name via lookup), pricingLogic summary, condition, priority, effectiveStartAt, effectiveEndAt, status, updatedAt
  - actions: view/edit, deactivate
- Rule editor:
  - Selectors with async search for product/category/location/tier
  - Pricing logic input form changes by type:
    - markup over cost: numeric percent
    - discount from MSRP: numeric percent
    - fixed price: amount + currency (currency locked if backend expects single currency; see Open Questions)
  - Save/cancel transitions

### State changes
- On save:
  - Create: new PriceBookRule persisted with status ACTIVE/INACTIVE
  - Update: existing PriceBookRule updated if not immutable
  - Deactivate: effectiveEndAt set or status changed to INACTIVE
- UI should reflect backend-calculated immutability: rules with ended effective window must be read-only.

### Service interactions
- Fetch price books and rules
- CRUD for books/rules
- Lookups for product/category/location/tier
- Fetch audit logs for a priceBookId and/or ruleId

---

## 7. Business Rules (Translated to UI Behavior)

### Validation (client-side, mirrored server-side)
- Required fields:
  - PriceBook: `name`, `scope`, `status`, `isDefault` (and `scopeId` required when scope != company default)
  - PriceBookRule: `priceBookId`, `targetType`, `pricingLogicType`, `priority`, `effectiveStartAt`, `status`
  - If `targetType != GLOBAL`, `targetId` required
  - If `effectiveEndAt` provided: `effectiveEndAt >= effectiveStartAt`
- Determinism support inputs:
  - `priority` required integer (no client assumption of range)
- Conflict awareness:
  - On save failure with conflict error, UI must show:
    - message ‚ÄúConflicting rule exists for the same target/condition with overlapping effective dates‚Äù
    - list of conflicting rule identifiers if provided by backend
- Immutability:
  - If rule effective period has ended (backend BR6), UI must render fields read-only and disable Save; show inline message ‚ÄúHistorical rules are immutable; create a new rule to change pricing.‚Äù

### Enable/disable rules
- Disable targetId input when targetType = GLOBAL.
- Disable condition inputs when conditionType = NONE.
- Disable all edits when rule immutable.
- Disable ‚ÄúSet as Default‚Äù toggle if backend rejects multiple defaults per scope; UI should pre-check existing defaults and warn before submit.

### Visibility rules
- Show condition section only if backend supports conditions on base rules.
- Show an ‚ÄúEvaluation notes‚Äù / ‚ÄúStatus explanation‚Äù tooltip when a rule status is `NOT_APPLICABLE_MISSING_BASE` (if this status is persisted on rules; see Open Questions).

### Error messaging expectations
- Field-level errors for required/malformed values.
- Form-level banner for 403/401/500.
- Conflict error must be actionable (identify overlapping window/target/condition).

---

## 8. Data Requirements

### Entities involved (frontend view models)
- `PriceBook`
- `PriceBookRule`
- `AuditLog` (or equivalent audit entity)
- Reference entities (read-only lookups):
  - Product (for SKU/productId)
  - Category taxonomy
  - Location
  - CustomerTier

### Fields (type, required, defaults)

#### PriceBook (minimal UI contract)
- `priceBookId` (UUID, read-only)
- `name` (string, required)
- `scope` (enum: COMPANY_DEFAULT | LOCATION | CUSTOMER_TIER | LOCATION_AND_TIER?; **see Open Questions**)
- `scopeId` (UUID/string depending on scope; required when scope != COMPANY_DEFAULT)
- `isDefault` (boolean, required)
- `status` (enum ACTIVE|INACTIVE, required)

Defaults (UI-only ergonomics):
- `status = ACTIVE` on create
- `isDefault = false` on create (unless explicitly creating company default; **do not assume**)

#### PriceBookRule (minimal UI contract)
- `ruleId` (UUID, read-only)
- `priceBookId` (UUID, required, hidden from user when inside a book)
- `targetType` (enum SKU|CATEGORY|GLOBAL, required)
- `targetId` (UUID/string, required unless GLOBAL)
- `pricingLogic` (JSON object, required)
  - `type` (enum MARKUP_OVER_COST | DISCOUNT_FROM_MSRP | FIXED_PRICE; **see Open Questions**)
  - `value` (decimal/percent or amount)
  - `currency` (ISO 4217, required for FIXED_PRICE if backend requires)
- `conditionType` (enum CUSTOMER_TIER|LOCATION|NONE, required)
- `conditionValue` (string/UUID, required if conditionType != NONE)
- `priority` (int, required)
- `effectiveStartAt` (timestamp, required)
- `effectiveEndAt` (timestamp, optional)
- `status` (enum ACTIVE|INACTIVE|NOT_APPLICABLE_MISSING_BASE?, required)
- `createdAt/createdBy`, `updatedAt/updatedBy` (read-only display)

Read-only vs editable by state/role
- Users without pricing manage permission: read-only access (or no access) depending on security policy (see Open Questions).
- Immutable historical rule: all fields read-only.

Derived/calculated fields (UI)
- Human-readable summaries:
  - Target label (GLOBAL or resolved product/category name)
  - Condition label (e.g., ‚ÄúLocation: Dallas‚Äù)
  - Pricing logic summary (‚ÄúFixed $89.99‚Äù, ‚ÄúCost + 20%‚Äù, ‚ÄúMSRP - 10%‚Äù)

---

## 9. Service Contracts (Frontend Perspective)

> Note: Backend story references REST APIs for other domains, but does not specify pricing CRUD endpoints. For Moqui buildability, endpoint/service names must be confirmed (Open Questions). Below is the **required shape** the frontend needs, not exact URLs.

### Load/view calls
- List PriceBooks
  - Input: filters (status, scope, scopeId, isDefault), pagination
  - Output: array of PriceBook summary + total
- Get PriceBook detail
  - Input: priceBookId
  - Output: PriceBook
- List PriceBookRules for a PriceBook
  - Input: priceBookId + filters (status, targetType, effectiveAsOf optional), pagination/sort
  - Output: array of PriceBookRule summary + total
- Get Rule detail
  - Input: ruleId
  - Output: PriceBookRule full

### Create/update calls
- Create PriceBook
- Update PriceBook
- Create PriceBookRule
- Update PriceBookRule
- Deactivate PriceBookRule (either update with status/effectiveEndAt or dedicated action)

### Submit/transition calls
- If backend models activation/deactivation as transitions:
  - `activateRule(ruleId)`
  - `deactivateRule(ruleId, effectiveEndAt?)`

### Error handling expectations
- 400 validation errors return field map usable for inline errors.
- 409 conflict for overlapping rule windows, includes conflicting rule references.
- 403 for unauthorized; UI routes to an ‚ÄúUnauthorized‚Äù screen or shows error banner.
- 5xx show retry guidance and preserve unsaved form state.

---

## 10. State Model & Transitions

### Allowed states
PriceBook:
- ACTIVE
- INACTIVE

PriceBookRule:
- ACTIVE
- INACTIVE
- (Possibly) NOT_APPLICABLE_MISSING_BASE (if persisted vs evaluation-only; see Open Questions)

### Role-based transitions
- Pricing admin:
  - create/update/deactivate
- Read-only roles:
  - view only

### UI behavior per state
- INACTIVE rules show disabled styling and cannot be activated unless backend supports re-activation (Open Question).
- Immutable historical: regardless of ACTIVE/INACTIVE, if `effectiveEndAt < now`, UI is read-only.

---

## 11. Alternate / Error Flows

### Validation failures
- Missing required fields ‚Üí prevent submit; highlight fields.
- `effectiveEndAt < effectiveStartAt` ‚Üí inline error on end date field.
- Invalid percent/amount format ‚Üí inline numeric error.

### Concurrency conflicts
- If backend uses optimistic locking (e.g., version field), on 409 the UI must:
  - show ‚ÄúThis rule was updated by someone else‚Äù
  - offer reload and re-apply edits (best-effort; do not auto-merge)

### Unauthorized access
- If user lacks permission:
  - On navigation: show 403 page or redirect (implementation choice per app conventions; Open Question)
  - Hide create/edit buttons if permissions info available in session.

### Empty states
- No price books: show empty state with ‚ÄúCreate Price Book‚Äù if authorized.
- No rules in a book: show empty rules state with ‚ÄúAdd Rule‚Äù.

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: View base price books list
Given I am an authenticated user with permission to view pricing configuration  
When I navigate to the Base Price Books list screen  
Then I see a paginated list of existing price books with status and scope information  
And I can open a price book detail screen

### Scenario 2: Create a new base price book
Given I have permission to manage price books  
When I create a new price book with required fields (name, scope, status, default flag)  
Then the system saves the price book successfully  
And the new price book appears in the list  
And an audit record is created for the operation

### Scenario 3: Create a global rule (e.g., markup-based)
Given I have permission to manage price book rules  
And I am viewing a price book detail page  
When I add a new rule with targetType "GLOBAL", a markup-based pricing logic, a priority, and an effectiveStartAt  
And I save the rule  
Then the rule is persisted and appears in the rules list  
And the rule status is displayed as returned by the backend  
And an audit record is visible in the audit view

### Scenario 4: Create a SKU fixed-price rule
Given I have permission to manage price book rules  
And I am viewing a price book detail page  
When I add a new rule with targetType "SKU" and a selected productId and fixed price values  
And I save the rule  
Then the rule is persisted and appears in the rules list with target label resolved to the product  
And the pricing logic summary displays the fixed price

### Scenario 5: Reject conflicting rule due to overlapping effective window
Given I have permission to manage price book rules  
And a rule already exists for the same target and condition with an overlapping effective date range  
When I attempt to save a new rule that overlaps  
Then the save fails with a conflict/validation error  
And the UI displays an actionable error message indicating a conflicting rule exists  
And the user‚Äôs entered form values remain intact for correction

### Scenario 6: Enforce immutability for historical rules
Given I am viewing a rule whose effectiveEndAt is in the past  
When I open the rule detail screen  
Then the rule fields are read-only  
And the Save action is disabled  
And the UI instructs me to create a new rule to change pricing

### Scenario 7: Unauthorized user cannot edit
Given I am an authenticated user without permission to manage pricing rules  
When I navigate to a rule edit URL directly  
Then the UI prevents editing and shows an unauthorized message or page  
And no update call is made

---

## 13. Audit & Observability

### User-visible audit data
- Audit tab/list shows entries for create/update/deactivate:
  - timestamp
  - actor (userId/display name if available)
  - entity type (PriceBook / PriceBookRule)
  - entity id
  - change summary (field diffs if provided)

### Status history
- For each rule, show createdAt/updatedAt and status changes if audit provides them.

### Traceability expectations
- UI must include correlation/request id in error details display (if returned by backend headers/body).
- All create/update actions should log frontend telemetry event (if app has standard logging) containing priceBookId/ruleId and outcome (success/failure), without sensitive data.

---

## 14. Non-Functional UI Requirements

- **Performance:** Rules table should support pagination and server-side filtering; avoid loading all rules for large datasets.
- **Accessibility:** All form controls must be keyboard accessible and have labels; validation errors must be announced to screen readers.
- **Responsiveness:** Usable on tablet widths; tables should adapt (stack or horizontal scroll).
- **i18n/timezone/currency:**
  - Display timestamps in user locale but submit in backend-required format.
  - Currency display must follow ISO 4217; formatting consistent with app conventions.
  - Timezone for effective dates must be consistent (Open Question).

---

## 15. Applied Safe Defaults
- SD-UI-EMPTY-STATE: Provide explicit empty states for ‚Äúno price books‚Äù and ‚Äúno rules‚Äù with CTA if authorized; qualifies as safe UX ergonomics; impacts UX Summary, Error Flows.
- SD-UI-PAGINATION: Use standard server-driven pagination/sorting on list tables; qualifies as safe ergonomics and scalability; impacts UX Summary, Service Contracts.
- SD-ERR-STANDARD-MAPPING: Map 400‚Üífield errors, 401/403‚Üíunauthorized UX, 409‚Üíconflict banner, 5xx‚Üíretry banner; qualifies as standard error handling; impacts Service Contracts, Error Flows, Acceptance Criteria.

---

## 16. Open Questions

1. **Moqui routing & screen conventions:** What is the required screen path/module naming in `durion-moqui-frontend` for pricing admin screens (e.g., `/apps/pos/pricing/...` vs `/pricing/...`), and what existing menu screen should be extended?
2. **Authorization model (denylist item):** What permissions/roles gate *view* vs *manage* for price books/rules in the frontend, and what is the exact permission string(s) to check (e.g., `pricing:pricebook:manage`)?
3. **Backend CRUD contract:** What are the exact Moqui services or REST endpoints for `PriceBook` and `PriceBookRule` list/get/create/update/deactivate, including request/response schemas and error formats (400 vs 409 conflict payload)?
4. **Conditions model mismatch:** Backend reference shows `conditionType` as a single enum (`CUSTOMER_TIER`, `LOCATION`, `NONE`), but the original story description says rules can be tiered by customer tier and mentions location conditions as well. Can a rule have **both** location and customer tier simultaneously, or must it be expressed via separate scoped PriceBooks (BR5) and single-condition rules?
5. **PriceBook scope enums:** Backend BR5 selection includes `(locationId + customerTier)` precedence, implying a combined scope. Does `PriceBook.scope` support a combined scope (location+tier), and if so what is the exact representation (`scope=LOCATION_TIER` with two IDs vs composite scopeId)?
6. **Pricing logic schema:** What is the exact shape of `pricingLogic` JSON (field names, allowed types, percent vs basis points, decimal precision)? Frontend must not guess monetary precision/rounding.
7. **Currency handling:** Are base price books single-currency (e.g., USD only) or multi-currency? For FIXED_PRICE rules, must UI require/select currency, and what currencies are allowed?
8. **Effective dating timezone:** Are `effectiveStartAt/effectiveEndAt` interpreted as UTC timestamps, local store time, or user timezone? Should UI use date-only or date-time pickers?
9. **Deactivation mechanism:** Should deactivation be done by setting `status=INACTIVE`, setting `effectiveEndAt`, or either? If either, which should UI prefer and how should it message the behavior?
10. **Audit retrieval:** What entity/service provides audit entries for rule changes, and what fields are available (diffs, actor display name, correlation id)?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Pricing: Define Base Company Price Book Rules ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/118

====================================================================================================

FRONTEND STORY (FULL CONTEXT)

====================================================================================================

Title: [FRONTEND] [STORY] Pricing: Define Base Company Price Book Rules
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/118
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Pricing: Define Base Company Price Book Rules

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Pricing Analyst**, I want base price books so that pricing is consistent across stores with controlled variation.

## Details
- Rule types: markup over cost, discount from MSRP, fixed price.
- Price books can be tiered by customer tier.
- Versioning + effective dating.

## Acceptance Criteria
- Deterministic rule evaluation.
- Version changes audited.

## Integrations
- Workexec calls PriceQuote with location + customer tier; store overrides layered after base.

## Data / Entities
- PriceBook, PriceRule, PriceBookVersion, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Product / Parts Management


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

====================================================================================================

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #159: [FRONTEND] [STORY] Promotions: Apply Offer During Estimate Pricing  
File: ./scripts/story-work/frontend/159/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:pricing
- status:draft

### Recommended
- agent:pricing-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** pricing-strict

STOP: Clarification required before finalization

---

## 1. Story Header

**Title:** Promotions: Apply Promotion Code During Estimate Pricing (Frontend / Moqui)

**Primary Persona:** Service Advisor

**Business Value:** Enables Service Advisors to apply a promotion code to an estimate and immediately see the resulting discount and updated totals, ensuring accurate customer-facing pricing before estimate approval and preserving traceability of the applied offer.

---

## 2. Story Intent

### As a / I want / So that
- **As a** Service Advisor  
- **I want** to apply a promotion code to an existing estimate and see the resulting discount reflected in the estimate totals  
- **So that** customers receive correct pricing before approving the work and the applied offer is recorded for audit/traceability.

### In-scope
- UI entry to input a promotion code for a specific estimate.
- Client-side validation (required/non-empty, basic trimming).
- Call Moqui backend to apply a promotion code to an estimate (via Pricing/Workexec integration behind Moqui).
- Display applied promotion and the resulting pricing adjustment line(s) and updated totals.
- Display stable error codes returned by backend with user-friendly messages.
- Idempotent re-apply behavior handling in UI (same code ‚Üí no duplicate discount lines).
- Ability to clear/remove a promotion **only if** an explicit backend capability exists (otherwise out-of-scope; see Open Questions).

### Out-of-scope
- Creating/editing promotions, eligibility rules, or pricing formulas (Pricing/CRM domain back-office).
- Defining discount stacking/precedence beyond ‚Äúsingle promotion per estimate‚Äù (already defined).
- Manual price override workflows and approvals.
- Offline support.

---

## 3. Actors & Stakeholders

- **Service Advisor (Primary):** Applies promotion codes while preparing an estimate.
- **Customer (Beneficiary):** Receives accurate discounted pricing.
- **Pricing Service (System):** Validates/apply promotion, computes discount adjustment and totals (authoritative on math).
- **Work Execution / Estimate Owner (System):** Persists estimate state, applied promotion reference, and pricing adjustment lines.
- **CRM (Supporting):** System of record for promotion definitions and eligibility (invoked by Pricing per backend reference).

---

## 4. Preconditions & Dependencies

### Preconditions
- User is authenticated.
- User has permission to modify the target estimate.
- An estimate exists and is in an allowed state: `DRAFT` or `PENDING_APPROVAL` (names must match backend; see Open Questions).
- Estimate has at least one priceable line item.

### Dependencies
- Moqui screens for estimate detail and totals exist (or will be created as part of this story).
- Backend endpoint(s) exist to:
  - Load estimate header + pricing totals + applied adjustments.
  - Apply a promotion code to an estimate and return updated totals/adjustments with stable error codes.
- Stable backend error codes: `PROMO_NOT_FOUND`, `PROMO_NOT_APPLICABLE`, `PROMO_MULTIPLE_NOT_ALLOWED`, `SERVICE_UNAVAILABLE` (from backend story reference).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- From **Estimate Detail** screen (Service Advisor workflow), within a ‚ÄúPricing / Totals‚Äù context.

### Screens to create/modify
- **Modify:** `EstimateDetail` (existing) to add a ‚ÄúPromotion‚Äù section and bind to apply action.
- **Create (if missing):** A sub-screen/component for promotions within estimate context, e.g.:
  - `EstimateDetail/PromotionApply` (embedded screen)
- **Modify:** Totals/adjustments display area to include promotion adjustment line item(s) and applied promotion metadata.

### Navigation context
- Route includes `estimateId` parameter.
- Promotion application happens in-context; no separate full-page navigation required.
- After apply, remain on same estimate screen and refresh totals/adjustments panel.

### User workflows
**Happy path**
1. Open Estimate Detail.
2. Enter promotion code (e.g., `SAVE10`).
3. Click ‚ÄúApply‚Äù.
4. UI shows applied promotion label/code and adds a discount adjustment line (negative amount) in totals; total decreases accordingly.

**Alternate paths**
- Enter invalid code ‚Üí show error and do not change displayed totals.
- Enter valid but ineligible code ‚Üí show error and do not change totals.
- Attempt to apply a second promotion when one already applied ‚Üí show error; keep existing promotion.
- Backend unavailable ‚Üí show retryable error; keep current totals.

---

## 6. Functional Behavior

### Triggers
- User submits promotion code via an ‚ÄúApply‚Äù action.

### UI actions
- Promotion code input field (string).
- Apply button.
- While applying:
  - Disable Apply button.
  - Show in-place loading indicator in the promotion section.
- On success:
  - Refresh estimate pricing model in UI (adjustments + totals + applied promotion reference).
- On failure:
  - Show error message mapped from `errorCode`.
  - Do not mutate local estimate totals; optionally re-fetch estimate to ensure consistency only if backend indicates partial updates (should not happen per backend story).

### State changes (frontend)
- Local view-model updates:
  - `appliedPromotion` display (code/label/sourceId if provided).
  - `appliedAdjustments[]` includes a `type=PROMOTION` entry.
  - Totals updated from backend response.

### Service interactions
- `GET` load estimate (header + line items + pricing summary + applied adjustments).
- `POST` apply promotion to estimate (promotion code + estimateId).
- Optional `GET` refresh after apply if apply endpoint does not return full pricing payload (see Open Questions).

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- Promotion code:
  - Required (non-empty after trim).
  - Max length limit **TBD** (see Open Questions). If unknown, do not enforce max length beyond reasonable UI input constraints; allow backend to validate.
- Estimate state constraint:
  - Show promotion input enabled only when estimate state is in allowed set (Draft/Pending Approval).
  - If state disallowed, show read-only messaging: ‚ÄúPromotions can only be applied to Draft or Pending Approval estimates.‚Äù

### Enable/disable rules
- Disable Apply button when:
  - Code is empty after trim
  - Request in-flight
  - Estimate state not eligible

### Visibility rules
- Show ‚ÄúApplied Promotion‚Äù summary only if backend indicates a promotion is applied (either via `appliedPromotion` reference or presence of `PricingAdjustment(type=PROMOTION)`).
- If one promotion per estimate is enforced:
  - If promotion already applied, either:
    - Keep input visible but applying another code will error with `PROMO_MULTIPLE_NOT_ALLOWED`, or
    - Hide/disable input and show applied promotion summary (preferred UX)  
  (Exact behavior depends on whether ‚Äúreplace promotion‚Äù is allowed; see Open Questions.)

### Error messaging expectations
- Use backend `errorCode` as primary mapping key; message copy can be user-friendly but must preserve code for support/debug.
- Minimum mapping:
  - `PROMO_NOT_FOUND` ‚Üí ‚ÄúPromotion code not found or expired.‚Äù
  - `PROMO_NOT_APPLICABLE` ‚Üí ‚ÄúThis promotion doesn‚Äôt apply to the current estimate.‚Äù
  - `PROMO_MULTIPLE_NOT_ALLOWED` ‚Üí ‚ÄúOnly one promotion can be applied to an estimate.‚Äù
  - `SERVICE_UNAVAILABLE` ‚Üí ‚ÄúPromotion service is temporarily unavailable. Please try again.‚Äù
  - Unknown ‚Üí ‚ÄúUnable to apply promotion. Please try again or contact support.‚Äù (include error code if present)

---

## 8. Data Requirements

> Note: Exact Moqui entity names are not provided in inputs; this story specifies a frontend-facing data model and requires mapping to actual Moqui entities/services during implementation.

### Entities involved (conceptual)
- **Estimate** (Workexec-owned)
- **PricingAdjustment** (Pricing-authored, Workexec-persisted association to estimate)
- **AppliedPromotion** reference (association on estimate pointing to promotion/offer id)

### Fields (type, required, defaults)

**Estimate (subset needed by UI)**
- `estimateId`: UUID, required, read-only
- `status`: string enum, required, read-only
- `customerId`: UUID, required, read-only (for context display only)
- `currencyUomId` or `currency`: string (ISO 4217), required, read-only
- `subtotal`: decimal/money, read-only
- `total`: decimal/money, read-only
- `taxTotal`: decimal/money, read-only (if available)
- `appliedPromotion` (optional):
  - `promotionId`/`sourceId`: UUID, read-only
  - `promotionCode`: string, read-only (if returned)
  - `label`: string, read-only (if returned)
- `appliedAdjustments[]`: array, read-only

**PricingAdjustment (promotion)**
- `type`: string, required, read-only; expected `PROMOTION`
- `sourceId`: UUID, required, read-only (promotion/offer id)
- `label`: string, required for display (if not provided, UI must still show ‚ÄúPromotion‚Äù and code/sourceId)
- `amount`: decimal/money, required, read-only; negative value
- `metadata`: object/json, optional, read-only (for audit display if provided)

**Promotion code input (UI-only)**
- `promotionCode`: string, required on submit; trimmed

### Read-only vs editable by state/role
- Only the **promotionCode input** is editable, and only in eligible estimate states.
- All totals and adjustments are read-only.

### Derived/calculated fields
- Discount amount and totals are calculated by Pricing (backend). UI does not compute amounts.

---

## 9. Service Contracts (Frontend Perspective)

> Moqui service names/paths are not provided; these contracts must be wired to existing Moqui services/endpoints.

### Load/view calls
- `GET /estimates/{estimateId}` (or Moqui screen transition/service call) returning:
  - Estimate header, status
  - Line items summary (optional for this UI)
  - Totals and appliedAdjustments
  - Applied promotion reference (if available)

### Create/update calls (apply promotion)
- `POST /estimates/{estimateId}/promotion:apply` (or equivalent)
  - Request:
    - `estimateId`: UUID (path or body)
    - `promotionCode`: string
  - Response (success):
    - Updated totals + appliedAdjustments including promotion adjustment
    - Applied promotion reference (promotionId/sourceId, label/code if available)
  - Response (failure):
    - `errorCode`: string (stable)
    - `message`: string (provisional)
    - `details`: optional object

### Submit/transition calls
- None beyond apply action.

### Error handling expectations
- HTTP 400 for business validation failures (`PROMO_*` errors) per backend reference.
- HTTP 503 for `SERVICE_UNAVAILABLE`.
- UI must:
  - Keep current estimate view unchanged on 4xx/5xx.
  - Display error feedback with the errorCode.
  - Allow retry after 503.

---

## 10. State Model & Transitions

### Allowed states (for promotion application)
- `DRAFT`
- `PENDING_APPROVAL`

(Exact enum values must match backend/Workexec; see Open Questions.)

### Role-based transitions
- No state transitions are initiated by applying a promotion (per backend reference).  
- Authorization is assumed to be covered by estimate modify permission; any separate permission for promotions is **TBD**.

### UI behavior per state
- Eligible states: show editable promotion input and Apply button.
- Ineligible states: show applied promotion (if any) read-only; hide/disable Apply.

---

## 11. Alternate / Error Flows

### Validation failures (client-side)
- Empty code:
  - Prevent submit.
  - Show inline validation: ‚ÄúEnter a promotion code.‚Äù

### Backend validation failures (business)
- `PROMO_NOT_FOUND`:
  - Show error; keep totals unchanged.
- `PROMO_NOT_APPLICABLE`:
  - Show error; keep totals unchanged.
- `PROMO_MULTIPLE_NOT_ALLOWED`:
  - Show error; keep existing promotion/totals unchanged.

### Concurrency conflicts
- If estimate is modified elsewhere and backend rejects apply due to version conflict:
  - Behavior **TBD** (need error code/contract).  
  - UI should prompt user to refresh estimate and retry (see Open Questions).

### Unauthorized access
- If backend returns 401/403:
  - Show ‚ÄúYou don‚Äôt have permission to apply promotions to this estimate.‚Äù
  - Do not reveal promotion validity/eligibility details.

### Empty states
- If estimate has no priceable line items:
  - Disable Apply and show message: ‚ÄúAdd at least one line item before applying a promotion.‚Äù
  (Backed by backend precondition; if backend also enforces, display its error code if returned.)

---

## 12. Acceptance Criteria

### Scenario 1: Apply a valid promotion successfully
**Given** I am a Service Advisor viewing an estimate in `DRAFT` state with at least one priceable line item  
**And** the estimate pricing subtotal is available  
**When** I enter a valid promotion code `SAVE10` and click Apply  
**Then** the UI sends an apply request for that `estimateId` with `promotionCode=SAVE10`  
**And** the UI displays an applied promotion indicator (code/label)  
**And** the estimate totals display includes a `PricingAdjustment` line with `type=PROMOTION` and a negative amount  
**And** the displayed estimate total is updated to the backend-returned value

### Scenario 2: Reject an invalid/expired promotion code
**Given** I am viewing an eligible estimate  
**When** I apply the promotion code `FAKECODE`  
**And** the backend responds with errorCode `PROMO_NOT_FOUND`  
**Then** the UI shows an error message for `PROMO_NOT_FOUND`  
**And** the estimate totals and adjustment lines shown remain unchanged from before the attempt

### Scenario 3: Reject a valid code that is not applicable to this estimate
**Given** I am viewing an eligible estimate that does not meet eligibility for code `OILSPECIAL`  
**When** I apply the promotion code `OILSPECIAL`  
**And** the backend responds with errorCode `PROMO_NOT_APPLICABLE`  
**Then** the UI shows an error message for `PROMO_NOT_APPLICABLE`  
**And** no promotion adjustment line is added  
**And** totals remain unchanged

### Scenario 4: Prevent multiple promotions on one estimate
**Given** I am viewing an eligible estimate that already has an applied promotion discount line  
**When** I attempt to apply a different promotion code  
**And** the backend responds with errorCode `PROMO_MULTIPLE_NOT_ALLOWED`  
**Then** the UI shows an error message for `PROMO_MULTIPLE_NOT_ALLOWED`  
**And** the originally applied promotion remains displayed  
**And** totals remain unchanged

### Scenario 5: Handle service unavailability safely
**Given** I am viewing an eligible estimate  
**When** I apply a promotion code and the backend responds with HTTP 503 and errorCode `SERVICE_UNAVAILABLE`  
**Then** the UI shows a retryable error message  
**And** the estimate remains unchanged  
**And** I can retry applying the promotion code after the error

---

## 13. Audit & Observability

### User-visible audit data
- Display (if provided by backend):
  - Applied promotion label/code
  - Applied promotion sourceId (for support, may be behind a ‚Äúdetails‚Äù toggle)

### Status history
- Not a state transition; however, UI should show that promotion is applied as part of estimate pricing summary.

### Traceability expectations
- Frontend must include correlation/request id propagation if the Moqui frontend framework supports it (e.g., via headers) for:
  - apply request
  - subsequent refresh request
- Log (frontend console/logger) should include:
  - `estimateId`
  - `promotionCode` (consider sensitivity‚Äîpromotion codes are not secrets but avoid over-logging; only log in debug level)
  - returned `errorCode` on failure

---

## 14. Non-Functional UI Requirements

- **Performance:** Apply action should provide feedback within 1500ms under normal conditions; show loading state while pending.
- **Accessibility:** Promotion input and Apply button must be keyboard operable; errors announced via appropriate ARIA/live region patterns supported by Quasar.
- **Responsiveness:** Works on tablet widths commonly used at service desks; promotion section should not require horizontal scrolling.
- **i18n/timezone/currency:** Currency display must use estimate currency from backend; do not assume USD formatting. (No additional currency conversion.)

---

## 15. Applied Safe Defaults

- SD-UX-EMPTY-STATE-01: Show a clear empty-state message and disable Apply when no priceable line items are present; qualifies as safe UX ergonomics with no domain policy changes; impacts UX Summary, Error Flows.
- SD-ERR-MAP-01: Map backend `errorCode` values to user-friendly messages while preserving the code for support; qualifies as safe error-handling boilerplate; impacts Business Rules, Error Flows, Acceptance Criteria.
- SD-UX-LOADING-01: Disable submit and show loading indicator during apply request to prevent double-submit; qualifies as safe UI ergonomics; impacts Functional Behavior, Error Flows.

---

## 16. Open Questions

1. **Backend endpoint contract (blocking):** What are the exact Moqui service names / REST paths for:
   - Loading an estimate with totals/adjustments
   - Applying a promotion code to an estimate  
   Does the apply endpoint return the full updated estimate pricing payload, or must the frontend re-fetch after applying?

2. **Estimate state enum values (blocking):** What are the exact allowed estimate statuses for applying promotions, and what are the canonical string values used by Moqui/workexec (e.g., `DRAFT` vs `Draft`)?

3. **Replace/remove promotion (blocking):** When one promotion is already applied, should the UI:
   - Block applying any new code (current rule: single promotion) and provide no replace option, or
   - Allow ‚ÄúReplace promotion‚Äù (which would still result in exactly one promotion), or
   - Allow ‚ÄúRemove promotion‚Äù action?  
   If allowed, what is the backend service contract and audit expectation?

4. **Concurrency/versioning (blocking):** If the estimate is changed concurrently, what error code/HTTP status is returned (e.g., 409), and should the UI auto-refresh or prompt the user?

5. **Promotion code constraints (non-blocking unless enforced in backend):** Is there a maximum length / allowed character set for promotion codes that should be validated client-side?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Promotions: Apply Offer During Estimate Pricing  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/159  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Promotions: Apply Offer During Estimate Pricing

**Domain**: user

### Story Description

/kiro  
# User Story

## Narrative
As a **Service Advisor**, I want **to apply a promotion code to an estimate and see the discount** so that **customers receive correct pricing before approval**.

## Details
- Validate code and eligibility.
- Record applied offer and discount parameters/lines.

## Acceptance Criteria
- Invalid code rejected.
- Discount line appears in estimate totals.
- Applied offer recorded for traceability.

## Integration Points (Workorder Execution)
- Workorder Execution calls CRM promotions API to validate/apply.
- CRM returns discount parameters or rule reference.

## Data / Entities
- AppliedPromotion reference
- PricingAdjustment (WO domain)

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: CRM

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #160: [FRONTEND] [STORY] Promotions: Define Eligibility Rules (Account/Vehicle)  
File: ./scripts/story-work/frontend/160/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:pricing
- status:draft

### Recommended
- agent:pricing-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** pricing-strict

---

## 1. Story Header

**Title:** [FRONTEND] [STORY] Promotions: Define Eligibility Rules (Account/Vehicle)  
**Primary Persona:** Account Manager (and/or Pricing Analyst)  
**Business Value:** Ensure promotions are only applied to intended customers/vehicles by configuring eligibility criteria and providing explainable eligibility decisions during estimate pricing.

---

## 2. Story Intent

### As a / I want / So that
- **As an** Account Manager / Pricing Analyst  
- **I want** to configure eligibility rules for a promotion based on account and vehicle attributes (including optional fleet-size threshold)  
- **So that** the pricing engine can correctly apply or deny promotions with an explanation (reason code) during estimate pricing.

### In-scope
- Promotion eligibility rule configuration UI (create, edit, delete, list) attached to a specific promotion.
- Eligibility rule ‚Äútest/evaluate‚Äù UI that calls an evaluation service and displays decision + reason.
- Frontend wiring for Moqui screens, forms, transitions, and service calls.
- Validation and error handling aligned to business rules (fail-safe deny, explicit reason codes).

### Out-of-scope
- Creating/editing promotions themselves (assumed already exists and navigable).
- Implementing pricing calculation, applying discounts, tax/total math (owned by pricing backend/services).
- Defining vehicle tags taxonomy and account fleet size computation (owned by Inventory/CRM systems of record).
- Advanced promotion stacking/precedence (explicitly out of scope; only eligibility rules).

---

## 3. Actors & Stakeholders

- **Primary user:** Account Manager / Pricing Analyst (configures rules; runs evaluation test)
- **Secondary user:** Service Advisor (consumes accurate outcomes indirectly during estimate pricing)
- **System actor:** Pricing Engine / Estimate Pricing flow (calls eligibility evaluation)
- **External domains (SoR):**
  - **CRM**: account data incl. fleet size
  - **Inventory**: vehicle data incl. tags/categories
- **Compliance/Audit stakeholder:** Finance/Operations (needs traceability for why promo applied/denied)

---

## 4. Preconditions & Dependencies

- User is authenticated in the frontend and has permission to manage promotions eligibility (permission token/authorization handled by Moqui security).
- A **Promotion** exists and has a stable identifier (`promotionId`).
- Backend services exist (or will exist) for:
  - CRUD of `PromotionEligibilityRule`
  - Eligibility evaluation given `promotionId` and context (`accountId`, `vehicleId` optional)
- UI has a navigation path to a promotion detail/config screen.

**Dependency risks:** service endpoints/parameters are not defined in provided inputs; must be clarified (see Open Questions).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- From Promotion detail screen: action ‚ÄúEligibility Rules‚Äù
- Optional: Promotions list ‚Üí select promotion ‚Üí Eligibility Rules

### Screens to create/modify
1. **Screen:** `PromotionDetail` (existing; modify)
   - Add navigation link/tab to `PromotionEligibilityRules`
2. **Screen:** `PromotionEligibilityRules` (new)
   - Lists rules for `promotionId`
   - Actions: Add Rule, Edit Rule, Delete Rule, Test Eligibility
3. **Screen/Dialog:** `PromotionEligibilityRuleEdit` (new, could be embedded dialog form)
   - Create/update form with validation and operator/value inputs
4. **Screen/Dialog:** `PromotionEligibilityTest` (new, could be section in rules screen)
   - Input: accountId, vehicleId (optional depending on rules), run evaluation, show decision + reason

### Navigation context
- All screens scoped by `promotionId` in the path or parameters.
- Breadcrumbs: Promotions ‚Üí Promotion {code/name} ‚Üí Eligibility Rules

### User workflows
**Happy path: configure and test**
1. Open promotion ‚Üí Eligibility Rules
2. Click ‚ÄúAdd Rule‚Äù
3. Choose condition type, operator, value
4. Save ‚Üí rule appears in list
5. Open ‚ÄúTest Eligibility‚Äù, enter context, run test
6. See result: Eligible/Ineligible + reason code

**Alternate paths**
- Edit existing rule and re-test.
- Delete rule (with confirm) and verify list updates.
- Attempt save with invalid inputs ‚Üí inline validation errors.

---

## 6. Functional Behavior

### Triggers
- Screen load for `PromotionEligibilityRules` with `promotionId`
- User submits Create/Update/Delete rule
- User submits Evaluate/Test eligibility

### UI actions
- **List view**
  - Fetch rules for promotion
  - Display each rule condition type/operator/value
  - Provide per-row actions: Edit, Delete
- **Create/Edit**
  - Form fields update based on `conditionType` (e.g., fleet size expects numeric)
  - Save triggers backend create/update service
- **Delete**
  - Confirmation modal; on confirm, call delete service; refresh list
- **Test/Evaluate**
  - Call evaluation service with `promotionId` + context
  - Display `isEligible` and `reasonCode` returned

### State changes
- Rule records created/updated/deleted in backend.
- No local state persisted beyond screen session.

### Service interactions
- `find` rules by promotionId
- `create` rule
- `update` rule
- `delete` rule
- `evaluate` eligibility

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- **Required fields:** `promotionId`, `conditionType`, `operator`, `value`
- `value` validation by condition type:
  - `ACCOUNT_ID_LIST`: must be a non-empty list of identifiers (format TBD); UI should accept comma-separated input and trim whitespace.
  - `VEHICLE_TAG`: must be non-empty string token (no commas unless explicitly allowed‚ÄîTBD).
  - `ACCOUNT_FLEET_SIZE`: must be an integer or numeric threshold (exact numeric type TBD); reject non-numeric.
- `operator` must be compatible with `conditionType` (matrix TBD; must be clarified).

### Enable/disable rules
- Disable ‚ÄúSave‚Äù until form passes client-side validation.
- Disable ‚ÄúTest‚Äù while evaluation call in-flight.

### Visibility rules
- Show/hide context fields on Test panel:
  - If any configured rule requires account context, show/require `accountId`.
  - If any rule requires vehicle context, show/require `vehicleId`.
  - If both exist, require both.
  - If rules list is empty, Test is allowed but expected result behavior must be clarified (eligible vs ineligible).

### Error messaging expectations
- Display backend validation errors inline at field level when possible; otherwise show a top-of-form error summary.
- For evaluation failures due to missing context, show a specific message including `reasonCode` (e.g., ‚ÄúMissing account context‚Äù).
- For dependent service unavailability during evaluation: show ‚ÄúEligibility evaluation unavailable; promotion treated as not eligible‚Äù (wording must align to backend reason code; TBD).

---

## 8. Data Requirements

### Entities involved
- `Promotion` (read-only in this story; used for context)
- `PromotionEligibilityRule` (CRUD)
- `EligibilityDecision` (evaluation response)

### Fields (type, required, defaults)

**PromotionEligibilityRule**
- `ruleId` (UUID, required for existing; generated on create)
- `promotionId` (UUID, required; read-only in form once scoped)
- `conditionType` (ENUM, required): `ACCOUNT_ID_LIST`, `VEHICLE_TAG`, `ACCOUNT_FLEET_SIZE`
- `operator` (ENUM, required): **TBD exact allowed values per condition type**
- `value` (string, required): serialized value (comma list / token / numeric string)

### Read-only vs editable
- `ruleId`: read-only
- `promotionId`: read-only (inferred from route)
- Others editable when user has manage permission

### Derived/calculated fields
- None in UI; evaluation returns derived decision (`isEligible`, `reasonCode`)

---

## 9. Service Contracts (Frontend Perspective)

> Backend endpoints are not specified in provided inputs; below is a Moqui-frontend contract expectation that MUST be mapped to actual services once confirmed.

### Load/view calls
- **List rules**
  - Input: `promotionId`
  - Output: array of `PromotionEligibilityRule`
  - Errors:
    - 401/403 ‚Üí route to unauthorized screen or show permission error
    - 404 promotion not found ‚Üí show not found

### Create/update calls
- **Create rule**
  - Input: `promotionId`, `conditionType`, `operator`, `value`
  - Output: created `PromotionEligibilityRule` (including `ruleId`)
- **Update rule**
  - Input: `ruleId` + editable fields
  - Output: updated rule

### Delete call
- **Delete rule**
  - Input: `ruleId`
  - Output: success boolean/empty

### Submit/transition calls
- None (no lifecycle states specified for rules)

### Error handling expectations
- Map field validation errors to form fields when backend returns structured validation.
- On unknown server errors: show generic failure and allow retry; do not assume rule saved.

---

## 10. State Model & Transitions

### Allowed states
- No explicit state machine for `PromotionEligibilityRule` provided.

### Role-based transitions
- If user lacks permission:
  - Read-only access (if allowed) or block entirely (TBD)
  - Create/Edit/Delete buttons hidden or disabled with tooltip ‚ÄúInsufficient permissions‚Äù

### UI behavior per state
- N/A beyond permissions and loading/error states (loading spinner, empty state message)

---

## 11. Alternate / Error Flows

- **Empty state (no rules configured):**
  - Show message ‚ÄúNo eligibility rules configured‚Äù
  - Provide CTA ‚ÄúAdd Rule‚Äù
  - Test behavior with no rules: **TBD** (Open Question)
- **Validation failures on save:**
  - Highlight invalid fields; preserve user input; no navigation
- **Concurrency conflicts:**
  - If update/delete fails due to missing rule (already deleted), refresh list and show ‚ÄúRule no longer exists‚Äù
- **Unauthorized access (401/403):**
  - Show access denied; do not display sensitive data
- **Evaluation service unavailable:**
  - Show evaluation unavailable; do not infer eligibility; if backend returns fail-safe `isEligible=false` with reason, display it

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: View eligibility rules for a promotion
**Given** I am an authenticated Account Manager with permission to manage promotion eligibility  
**And** a promotion exists with `promotionId`  
**When** I navigate to the promotion‚Äôs ‚ÄúEligibility Rules‚Äù screen  
**Then** the system loads and displays the list of `PromotionEligibilityRule` records for that `promotionId`  
**And** if no rules exist, an empty state is shown with an ‚ÄúAdd Rule‚Äù action

### Scenario 2: Create an account ID list eligibility rule
**Given** I am on the ‚ÄúEligibility Rules‚Äù screen for a promotion  
**When** I click ‚ÄúAdd Rule‚Äù  
**And** I select `conditionType = ACCOUNT_ID_LIST`  
**And** I select a valid operator for account list matching  
**And** I enter a non-empty list of account IDs in `value`  
**And** I click ‚ÄúSave‚Äù  
**Then** the rule is persisted via a create service call  
**And** the newly created rule appears in the rules list

### Scenario 3: Prevent saving invalid fleet size rule
**Given** I am adding an eligibility rule  
**When** I select `conditionType = ACCOUNT_FLEET_SIZE`  
**And** I enter a non-numeric `value`  
**And** I click ‚ÄúSave‚Äù  
**Then** the UI blocks submission and displays a validation error indicating fleet size must be numeric  
**And** no create/update service call is made

### Scenario 4: Edit an existing rule
**Given** at least one eligibility rule exists for the promotion  
**When** I click ‚ÄúEdit‚Äù on a rule  
**And** I change the operator and/or value to valid inputs  
**And** I click ‚ÄúSave‚Äù  
**Then** the UI calls the update service  
**And** the list refreshes showing the updated rule values

### Scenario 5: Delete an existing rule with confirmation
**Given** an eligibility rule exists in the list  
**When** I click ‚ÄúDelete‚Äù  
**And** I confirm deletion  
**Then** the UI calls the delete service  
**And** the rule is removed from the list  
**And** a success message is shown

### Scenario 6: Test eligibility and display decision + reason
**Given** a promotion has one or more eligibility rules configured  
**When** I open the ‚ÄúTest Eligibility‚Äù panel  
**And** I provide the required context inputs (accountId and/or vehicleId as required by configured rules)  
**And** I click ‚ÄúRun Test‚Äù  
**Then** the UI calls the eligibility evaluation service with `promotionId` and the provided context  
**And** the UI displays the returned `isEligible` result  
**And** the UI displays the returned `reasonCode`

### Scenario 7: Evaluation fails due to missing required context
**Given** a promotion has eligibility rules that require `accountId`  
**When** I attempt to run the eligibility test without providing `accountId`  
**Then** the UI blocks the call and shows a ‚Äúmissing account context‚Äù error  
**Or** if backend is called, the UI displays the backend `reasonCode` indicating missing context (exact behavior depends on backend contract)

---

## 13. Audit & Observability

### User-visible audit data
- Display `ruleId` (or a short form) in the rule list details view (useful for support).
- If backend provides `createdBy/createdDate/lastUpdatedBy/lastUpdatedDate`, display on edit/view (TBD availability).

### Status history
- Not applicable unless backend provides history; do not invent.

### Traceability expectations
- Frontend should include `promotionId` and `ruleId` in structured logs for create/update/delete actions (console/network logs as per project convention).
- Eligibility test results should be traceable (promotionId, input context, decision, reasonCode) in UI event logging if project convention supports it.

---

## 14. Non-Functional UI Requirements

- **Performance:** Rules list should render within 1s after data load for typical rule counts (assume < 100).
- **Accessibility:** All form controls labeled; errors announced; keyboard navigable dialogs.
- **Responsiveness:** Works on tablet width; forms usable without horizontal scroll.
- **i18n/timezone/currency:** Not applicable (no monetary/currency display). Reason codes displayed as provided; optionally map to human-readable strings if a mapping exists (TBD).

---

## 15. Applied Safe Defaults

- SD-UI-EMPTY-STATE: Provide a standard empty-state with CTA when no rules exist; safe because it doesn‚Äôt alter business logic. (Impacted: UX Summary, Alternate/Error Flows)
- SD-UI-INFLIGHT-DISABLE: Disable submit buttons during in-flight service calls to prevent duplicate submissions; safe ergonomic default. (Impacted: Functional Behavior, Alternate/Error Flows)
- SD-UI-PAGINATION-LOCAL: If rules list exceeds a reasonable threshold, use standard table pagination defaults; safe because it doesn‚Äôt affect data. (Impacted: UX Summary)

---

## 16. Open Questions

1. **Service contracts:** What are the exact Moqui service names/endpoints for:
   - list rules by `promotionId`
   - create/update/delete rule
   - evaluate eligibility (`promotionId`, `accountId`, `vehicleId`) and return shape (`isEligible`, `reasonCode`, optional explanation text)?
2. **Rule combination logic:** When multiple rules exist for a promotion, is eligibility evaluated with **AND** (all must pass) or **OR** (any pass)? Is this configurable per promotion?
3. **Operator matrix:** Which operators are valid per `conditionType` (and their semantics)? E.g., does `ACCOUNT_ID_LIST` support `IN` only, also `NOT_IN`? Does `VEHICLE_TAG` support `EQUALS` only?
4. **Identifier formats:** What is the canonical format for `accountId` and `vehicleId` in UI input (UUID vs human code)? Should the UI provide lookup/search selectors instead of free-text?
5. **No-rules behavior:** If a promotion has **zero** eligibility rules, is it considered eligible for all contexts, or ineligible until rules are defined?
6. **Reason codes catalog:** What is the authoritative initial enum set for `reasonCode` and should the UI map them to user-friendly messages?
7. **Permissions:** What permission(s) should gate view vs manage (create/edit/delete) eligibility rules in the Moqui frontend?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Promotions: Define Eligibility Rules (Account/Vehicle)  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/160  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Promotions: Define Eligibility Rules (Account/Vehicle)

**Domain**: user

### Story Description

/kiro
# User Story

## Narrative
As a **Account Manager**, I want **to restrict offers to certain accounts or vehicle categories** so that **promotions are applied correctly**.

## Details
- Eligibility: specific accounts, simple tags (e.g., trailer/tractor), optional fleet-size threshold.
- Return eligibility decision with reason.

## Acceptance Criteria
- Configure eligibility.
- Evaluate eligibility with explanation.

## Integration Points (Workorder Execution)
- Workorder Execution calls eligibility evaluation during estimate pricing.

## Data / Entities
- PromotionEligibilityRule

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: CRM


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #161: [FRONTEND] [STORY] Promotions: Create Promotion Offer (Basic)  
File: ./scripts/story-work/frontend/161/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:pricing
- status:draft

### Recommended
- agent:pricing-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** pricing-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Promotions: Create Promotion Offer (Basic)

### Primary Persona
Account Manager

### Business Value
Enable Account Managers to create and manage simple promotions (percent off labor/parts or fixed amount off invoice) with valid date ranges and unique codes so downstream estimate/work order flows can retrieve applicable active promotions.

---

## 2. Story Intent

### As a / I want / So that
- **As an** Account Manager  
- **I want** to create a basic Promotion Offer with code, type, value, store scope, start/end dates, and optional usage limit; and activate/deactivate it  
- **So that** eligible customers can have that promotion applied to estimates/work orders when the promotion is active and within its valid dates

### In-scope
- Promotion Offer create (draft)
- Promotion Offer view (details)
- Promotion Offer activate / deactivate actions
- Frontend validations that are deterministic from rules (date range, required fields, non-negative numeric values)
- Handling backend uniqueness errors for promotion code
- Routing/navigation and Moqui screen/form/service wiring for the UI

### Out-of-scope
- Defining or editing promotion eligibility rules (customer eligibility model not specified)
- Applying promotions to estimates/work orders (consumption use-case)
- Promotion stacking/combination logic
- Approval workflows or guardrails (not described for promotions)
- Bulk import/export of promotions

---

## 3. Actors & Stakeholders
- **Account Manager (primary user):** creates and manages promotions.
- **Pricing domain maintainers:** ensure promotions are created with correct constraints and are auditable.
- **Work Execution (downstream consumer):** queries active promotions (integration point; UI not implementing this query).
- **Store/Location managers (stakeholder):** care about store-scoped promotions.
- **Compliance/Audit (stakeholder):** expects status changes to be traceable.

---

## 4. Preconditions & Dependencies

### Preconditions
- User is authenticated in the frontend.
- User has permission to manage promotions (exact permission string(s) **TBD**, see Open Questions).

### Dependencies
- Moqui backend endpoints/services exist (or will be implemented) to:
  - Create PromotionOffer in `DRAFT`
  - Fetch PromotionOffer by ID
  - Transition status to `ACTIVE` / `INACTIVE` (and possibly compute `EXPIRED`)
  - Enforce unique `promotionCode`
  - Validate date range and numeric constraints server-side

### Cross-domain dependencies (read-only)
- Store/location reference data for `storeCode` selection (source of truth **TBD**).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Primary: POS backoffice ‚Üí Pricing/Promotions ‚Üí ‚ÄúCreate Promotion‚Äù
- Secondary: Promotions list (if exists) ‚Üí ‚ÄúNew Promotion‚Äù button  
  (If list screen does not exist yet, link from a generic Pricing dashboard screen.)

### Screens to create/modify
1. **`PromotionOfferList`** (create if missing; minimal list to access ‚ÄúCreate‚Äù and view existing)
2. **`PromotionOfferCreate`** (new)
3. **`PromotionOfferDetail`** (new or extend existing) with activate/deactivate actions

> Screen path naming is project-convention dependent (README not provided here). Implementer should place screens under the pricing/promotions area consistent with repo patterns.

### Navigation context
- After successful create: redirect to `PromotionOfferDetail?promotionOfferId=<id>`
- From detail: provide ‚ÄúBack to Promotions‚Äù link to list

### User workflows
#### Happy path: create draft
1. Account Manager opens Create Promotion screen.
2. Enters: code, description, store code (or selects ‚ÄúAll stores‚Äù if supported), start/end dates, promotion type, promotion value, optional usage limit.
3. Clicks ‚ÄúCreate‚Äù.
4. System creates promotion in `DRAFT`, shows detail screen.

#### Happy path: activate
1. On detail screen for `DRAFT` or `INACTIVE` promotion, user clicks ‚ÄúActivate‚Äù.
2. System transitions status to `ACTIVE` if allowed.
3. UI reflects updated status and disables/enables buttons accordingly.

#### Happy path: deactivate
1. On detail screen for `ACTIVE` promotion, user clicks ‚ÄúDeactivate‚Äù.
2. System transitions status to `INACTIVE`.
3. UI reflects updated status.

#### Alternate: validation failure
- Inline field errors for client-side validations; server-side errors shown as form-level messages and field-level messages when mapped.

---

## 6. Functional Behavior

### Triggers
- Navigation to Create screen
- Submit Create form
- Click Activate / Deactivate on Detail screen
- Navigation to Detail screen (load by ID)

### UI actions
#### Create screen actions
- `Create` button submits form.
- `Cancel` returns to list without saving.

#### Detail screen actions
- `Activate` button (visible/enabled when status allows)
- `Deactivate` button (visible/enabled when status allows)
- Read-only display of immutable fields (see Data Requirements)

### State changes
- On create: status set to `DRAFT` (backend authoritative)
- On activate: `DRAFT` ‚Üí `ACTIVE` or `INACTIVE` ‚Üí `ACTIVE`
- On deactivate: `ACTIVE` ‚Üí `INACTIVE`
- `EXPIRED` handling: UI must treat as non-activatable; how status becomes `EXPIRED` is backend-defined.

### Service interactions (Moqui)
- Create screen form submits to a Moqui service (synchronous) that returns `promotionOfferId`.
- Detail screen actions call transition services.

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
Client-side validations (mirrors backend; backend remains authoritative):
- **promotionCode**: required; trim whitespace; reject empty string.
- **description**: required; reject empty string.
- **storeCode**: required vs optional **TBD** (Open Question); if optional, allow null meaning ‚Äúall stores‚Äù.
- **startDate/endDate**: required; validate `startDate <= endDate`.
- **promotionType**: required; must be one of:
  - `PERCENT_LABOR`
  - `PERCENT_PARTS`
  - `FIXED_INVOICE`
- **promotionValue**: required; must be > 0 (or >= 0?) **TBD** (Open Question).  
  UI must prevent negative values at minimum.
- **usageLimit**: optional; if present must be integer and >= 0.

Server-side validation/error mapping:
- Duplicate code: show field error on `promotionCode`: ‚ÄúPromotion code must be unique‚Äù.
- Invalid dates: show field error on date fields: ‚ÄúStart date must be on or before the end date‚Äù.
- Activation constraints (e.g., endDate in past): show banner/toast: ‚ÄúCannot activate an expired promotion‚Äù.

### Enable/disable rules
- `promotionCode` becomes read-only after creation (immutable).
- Activate button enabled when current status in {`DRAFT`, `INACTIVE`} and promotion is not expired (backend decides).
- Deactivate button enabled when status == `ACTIVE`.

### Visibility rules
- Show status badge/value prominently on detail.
- Show `usageLimit` as ‚ÄúUnlimited‚Äù when null.

### Error messaging expectations
- Form submit errors shown at top with a concise summary plus field-level messages where possible.
- Preserve backend message text for uniqueness/date errors if provided, otherwise use standardized messages above.

---

## 8. Data Requirements

### Entities involved
- `PromotionOffer` (pricing domain)

### Fields (type, required, defaults)
> Types are frontend types; backend types expected per pricing rules.

| Field | Frontend Type | Required (Create) | Default | Notes |
|---|---|---:|---|---|
| promotionOfferId | string (UUID) | no | n/a | Assigned by backend |
| promotionCode | string | yes | none | Immutable after create |
| description | string | yes | none | Internal description |
| storeCode | string \| null | **TBD** | **TBD** | Scope semantics unclear |
| startDate | string (YYYY-MM-DD) | yes | none | Date-only |
| endDate | string (YYYY-MM-DD) | yes | none | Date-only |
| promotionType | enum string | yes | none | Values listed above |
| promotionValue | number/string decimal | yes | none | Precision/format **TBD** (do not assume rounding) |
| usageLimit | number (int) \| null | no | null | Null = unlimited |
| status | enum string | no | `DRAFT` | Backend authoritative |

### Read-only vs editable by state/role
- After create (detail screen):
  - **Read-only always:** `promotionOfferId`, `promotionCode`, `status`
  - **Editable fields:** Not in scope for this basic story (create + activate/deactivate only).  
    If edit is desired, must be separate story.

### Derived/calculated fields
- `isAvailableForUse` (derived UI hint only): status == `ACTIVE` AND today within start/end date  
  Note: backend is authoritative; UI can display informational hint but must not make enforcement decisions beyond button enablement and messaging.

---

## 9. Service Contracts (Frontend Perspective)

> Exact service names/paths are not provided. Define Moqui service interfaces and screen transitions consistent with repo conventions. The frontend must be coded to those Moqui endpoints.

### Load/view calls
1. **Get Promotion Offer**
   - Input: `promotionOfferId`
   - Output: full `PromotionOffer` record
   - Errors:
     - 404/not found ‚Üí show ‚ÄúPromotion not found‚Äù and link back to list
     - 403 ‚Üí show unauthorized message

### Create/update calls
2. **Create Promotion Offer**
   - Input: `promotionCode`, `description`, `storeCode`, `startDate`, `endDate`, `promotionType`, `promotionValue`, `usageLimit`
   - Output: `promotionOfferId`, created entity (or fetch after create)
   - Errors:
     - Duplicate code (409 or validation error) ‚Üí field error on `promotionCode`
     - Validation errors ‚Üí field errors
     - 403 ‚Üí unauthorized

### Submit/transition calls
3. **Activate Promotion Offer**
   - Input: `promotionOfferId`
   - Output: updated status (or entity)
   - Errors:
     - Cannot activate expired/endDate past ‚Üí show actionable error
     - Concurrency (status changed) ‚Üí reload and show ‚ÄúPromotion status changed; page refreshed‚Äù

4. **Deactivate Promotion Offer**
   - Input: `promotionOfferId`
   - Output: updated status (or entity)

### Error handling expectations
- Moqui service errors map to:
  - Field errors: when error payload identifies field (preferred)
  - Form-level errors: otherwise
- Always preserve correlation/request ID if provided by backend in error response for support.

---

## 10. State Model & Transitions

### Allowed states
- `DRAFT`
- `ACTIVE`
- `INACTIVE`
- `EXPIRED` (may be computed; UI treats as terminal/non-activatable)

### Role-based transitions
- Account Manager with promotion-management permission:
  - `DRAFT` ‚Üí `ACTIVE`
  - `ACTIVE` ‚Üí `INACTIVE`
  - `INACTIVE` ‚Üí `ACTIVE`
- Any user without permission:
  - Can view list/detail only if allowed; otherwise blocked (permission model **TBD**)

### UI behavior per state
- `DRAFT`: show Activate enabled; show Deactivate hidden/disabled
- `ACTIVE`: show Deactivate enabled; show Activate hidden/disabled
- `INACTIVE`: show Activate enabled
- `EXPIRED`: show Activate disabled with tooltip/message; show Deactivate hidden/disabled

---

## 11. Alternate / Error Flows

### Validation failures
- Start date after end date ‚Üí prevent submit client-side; if server returns same, show field errors.
- Negative promotionValue or usageLimit ‚Üí prevent submit client-side; show field errors.

### Concurrency conflicts
- If activation/deactivation fails due to stale status:
  - UI reloads PromotionOffer and displays non-blocking message: ‚ÄúPromotion status updated by another user.‚Äù

### Unauthorized access
- If create screen accessed without permission:
  - Show ‚ÄúYou don‚Äôt have access to manage promotions.‚Äù
  - Do not render form submit actions.

### Empty states
- Promotions list empty: show empty state and ‚ÄúCreate Promotion‚Äù CTA.

### Backend dependency failures
- If service unavailable/timeouts:
  - Show retry affordance; do not assume operation succeeded.

---

## 12. Acceptance Criteria

### Scenario 1: Create a new draft promotion (percent off labor)
**Given** I am authenticated as an Account Manager with permission to manage promotions  
**And** I am on the Create Promotion screen  
**When** I enter a unique promotion code "LABOR15" and a description  
**And** I select promotion type "PERCENT_LABOR" with promotion value "15"  
**And** I set startDate "2026-02-01" and endDate "2026-02-28" with startDate on/before endDate  
**And** I submit the form  
**Then** a PromotionOffer is created successfully  
**And** the created PromotionOffer has status "DRAFT"  
**And** I am navigated to the PromotionOffer detail screen for the new promotion

### Scenario 2: Reject create when date range is invalid (client-side)
**Given** I am on the Create Promotion screen  
**When** I set startDate after endDate  
**Then** the UI shows a validation message "Start date must be on or before the end date"  
**And** the Create action is blocked until corrected

### Scenario 3: Reject create when promotion code is not unique (server-side)
**Given** a PromotionOffer already exists with promotionCode "SUMMER2024"  
**And** I am on the Create Promotion screen  
**When** I submit a new promotion with promotionCode "SUMMER2024"  
**Then** the backend rejects the request  
**And** the UI shows a field error on promotionCode "Promotion code must be unique"  
**And** no promotion is created

### Scenario 4: Activate a draft promotion
**Given** a PromotionOffer exists with status "DRAFT" and endDate is not in the past  
**And** I am on its PromotionOffer detail screen  
**When** I click "Activate"  
**Then** the promotion status becomes "ACTIVE"  
**And** the UI disables/hides the Activate action and enables the Deactivate action

### Scenario 5: Deactivate an active promotion
**Given** a PromotionOffer exists with status "ACTIVE"  
**And** I am on its PromotionOffer detail screen  
**When** I click "Deactivate"  
**Then** the promotion status becomes "INACTIVE"  
**And** the UI enables the Activate action

### Scenario 6: Prevent activation of an expired promotion
**Given** a PromotionOffer exists with endDate in the past  
**And** I am on its PromotionOffer detail screen  
**When** I attempt to activate the promotion  
**Then** activation is not allowed  
**And** the UI shows an error indicating the promotion is expired  
**And** the status remains unchanged after refresh

---

## 13. Audit & Observability

### User-visible audit data
- On detail screen, display (if available from backend):
  - `createdBy`, `createdDate`
  - `lastUpdatedBy`, `lastUpdatedDate`
- If not available, omit (do not fabricate).

### Status history
- If backend provides status change history, show a ‚ÄúStatus History‚Äù section (read-only).  
  Otherwise, not in scope.

### Traceability expectations
- All create/activate/deactivate calls must include correlation ID headers if the frontend has a standard mechanism (per repo convention).
- UI should log (frontend console/logger) structured events for:
  - promotion.create.submit
  - promotion.create.success/failure
  - promotion.activate.submit/success/failure
  - promotion.deactivate.submit/success/failure  
  (Do not log sensitive data; promotionCode is acceptable.)

---

## 14. Non-Functional UI Requirements

- **Performance:** Detail load should render skeleton/placeholder while fetching; avoid blocking UI thread.  
- **Accessibility:** All form fields labeled; errors announced; buttons keyboard accessible.  
- **Responsiveness:** Create/detail usable on tablet widths (Quasar standard breakpoints).  
- **i18n/timezone/currency:** Dates are date-only; timezone handling must be consistent (UTC vs store locale **TBD**). Currency formatting for FIXED_INVOICE value is **TBD** (do not assume currency).

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide an empty-state message and CTA on promotions list when no records exist; safe because it does not change domain behavior; impacts UX Summary, Alternate/Empty states.
- SD-ERR-MAP-VALIDATION: Map backend validation errors to field-level messages when field key is present, otherwise show form-level error banner; safe because it is standard error presentation without altering rules; impacts Business Rules, Service Contracts, Error Flows.

---

## 16. Open Questions

1. **Permission model (blocking):** What permission string(s) should the frontend enforce for create/activate/deactivate (e.g., `pricing:promotion:manage` per pricing guide), and is view access allowed to users without manage permission?
2. **Store scope semantics (blocking):** Is `storeCode` required? If optional, does null/empty mean ‚Äúall locations‚Äù, and how should the UI represent this (dropdown option ‚ÄúAll stores‚Äù)?
3. **Promotion value constraints (blocking):** For percent types, what is the allowed range (e.g., 0‚Äì100)? For fixed invoice amount, must it be > 0 and is there a maximum? (Do not assume.)
4. **Currency and formatting (blocking):** For `FIXED_INVOICE`, which currency applies (store currency? company currency?), and what decimal precision should the UI enforce/display?
5. **Status `EXPIRED` behavior (blocking):** Is `EXPIRED` a persisted status updated by backend job, or computed on read? What should activation service return if endDate is past but status isn‚Äôt `EXPIRED`?
6. **Eligibility (not implemented but impacts wording):** The story mentions ‚Äúeligible customers.‚Äù Is eligibility out of scope for this basic create flow (recommended), or must the create screen capture any eligibility fields now?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Promotions: Create Promotion Offer (Basic)  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/161  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Promotions: Create Promotion Offer (Basic)

**Domain**: user

### Story Description

/kiro
# User Story

## Narrative
As a **Account Manager**, I want **to create a simple promotion (discount amount/percent) with start/end dates** so that **I can apply it to estimates for eligible customers**.

## Details
- Offer types: % off labor, % off parts, fixed amount off invoice.
- Store code, description, active dates, optional usage limit.

## Acceptance Criteria
- Create/activate/deactivate offer.
- Validate date range.
- Unique code enforced.

## Integration Points (Workorder Execution)
- Workorder Execution can query active offers for a customer.

## Data / Entities
- PromotionOffer

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: CRM


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #259: [FRONTEND] [STORY] Pricing: Maintain MSRP per Product with Effective Dates
File: ./scripts/story-work/frontend/259/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:pricing
- status:draft

### Recommended
- agent:pricing-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** pricing-strict

---

## 1. Story Header

**Title:** [FRONTEND] Pricing: Maintain MSRP per Product with Effective Dates

**Primary Persona:** Pricing Manager

**Business Value:** Maintain auditable, effective-dated MSRP records per product so downstream pricing calculations, reporting, and compliance can reliably reference the correct MSRP for a given date.

---

## 2. Story Intent

### As a / I want / So that
**As a** Pricing Manager  
**I want** to create, update, and view MSRP records for a product with effective start/end dates (including indefinite end dates)  
**So that** the system has a single authoritative MSRP per product at any point in time, with clear history and validation against overlaps.

### In-scope
- Moqui UI screens to:
  - Search/select a product context for MSRP maintenance
  - List MSRP records for a product (effective-dated timeline)
  - Create a new MSRP record
  - Edit an existing MSRP record (subject to immutability/permissions policy)
  - View an MSRP record (read-only)
- Client-side and server-side validation surfacing for:
  - Required fields, date logic, positive amount, currency format
  - Overlapping effective date ranges conflict
  - Product existence validation failures
  - Permission/authorization failures
- Navigation, transitions, and confirmation/error handling patterns consistent with the Moqui frontend

### Out-of-scope
- Defining/altering pricing formulas, taxes, rounding policies, discount precedence
- Product master data management (owned by Inventory domain)
- Bulk import/export of MSRPs
- Approval workflows for MSRP changes (not specified)
- Promotion management, price books, location overrides

---

## 3. Actors & Stakeholders
- **Pricing Manager (primary user):** Maintains MSRP records.
- **Auditor (stakeholder):** Needs to review change history and effective-dated records.
- **Pricing Engine / Downstream consumers (system):** Consume active MSRP by product/date (frontend only surfaces; backend contract required).
- **Inventory domain (external dependency):** System of record for products; MSRP references a `productId` owned elsewhere.

---

## 4. Preconditions & Dependencies
- User is authenticated.
- User has permission to manage MSRP (permission string assumed from pricing guide: `pricing:msrp:manage`; exact mapping to Moqui artifact must exist).
- Backend endpoints exist (or will exist) to:
  - List MSRPs by product
  - Create MSRP
  - Update MSRP
  - Retrieve active MSRP by product/date (for view/testing)
  - Validate product existence (directly or indirectly)
- Inventory product lookup capability exists for selecting `productId` (contract TBD).
- System uses dates as **DATE** (not timestamp) for effective ranges; timezone rule must be confirmed.

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main menu: **Pricing ‚Üí MSRP Maintenance** (new top-level entry under Pricing).
- Optional contextual entry (if product detail screens exist): **Product ‚Üí Pricing ‚Üí MSRP** (TBD based on existing frontend IA; do not implement without confirmation).

### Screens to create/modify
Create:
1. **`apps/pos/pricing/msrp/ProductMsrpList.xml`** (screen)
   - Product selection context + list of MSRP records for selected product.
2. **`apps/pos/pricing/msrp/ProductMsrpDetail.xml`** (screen)
   - View/create/edit MSRP record.

Supporting components/forms:
- Form: `findProductMsrp` (filters by productId; may include effective date filter)
- Grid/list: `productMsrpList`
- Form: `createProductMsrp`
- Form: `updateProductMsrp`

### Navigation context
- `ProductMsrpList` is the hub.
- From list:
  - ‚ÄúCreate MSRP‚Äù ‚Üí `ProductMsrpDetail` in create mode with `productId` prefilled.
  - Select a record ‚Üí `ProductMsrpDetail` view/edit mode with `msrpId`.
- Breadcrumbs:
  - Pricing / MSRP / <Product> / <MSRP effective start>

### User workflows
**Happy path A (create time-bound MSRP)**
1. Pricing Manager opens MSRP Maintenance.
2. Selects product (via lookup/search).
3. Clicks ‚ÄúCreate MSRP‚Äù.
4. Enters amount, currency, start date, optional end date.
5. Submits; sees success message and returned record appears in list.

**Happy path B (create indefinite MSRP)**
- Same as A, but end date left blank; UI clearly labels as ‚ÄúNo end date (indefinite)‚Äù.

**Happy path C (edit MSRP)**
1. Open product MSRP list.
2. Open an MSRP record.
3. Edit allowed fields and save.
4. Returns to detail with updated audit metadata.

**Alternate path (view-only historical)**
- If record is historical and editing is disallowed, detail screen renders fields read-only with reason.

---

## 6. Functional Behavior

### Triggers
- User navigates to MSRP Maintenance menu item.
- User selects a product.
- User creates/edits an MSRP record.

### UI actions
- **Product selection**
  - Provide a product picker/lookup to populate `productId`.
  - On selection, load MSRP list for that product.
- **List MSRPs**
  - Show effective start/end, amount, currency, status indicator (derived: Active/Upcoming/Expired based on ‚Äútoday‚Äù and date range).
- **Create MSRP**
  - Open create form with `productId` locked (to prevent accidental cross-product creation).
- **Edit MSRP**
  - Open edit form for selected record.
  - Enforce read-only constraints if record is immutable or user lacks elevated permission.

### State changes (UI-level)
- After successful create/update:
  - Refresh MSRP list for product
  - Navigate to detail (or remain and show updated values) deterministically:
    - Create: navigate to detail view for new `msrpId`
    - Update: stay on detail, show toast/banner ‚ÄúSaved‚Äù
- On validation errors:
  - Keep user on form, highlight fields, show actionable messages.
- On conflict (overlap):
  - Show conflict banner ‚ÄúOverlapping effective dates exist for this product‚Äù and optionally link back to list filtered by date (if supported).

### Service interactions (frontend invoking backend)
- Load product lookup data (Inventory-owned; endpoint TBD)
- Load MSRP list by productId
- Create MSRP
- Update MSRP
- (Optional for screen) Load active MSRP for date filter preview (endpoint TBD)

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- **Required fields (create):**
  - `productId` (required; selected via lookup)
  - `amount` (required; must be > 0)
  - `currency` (required; must be 3-letter ISO 4217)
  - `effectiveStartDate` (required)
  - `effectiveEndDate` (optional)
- **Date logic:**
  - If `effectiveEndDate` provided, must be `>= effectiveStartDate` (same day allowed).
- **Overlap prevention:**
  - UI should pre-validate by showing existing ranges (informational), but authoritative validation happens server-side.
  - On server `409 Conflict` overlap error: display non-field error and keep form open.
- **Indefinite end date rule (BR2 in backend reference):**
  - If backend enforces ‚Äúnull end date must be latest-starting record‚Äù, UI must surface backend error clearly. (Exact error code/message mapping TBD.)

### Enable/disable rules
- If record is deemed **historical immutable** by backend policy:
  - Disable Save and make fields read-only (except maybe notes; not defined).
  - Show message: ‚ÄúThis MSRP ended in the past and cannot be edited.‚Äù
- If user lacks permission:
  - Hide Create/Edit actions, show read-only list.
  - If user deep-links into edit, show 403 handling (see error flows).

### Visibility rules
- Show audit metadata (created/updated timestamps and users) on detail screen.
- Show computed ‚ÄúStatus‚Äù chip/label:
  - `Active` if today within start/end (or end null)
  - `Upcoming` if today < start
  - `Expired` if end < today

### Error messaging expectations
- Field-level errors for missing/invalid input.
- Banner-level errors for:
  - Overlap conflicts
  - Product not found
  - Authorization failures
  - Backend unavailable / timeout

---

## 8. Data Requirements

### Entities involved
- **Pricing domain entity:** `ProductMSRP` (authoritative for MSRP records)
- **External reference:** Product (Inventory-owned) referenced by `productId`

### Fields
`ProductMSRP` (frontend model)
- `msrpId` (UUID, read-only, required for edit/view)
- `productId` (UUID, required; editable on create only; read-only on edit)
- `amount` (DECIMAL(19,4), required, > 0)
- `currency` (string(3), required, ISO 4217)
- `effectiveStartDate` (DATE, required)
- `effectiveEndDate` (DATE, optional; null = indefinite)
- `createdAt` (timestamp, read-only)
- `updatedAt` (timestamp, read-only)
- `updatedBy` (string, read-only)

Derived (UI-only; not persisted)
- `status` enum: `ACTIVE | UPCOMING | EXPIRED` (derived from effective dates + ‚Äútoday‚Äù)
- `isHistorical` boolean (derived; end date < today)

### Read-only vs editable by state/role
- Create:
  - Editable: productId (via picker), amount, currency, start/end dates
- Edit:
  - productId always read-only
  - amount/currency/dates editable unless backend indicates immutable or permission denies
- View:
  - all read-only

---

## 9. Service Contracts (Frontend Perspective)

> Backend contracts are not present in the provided frontend issue; the below names are placeholders and must be confirmed against actual Moqui service names / REST routes in this project.

### Load/view calls
1. **List MSRPs by product**
   - Request: `GET /api/pricing/msrp?productId=<uuid>`
   - Response: `200` list of `ProductMSRP`
2. **Get MSRP by id**
   - Request: `GET /api/pricing/msrp/<msrpId>`
   - Response: `200` `ProductMSRP`, `404` if not found
3. **(Optional) Get active MSRP by product/date**
   - Request: `GET /api/pricing/msrp/active?productId=<uuid>&date=YYYY-MM-DD`
   - Response: `200` single `ProductMSRP` or `404`/`204` if none (TBD)

### Create/update calls
4. **Create MSRP**
   - Request: `POST /api/pricing/msrp`
   - Body: `{ productId, amount, currency, effectiveStartDate, effectiveEndDate? }`
   - Responses:
     - `201` created entity (including `msrpId`)
     - `400` validation errors (field errors)
     - `404` or `400` product not found (TBD)
     - `409` overlap conflict
     - `403` forbidden
5. **Update MSRP**
   - Request: `PUT /api/pricing/msrp/<msrpId>` (or `PATCH`; TBD)
   - Body: `{ amount, currency, effectiveStartDate, effectiveEndDate? }`
   - Responses:
     - `200` updated entity
     - `400` validation
     - `403` forbidden
     - `404` not found
     - `409` overlap conflict
     - `409` immutable/historical conflict (could also be `403`; TBD)

### Error handling expectations
- Frontend must map:
  - `400` ‚Üí show field errors if structured, else banner
  - `403` ‚Üí show ‚ÄúYou do not have permission to manage MSRPs.‚Äù
  - `404` ‚Üí show ‚ÄúRecord not found‚Äù (and route back to list)
  - `409` ‚Üí show overlap/immutability conflict message (banner)
  - `5xx`/network ‚Üí show retry option and preserve form values

---

## 10. State Model & Transitions

### Allowed states (UI-derived; entity itself may not have a status field)
- `UPCOMING`: effectiveStartDate in future
- `ACTIVE`: today within effective range
- `EXPIRED`: effectiveEndDate in past

### Role-based transitions
- User with `pricing:msrp:manage`:
  - Can create MSRP
  - Can update MSRP unless historical immutability enforced
- User without permission:
  - Can view list/detail only (if screen accessible at all; auth gating TBD)

### UI behavior per state
- UPCOMING: editable (unless overridden by policy)
- ACTIVE: editable (unless restricted by policy)
- EXPIRED: default read-only; editing depends on ‚ÄúHistorical Immutability‚Äù policy (TBD)

---

## 11. Alternate / Error Flows

### Validation failures
- Missing required fields: inline errors; Save disabled until valid (client-side), but server remains authoritative.
- End date before start date: inline error; block submission.

### Concurrency conflicts
- If backend returns optimistic-lock style error (e.g., version mismatch):
  - Show banner ‚ÄúThis MSRP was updated by another user. Reload to continue.‚Äù
  - Provide ‚ÄúReload‚Äù action; warn unsaved changes will be lost.  
  *(Exact mechanism/version field not provided; may require backend support.)*

### Unauthorized access
- User navigates to create/edit without permission:
  - Show 403 page/banner and hide editing controls.
  - If on detail, render read-only and show permission message.

### Empty states
- No product selected:
  - Show instructions ‚ÄúSelect a product to view MSRPs.‚Äù
- Product selected but no MSRP records:
  - Show empty-state with CTA ‚ÄúCreate MSRP‚Äù.

### Dependency failures
- Product lookup fails (Inventory unavailable):
  - Disable product picker; show error and ‚ÄúRetry‚Äù.

---

## 12. Acceptance Criteria

### Scenario 1: View MSRP list for a product
**Given** I am authenticated  
**And** I have `pricing:msrp:manage` permission  
**When** I navigate to Pricing ‚Üí MSRP Maintenance  
**And** I select a product with id `<productId>`  
**Then** I see a list of MSRP records for `<productId>` including amount, currency, effective start, effective end (or ‚Äúindefinite‚Äù)  
**And** each row shows a derived status of Active/Upcoming/Expired based on today‚Äôs date.

### Scenario 2: Create a time-bound MSRP successfully
**Given** I am on the MSRP list for product `<productId>`  
**And** no existing MSRP overlaps 2025-01-01 through 2025-12-31  
**When** I choose Create MSRP  
**And** I enter amount `99.99`, currency `USD`, start date `2025-01-01`, end date `2025-12-31`  
**And** I submit  
**Then** the system creates the MSRP successfully  
**And** I see a success confirmation  
**And** the new MSRP appears in the product‚Äôs MSRP list.

### Scenario 3: Create an indefinite MSRP successfully
**Given** I am on the MSRP list for product `<productId>`  
**When** I choose Create MSRP  
**And** I enter amount `150.00`, currency `EUR`, start date `2026-01-01`  
**And** I leave end date blank  
**And** I submit  
**Then** the system creates the MSRP successfully  
**And** the list displays the end date as ‚Äúindefinite‚Äù.

### Scenario 4: Prevent invalid date logic in the UI
**Given** I am creating or editing an MSRP  
**When** I set effective start date to `2025-12-31`  
**And** I set effective end date to `2025-01-01`  
**Then** the Save action is disabled (or submission blocked)  
**And** I see an inline error that end date must be on/after start date.

### Scenario 5: Show overlap conflict returned by backend
**Given** an MSRP already exists for product `<productId>` from `2025-01-01` to `2025-12-31`  
**When** I attempt to create a new MSRP for `<productId>` with start date `2025-06-01`  
**Then** the backend responds with a conflict (HTTP 409)  
**And** the UI shows a non-field error indicating the effective dates overlap  
**And** my entered values remain in the form for correction.

### Scenario 6: Handle product not found during create
**Given** I attempt to create an MSRP with a productId that does not exist  
**When** I submit the form  
**Then** I see an error message indicating the product is invalid/not found  
**And** no MSRP record is created.

### Scenario 7: Permission enforcement in UI
**Given** I am authenticated  
**But** I do not have `pricing:msrp:manage` permission  
**When** I navigate to MSRP Maintenance  
**Then** I can view MSRP lists/details (if allowed)  
**And** I do not see Create or Edit actions  
**And** if I attempt to access a create/edit URL directly, I see a forbidden message and cannot save changes.

---

## 13. Audit & Observability

### User-visible audit data
- Detail screen shows:
  - createdAt, updatedAt, updatedBy (as provided by backend)
- List shows:
  - last updated timestamp (optional; if available)

### Status history
- UI supports viewing multiple records per product as the effective-dated ‚Äúhistory‚Äù.
- No separate ‚Äúhistory log‚Äù is created in this story.

### Traceability expectations
- Frontend logs (browser console in dev) should include correlation/request IDs if returned by backend headers (e.g., `X-Correlation-Id`) and surface them in error dialogs for support (header name TBD).
- Moqui server logs are out-of-scope for frontend, but UI must not drop backend error identifiers if provided.

---

## 14. Non-Functional UI Requirements
- **Performance:** MSRP list load should feel instantaneous for typical volumes; show loading indicator and avoid blocking UI.
- **Accessibility:** WCAG 2.1 AA with keyboard navigation for forms and tables; errors announced via ARIA live region where applicable.
- **Responsiveness:** Works on tablet widths commonly used in POS back office; list/table adapts (e.g., stacked rows).
- **i18n/timezone/currency:**
  - Currency shown as code (USD) at minimum; locale formatting may be applied if project has a standard.
  - Effective dates displayed in user locale but submitted as `YYYY-MM-DD`.
  - Timezone defining ‚Äútoday‚Äù must be clarified (UTC vs store local).

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide standard empty-state messaging and CTA when no MSRP records exist; safe UI ergonomics default with no domain impact. (Impacted sections: UX Summary, Error Flows)
- SD-UX-LOADING-ERROR: Standard loading spinners and retry on network failure; safe error-handling boilerplate. (Impacted sections: Service Contracts, Alternate/Error Flows)
- SD-UX-PRESERVE-FORM: Preserve user-entered values on server-side validation/conflict errors; safe UX behavior. (Impacted sections: Alternate/Error Flows, Acceptance Criteria)

---

## 16. Open Questions
1. **Inventory product lookup contract (blocking):** What is the frontend-supported way to select/validate `productId` (Moqui entity sync, REST endpoint, or existing product search screen)? Provide route/service name and minimal product fields for display (SKU/name).  
2. **Historical immutability policy (blocking):** Are MSRP records with `effectiveEndDate` in the past editable at all? If yes, what permission is required and what UI behavior should occur (warn + allow, or block)?  
3. **Indefinite end-date rule details (blocking):** Confirm BR2 ‚Äúnull end date only if latest-starting record‚Äù is enforced. If a user tries to create an indefinite record while a later-starting record exists, what error code/message should be shown?  
4. **Date ‚Äútoday‚Äù timezone (blocking):** Are effective dates evaluated in UTC, store local time, or user locale? This affects derived status labels and validations.  
5. **Backend endpoint shapes (blocking):** Confirm actual endpoints (or Moqui service names) and error payload format for field errors and conflicts so the frontend can map errors deterministically.  
6. **Authorization model (blocking):** Confirm permission string(s) and whether read-only viewing requires a separate permission or is open to any authenticated user.

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Pricing: Maintain MSRP per Product with Effective Dates
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/259
Labels: frontend, story-implementation, type:story, layer:functional, kiro

## ü§ñ Implementation Issue - Created by Durion Workspace Agent

### Original Story
**Story**: #198 - Pricing: Maintain MSRP per Product with Effective Dates
**URL**: https://github.com/louisburroughs/durion/issues/198
**Domain**: general

### Implementation Requirements
This issue was automatically created by the Missing Issues Audit System to address a gap in the automated story processing workflow.

The original story processing may have failed due to:
- Rate limiting during automated processing
- Network connectivity issues
- Temporary GitHub API unavailability
- Processing system interruption

### Implementation Notes
- Review the original story requirements at the URL above
- Ensure implementation aligns with the story acceptance criteria
- Follow established patterns for frontend development
- Coordinate with corresponding backend implementation if needed

### Technical Requirements
**Frontend Implementation Requirements:**
- Use Vue.js 3 with Composition API
- Follow TypeScript best practices
- Implement using Quasar UI framework components
- Ensure responsive design and accessibility (WCAG 2.1)
- Handle loading states and error conditions gracefully
- Implement proper form validation where applicable
- Follow established routing and state management patterns


### Notes for Agents
- This issue was created automatically by the Missing Issues Audit System
- Original story processing may have failed due to rate limits or network issues
- Ensure this implementation aligns with the original story requirements
- Frontend agents: Focus on Vue.js 3 components, TypeScript, Quasar UI framework. Coordinate with backend implementation for API contracts.

### Labels Applied
- `type:story` - Indicates this is a story implementation
- `layer:functional` - Functional layer implementation
- `kiro` - Created by Kiro automation
- `domain:general` - Business domain classification
- `story-implementation` - Implementation of a story issue
- `frontend` - Implementation type

---
*Generated by Missing Issues Audit System - 2025-12-26T17:37:19.493664193*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #84: [FRONTEND] [STORY] Order: Apply Price Override with Permission and Reason  
File: ./scripts/story-work/frontend/84/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:pricing
- status:draft

### Recommended
- agent:pricing-domain-agent
- agent:story-authoring

### Blocking / Risk
- risk:incomplete-requirements

**Rewrite Variant:** pricing-strict

---

# 1. Story Header

## Title
[FRONTEND] [STORY] Order: Apply Price Override with Permission and Reason

## Primary Persona
Service Advisor (POS user)

## Business Value
Enable compliant exception handling by allowing authorized users to override an order line‚Äôs price with reason capture and (when required) manager approval, while ensuring auditability and correct downstream totals/commission signaling.

---

# 2. Story Intent

## As a / I want / So that
- **As a** Service Advisor  
- **I want** to override a line item‚Äôs price by entering a new price and selecting a reason (and obtaining manager approval when required)  
- **So that** I can resolve pricing exceptions while remaining compliant and auditable.

## In-scope
- POS frontend UI to initiate a line price override for an existing Order Line.
- Permission-gated override entry, with reason code required.
- Support for ‚Äúimmediate apply‚Äù vs ‚Äúpending approval‚Äù outcomes based on backend threshold evaluation.
- Display of override status and metadata (who/why/when/approval) on the line item.
- Integration with Moqui backend services/endpoints for:
  - loading baseline line pricing context
  - normalizing entered amounts (via pricing service)
  - creating override requests
  - applying approved overrides (if applicable from UI)
- User-visible errors for unauthorized/validation failures.
- Basic audit/observability integration hooks (correlation/idempotency key propagation).

## Out-of-scope
- Creating/editing price override thresholds or guardrail configuration.
- Manager approval workflow UI (separate story unless already exists); this story will only support passing an existing `managerApprovalId` token/record if provided and reacting to `PendingApproval`.
- Reporting dashboards (‚ÄúReporting includes override usage‚Äù) beyond ensuring data is captured and visible in line details.
- Promotion/discount stacking rules and any pricing formulas (owned by Pricing backend).

---

# 3. Actors & Stakeholders

- **Service Advisor (primary):** requests override at POS.
- **Manager / Approver:** may approve overrides; may provide approval token/record.
- **Pricing Domain Services (backend):** SoR for rounding/normalization and override policy decisions (thresholds, status).
- **Order/Checkout (backend area):** persists override adjustments and recalculates totals; exposes order/line state to UI.
- **Finance/Reporting:** consumes stored override data (not implemented here, but depends on capture).
- **Security/Access Control:** provides permission assertions to UI and enforces on backend.

---

# 4. Preconditions & Dependencies

## Preconditions
- User is authenticated in POS and has an active session.
- An **Order** exists with at least one **Line Item** that has a baseline price from Pricing.
- UI can determine whether the current user has `price.override` capability (either via a permissions payload in session/user context or via an authorization check endpoint).

## Dependencies (must exist or be implemented in parallel)
- Backend endpoints/services corresponding to backend story #20 behaviors:
  - pricing normalization (`/api/v1/pricing/normalize` or Moqui service equivalent)
  - create override request (returns status: Applied vs PendingApproval, etc.)
  - (optional) apply override if approval already granted
  - lookup of valid override reason codes (`PriceOverrideReason`)
- Backend should provide deterministic outcomes and messages for:
  - 403 unauthorized
  - 409 concurrency/version conflict
  - 422 validation errors (invalid amount/reason/status)
- Moqui security artifacts for permission string `price.override` (or mapped equivalent) available to frontend.

---

# 5. UX Summary (Moqui-Oriented)

## Entry points
- From **Order Detail / Cart / Checkout** screen, on each line item:
  - Action: **‚ÄúOverride Price‚Äù** (only shown/enabled when allowed; see rules below)

## Screens to create/modify
- **Modify existing screen:** `OrderDetail` (or equivalent POS order screen)
  - Add override action per line
  - Add display of override status/metadata in line details
- **New dialog/screenlet:** `OrderLinePriceOverrideDialog`
  - Form inputs: new price, currency display, reason code, optional manager approval reference (if provided)

> Moqui implementation note: Prefer a **screenlet** with a **form-single** in a modal/dialog pattern; submit via transition to a service.

## Navigation context
- User remains within the Order context; dialog opens atop current order screen.
- On success, UI refreshes line and totals in-place.

## User workflows

### Happy path: immediate apply
1. Service Advisor clicks ‚ÄúOverride Price‚Äù on a line.
2. Dialog shows baseline price and current effective price, plus input for requested price and reason.
3. User enters requested price and selects reason code.
4. Submit.
5. Backend responds `Applied` (or equivalent success result) and returns updated line/totals.
6. UI shows updated effective price and ‚ÄúOverride Applied‚Äù metadata.

### Alternate path: requires approval (pending)
1. Same steps as above, but backend evaluates thresholds and responds `PendingApproval`.
2. UI shows line as ‚ÄúOverride Pending Approval‚Äù and does **not** present totals change unless backend includes updated totals (expected: totals unchanged until applied).
3. UI displays instructions: pending approval; cannot apply until approved.

### Alternate path: manager approval provided at submission
1. User includes `managerApprovalId` (if mechanism exists in UI context).
2. Backend accepts and applies override (if approval valid) or rejects (if invalid/insufficient).

---

# 6. Functional Behavior

## Triggers
- User action: click ‚ÄúOverride Price‚Äù on a line item.
- User action: submit override form.

## UI actions
- Open override dialog for selected `orderId` + `lineItemId`.
- Validate inputs client-side (format, required fields).
- Call backend to normalize entered amount (if required by contract) and then submit override request OR submit once and backend handles normalization (must match actual backend API; see Open Questions).

## State changes (frontend-visible)
- Line item effective price updates when override is applied.
- Line item shows override status badge/state:
  - Requested / PendingApproval / Approved / Rejected / Applied (as provided by backend)
- Line item shows override metadata:
  - reason code
  - requested by/at
  - approved by/at (if applicable)

## Service interactions (Moqui)
- Load order + line pricing context (baseline/effective)
- Load reason code list
- Normalize entered price (Pricing service)
- Create override request / apply override
- Refresh order summary totals and line items

---

# 7. Business Rules (Translated to UI Behavior)

## Validation
- **Requested price is required** and must be a valid monetary amount for the order currency.
- **Reason code is required** and must be one of `PriceOverrideReason` values.
- **Currency is not editable**; it is derived from Order/Line context.
- If backend enforces ISO4217 minor units and HALF_EVEN rounding:
  - UI must either:
    - submit as decimal string and let backend normalize, or
    - call normalize first and submit minor units returned.
  - UI must display normalized value if it differs from user entry (e.g., show ‚ÄúNormalized to $X.XX‚Äù).

## Enable/disable rules
- ‚ÄúOverride Price‚Äù action:
  - hidden or disabled when the line/order state does not allow overrides (must be supplied by backend; otherwise open question)
  - disabled if user lacks permission and has no manager approval mechanism available
- Submit button disabled until required fields are present and syntactically valid.

## Visibility rules
- Override metadata is visible on the line once any override exists (including pending/rejected), subject to user permissions if required by security policy (unclear; see Open Questions).

## Error messaging expectations
- 403: ‚ÄúYou don‚Äôt have permission to override prices.‚Äù
- 422: show field-level errors (price invalid, reason invalid, approval invalid).
- 409: ‚ÄúThis order was updated by another user. Refresh and try again.‚Äù
- Service unavailable for normalization/pricing: show ‚ÄúPricing service unavailable; cannot apply override right now.‚Äù (do not retry indefinitely; allow manual retry).

---

# 8. Data Requirements

## Entities involved (conceptual; UI reads/writes via services)
- `Order`
- `OrderLineItem`
- `PriceOverride`
- `ApprovalRecord` (referenced by `managerApprovalId`)
- `AuditLog` (view-only; surfaced via metadata fields)
- `PriceOverrideReason` (lookup for reason codes)

## Fields (type, required, defaults)

### UI input model: `PriceOverrideRequest`
- `orderId` (UUID, required)
- `lineItemId` (UUID, required)
- `requestedPrice` (string decimal in UI, required)
- `currency` (string ISO4217, read-only, required)
- `reasonCode` (string, required)
- `managerApprovalId` (UUID/string token, optional)
- `idempotencyKey` (string/UUID, required for submission; generated client-side)

### UI display model: `PriceOverrideView`
- `status` (enum string: Requested | PendingApproval | Approved | Rejected | Applied)
- `baselinePriceMinor` (long) + `currency`
- `requestedPriceMinor` (long) + `currency`
- `appliedPriceMinor` (long, optional until applied)
- `requestedBy` (string/userId)
- `requestedAt` (datetime)
- `approvedBy` (string/userId, nullable)
- `approvedAt` (datetime, nullable)
- `reasonCode` (string)

## Read-only vs editable by state/role
- Editable: requested price, reason code, manager approval reference **only at creation time**.
- Non-editable: baseline price, currency, audit metadata always read-only.
- If an override is already `PendingApproval`/`Applied`, UI must not allow editing; only view details.

## Derived/calculated fields
- Display ‚Äúdelta‚Äù (before/after) is derived in UI from baseline vs requested/applied if provided; no business decisions based on it (thresholds are backend-owned).

---

# 9. Service Contracts (Frontend Perspective)

> Note: exact service names/paths may differ in Moqui; implementer should map to actual services. Contracts below are required behaviors.

## Load/view calls
1. **Load order context**
   - Input: `orderId`
   - Output must include for each line:
     - `lineItemId`
     - `baselinePriceMinor` + `currency`
     - current effective price (either `appliedPriceMinor` or current line price)
     - existing `PriceOverride` summary if present (status + metadata)
2. **Load reason codes**
   - Output: list of `{reasonCode, description, activeFlag}`

## Create/update calls
3. **Normalize price amount (Pricing canonical)**
   - Input: `{amount: <decimal string>, currency}`
   - Output: `{normalizedMinor, normalizedDisplay}` OR `{normalizedAmountDecimal}`
   - Errors: 422 for invalid format/currency; 503 if unavailable.

4. **Create override request**
   - Input: `PriceOverrideRequest` (with normalized amount representation as required by backend)
   - Output: created override record with `status`, and updated order/line totals if applicable.
   - Errors:
     - 403 unauthorized (no permission/no valid manager approval)
     - 422 validation (invalid reason, invalid amount, invalid approval token)
     - 409 optimistic lock/version conflict (if order/line changed)

## Submit/transition calls
5. **Apply approved override** (optional if backend returns Applied immediately when approved)
   - Input: `{priceOverrideId, idempotencyKey}`
   - Output: updated override status Applied + updated order totals

## Error handling expectations
- All service calls must surface:
  - `correlationId` (if provided) in logs
  - user-friendly message + technical detail for console/log
- Idempotency:
  - client must send `idempotencyKey` on create/apply; retries must not double-apply.

---

# 10. State Model & Transitions

## Allowed states (as displayed/handled by UI)
- `Requested`
- `PendingApproval`
- `Approved`
- `Rejected`
- `Applied`

## Role-based transitions (frontend enforcement + backend authoritative)
- Service Advisor with `price.override`:
  - can submit override request
  - may receive immediate `Applied` if within thresholds (backend decides)
- User without `price.override`:
  - cannot submit unless they provide a valid `managerApprovalId` (backend decides validity)
- Manager/Approver:
  - approval action is out-of-scope UI here, but UI must support reflecting `Approved/Rejected` when viewing refreshed order.

## UI behavior per state
- `PendingApproval`: show ‚Äúpending‚Äù indicator; disable further override attempts on same line unless backend explicitly allows multiple requests (unclear; see Open Questions).
- `Applied`: show applied price and metadata; disable override edit for that override (new override request may or may not be allowed; unclear).
- `Rejected`: show rejected status + metadata; allow new request only if backend allows.

---

# 11. Alternate / Error Flows

## Validation failures
- Missing reason code ‚Üí inline error, prevent submit.
- Invalid price format (non-numeric, negative) ‚Üí inline error, prevent submit.
- Normalization returns different value ‚Üí show normalized value and require user confirmation (see Open Questions; may be optional).

## Concurrency conflicts
- If backend returns 409:
  - UI prompts refresh; on confirm, reload order and reopen dialog with latest baseline price.

## Unauthorized access
- If override action invoked but backend returns 403:
  - show permission error; do not persist any UI-local override state.

## Empty states
- If reason code list is empty/unavailable:
  - block submission and show ‚ÄúNo override reasons available; contact admin.‚Äù
- If line has no baseline price in response:
  - hide/disable override action and show ‚ÄúPricing not available for this line.‚Äù

---

# 12. Acceptance Criteria

## Scenario 1: Authorized immediate override applies and updates line
**Given** a Service Advisor is viewing an Order with a line item that has a baseline price and the user has `price.override` permission  
**When** the user opens ‚ÄúOverride Price‚Äù, enters a requested price, selects a reason code, and submits  
**Then** the UI sends an idempotent override request including `orderId`, `lineItemId`, requested amount, currency, and `reasonCode`  
**And** the UI displays the override status as `Applied` when returned  
**And** the line item effective price updates to the applied price  
**And** the UI shows override metadata (who/when/reason) on the line.

## Scenario 2: Override blocked without permission
**Given** a user without `price.override` permission is viewing an Order line  
**When** they attempt to submit a price override without a valid manager approval reference  
**Then** the backend responds 403  
**And** the UI shows ‚ÄúYou don‚Äôt have permission to override prices.‚Äù  
**And** the order and line prices remain unchanged.

## Scenario 3: Override requires approval and becomes pending
**Given** a Service Advisor submits an override that requires approval per backend threshold policy  
**When** the override request is submitted without manager approval  
**Then** the UI displays the resulting override status as `PendingApproval`  
**And** the UI indicates totals are not changed until approval (unless backend returns changed totals)  
**And** the UI prevents editing the pending override request from this dialog.

## Scenario 4: Invalid reason code prevented/handled
**Given** the override dialog is open  
**When** the user does not select a reason code and tries to submit  
**Then** the UI shows a required-field validation error and does not call the create override service.

## Scenario 5: Concurrency conflict handling
**Given** the override dialog is open for a line item  
**When** the user submits and the backend responds with 409 due to a version conflict  
**Then** the UI prompts the user to refresh  
**And** upon refresh, the UI reloads the order and allows the user to retry with updated baseline data.

## Scenario 6: Idempotent retry does not double-apply
**Given** the user submits an override and a network timeout occurs after request submission  
**When** the UI retries submission with the same `idempotencyKey`  
**Then** the backend returns the original result  
**And** the UI displays a single override record (no duplicate applied overrides shown).

---

# 13. Audit & Observability

## User-visible audit data
- On the line item (or line details panel), display:
  - override status
  - reason code
  - requestedBy/requestedAt
  - approvedBy/approvedAt (if present)

## Status history
- If backend provides multiple audit entries/status history, UI should display a simple chronological list in a collapsible ‚ÄúOverride History‚Äù section (otherwise show current metadata only).

## Traceability expectations
- Frontend generates and sends:
  - `idempotencyKey` per create/apply action
  - correlation/request ID header if the project standard exists (Moqui often uses request attributes; implementer to align)
- Frontend logs (console/dev logging or app logging) include `orderId`, `lineItemId`, `priceOverrideId` (if returned), and correlationId.

---

# 14. Non-Functional UI Requirements

- **Performance:** Override dialog should open with cached order data; reason codes may be cached per session. Service calls should not block UI; show loading states.
- **Accessibility:** Dialog and form controls must be keyboard navigable; errors announced via accessible helper text.
- **Responsiveness:** Must work on tablet widths commonly used in POS.
- **i18n/timezone/currency:** Currency formatting must respect order currency; timestamps displayed in user‚Äôs locale/timezone (no assumptions about timezone conversions beyond display).

---

# 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Show explicit empty-state messaging for missing reason codes because it is UI ergonomics and does not change domain policy. Impacted sections: UX Summary, Alternate/Error Flows.
- SD-ERR-STD-MAPPING: Map 403/409/422/503 to standard user-facing notifications and field errors because it is standard error handling implied by backend contract. Impacted sections: Business Rules, Service Contracts, Alternate/Error Flows.
- SD-OBS-CORRELATION: Generate a client idempotency key and propagate correlation identifiers when available because it is observability boilerplate and recoverable. Impacted sections: Service Contracts, Audit & Observability, Acceptance Criteria.

---

# 16. Open Questions

1. **Backend API shape:** What are the exact Moqui service names/REST paths and payload formats for:
   - pricing normalization
   - create override request
   - apply approved override  
   (Needed to implement transitions/forms without guessing.)

2. **Manager approval capture UX:** How is `managerApprovalId` obtained in the POS?
   - manager login re-auth modal?
   - scanned approval code/token?
   - selection from pending approvals?
   (Story mentions ‚Äúoptional manager approval‚Äù but not the mechanism.)

3. **Order/line eligibility constraints:** Are there order states or line types where overrides are forbidden (e.g., finalized/paid/refunded, promo lines, tax lines)? If yes, backend should return an explicit flag per line or an error code to guide UI.

4. **Multiple overrides per line:** If an override is already `Applied` or `PendingApproval`, can a new override request be created for the same line? If allowed, what is the rule (supersede, stack, only latest active)?

5. **Reason code catalog:** Where is `PriceOverrideReason` sourced and does it include descriptions/localization/active flags? Is the list global or location/business-unit scoped?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Order: Apply Price Override with Permission and Reason  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/84  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Order: Apply Price Override with Permission and Reason

**Domain**: user

### Story Description

/kiro
# User Story

## Narrative
As a **Service Advisor**, I want to override a line price with reason and permission so that I can resolve exceptions while staying compliant.

## Details
- Override requires role/permission.
- Capture reason code and optional manager approval.

## Acceptance Criteria
- Override blocked without permission.
- Override recorded with who/why.
- Reporting includes override usage.

## Integrations
- Pricing service returns baseline; override stored as adjustment.

## Data / Entities
- PriceOverride, ApprovalRecord, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Experience
- domain :  Point of Sale

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration


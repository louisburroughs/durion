‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
DOMAIN: accounting
Total Stories: 36
Generated: dim. 18 janv. 2026 12:03:02 EST
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #143: [FRONTEND] [STORY] Timekeeping: Export Approved Time for Accounting/Payroll  
File: ./scripts/story-work/frontend/143/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

STOP: Clarification required before finalization

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Timekeeping: Export Approved Time for Accounting/Payroll

### Primary Persona
Accounting Clerk (Accounting user)

### Business Value
Enable payroll and cost accounting processing by exporting **only** approved time entries with payroll-facing identifiers, with a complete audit trail of export activity.

---

## 2. Story Intent

### As a / I want / So that
- **As an** Accounting Clerk  
- **I want** to export approved time entries by date range and location(s) in CSV or JSON  
- **So that** payroll processing and cost accounting can be performed using payroll-facing identifiers and a stable definition of ‚ÄúAPPROVED‚Äù.

### In-scope
- A Moqui screen flow to:
  - Choose **date range** (inclusive) and **one or more locations**
  - Choose **format** (CSV or JSON)
  - Request an export
  - Download the resulting file (or receive the file directly, depending on backend behavior)
- Display export outcome:
  - records exported count
  - records skipped due to missing mappings (if available)
  - correlation/export id (if provided)
- User-visible audit visibility (at least ‚ÄúExport requested by/when/parameters/status‚Äù)

### Out-of-scope
- Creating/maintaining payroll identity mappings (employee/location ‚Üí payroll IDs)
- Approving/unapproving time entries
- Scheduling recurring exports
- Editing/exporting non-approved time entries
- Building backend export logic (referenced backend story only)

---

## 3. Actors & Stakeholders
- **Primary Actor:** Accounting Clerk
- **Stakeholders:**
  - Payroll processors (downstream consumers of export file)
  - Cost accounting analysts
  - Auditors/Compliance (require immutable audit record)
  - People/Timekeeping domain owners (system of record for time entry + approval)

---

## 4. Preconditions & Dependencies
- User is authenticated in the Moqui frontend.
- User has permission to export time for accounting/payroll (exact permission string **TBD**, see Open Questions).
- Backend provides an export capability supporting:
  - date range (inclusive)
  - location(s)
  - format (CSV/JSON)
  - exporting **only APPROVED** time entries
  - skipping unmapped entries and recording a remediation artifact (backend behavior)
- Locations list is available to the frontend (either via accounting export API ‚Äúlocations‚Äù endpoint or existing location directory endpoint).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main navigation: **Accounting ‚Üí Timekeeping Exports** (menu item)
- Optional deep link: `/accounting/timekeeping/export` (route to be confirmed with repo conventions)

### Screens to create/modify
- **New Screen:** `accounting/timekeeping/ExportApprovedTime.xml` (name illustrative; final per repo conventions)
  - Form to capture export parameters
  - Results panel for last-run outcome
  - Download link/button when file is ready/returned
- **Optional New Screen:** `accounting/timekeeping/ExportHistory.xml`
  - List prior export requests (if backend provides history/audit query)
- **Optional Component:** reusable ‚Äúdownload file‚Äù handler if repo uses common patterns

### Navigation context
- Breadcrumb: Accounting ‚Üí Timekeeping Exports ‚Üí Export Approved Time
- From this screen, user can:
  - Run a new export
  - (Optional) view export history / audit log

### User workflows
**Happy path (synchronous download):**
1. User opens Export Approved Time screen
2. Selects start date, end date, location(s), and format
3. Clicks ‚ÄúExport‚Äù
4. System validates inputs client-side and submits
5. Backend responds with file payload/stream
6. Browser downloads file; UI shows success + counts

**Alternate path (async job + later download):**
1‚Äì3 same
4. Backend responds with `exportId` + status ‚ÄúQUEUED/PROCESSING‚Äù
5. UI polls or provides ‚ÄúRefresh status‚Äù
6. When READY, user clicks Download

**Alternate path (empty result):**
- Export completes successfully; file contains CSV header only or empty JSON array; UI indicates ‚Äú0 exported‚Äù

---

## 6. Functional Behavior

### Triggers
- User clicks **Export** on the export form.

### UI actions
- Date pickers for `startDate` and `endDate`
- Multi-select for `locationId` (one or more)
- Format selector: `CSV` | `JSON`
- Export button
- Status area:
  - success/failure message
  - exported count
  - skipped count (if provided)
  - download action (if applicable)

### State changes (frontend)
- `idle` ‚Üí `validating` ‚Üí `submitting` ‚Üí `complete` or `error`
- If async: `complete` may be replaced by `queued/processing/ready/error`

### Service interactions (Moqui)
- On screen load: fetch available locations (dependency; endpoint TBD)
- On export submit:
  - invoke backend export service/endpoint
  - handle binary download or job response
- On history display (optional): fetch audit/history list

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- `startDate` required
- `endDate` required
- `endDate >= startDate` (inclusive range)
- At least one `locationId` required (unless backend supports ‚Äúall locations‚Äù; TBD)
- `format` required (CSV default allowed only if confirmed as safe; otherwise no default)

### Enable/disable rules
- Export button disabled while submitting
- Download button visible/enabled only when backend indicates file ready or a file blob is available

### Visibility rules
- If backend returns ‚Äúempty dataset‚Äù, show informational message and still provide download (because output is meaningful/auditable)
- If backend reports skipped/unmapped entries count/details, show summary; do **not** display PII-heavy details by default

### Error messaging expectations
- Parameter validation errors: show inline field error + top-level summary
- Unauthorized (403): show ‚ÄúYou do not have permission to export approved time.‚Äù
- Backend unavailable (503): show retry guidance
- Server validation: show backend error code and user-friendly message (do not expose sensitive data)

---

## 8. Data Requirements

### Entities involved (frontend perspective)
- **TimeEntry** (read/exported; owned by People domain; not directly edited here)
- **PayrollIdentityMap** (conceptual mapping; owned by Accounting; not managed here)
- **ExportAuditEvent / ExportRequest** (conceptual; for history/audit display; owned by Accounting)

### Fields (type, required, defaults)
**Export Request Inputs**
- `startDate` (date, required)
- `endDate` (date, required)
- `locationIds` (List<id>, required; min 1) ‚Äî *TBD if optional*
- `format` (enum: `CSV` | `JSON`, required)
- (Optional) `timeZone` (IANA string) ‚Äî if backend needs it; TBD
- (Optional) `businessUnitId` ‚Äî if required for accounting scoping; TBD

**Export Response (minimum UI needs)**
- `status` (enum: SUCCESS|FAILED|QUEUED|PROCESSING|READY) ‚Äî TBD
- `recordsExportedCount` (number)
- `recordsSkippedCount` (number) ‚Äî especially missing mapping
- `correlationId` / `exportId` (string)
- `downloadUrl` (string) OR binary payload

### Read-only vs editable by state/role
- All response fields are read-only
- Inputs editable only when not submitting; editable after completion to run another export

### Derived/calculated fields
- Display-only ‚ÄúDate range (inclusive)‚Äù summary
- ‚ÄúLocations selected‚Äù summary

---

## 9. Service Contracts (Frontend Perspective)

> Backend contract details are not provided in the frontend issue text; the backend story describes behavior but not concrete endpoints. Frontend implementation requires confirmation of actual Moqui service names / REST endpoints and response shapes.

### Load/view calls
- `GET /locations` (or equivalent) to populate location selector ‚Äî **TBD**
- (Optional) `GET /accounting/timekeeping/exports` to show history ‚Äî **TBD**

### Create/update calls
- Export request (one of the following patterns ‚Äî **TBD which is correct**):
  1) `POST /accounting/timekeeping/exports` with JSON body ‚Üí returns file stream OR job metadata
  2) Moqui service call (e.g., `accounting.time.exportApprovedTime`) returning `fileId`/`downloadUrl`

### Submit/transition calls
- If async:
  - `GET /accounting/timekeeping/exports/{exportId}` to check status
  - `GET /accounting/timekeeping/exports/{exportId}/download` to download file

### Error handling expectations
- `400` invalid params (e.g., endDate < startDate) ‚Üí map to inline errors where possible
- `403` forbidden ‚Üí show permission error
- `503` upstream unavailable (people/timekeeping) ‚Üí show retry + do not cache failure as permanent
- Empty result should be `200` with empty dataset and still downloadable content

---

## 10. State Model & Transitions

### Allowed states (frontend-local)
- `IDLE`
- `VALIDATION_ERROR`
- `SUBMITTING`
- `SUCCESS_READY` (file ready / downloaded)
- `ASYNC_QUEUED` (if job created)
- `ASYNC_PROCESSING`
- `ASYNC_READY`
- `FAILED`

### Role-based transitions
- Only authorized Accounting users can move from `IDLE` ‚Üí `SUBMITTING` (enforced by backend; frontend should also hide/disable entry points if permission is known)

### UI behavior per state
- `SUBMITTING`: disable inputs and show progress
- `SUCCESS_READY`: show success summary + download result (or ‚Äúdownloaded‚Äù confirmation)
- `ASYNC_*`: show status + refresh/poll controls + enable download only when READY
- `FAILED`: show error summary + keep user inputs for retry

---

## 11. Alternate / Error Flows

### Validation failures
- Missing dates, invalid range, no locations selected ‚Üí prevent submit, show inline errors

### Concurrency conflicts
- Not expected for export request; if backend returns `409` due to idempotency conflict, show message:
  - ‚ÄúAn export with these parameters is already in progress. Refresh status or download existing export.‚Äù (only if backend supports this concept; TBD)

### Unauthorized access
- If screen accessed without permission:
  - hide export form and show ‚ÄúNot authorized‚Äù message
  - do not call export endpoint

### Empty states
- No locations available:
  - show blocking empty state ‚ÄúNo locations available to export. Contact an administrator.‚Äù
- No matching approved entries:
  - show success with 0 exported; allow download

---

## 12. Acceptance Criteria

### Scenario 1: Export CSV for date range and location(s) includes only approved entries
**Given** the user has permission to export approved time  
**And** there exist time entries in the selected date range and locations with mixed approval states  
**When** the user requests an export in `CSV` format  
**Then** the export result contains only entries in state `APPROVED`  
**And** the UI presents a successful completion message including `recordsExportedCount`  
**And** the user can download the CSV output.

### Scenario 2: Export JSON returns success with empty dataset when no approved entries match
**Given** the user has permission to export approved time  
**And** there are no `APPROVED` time entries in the selected date range and locations  
**When** the user requests an export in `JSON` format  
**Then** the request succeeds  
**And** the UI indicates `recordsExportedCount = 0`  
**And** the downloaded JSON content is an empty array (or equivalent empty dataset per contract).

### Scenario 3: Client blocks invalid date range
**Given** the user is on the Export Approved Time screen  
**When** the user sets `endDate` earlier than `startDate`  
**And** clicks Export  
**Then** the UI prevents submission  
**And** shows a validation error stating the end date must be on or after the start date.

### Scenario 4: Unauthorized user cannot export
**Given** the user lacks the required export permission  
**When** the user navigates to the Export Approved Time screen  
**Then** the export action is not available  
**And** any attempted export request results in a clear ‚Äúnot authorized‚Äù message (403-handling).

### Scenario 5: Missing payroll/location mapping causes entries to be skipped (reported outcome)
**Given** there is an `APPROVED` time entry in range  
**And** the backend determines it has missing employee and/or location mapping for payroll export  
**When** the user requests an export  
**Then** that entry is not included in the downloaded output  
**And** the UI displays that some entries were skipped due to missing mappings (count and generic reason at minimum).

### Scenario 6: Export activity is audited (user-visible confirmation)
**Given** the user successfully completes an export request  
**When** the export completes  
**Then** the UI displays a correlation/export identifier (if provided)  
**And** the export request appears in export history/audit view (if provided), including requester, timestamp, parameters, and outcome.

---

## 13. Audit & Observability

### User-visible audit data
- Show at minimum after completion:
  - Requested by (current user)
  - Requested at (timestamp)
  - Parameters (date range, locations, format)
  - Outcome (success/failure) and counts
  - Correlation/export ID (if provided)

### Status history
- If backend provides export history:
  - list includes: timestamp, requester, date range, locations, format, status, exported/skipped counts, correlation/export id

### Traceability expectations
- Frontend includes `X-Correlation-Id` header if the project standard exists (TBD)
- Ensure no export file contents are logged in browser console

---

## 14. Non-Functional UI Requirements
- **Performance:** locations list should load within 2 seconds under normal conditions; export submit should show immediate progress feedback
- **Accessibility:** keyboard navigable form controls; label all inputs; announce errors (ARIA) in Quasar components
- **Responsiveness:** usable on tablet-sized screens (accounting backoffice)
- **i18n/timezone:** dates displayed in user locale; clarify whether export date interpretation uses store/location timezone or user timezone (TBD)

---

## 15. Applied Safe Defaults
- none

---

## 16. Open Questions

1. **Backend contract (blocking):** What are the exact Moqui endpoints/services for:
   - requesting an export (path/service name, request/response schema)
   - downloading the file (binary vs URL)
   - async status polling (if applicable)?
2. **Delivery mode (blocking):** Is export **synchronous download** or an **async job** that becomes downloadable later (or both)?
3. **Authorization (blocking):** What permission(s)/scope(s) gate:
   - viewing the export screen
   - executing the export?
4. **Location selector source (blocking):** Which endpoint/service provides the list of locations the accounting clerk may export for, and what filtering (by business unit / user access) is required?
5. **Time zone semantics (blocking):** Are `startDate/endDate` interpreted in:
   - location timezone,
   - business unit timezone,
   - or user timezone?
6. **Skipped-entry reporting (non-blocking but important):** Should UI show only counts, or also provide a downloadable ‚Äúskipped report‚Äù (e.g., missing mapping details) for remediation?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Timekeeping: Export Approved Time for Accounting/Payroll  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/143  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Timekeeping: Export Approved Time for Accounting/Payroll

**Domain**: user

### Story Description

/kiro  
# User Story

## Narrative
As an **Accounting user**, I want **to export approved time** so that **it can be used for payroll or cost accounting**.

## Details
- Export by date range and location.
- Provide CSV/JSON output.

## Acceptance Criteria
- Only approved time is exported.
- Export includes person identifiers and location.
- Export activity is audited.

## Integration Points (workexec/shopmgr)
- None required initially.

## Data / Entities
- TimeEntry

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: People Management

### Frontend Requirements
- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack
- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #177: [FRONTEND] [STORY] Accounting: Handle Refund Issued ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/177
File: ./scripts/story-work/frontend/177/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements
- risk:financial-inference

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

**Title:** [FRONTEND] [STORY] Accounting: Handle Refund Issued (Review + Trace Refund Against Original Transaction)

**Primary Persona:** Accounting Clerk / Finance Ops User (with accounting permissions)

**Business Value:** Enable finance users to view and validate refund issuance events with complete traceability to the original payment/invoice, ensuring refunds are discoverable, auditable, and exceptions are handled consistently (over-refunds, missing references, duplicates).

---

## 2. Story Intent

**As a** Finance Ops user  
**I want** a UI to review `RefundIssued` events / refund transactions and see their linkage to the original payment and/or invoice (including reason and authorizer)  
**So that** I can audit refund activity, identify exceptions, and provide operational support without needing database access.

### In-scope
- A Moqui screen flow to:
  - List refunds / refund events
  - View a refund‚Äôs details and traceability links (original transaction, related invoice/payment)
  - Surface processing/status and failure reasons when refund handling fails
- Basic filtering/search on key identifiers (refundId, eventId, originalTxnRef, date range, status)
- Display audit metadata (authorizer, occurredAt/createdAt, createdBy)
- Error/empty states for missing/invalid references

### Out-of-scope
- Initiating/authorizing a refund from the UI (issuing refunds)
- Defining GL debit/credit mappings, posting categories, or journal entry lines in the UI
- Editing refund financials (amount/currency/reason) after receipt
- Tax/refund policy decisions (jurisdictional rules, GL account selection)

---

## 3. Actors & Stakeholders
- **Primary user:** Finance Ops / Accounting Clerk
- **Secondary stakeholders:** Auditors/Compliance (read-only needs), Customer Support (lookup), Engineering/Support (diagnostics)
- **Upstream system actor (source):** Payment system emitting `RefundIssued` events (system-to-system)

---

## 4. Preconditions & Dependencies
- Backend (Moqui services/entities) provides a persisted representation of refunds/refund events and their linkage to an original transaction (payment and/or invoice).
- Event contract reference exists: ‚ÄúDurion Accounting Event Contract v1‚Äù (PDF linked), but required fields/enums are not provided in this prompt.
- Permission model exists for accounting read access and viewing audit metadata.

**Dependency:** The frontend needs stable service endpoints for:
- Searching refunds
- Fetching refund detail (including original transaction link and any processing status/errors)
- (Optional) fetching linked payment/invoice summaries for navigation

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main navigation: **Accounting ‚Üí Refunds**
- Deep links:
  - `/accounting/refunds` (list)
  - `/accounting/refunds/<refundId>` (detail)
  - Optional: `/accounting/refunds/event/<eventId>` if eventId is first-class

### Screens to create/modify
1. **Screen:** `accounting/refunds/RefundList.xml`
   - List/search/filter refunds (and/or refund events).
2. **Screen:** `accounting/refunds/RefundDetail.xml`
   - View refund data, status, linkage, and audit trail.
3. **(Optional) Reuse/Link:** existing screens for Payment/Invoice detail if present in repo; otherwise show read-only summaries.

### Navigation context
- Breadcrumb: Accounting ‚Üí Refunds ‚Üí Refund Detail
- From Refund Detail, allow navigation to:
  - Original Payment (if resolvable)
  - Invoice (if resolvable)
  - Source Event (if stored)

### User workflows
**Happy path**
1. User opens Refunds list.
2. User searches by refundId or originalTxnRef.
3. User opens Refund Detail.
4. User verifies amount/currency/reason, authorizer, occurredAt, and confirms links to original transaction.

**Alternate paths**
- Refund exists but original payment/invoice is missing ‚Üí show ‚ÄúUnresolved reference‚Äù with identifiers.
- Refund processing failed (backend recorded failure) ‚Üí show status + failure reason and raw error message (sanitized).
- Duplicate event detected / idempotency conflict ‚Üí show conflict banner and link to event record(s) if available.

---

## 6. Functional Behavior

### Triggers
- User navigates to Refunds list or Refund Detail.
- User applies filters/search.
- User clicks a linked entity (payment/invoice) from detail.

### UI actions
- Search by:
  - refundId
  - eventId (if applicable)
  - originalTxnRef / originalTransactionId
  - status
  - occurredAt/createdAt date range
  - reasonCode (if enumerated)
- Open detail view
- Copy-to-clipboard for IDs (refundId/eventId/originalTxnRef) for support workflows

### State changes
- Frontend is read-only for refund records in this story (no state mutation except navigation).
- Any ‚Äústatus‚Äù displayed is backend-provided and not changed by the UI.

### Service interactions
- List screen calls a search/find service.
- Detail screen calls a get service by `refundId` (and optionally fetches linked payment/invoice summaries).

---

## 7. Business Rules (Translated to UI Behavior)

> Note: Accounting domain rules mention GL impacts and reason-code-dependent treatment; frontend must **not** infer accounting postings. It must display what backend provides.

### Validation
- Search form validation:
  - If user enters an ID, enforce basic format checks if known (UUID). If unknown, allow free-text but label field as ‚ÄúIdentifier‚Äù.
  - Date range: end date must be >= start date.

### Enable/disable rules
- ‚ÄúView Original Payment‚Äù link enabled only when backend returns a resolvable `paymentId` (or a navigation-safe reference).
- ‚ÄúView Invoice‚Äù link enabled only when backend returns `invoiceId`.

### Visibility rules
- Show a prominent banner when:
  - Refund status = FAILED
  - Reference missing (original transaction not found)
  - Refund exceeds original amount (if backend marks this failure reason)
  - Duplicate/conflict detected (if backend exposes a conflict flag/reason)

### Error messaging expectations
- Backend error codes (if returned) should map to user-facing messages:
  - `REFUND_EXCEEDS_ORIGINAL_AMOUNT` ‚Üí ‚ÄúRefund amount exceeds refundable balance of original transaction.‚Äù
  - `ORIGINAL_TRANSACTION_NOT_FOUND` ‚Üí ‚ÄúOriginal transaction could not be found.‚Äù
  - `INVALID_REASON_CODE` ‚Üí ‚ÄúRefund reason code is invalid or unsupported.‚Äù
  - `INGESTION_DUPLICATE_CONFLICT` (or equivalent) ‚Üí ‚ÄúDuplicate refund event conflict detected; requires investigation.‚Äù
- Always show a support-friendly details section with correlation IDs (refundId, eventId, originalTxnRef) without exposing sensitive payment details.

---

## 8. Data Requirements

### Entities involved (frontend-read)
- `Refund` or `RefundTransaction` (name TBD by backend/Moqui entities)
- `Payment` (read-only lookup/navigation)
- `Invoice` (read-only lookup/navigation)
- `AccountingEvent` / stored `RefundIssued` event record (optional, if persisted)

### Fields (type, required, defaults)
**Refund list item (minimum)**
- `refundId` (string/UUID, required)
- `eventId` (string/UUID, optional but preferred)
- `originalTransactionId` or `originalTxnRef` (string, required by business rule; may be unresolved)
- `refundAmount` (decimal, required)
- `currencyUomId` / `currency` (string, required)
- `reasonCode` (string, required)
- `status` (string enum, required) ‚Äî e.g., `COMPLETED`, `FAILED`, `PENDING` (actual values TBD)
- `occurredAt` (datetime, required if event-based) OR `createdAt` (datetime, required)

**Refund detail (additional)**
- `authorizerId` (string, optional depending on contract; displayed if present)
- `failureReason` (string, optional)
- `failureMessage` (string, optional; must be sanitized)
- `linkedPaymentId` (string/UUID, optional)
- `linkedInvoiceId` (string/UUID, optional)
- `sourceModule` (string, optional)
- `schemaVersion` (string, optional)
- `businessUnitId` (string/UUID, optional)
- Audit fields: `createdByUserId`, `createdAt`, `lastUpdatedByUserId`, `lastUpdatedAt` (as available)

### Read-only vs editable
- All fields are **read-only** in this story.

### Derived/calculated fields (UI-only)
- ‚ÄúReference status‚Äù derived from presence/absence of linked entities:
  - `Resolved` if linked entity IDs present
  - `Unresolved` if missing but originalTxnRef present

---

## 9. Service Contracts (Frontend Perspective)

> Backend service names are not provided; define placeholders that Moqui devs must map to actual services.

### Load/view calls
1. **Search refunds**
   - Service: `AccountingRefundServices.searchRefunds` (placeholder)
   - Inputs:
     - `refundId?`, `eventId?`, `originalTxnRef?`, `status?`, `reasonCode?`
     - `fromDate?`, `thruDate?`
     - `pageIndex`, `pageSize`, `orderBy` (safe default)
   - Output:
     - `refundList[]` with fields listed in Data Requirements
     - `totalCount`

2. **Get refund detail**
   - Service: `AccountingRefundServices.getRefund` (placeholder)
   - Inputs: `refundId` (required)
   - Output: `refund` object including link references and failure metadata

3. **(Optional) Get linked payment/invoice summary**
   - Services: `PaymentServices.getPaymentSummary` / `BillingInvoiceServices.getInvoiceSummary` (placeholders)
   - Inputs: `paymentId` or `invoiceId`
   - Output: minimal summary for navigation confirmation (no sensitive PAN data)

### Create/update calls
- none (read-only story)

### Submit/transition calls
- none

### Error handling expectations
- `401/403`: route to unauthorized screen or show ‚ÄúNot authorized‚Äù and hide list data.
- `404` on refund detail: show ‚ÄúRefund not found‚Äù with entered ID.
- `409` conflict (duplicate/conflict): show conflict banner; include IDs.
- `5xx` / timeout: show retry affordance and preserve search criteria.

---

## 10. State Model & Transitions

### Allowed states (display-only; owned by backend)
- `PENDING` (if ingestion/processing is async)
- `COMPLETED`
- `FAILED`
- `QUARANTINED` (if conflict/dlq concept exists)

### Role-based transitions
- None in UI (no actions that transition state).

### UI behavior per state
- `COMPLETED`: show normal detail, enable links if available.
- `FAILED`: show failure banner + reason, show ‚Äúnext steps‚Äù hint: contact support with IDs.
- `PENDING`: show processing banner; disable navigation to journal entry/posting (if those exist).
- `QUARANTINED`: show quarantine banner and any available diagnostic metadata.

---

## 11. Alternate / Error Flows

### Validation failures
- Invalid date range ‚Üí block search submission; inline error.
- If UUID format is enforced and invalid ‚Üí inline error (only if confirmed UUID in Open Questions is resolved).

### Concurrency conflicts
- If refund updates between list and detail load, show latest data (no edits). If backend provides version, ignore in UI.

### Unauthorized access
- If user lacks permission, show access denied; do not leak whether a given refundId exists.

### Empty states
- No refunds match filters ‚Üí show empty state with suggestion to broaden date range or search by ID.

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: View refunds list with filters
**Given** the user has permission to view accounting refunds  
**When** the user navigates to `Accounting ‚Üí Refunds`  
**Then** the system displays a list of refunds with columns including refundId, amount, currency, status, occurredAt/createdAt, and originalTxnRef  
**And** the user can filter by date range and status  
**And** the results update to match the filter criteria.

### Scenario 2: View refund detail with traceability links
**Given** a refund exists with `refundId = R1` and references an original transaction  
**When** the user opens the refund detail for `R1`  
**Then** the system displays refund amount, currency, reasonCode, authorizer (if provided), and occurredAt/createdAt  
**And** the system displays the originalTxnRef/originalTransactionId  
**And** if linked invoiceId/paymentId are provided, the UI renders navigation links to them.

### Scenario 3: Missing original transaction reference resolution
**Given** a refund exists whose originalTxnRef cannot be resolved to a known payment/invoice record  
**When** the user opens the refund detail  
**Then** the UI displays an ‚ÄúUnresolved reference‚Äù banner  
**And** the UI still displays originalTxnRef and all refund identifiers for support  
**And** the UI does not render broken navigation links.

### Scenario 4: Refund processing failed due to over-refund
**Given** a refund is in status `FAILED` with failureReason `REFUND_EXCEEDS_ORIGINAL_AMOUNT`  
**When** the user opens the refund detail  
**Then** the UI shows a failure banner with a user-friendly message  
**And** the UI shows the failure reason code and correlation identifiers (refundId, eventId, originalTxnRef).

### Scenario 5: Unauthorized user
**Given** the user does not have permission to view refunds  
**When** the user navigates to the refunds list or a refund detail URL directly  
**Then** the UI shows an access denied message  
**And** no refund data is displayed.

---

## 13. Audit & Observability

### User-visible audit data
- Show (when available): createdAt, createdBy, occurredAt, sourceModule, schemaVersion, authorizerId.
- Provide a ‚ÄúCopy identifiers‚Äù block: refundId, eventId, originalTxnRef, businessUnitId.

### Status history
- If backend exposes status history/events, show a read-only timeline; otherwise omit (do not infer).

### Traceability expectations
- UI must always display the immutable linkage identifiers even when linked entities are missing.

---

## 14. Non-Functional UI Requirements
- **Performance:** refunds list should load within 2 seconds for default page size under normal conditions; pagination required.
- **Accessibility:** all interactive elements keyboard-navigable; error banners announced via aria-live; sufficient contrast.
- **Responsiveness:** list and detail usable on tablet widths; avoid overflow for long IDs (wrap/copy behavior).
- **i18n/timezone/currency:** display currency using `currencyUomId`/ISO code and locale formatting; timestamps shown in user‚Äôs timezone (if available in app settings).

---

## 15. Applied Safe Defaults
- SD-UI-EMPTY-STATE: Provide a standard empty-state panel on list when no results; safe because it is purely UX and does not alter domain behavior. (Impacted: UX Summary, Alternate/Empty states)
- SD-UI-PAGINATION: Default pagination (`pageSize=25`, user-selectable 25/50/100) on list; safe because it affects only presentation/performance. (Impacted: UX Summary, Service Contracts)
- SD-ERR-RETRY: On transient errors/timeouts show retry button and preserve filters; safe because it is standard error ergonomics. (Impacted: Service Contracts, Error Flows)

---

## 16. Open Questions

1. **Domain/System of Record:** Is this frontend story intended to show data from the **Accounting** domain‚Äôs persisted `RefundTransaction` (post-processing), or from a **Payment** domain refund record/event log, or both? (This affects service endpoints and entity naming.)
2. **Canonical identifiers & formats:** Are `refundId` and `eventId` guaranteed UUIDs (and which version)? Should the UI enforce UUID validation or accept arbitrary strings?
3. **Refund status model:** What are the authoritative statuses for refunds in the Moqui backend (e.g., `PENDING/COMPLETED/FAILED/QUARANTINED`), and do we have a status history to display?
4. **Reason codes enumeration:** What is the allowed set of `reasonCode` values for refunds (from ‚ÄúDurion Accounting Event Contract v1‚Äù)? Should the UI treat them as opaque strings or provide friendly labels?
5. **Linkage rules:** Does every refund link to a **Payment** only, an **Invoice** only, or potentially both? What fields are returned for linkage (paymentId, invoiceId, originalTransactionId, originalTxnRef)?
6. **Authorization/permissions:** What permission(s)/roles gate access to refund screens (read-only)? Please provide the exact permission tokens used in this project so the Moqui screens can enforce them.
7. **Conflict/duplicate visibility:** If idempotency conflict/DLQ/quarantine exists, does the backend expose a record the UI can query (and what fields), or should the UI only show a generic failure?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Accounting: Handle Refund Issued ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/177

====================================================================================================

FRONTEND STORY (FULL CONTEXT)

====================================================================================================

Title: [FRONTEND] [STORY] Accounting: Handle Refund Issued  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/177  
Labels: frontend, story-implementation, payment  

## Frontend Implementation for Story

**Original Story**: [STORY] Accounting: Handle Refund Issued

**Domain**: payment

### Story Description

/kiro  
Reverse cash and revenue effects with full traceability.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Actor
Accounting System

## Trigger
Receipt of `RefundIssued` event or authorized refund action

## Main Flow
1. Validate refund authorization and reference
2. Identify original payment and/or invoice
3. Reduce cash/bank balance
4. Adjust AR and/or revenue as appropriate
5. Record refund transaction with reason code
6. Persist linkage to original payment/invoice

## Alternate / Error Flows
- Refund exceeds original payment ‚Üí block
- Partial refund ‚Üí supported
- Refund against already credited invoice

## Business Rules
- Refunds must reference an original transaction
- Revenue impact depends on refund reason (pricing error vs goodwill)
- Refunds require explicit authorization

## Data Requirements
- Entities: Refund, Payment, Invoice
- Fields: refundAmount, reasonCode, originalTxnRef

## Acceptance Criteria
- [ ] Cash/bank balance reduces correctly
- [ ] AR and/or revenue adjust appropriately
- [ ] Refund is traceable to original transaction
- [ ] Audit trail captures reason and authorizer

## References
- Durion Accounting Event Contract v1

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299815/Durion_Accounting_Event_Contract_v1.pdf)

### Frontend Requirements
- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack
- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #178: [FRONTEND] [STORY] Accounting: Apply Payment to Invoice ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/178
File: ./scripts/story-work/frontend/178/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

STOP: Clarification required before finalization

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Accounting: Apply Payment to Invoice (Single Payment ‚Üí One or More Invoices)

### Primary Persona
Accounting Clerk (human user) operating within the Accounting domain UI

### Business Value
Ensure cleared payments are applied to invoices accurately and atomically, keeping invoice balances/statuses correct, producing auditable application records, and handling overpayments via explicit customer credit‚Äîreducing AR reconciliation errors and audit risk.

---

## 2. Story Intent

### As a / I want / So that
- **As an** Accounting Clerk  
- **I want** to apply a cleared payment to one or more open invoices (with validation, atomic submission, and clear outcome messaging)  
- **So that** invoice balances/statuses update correctly, remaining payment value is handled deterministically (including customer credit for overpayment), and the action is auditable and reversible.

### In-scope
- A dedicated frontend workflow to:
  - Load a cleared/available payment and its unapplied amount
  - Search/select eligible invoices for the same customer & currency
  - Allocate amounts across one or more invoices
  - Validate constraints before submit
  - Submit the application as a single atomic command with an idempotency key (`applicationRequestId`)
  - Display resulting invoice statuses/balances and any created customer credit
  - View application records created by the submission

### Out-of-scope
- Payment authorization/capture/clearing lifecycle (owned by Payment domain)
- Creating/editing invoices (Billing/Work Execution domains)
- Reversing/unapplying a payment application (mentioned as a rule but not specified as a UI in the provided frontend story)
- GL posting details, chart of accounts, posting rule configuration
- Multi-currency conversions (currency must match; no FX)

---

## 3. Actors & Stakeholders
- **Primary user:** Accounting Clerk
- **Secondary stakeholders:** Finance leadership, Auditors/Compliance
- **System interactions:** Moqui backend services for Accounting domain (apply command, view payment/invoices, view results)

---

## 4. Preconditions & Dependencies

### Preconditions
- Payment has been cleared/settled upstream and is represented in Accounting as an available payment record (backend reference: `ReceivablePayment` with `status=AVAILABLE` and `unappliedAmount > 0`).
- User is authenticated.
- User is authorized (permission must exist for applying payments; exact permission string is an open question).

### Dependencies
- Backend endpoints/services exist (or will exist) consistent with backend story #114:
  - View payment availability (by `paymentId`)
  - Search/list eligible invoices for a customer
  - Submit atomic apply request:
    - `POST /accounting/payments/{paymentId}/applications` with `applicationRequestId` and allocation list
  - Return created `PaymentApplication` records and (if applicable) created `CustomerCredit`

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- From Accounting navigation: **Accounting ‚Üí Receivables ‚Üí Payments ‚Üí Apply to Invoices**
- Deep link route supported:
  - `/accounting/payments/:paymentId/apply` (paymentId required)

### Screens to create/modify
1. **New Screen:** `apps/accounting/screen/receivables/PaymentApply.xml` (name indicative)
   - Purpose: Apply one payment across one or more invoices
2. **Optional supporting screen (if not existing):**
   - `PaymentView.xml` to view payment details & existing applications (can be a simple view section embedded in apply screen)

### Navigation context
- Breadcrumb: Accounting / Receivables / Payments / Apply
- Back navigation returns to payment list or payment detail (depends on entry path)

### User workflows

#### Happy path: apply payment across invoices
1. User opens Apply screen for a payment.
2. System loads payment details and shows `totalAmount`, `unappliedAmount`, `currency`, `customer`.
3. System loads list/search of eligible invoices for same customer/currency with `balanceDue > 0` and applicable states.
4. User selects one or more invoices and enters `amountToApply` per invoice.
5. UI validates totals and per-invoice constraints.
6. User submits.
7. On success, UI shows confirmation + results:
   - Created application records
   - Updated invoice balances/statuses
   - If overpayment credit created: show credit identifier and amount

#### Alternate path: apply full amount to a single invoice
- Same as above, but single invoice selection; ‚ÄúApply full remaining amount‚Äù convenience action is allowed (safe default UX).

#### Error paths
- Validation errors returned by service (invoice not applicable, insufficient funds, currency mismatch) displayed inline and/or as a banner, with no partial updates shown as successful.
- Concurrency conflicts (invoice balance changed; payment unapplied changed) prompt user to reload and re-allocate.

---

## 6. Functional Behavior

### Triggers
- Screen load with `paymentId`
- User actions: select invoice(s), enter allocation amounts, submit application

### UI actions
- **Load payment** on screen init:
  - Fetch payment availability record by `paymentId`
- **Load invoices**:
  - Fetch eligible invoices for `customerId` and `currencyUomId` from payment record
  - Support filtering by invoice number and status (safe default)
- **Allocate amounts**:
  - For each selected invoice, user enters `amountToApply` (decimal currency)
  - Provide actions:
    - ‚ÄúApply remaining‚Äù to auto-fill amount up to invoice balance (safe default)
    - ‚ÄúClear allocations‚Äù
- **Submit**:
  - Generate `applicationRequestId` (UUID) client-side per submission attempt
  - Send allocations list to backend
  - Disable submit while request in flight; prevent double-submit

### State changes (frontend view state)
- `screenState`: Loading ‚Üí Ready ‚Üí Submitting ‚Üí Success | Error
- Store the submission response:
  - application records
  - updated invoices (or re-fetch invoices)
  - created customer credit (if any)

### Service interactions
- View services: payment details, eligible invoices
- Command service: apply payment allocations atomically
- Error mapping:
  - validation errors mapped to field/invoice rows and banner
  - conflicts mapped to ‚ÄúReload needed‚Äù UI

---

## 7. Business Rules (Translated to UI Behavior)

### Validation (client-side, before submit)
For each allocation row `{invoiceId, amountToApply}`:
- `amountToApply` required for selected invoices
- `amountToApply > 0`
- `amountToApply <= invoice.balanceDue` (based on loaded data; still enforced by backend)
Across all selected invoices:
- `sum(amountToApply) <= payment.unappliedAmount` (based on loaded data; still enforced by backend)
Eligibility rules:
- Invoices must not be in non-applicable statuses (backend reference: not `PaidInFull`, `Voided`, `Cancelled`; exact status values are an open question for frontend display mapping)

### Enable/disable rules
- Submit disabled if:
  - payment is not `AVAILABLE`
  - `unappliedAmount <= 0`
  - no invoices selected
  - any selected invoice missing/invalid `amountToApply`
  - sum exceeds `unappliedAmount`

### Visibility rules
- Show ‚ÄúOverpayment will create customer credit‚Äù informational text when:
  - payment total > sum(amountToApply) AND the backend policy is to convert remainder to credit on submit  
  (Note: backend story says credit created if payment value exceeds application total; UI should reflect this clearly.)

### Error messaging expectations
- Use backend error codes when available and present actionable guidance:
  - `VALIDATION_ERROR:INVOICE_NOT_APPLICABLE` ‚Üí ‚ÄúInvoice is not eligible for payment application (status prevents applying).‚Äù
  - `VALIDATION_ERROR:INSUFFICIENT_FUNDS` ‚Üí ‚ÄúApplied total exceeds remaining unapplied amount.‚Äù
  - `VALIDATION_ERROR:CURRENCY_MISMATCH` ‚Üí ‚ÄúPayment currency must match invoice currency.‚Äù

---

## 8. Data Requirements

### Entities involved (frontend-facing)
- `ReceivablePayment` (or equivalent accounting payment-availability record)
- `Invoice` (read-only for this workflow)
- `PaymentApplication` (result records)
- `CustomerCredit` (result record when overpayment)

### Fields

#### Payment (ReceivablePayment)
- `paymentId` (string/UUID; required; route param)
- `customerId` (string/UUID; required)
- `currencyUomId` (string; required, e.g., `USD`)
- `totalAmount` (decimal; required)
- `unappliedAmount` (decimal; required)
- `status` (enum/string; required; must allow `AVAILABLE`)
- `clearedAt` (datetime; required)
- Optional display:
  - `paymentRef` / external reference (if available)

#### Invoice (for selection)
- `invoiceId` (string/UUID; required)
- `invoiceNumber` (string; required for display/search) **(open question if available)**
- `status` (enum/string; required)
- `balanceDue` (decimal; required)
- `invoiceDate` (date/datetime; optional)
- `dueDate` (date; optional)

#### Allocation input (client-only until submit)
- `invoiceId` (required)
- `amountToApply` (decimal; required; currency-scale precision)

#### Submit result
- `PaymentApplication`:
  - `paymentApplicationId` (required)
  - `paymentId`, `invoiceId`, `customerId`, `currencyUomId` (required)
  - `appliedAmount` (required)
  - `applicationTimestamp` (required)
  - `applicationRequestId` (required)
- `CustomerCredit` (if created):
  - `creditId` (required)
  - `amount` (required)
  - `currencyUomId` (required)
  - `sourcePaymentId` (required)
  - `createdAt` (required)

### Read-only vs editable
- Payment fields: read-only
- Invoice fields: read-only
- `amountToApply`: editable per selected invoice row only

### Derived/calculated fields (frontend)
- `appliedTotal = sum(amountToApply)` (client computed)
- `remainingAfterApply = payment.unappliedAmount - appliedTotal` (client computed; informational)

---

## 9. Service Contracts (Frontend Perspective)

> Moqui implementation may use REST endpoints, screen transitions calling services, or `service-call` within screens. Names below specify required behavior; exact service names are open questions unless already standardized in the repo.

### Load/view calls

1. **Load payment availability**
- **Request:** `GET /accounting/payments/{paymentId}`
- **Response (min):** ReceivablePayment fields listed above + optionally existing applications summary
- **Errors:**
  - 404 ‚Üí show ‚ÄúPayment not found‚Äù
  - 403 ‚Üí show ‚ÄúNot authorized‚Äù

2. **Load eligible invoices**
- **Request:** `GET /accounting/customers/{customerId}/invoices?currencyUomId=XXX&eligibleForPayment=true`
- **Response:** list of invoices with fields above
- **Errors:**
  - 503 (dependency down) ‚Üí show retry option

### Create/update calls

3. **Apply payment allocations (atomic command)**
- **Request:** `POST /accounting/payments/{paymentId}/applications`
- **Body:**
  - `applicationRequestId` (UUID; required; idempotency)
  - `applications`: array of `{ invoiceId, amountToApply }` (required; at least 1)
- **Response (success):**
  - created `PaymentApplication` records
  - updated payment (`unappliedAmount`, maybe status)
  - updated invoices or an indicator to re-fetch
  - `customerCredit` object when remainder becomes credit
- **Errors (expected):**
  - 400 validation: includes error code(s) listed in business rules
  - 409 conflict: optimistic locking / changed balances
  - 403 unauthorized

### Error handling expectations
- Display backend-provided `errorCode` and `message` (message sanitized) in a user-friendly mapping.
- For per-invoice errors, highlight the invoice row(s) affected when backend returns invoiceId-specific errors (open question: error response shape).

---

## 10. State Model & Transitions

### Allowed states (domain concepts surfaced in UI)
- Payment availability status: `AVAILABLE` (required for apply)
  - Other statuses may exist (e.g., `FULLY_APPLIED`, `ON_HOLD`) **(open question)**
- Invoice statuses relevant to eligibility:
  - Eligible: `Open`, `PartiallyPaid` (from backend reference)
  - Ineligible: `PaidInFull`, `Voided`, `Cancelled` (from backend reference)

### Role-based transitions
- User with apply permission can execute ‚ÄúApply‚Äù command.
- Others can view but cannot submit (UI should hide/disable submit) **(exact permission open question)**

### UI behavior per state
- If payment status not `AVAILABLE` or `unappliedAmount <= 0`:
  - screen shows payment details + existing applications
  - allocation and submit controls disabled with explanation

---

## 11. Alternate / Error Flows

### Validation failures (client-side)
- User enters amount > invoice balanceDue ‚Üí inline error, submit disabled
- User enters total > payment unappliedAmount ‚Üí show banner ‚ÄúTotal exceeds remaining payment amount‚Äù, submit disabled

### Backend validation failures
- Invoice becomes ineligible between load and submit:
  - backend returns `INVOICE_NOT_APPLICABLE`
  - UI shows error and offers ‚ÄúReload invoices‚Äù
- Insufficient funds due to concurrent application elsewhere:
  - backend returns `INSUFFICIENT_FUNDS` or 409
  - UI prompts reload payment and re-allocate

### Concurrency conflicts
- If backend indicates optimistic lock conflict (409):
  - UI shows ‚ÄúData changed since you started. Reload required.‚Äù
  - Provide ‚ÄúReload‚Äù action (re-fetch payment + invoices; clear allocations)

### Unauthorized access
- 403 on load or submit:
  - show not authorized page/message
  - do not reveal sensitive payment/invoice details beyond what is already loaded

### Empty states
- No eligible invoices:
  - show ‚ÄúNo open invoices available for this customer in this currency.‚Äù
  - still allow apply? No‚Äîsubmit disabled; user can navigate to invoice list (link)

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: Load apply screen with available payment
**Given** I am an authenticated Accounting Clerk with permission to apply payments  
**When** I open `/accounting/payments/{paymentId}/apply` for a payment with `status=AVAILABLE` and `unappliedAmount>0`  
**Then** the system displays payment details including `unappliedAmount` and `currency`  
**And** the system lists eligible invoices for the same customer and currency with `balanceDue>0`.

### Scenario 2: Apply full payment to one invoice successfully
**Given** an available payment with `unappliedAmount = 100.00`  
**And** an eligible invoice with `balanceDue = 100.00`  
**When** I allocate `amountToApply = 100.00` to that invoice and submit  
**Then** the application request is submitted with a generated `applicationRequestId`  
**And** the UI shows a success confirmation including created `PaymentApplication` record(s)  
**And** the invoice is shown as `PaidInFull` with `balanceDue = 0.00` (either from response or after refresh)  
**And** the payment `unappliedAmount` is shown as `0.00`.

### Scenario 3: Apply partial payment to one invoice successfully
**Given** an available payment with `unappliedAmount = 50.00`  
**And** an eligible invoice with `balanceDue = 100.00`  
**When** I allocate `amountToApply = 50.00` and submit  
**Then** the UI shows success and the invoice status becomes `PartiallyPaid`  
**And** the invoice `balanceDue` decreases by `50.00`  
**And** the payment `unappliedAmount` becomes `0.00`.

### Scenario 4: Apply payment across multiple invoices atomically
**Given** an available payment with `unappliedAmount = 120.00`  
**And** two eligible invoices with `balanceDue = 70.00` and `balanceDue = 80.00`  
**When** I allocate `70.00` to the first invoice and `50.00` to the second and submit  
**Then** the UI shows success with two `PaymentApplication` records  
**And** the first invoice becomes `PaidInFull` with `balanceDue=0.00`  
**And** the second invoice becomes `PartiallyPaid` with `balanceDue` reduced by `50.00`  
**And** the payment `unappliedAmount` becomes `0.00`.

### Scenario 5: Overpayment creates customer credit
**Given** an available payment with `unappliedAmount = 200.00`  
**And** an eligible invoice with `balanceDue = 150.00`  
**When** I allocate `150.00` and submit  
**Then** the UI shows success  
**And** a `CustomerCredit` is displayed with `amount = 50.00` and `currency` matching the payment  
**And** the payment is shown with no remaining unapplied amount (per backend policy).

### Scenario 6: Client-side validation prevents submitting invalid amounts
**Given** I am allocating amounts to invoices  
**When** my applied total exceeds the payment‚Äôs `unappliedAmount`  
**Then** the Submit action is disabled  
**And** the UI displays an error indicating the total exceeds the remaining payment amount.

### Scenario 7: Backend rejects ineligible invoice
**Given** I selected an invoice that becomes `Voided` before submission  
**When** I submit the application  
**Then** the UI shows an error mapped from `VALIDATION_ERROR:INVOICE_NOT_APPLICABLE`  
**And** no success confirmation is shown  
**And** the UI offers to reload invoices.

### Scenario 8: Concurrency conflict requires reload
**Given** the payment‚Äôs unapplied amount changes due to another application  
**When** I submit allocations based on stale data  
**Then** the backend returns a conflict (HTTP 409 or equivalent)  
**And** the UI prompts me to reload payment and invoice data before retrying.

---

## 13. Audit & Observability

### User-visible audit data
- After a successful submit, show:
  - `applicationRequestId`
  - `applicationTimestamp`
  - list of created `PaymentApplication` IDs (or references)
  - (if returned) backend `traceId` or correlation ID **(open question if exposed)**

### Status history
- Display existing payment applications for this payment (if load endpoint provides it) or provide a link to a Payment Applications view.

### Traceability expectations
- Frontend must include `applicationRequestId` on submit.
- Frontend should propagate correlation headers if used by the project (e.g., `X-Trace-Id`) **(open question: standard header in this repo).**

---

## 14. Non-Functional UI Requirements
- **Performance:** initial load (payment + invoice list) should render usable state within 2 seconds on typical LAN; invoice list should support pagination if large.
- **Accessibility:** keyboard navigable allocation table; errors announced via aria-live; sufficient contrast for validation states.
- **Responsiveness:** usable on tablet width; allocation inputs remain accessible.
- **i18n/timezone/currency:** display amounts using `currencyUomId` formatting; timestamps in user timezone (unless project standard differs‚Äîopen question).

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Show explicit empty-state messaging when no eligible invoices are returned; qualifies as safe UI ergonomics; impacts UX Summary, Error Flows.
- SD-UX-PAGINATION: Paginate invoice results when list exceeds page size; safe for ergonomics and does not change business logic; impacts UX Summary, Data Requirements.
- SD-UX-PREVENT-DOUBLE-SUBMIT: Disable submit while request is in flight to avoid duplicate submissions; safe because backend is idempotent but UX should prevent accidental repeats; impacts Functional Behavior, Error Flows.
- SD-ERR-STANDARD-MAPPING: Map HTTP 400/403/404/409/503 to banner + actionable guidance; safe because it does not assume domain policy beyond status codes; impacts Service Contracts, Error Flows.

---

## 16. Open Questions

1. **Permissions / roles:** What is the exact permission string(s) to gate ‚ÄúApply Payment‚Äù submit in the frontend (e.g., `accounting.payment.apply` vs `invoice.adjust`-style)?  
2. **Service/API naming & shapes:** What are the actual Moqui service names or REST endpoints for:
   - loading `ReceivablePayment` by `paymentId`
   - listing eligible invoices for customer/currency
   - submitting payment applications  
   Include expected request/response JSON (especially error response structure for per-invoice errors).
3. **Invoice status enum values:** What are the canonical invoice status values in the frontend contract (exact strings) for eligible vs ineligible states?  
4. **Overpayment UX certainty:** Backend story indicates remainder becomes `CustomerCredit` and recommends setting `unappliedAmount` to `0` after credit creation. Should the UI always expect `unappliedAmount=0` on success when credit is created, and should it hide ‚Äúremaining payment‚Äù in that case?  
5. **Correlation/trace header standard:** Does this frontend project set/provide a standard correlation ID header (name and behavior) that should be included on submit and logged client-side?  
6. **Reversal workflow:** Business rules mention reversibility with audit. Is a separate frontend story planned for reversing applications, or should this story include a ‚ÄúReverse‚Äù action from the success/results view?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Accounting: Apply Payment to Invoice ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/178

====================================================================================================

FRONTEND STORY (FULL CONTEXT)

====================================================================================================

Title: [FRONTEND] [STORY] Accounting: Apply Payment to Invoice  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/178  
Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] Accounting: Apply Payment to Invoice

**Domain**: payment

### Story Description

/kiro  
Apply payments to invoices with clear AR reconciliation.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Actor
Accounting System

## Trigger
User action or automated rule to apply a recorded payment to one or more invoices

## Main Flow
1. Select payment and target open invoice(s)
2. Validate invoice status and remaining balance
3. Apply payment amount to invoice(s)
4. Reduce Accounts Receivable balance accordingly
5. Update invoice payment status (partial/paid)
6. Persist application records

## Alternate / Error Flows
- Overpayment ‚Üí create credit balance
- Invoice closed or voided ‚Üí block application
- Partial application across multiple invoices

## Business Rules
- AR reduction occurs only when payment is applied
- One payment may apply to multiple invoices
- One invoice may have multiple payments
- Application must be reversible with audit

## Data Requirements
- Entities: PaymentApplication, Invoice, AR
- Fields: appliedAmount, invoiceId, applicationTimestamp

## Acceptance Criteria
- [ ] AR balance reduces correctly
- [ ] Invoice status updates accurately
- [ ] Partial payments are supported
- [ ] Application is auditable and reversible

## References
- Durion Accounting Event Contract v1

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299815/Durion_Accounting_Event_Contract_v1.pdf)


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

====================================================================================================

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #179: [FRONTEND] [STORY] Accounting: Ingest PaymentReceived Event  
File: ./scripts/story-work/frontend/179/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Accounting: Ingest PaymentReceived Event (Ops UI + Work Queue)

### Primary Persona
Accounting Ops User (Accountant / Accounting Clerk)

### Business Value
Provide an operational UI to monitor and troubleshoot `PaymentReceived` event ingestion outcomes (success/duplicate/rejected), and to work ‚Äúunapplied/unassigned‚Äù payments, enabling timely reconciliation and reducing support burden while preserving auditability and idempotency guarantees.

---

## 2. Story Intent

### As a / I want / So that
- **As an** Accounting Ops User  
- **I want** a UI to view ingested `PaymentReceived` events and resulting `Payment` records (including duplicates and failures) and to triage unapplied/unassigned payments  
- **So that** I can reconcile cash receipts, identify issues (schema/currency/customer mismatches), and maintain traceable accounting records without needing direct database access.

### In-scope
- New/updated Moqui screens to:
  - List and view `Payment` records created from `PaymentReceived` events.
  - Provide an ‚ÄúUnapplied & Unassigned Payments‚Äù work queue (filters, drilldown).
  - Display source metadata: `externalTransactionId`, `sourceSystem`, `receivedTimestamp`, `currency`, `paymentMethod`, and stored `sourceEventPayload` (read-only).
  - Display ingestion outcome signals surfaced by backend (success/duplicate/rejected/quarantined) **if available**.
- Frontend actions limited to:
  - Search/filter/sort
  - View details
  - (Optional only if backend exists) manually associate a `customerId` for unassigned payments.

### Out-of-scope
- Building the ingestion pipeline itself (message broker consumption).
- Creating or changing accounting posting rules, GL mappings, journal entry logic (backend-owned).
- Applying payments to invoices / AR reduction (explicitly out-of-scope per business rules).
- Editing immutable payment financials (amount/currency/method) after ingestion.

---

## 3. Actors & Stakeholders

- **Primary Actor:** Accounting Ops User
- **Secondary Actors:**
  - Support/On-call Engineer (uses UI to diagnose ingestion failures)
  - Controller/Auditor (views traceability / audit fields)
- **System Stakeholders/Integrations (context):**
  - External payment source(s) emitting `PaymentReceived`
  - Accounting backend that persists Payment + JournalEntry and enforces idempotency

---

## 4. Preconditions & Dependencies

### Preconditions
- User is authenticated in the frontend and authorized to access accounting payments screens.
- Backend persists `Payment` records with fields described in the provided backend reference (or equivalent).

### Dependencies (blocking unless confirmed)
- Backend endpoints exist for:
  - Listing payments with filters (status, customer assigned/unassigned, date range, currency, sourceSystem, externalTransactionId)
  - Fetching payment details including `sourceEventPayload`
  - (Optional) Updating `customerId` for payments in `UNAPPLIED` state (if permitted)
- Backend provides a way to surface ingestion failures/duplicates (could be via a separate ‚Äúevent ingestion log‚Äù entity/service). If not available, UI will only show persisted `Payment` records (successful ingestions).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Left nav (Accounting) ‚Üí **Payments**
  - **Payments List**
  - **Unapplied & Unassigned Queue** (pre-filtered list view)

### Screens to create/modify
- `apps/accounting/screen/PaymentList.xml` (new)
- `apps/accounting/screen/PaymentDetail.xml` (new)
- `apps/accounting/screen/UnappliedPaymentQueue.xml` (new; can reuse PaymentList with preset parameters)
- Optional: `apps/accounting/screen/PaymentCustomerAssignDialog.xml` (inline modal pattern) or embedded form in detail screen.

### Navigation context
- `PaymentList` ‚Üí click row ‚Üí `PaymentDetail?paymentId=...`
- From `UnappliedPaymentQueue` ‚Üí `PaymentDetail`
- `PaymentDetail` includes related links (read-only) to:
  - Customer detail (if `customerId` exists)
  - Journal Entry detail (if backend exposes reference)

### User workflows
**Happy path (ops review):**
1. User opens Payments List
2. Filters by date range and/or sourceSystem
3. Opens a payment detail
4. Confirms status `UNAPPLIED`, reviews payload/metadata, and (if allowed) assigns customer

**Alternate path (duplicate investigation):**
1. User searches by `externalTransactionId`
2. UI shows existing payment record (only one)
3. If backend exposes ingestion log, user sees duplicate attempts listed as non-mutating events

**Alternate path (unknown customer):**
1. User opens Unapplied & Unassigned Queue (customerId null)
2. Opens payment detail
3. Assigns customer (if supported) and saves; payment remains `UNAPPLIED` (application to invoices is out-of-scope)

---

## 6. Functional Behavior

### Triggers
- User navigates to Payments screens.
- User submits filters/search.
- User opens a payment detail.
- (Optional) User submits ‚ÄúAssign Customer‚Äù action.

### UI actions
- **List view actions**
  - Filter by:
    - `status` (default: all)
    - `customerAssigned` (assigned/unassigned)
    - `receivedTimestamp` range (required default: last 30 days if supported as safe UX default)
    - `currency`
    - `paymentMethod`
    - `sourceSystem`
    - `externalTransactionId` exact match
  - Pagination and sortable columns.

- **Detail view actions**
  - View read-only fields (see Data Requirements)
  - Expand/collapse `sourceEventPayload` JSON viewer (read-only)
  - (Optional) Assign customer:
    - Customer lookup control (search by name/email/phone/id per backend capability)
    - Save association

### State changes (frontend-visible)
- None for ingestion itself.
- Optional customer assignment changes `Payment.customerId` only.
- No UI action changes `Payment.status` in this story.

### Service interactions
- Load list and detail via Moqui transitions calling backend services (see Service Contracts).
- On optional customer assignment: call update service and refresh detail.

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- Filters:
  - `receivedTimestampFrom` must be <= `receivedTimestampThru` (client-side validation).
- Customer assignment (if supported):
  - Only allowed when `Payment.status == UNAPPLIED`.
  - Only allowed if payment is not marked immutable due to posting lock (backend should enforce; UI should disable if backend indicates not allowed).

### Enable/disable rules
- Disable ‚ÄúAssign Customer‚Äù action when:
  - user lacks permission
  - `customerId` already set (unless ‚ÄúChange‚Äù is explicitly allowed; see Open Questions)
  - payment status is not `UNAPPLIED`

### Visibility rules
- Show `sourceEventPayload` only to authorized roles (may contain sensitive data); otherwise show ‚ÄúRestricted‚Äù.
- Show journal entry link only if backend provides a `journalEntryId`/reference.

### Error messaging expectations
- Display backend error codes/messages verbatim but user-friendly:
  - `UNAUTHORIZED` ‚Üí ‚ÄúYou do not have access to this action.‚Äù
  - `VALIDATION_ERROR` ‚Üí show field-level messages
  - `NOT_FOUND` ‚Üí ‚ÄúPayment not found or you no longer have access.‚Äù
  - `CONFLICT/OPTIMISTIC_LOCK` ‚Üí ‚ÄúThis payment was updated by someone else. Refresh and try again.‚Äù

---

## 8. Data Requirements

### Entities involved (frontend perspective)
- `Payment` (accounting-owned)
- `Customer` (CRM/people-owned; referenced read-only except lookup)
- Optional: `JournalEntry` reference (accounting-owned, read-only link)
- Optional: `PaymentIngestionLog` / `AccountingEventIngestion` (if backend exposes)

### `Payment` fields to display
| Field | Type | Required | Editable | Notes |
|---|---|---:|---:|---|
| `paymentId` | UUID | yes | no | Primary identifier |
| `status` | Enum | yes | no | Expect at least `UNAPPLIED`, `APPLIED` (others TBD) |
| `amount` | Decimal(19,4) | yes | no | Display with currency |
| `currency` | ISO 4217 string(3) | yes | no | |
| `paymentMethod` | Enum | yes | no | Values TBD; display label |
| `receivedTimestamp` | UTC timestamp | yes | no | Display in user timezone, store UTC |
| `externalTransactionId` | string | yes | no | Search key; unique |
| `sourceSystem` | string | yes | no | |
| `customerId` | UUID nullable | no | **optional** | Editable only if policy allows |
| `sourceEventPayload` | JSON | yes | no | Read-only; restricted visibility |
| Standard audit | `createdAt/By`, `updatedAt/By` | yes | no | Display on detail |

### Derived/calculated fields (UI-only)
- `customerAssigned` boolean = (`customerId` != null)
- ‚ÄúAge‚Äù = now - receivedTimestamp (display)

---

## 9. Service Contracts (Frontend Perspective)

> Note: Exact service names/routes must align with `durion-moqui-frontend` conventions; define placeholders and require confirmation if unknown.

### Load/list calls
- `GET /accounting/payments` (or Moqui screen transition calling service like `accounting.PaymentServices.listPayments`)
  - Request params: filters described above, `pageIndex`, `pageSize`, `sortField`, `sortOrder`
  - Response: list of Payment summaries + total count

### View/detail calls
- `GET /accounting/payments/{paymentId}` (or `accounting.PaymentServices.getPayment`)
  - Response: full Payment incl. `sourceEventPayload` (if authorized)

### Update calls (optional)
- `POST /accounting/payments/{paymentId}/assignCustomer` (or `accounting.PaymentServices.assignCustomerToPayment`)
  - Request: `paymentId`, `customerId`, optional `reason` (if required by audit policy; see Open Questions)
  - Response: updated Payment

### Error handling expectations
- Map HTTP 401/403 ‚Üí route to login or show unauthorized banner; disable actions.
- 404 ‚Üí show not found screen with back link.
- 409 ‚Üí show conflict toast and refresh option.
- Validation errors: render field messages.

---

## 10. State Model & Transitions

### Allowed states (Payment)
- `UNAPPLIED` (created on ingestion)
- `APPLIED` (exists but out-of-scope to transition here)
- Others (e.g., `REVERSED`, `VOID`) are unknown ‚Üí do not assume.

### Role-based transitions (UI)
- No status transitions in this story.
- Optional ‚ÄúAssign Customer‚Äù is a *mutation* but not a state transition:
  - Allowed roles/permissions: **TBD** (see Open Questions)

### UI behavior per state
- `UNAPPLIED`: show ‚ÄúUnapplied‚Äù badge; show queue inclusion.
- `APPLIED`: read-only; hide queue inclusion; assignment disabled.

---

## 11. Alternate / Error Flows

### Validation failures
- Invalid date range filter ‚Üí block submission; show inline error.

### Concurrency conflicts
- If assignment save returns 409/optimistic lock:
  - show conflict message
  - reload payment detail
  - user re-attempts if still applicable

### Unauthorized access
- If user lacks permission to view payload:
  - hide payload section and show ‚ÄúRestricted‚Äù
- If user lacks permission to assign customer:
  - do not render action, or render disabled with tooltip.

### Empty states
- Payments list returns 0 results:
  - show ‚ÄúNo payments found‚Äù with ‚ÄúClear filters‚Äù.
- Unapplied/unassigned queue empty:
  - show ‚ÄúNo unassigned payments.‚Äù

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: View payments list with filters
**Given** an Accounting Ops User with permission to view payments  
**When** the user opens the Payments List screen  
**Then** the system displays a paginated list of payments with columns including amount, currency, status, received timestamp, source system, and external transaction id  
**And** the user can filter by received date range and source system  
**And** the results update to match the filters.

### Scenario 2: Drill into payment details with traceability
**Given** a payment exists with an `externalTransactionId` and stored `sourceEventPayload`  
**When** the user opens the Payment Detail screen for that payment  
**Then** the system displays all read-only payment fields including `externalTransactionId`, `sourceSystem`, and `receivedTimestamp`  
**And** the system displays the `sourceEventPayload` as read-only JSON **when the user is authorized**.

### Scenario 3: Restricted payload access
**Given** a user who can view payments but is not authorized to view `sourceEventPayload`  
**When** the user opens the Payment Detail screen  
**Then** the system does not render the payload content  
**And** the UI indicates the payload is restricted.

### Scenario 4 (Optional): Assign customer to an unassigned unapplied payment
**Given** a payment exists with `status` = `UNAPPLIED` and `customerId` is null  
**And** the user has permission to assign a customer  
**When** the user selects a customer and submits the assignment  
**Then** the payment is updated to include the selected `customerId`  
**And** the payment remains in `UNAPPLIED` status  
**And** the change is reflected after refresh.

### Scenario 5: Prevent customer assignment when not allowed
**Given** a payment exists with `status` != `UNAPPLIED`  
**When** the user views the payment detail  
**Then** the ‚ÄúAssign Customer‚Äù action is not available (or disabled)  
**And** attempting the action (if forced) returns an authorization/state error and the UI shows a clear message.

---

## 13. Audit & Observability

### User-visible audit data
- Show `createdAt`, `createdBy`, `updatedAt`, `updatedBy` on Payment Detail.
- If backend provides ingestion timestamps/status (e.g., processedAt, ingestionStatus), display read-only.

### Status history
- If backend exposes status history for payment (not specified), show in a timeline; otherwise omit.

### Traceability expectations
- Payment Detail must prominently display:
  - `externalTransactionId` (copyable)
  - `sourceSystem`
  - correlation id / event id **if present in payload or explicit field** (not assumed)
- All frontend transitions should include `paymentId` in logs (Moqui server logs) and UI errors.

---

## 14. Non-Functional UI Requirements

- **Performance:** Payments list should load within 2s for typical page sizes (e.g., 25‚Äì50) under normal conditions; server-side pagination required.
- **Accessibility:** Keyboard navigable table; proper labels for filter inputs; JSON viewer accessible (expand/collapse).
- **Responsiveness:** List and detail usable on tablet widths; columns may collapse to stacked fields.
- **i18n/timezone/currency:**
  - Display timestamps in user locale/timezone; store/transport UTC.
  - Display money with currency code; do not assume symbol mapping beyond currency code.

---

## 15. Applied Safe Defaults

- SD-UX-EMPTY-STATE: Provide standardized empty-state messaging with ‚ÄúClear filters‚Äù action; safe because it doesn‚Äôt alter business logic. (Impacted: UX Summary, Alternate / Error Flows)
- SD-UX-PAGINATION: Use server-side pagination with default page size 25; safe UI ergonomics only. (Impacted: UX Summary, Service Contracts, Acceptance Criteria)

---

## 16. Open Questions

1. **Backend API contract (blocking):** What are the exact Moqui service names and screen paths (or REST endpoints) for listing and retrieving `Payment` records in `durion-moqui-frontend` conventions?
2. **Permission model (blocking):** What permissions/roles control:
   - viewing payments list/detail,
   - viewing `sourceEventPayload`,
   - assigning/changing `customerId`?
3. **Customer assignment policy (blocking):** Is manual association of `customerId` allowed for ingested payments? If yes, is ‚Äúchange customer after set‚Äù allowed, and is a reason/justification required for audit?
4. **Ingestion outcome visibility (blocking):** Is there an entity/service to view duplicates, rejected events, DLQ/quarantine status, or ingestion logs? If yes, what fields and filters should be exposed in the UI?
5. **Currency mismatch handling visibility (blocking):** If currency mismatch causes rejection/DLQ, should the UI expose these rejected events (even though no Payment record exists), or is UI limited to successfully persisted payments only?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Accounting: Ingest PaymentReceived Event  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/179  
Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] Accounting: Ingest PaymentReceived Event

**Domain**: payment

### Story Description

/kiro  
Focus on cash recognition, AR reduction, and idempotency.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Actor
Accounting System

## Trigger
Receipt of `PaymentReceived` event from an external payment source  
(e.g., POS terminal, bank feed, payment processor, manual entry)

## Main Flow
1. Receive payment event with amount, currency, method, and reference(s)
2. Validate event schema and idempotency key
3. Identify target customer and candidate open invoices
4. Record cash receipt in appropriate cash/bank account
5. Create unapplied payment record or proceed to invoice application
6. Persist payment with full source metadata

## Alternate / Error Flows
- Duplicate event ‚Üí ignore (idempotent)
- Unknown customer or reference ‚Üí create unapplied payment
- Currency mismatch ‚Üí reject or flag for review
- Posting failure ‚Üí retry or dead-letter

## Business Rules
- Payment receipt reduces cash suspense or increases cash immediately
- Payment does not reduce AR until applied to invoice(s)
- Idempotency is enforced per external transaction reference

## Data Requirements
- Entities: Payment, CashAccount, Customer
- Fields: amount, currency, method, receivedTimestamp, externalTxnId

## Acceptance Criteria
- [ ] Cash/bank balance increases correctly
- [ ] Payment is recorded exactly once
- [ ] Unapplied payments are visible and traceable
- [ ] Payment references external source transaction

## References
- Durion Accounting Event Contract v1

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299815/Durion_Accounting_Event_Contract_v1.pdf)

### Frontend Requirements
- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack
- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #180: [FRONTEND] [STORY] Accounting: Ingest InvoiceAdjusted or CreditMemo Event  
File: ./scripts/story-work/frontend/180/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Accounting: Review & Resolve `InvoiceAdjusted` / `CreditMemoIssued` Ingestion Results (Journal Entry Corrections UI)

### Primary Persona
Accounting Ops Specialist (and Accounting Manager as approver/oversight)

### Business Value
Provide a Moqui UI to view, triage, and trace invoice adjustment/credit memo ingestion outcomes so finance can verify AR/Revenue/Tax corrections, investigate failures (DLQ/quarantine), and prove audit linkage to the original invoice and resulting journal entries.

---

## 2. Story Intent

### As a / I want / So that
**As an** Accounting Ops Specialist,  
**I want** to view `InvoiceAdjusted` and `CreditMemoIssued` events and their resulting journal entries (or failure reasons),  
**so that** I can confirm postings reconcile prior postings, investigate ingestion exceptions, and maintain an audit trail linking adjustments/credit memos to the original invoice.

### In-scope
- Moqui screens to:
  - List ingestion records for `InvoiceAdjusted` and `CreditMemoIssued`
  - View event payload summary + processing status + errors
  - Navigate from event ‚Üí original invoice ‚Üí generated journal entry (and lines)
  - View reconciliation summary (before vs after) when available from backend
- UI support for idempotency/conflict visibility (duplicate/conflict flags)
- Standard filtering/searching for operational triage (date range, status, invoiceId, eventId)

### Out-of-scope
- Defining debit/credit mappings or financial posting rules (Accounting backend responsibility)
- Implementing the event consumer/ingestion backend itself
- Editing or re-posting journal entries from the UI (immutability constraint)
- Approving variances/adjustments unless an explicit backend contract exists (not provided)

---

## 3. Actors & Stakeholders
- **Primary user:** Accounting Ops Specialist
- **Secondary:** Accounting Manager / Auditor (read-only traceability)
- **System actors (context):** Event ingestion processor (backend), DLQ/quarantine mechanism (backend)

---

## 4. Preconditions & Dependencies
- Backend provides persistent records representing:
  - Received accounting events (`InvoiceAdjusted`, `CreditMemoIssued`)
  - Their processing status (processed/rejected/quarantined/etc.)
  - Linkage to `originalInvoiceId`
  - Linkage to created `JournalEntry`/transaction IDs when processed successfully
  - Error codes/messages when not successful
- Backend exposes read endpoints (Moqui services or REST) to retrieve:
  - Event ingestion list + filters
  - Event ingestion detail (including payload summary and error detail)
  - Journal entry detail/lines by transactionId or journalEntryId
  - Invoice header (at least invoiceId/invoiceNumber/status/currency) for navigation context
- Permissions exist for accounting operations viewing (exact permission strings are **not provided**; see Open Questions).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main menu: **Accounting ‚Üí Event Ingestion ‚Üí Adjustments & Credit Memos**
- Deep links supported:
  - `/accounting/events/adjustments` (list)
  - `/accounting/events/adjustments/<eventId>` (detail)

### Screens to create/modify
1. **Screen:** `Accounting/EventIngestion/AdjCreditMemoList`
   - Purpose: operational list/queue view of relevant event types
2. **Screen:** `Accounting/EventIngestion/AdjCreditMemoDetail`
   - Purpose: traceability view showing event ‚Üí invoice ‚Üí journal entry results
3. (Optional if already exists) Reuse or link to existing screens:
   - `Accounting/JournalEntry/View` (or create a minimal view screen if missing)
   - `Billing/Invoice/View` (read-only header link)

### Navigation context
- Breadcrumb: Accounting > Event Ingestion > Adjustments & Credit Memos > (Event Detail)
- From detail screen, provide transitions to:
  - Original Invoice view (by `originalInvoiceId`)
  - Journal Entry view (by `transactionId`/`journalEntryId`)

### User workflows
**Happy path**
1. User opens list screen and filters to ‚ÄúProcessed‚Äù for a date range.
2. User opens an event row.
3. Detail shows:
   - Event identifiers (eventId, type, occurredAt, sourceModule)
   - Linked original invoice
   - Linked resulting journal entry/transaction
   - Reconciliation summary (if provided)
4. User navigates to journal entry lines to confirm balanced totals and linkage.

**Alternate paths**
- User filters to ‚ÄúRejected/Quarantined/DLQ‚Äù and opens a failed record to view error code/message and invoice lookup context.
- User finds duplicate/conflict and reviews conflict reason.

---

## 6. Functional Behavior

### Triggers
- User navigates to list/detail screens (no automatic posting actions initiated from frontend).

### UI actions
**List screen**
- Filter by:
  - Event Type: `InvoiceAdjusted`, `CreditMemoIssued` (default both)
  - Processing Status (multi-select)
  - Date range (occurredAt or receivedAt ‚Äî clarify)
  - `eventId` (exact match)
  - `originalInvoiceId` (exact match)
  - `sourceModule` (optional)
- Row click ‚Üí open detail screen for that `eventId`

**Detail screen**
- Show summary fields + processing outcome
- If processed successfully:
  - Show journal linkage(s) and allow navigation
- If failed:
  - Show error code, message, and failure classification (schema validation, not found, unbalanced, auth failure, duplicate conflict, etc.) as provided by backend
  - If backend provides DLQ/quarantine reference, show it read-only

### State changes
- Frontend performs **no** state changes unless backend exposes explicit ‚Äúacknowledge/retry‚Äù actions (not provided; out-of-scope for now).

### Service interactions
- Read-only service calls to load list and detail data; see Service Contracts.

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- Filter inputs:
  - Date range: start must be <= end
  - UUID fields (`eventId`, `originalInvoiceId`) must validate as UUID format before search submit; show inline validation error

### Enable/disable rules
- ‚ÄúView Journal Entry‚Äù link enabled only when backend returns a journal reference.
- ‚ÄúView Invoice‚Äù link enabled only when `originalInvoiceId` present.

### Visibility rules
- Error panel visible only when status is failure/quarantined/etc. and error details exist.
- Conflict/duplicate badge visible only when backend flags event as duplicate/conflict.

### Error messaging expectations
- Backend error codes must be displayed verbatim with a human-readable label where possible (do not re-interpret accounting meaning).
- Standard Moqui error banner for network/500 errors; preserve correlationId if returned.

---

## 8. Data Requirements

### Entities involved (frontend-read models; actual entity names TBD)
Because the authoritative backend contract is not provided, the UI will require these logical data objects:

1. **AccountingEventIngestionRecord**
   - `eventId` (UUID, required)
   - `eventType` (enum: `InvoiceAdjusted` | `CreditMemoIssued`, required)
   - `schemaVersion` (string, required)
   - `sourceModule` (string, required)
   - `occurredAt` (datetime, required)
   - `receivedAt` (datetime, required)
   - `businessUnitId` (string/UUID, required)
   - `currencyUomId` (string, required)
   - `originalInvoiceId` (UUID, required)
   - `processingStatus` (enum, required)
   - `processingAttemptCount` (int, optional)
   - `lastErrorCode` (string, optional)
   - `lastErrorMessage` (string, optional)
   - `correlationId` (string, optional)
   - `journalTransactionId` (UUID/string, optional) OR `journalEntryId` (UUID/string, optional)
   - `duplicateOfEventId` (UUID, optional)
   - `conflictDetected` (boolean, optional)
   - `payloadSummary` (json/string, optional; must be safe to display)

2. **InvoiceHeader (read-only)**
   - `invoiceId` (UUID)
   - `invoiceNumber` (string)
   - `status` (string)
   - `issuedAt` (datetime)
   - `customerId` (UUID/string)
   - `currencyUomId` (string)
   - Totals optional (only if backend provides without implying accounting calculations)

3. **JournalEntryView**
   - `journalEntryId` (UUID/string)
   - `transactionId` (UUID/string)
   - `effectiveDate` (date)
   - `status` (Draft/Posted/etc. as provided)
   - `sourceEventId` (UUID)
   - `lines[]`: (`glAccountId`, `debitAmount`, `creditAmount`, `description`)

### Fields: read-only vs editable
- All fields in this story are **read-only** in the UI.

### Derived/calculated fields (UI-only)
- Display-only:
  - Status badge mapping from `processingStatus`
  - ‚ÄúHas Journal Link‚Äù boolean = journal reference present
  - ‚ÄúHas Error‚Äù boolean = lastErrorCode/message present

---

## 9. Service Contracts (Frontend Perspective)

> Moqui naming below uses placeholders; must be aligned to actual services/endpoints once confirmed.

### Load/view calls
1. **List ingestion records**
   - Service: `accounting.event.IngestionList` (placeholder)
   - Inputs:
     - `eventTypes[]`
     - `status[]`
     - `occurredAtFrom`, `occurredAtTo` (or receivedAt; clarify)
     - `eventId`, `originalInvoiceId`
     - pagination: `pageIndex`, `pageSize`
     - sorting: `sortBy`, `sortOrder`
   - Output:
     - `records[]: AccountingEventIngestionRecord (summary subset)`
     - `totalCount`

2. **Get ingestion record detail**
   - Service: `accounting.event.IngestionDetail` (placeholder)
   - Inputs: `eventId`
   - Output: full `AccountingEventIngestionRecord` + optional linked resources keys

3. **Get invoice header**
   - Service: `billing.invoice.GetHeader` (or `accounting.invoice.ViewHeader` if replicated)
   - Inputs: `invoiceId`
   - Output: `InvoiceHeader`

4. **Get journal entry / transaction**
   - Service: `accounting.journalEntry.Get` (by `journalEntryId` or `transactionId`)
   - Output: `JournalEntryView`

### Create/update/submit calls
- None (read-only story)

### Error handling expectations
- For service validation errors:
  - Display inline on filter form (list screen)
- For 401/403:
  - Show ‚ÄúNot authorized‚Äù page/message and hide data
- For 404 on detail:
  - Show ‚ÄúEvent not found‚Äù with link back to list
- For network/500:
  - Global error banner; provide correlationId if returned in headers/body

---

## 10. State Model & Transitions

### Allowed states (processingStatus)
Backend-driven; UI must treat as opaque enumerations but support common statuses if present:
- `RECEIVED`
- `VALIDATED`
- `PROCESSED`
- `REJECTED`
- `QUARANTINED` / `DLQ`
- `DUPLICATE_IGNORED`
- `DUPLICATE_CONFLICT`

### Role-based transitions
- None in UI (no actions that mutate state).

### UI behavior per state
- `PROCESSED`: show journal linkage panel + navigation links
- Failure states (`REJECTED`, `QUARANTINED`, `DLQ`, `DUPLICATE_CONFLICT`): show error panel with code/message and any provided remediation hint
- `DUPLICATE_IGNORED`: show badge and link to original event if `duplicateOfEventId` provided

---

## 11. Alternate / Error Flows

### Validation failures (client-side)
- Invalid UUID in filters ‚Üí block submit; show ‚ÄúMust be a valid UUID‚Äù
- Date range invalid ‚Üí block submit; show ‚ÄúStart date must be before end date‚Äù

### Concurrency conflicts
- If record status changes between list and detail load:
  - Detail screen shows latest status; optionally show ‚ÄúUpdated since list view‚Äù indicator (non-blocking)

### Unauthorized access
- If user lacks permission:
  - List screen shows no data and a permission error (do not leak existence of events)

### Empty states
- No records match filters:
  - Show empty state with ‚ÄúClear filters‚Äù action

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: List adjustment/credit memo ingestion records
Given I am an authorized accounting user  
When I navigate to Accounting > Event Ingestion > Adjustments & Credit Memos  
Then I see a list of ingestion records containing only event types InvoiceAdjusted and CreditMemoIssued  
And each row shows at minimum eventId, eventType, occurredAt (or receivedAt), processingStatus, and originalInvoiceId

### Scenario 2: Filter by originalInvoiceId and status
Given I am on the ingestion list screen  
When I enter a valid originalInvoiceId and select status ‚ÄúPROCESSED‚Äù and submit  
Then the list shows only records matching that invoiceId and status  
And pagination controls allow navigating result pages when totalCount > pageSize

### Scenario 3: View processed event detail with journal linkage
Given an ingestion record exists with processingStatus ‚ÄúPROCESSED‚Äù and a journalTransactionId (or journalEntryId)  
When I open the event detail screen for its eventId  
Then I see the event identifiers (eventId, eventType, schemaVersion, sourceModule, occurredAt)  
And I see a link to the original invoice using originalInvoiceId  
And I see a link to the resulting journal entry/transaction using the journal reference

### Scenario 4: View rejected/quarantined event detail with error details
Given an ingestion record exists with processingStatus ‚ÄúREJECTED‚Äù (or ‚ÄúQUARANTINED/DLQ‚Äù) and lastErrorCode/lastErrorMessage populated  
When I open the event detail screen  
Then I see the error code and error message displayed  
And no journal navigation link is shown

### Scenario 5: Invalid filter input is blocked client-side
Given I am on the ingestion list screen  
When I enter an invalid UUID into the eventId filter and submit  
Then the UI prevents the search  
And I see a validation message indicating the UUID format is invalid

### Scenario 6: Unauthorized user cannot access ingestion data
Given I am not authorized to view accounting ingestion records  
When I navigate to the ingestion list screen  
Then the UI shows an unauthorized message  
And no ingestion record data is displayed

---

## 13. Audit & Observability

### User-visible audit data
- Display read-only audit/trace fields when provided:
  - `correlationId`
  - `processingAttemptCount`
  - `receivedAt` and `occurredAt`
  - `sourceModule`
- Ensure links provide traceability chain:
  - Event ‚Üí Original Invoice ‚Üí Journal Entry/Lines

### Status history
- If backend provides status history (timestamps + status), render as a read-only timeline.
- If not provided, omit (do not fabricate).

### Traceability expectations
- All screens must include key identifiers in the UI for support copy/paste:
  - eventId, originalInvoiceId, journalTransactionId/journalEntryId, correlationId

---

## 14. Non-Functional UI Requirements
- **Performance:** list screen should load first page within 2 seconds under normal conditions (excluding backend slowness)
- **Accessibility:** keyboard navigable table, proper labels for filters, sufficient contrast for status badges
- **Responsiveness:** usable on tablet widths; filters collapse to stacked layout
- **i18n/timezone:** display timestamps in user locale/timezone (do not change stored values); currency displayed using `currencyUomId` formatting only when amounts are provided by backend (no new calculations)

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide standard empty-state messaging and ‚ÄúClear filters‚Äù action; qualifies as safe UX ergonomics; impacts UX Summary, Error Flows.
- SD-UX-PAGINATION: Default pageSize=25 with server-side pagination parameters; qualifies as safe UX ergonomics; impacts Service Contracts, UX Summary.
- SD-ERR-STANDARD-MAPPING: Map HTTP 401/403/404/409/500 to standard Moqui/Quasar notification patterns without changing domain semantics; qualifies as safe error-handling; impacts Error Flows, Service Contracts.

---

## 16. Open Questions
1. **Backend read model & endpoints (blocking):** What are the exact Moqui services (or REST endpoints) and field names for listing and viewing `InvoiceAdjusted` / `CreditMemoIssued` ingestion records (including status, error details, and journal linkage)?
2. **Status enumeration (blocking):** What are the authoritative `processingStatus` values and their meanings (especially DLQ vs quarantined vs rejected vs duplicate/conflict)?
3. **Timestamp filter basis (blocking):** Should list filtering default to `occurredAt` (event time) or `receivedAt` (ingestion time)? Which fields are available?
4. **Permissions (blocking):** What permission(s) govern access to these screens (e.g., `accounting.events.view`, `accounting.ingestion.view`), and are auditors allowed read-only access?
5. **Journal navigation key (blocking):** Does the backend expose linkage by `transactionId`, `journalEntryId`, or both? Which should be primary for navigation?
6. **Payload display policy (blocking/security):** Is it acceptable to display raw event payload JSON in the UI, or must it be redacted/limited to a safe ‚ÄúpayloadSummary‚Äù provided by backend?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Accounting: Ingest InvoiceAdjusted or CreditMemo Event  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/180  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Accounting: Ingest InvoiceAdjusted or CreditMemo Event

**Domain**: user

### Story Description

/kiro  
Handle revenue, tax, and AR changes from invoice adjustments.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Actor
Accounting System

## Trigger
Receipt of `InvoiceAdjusted` or `CreditMemoIssued` event

## Main Flow
1. Validate adjustment authorization
2. Reverse or amend prior AR, revenue, and tax entries
3. Post adjusted values
4. Maintain linkage to original invoice

## Acceptance Criteria
- [ ] Adjustments reconcile prior postings
- [ ] Credit memos reduce AR and revenue correctly
- [ ] Full audit trail preserved

## References
- Durion Accounting Event Contract v1

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299815/Durion_Accounting_Event_Contract_v1.pdf)

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #181: [FRONTEND] [STORY] Accounting: Ingest InvoiceIssued Event ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/181  
File: ./scripts/story-work/frontend/181/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

STOP: Clarification required before finalization

---

## 1. Story Header

**Title:** [FRONTEND] [STORY] Accounting: Ingest `InvoiceIssued` Event (UI for Ingestion Status, Idempotency, and Posting References)

**Primary Persona:** Accounting Ops / Finance Admin (with operational responsibility for accounting integrations)

**Business Value:** Provide visibility and operational control for `InvoiceIssued` event ingestion so Accounting can confirm idempotent processing, diagnose failures (schema/CoA mapping), and trace resulting financial postings (AR/revenue/tax liabilities) without backend access.

---

## 2. Story Intent

**As an** Accounting Ops user  
**I want** a Moqui/Quasar UI to view and troubleshoot `InvoiceIssued` event ingestion results (processed/duplicate/rejected), including idempotency keys and posting references  
**So that** I can ensure invoices post exactly once, quickly resolve ingestion errors, and provide traceability for audit and reconciliation.

### In-scope
- Moqui screens to:
  - List ingested `InvoiceIssued` events and their processing status
  - View event details (envelope + key invoice financial fields relevant to posting)
  - View idempotency determination (`invoiceId + invoiceVersion`, and/or `eventId`)
  - View posting references created by ingestion (e.g., `ledgerTransactionId`, journal entry references) **as read-only**
  - Basic operational actions **only if backend supports them** (e.g., retry/reprocess) ‚Äî otherwise, display-only
- Standardized error rendering for validation failures and duplicates (user-facing, non-sensitive)
- Navigation entry under an Accounting/Integrations area

### Out-of-scope
- Implementing the ingestion/posting logic itself (backend responsibility)
- Creating or editing Chart of Accounts, Posting Rules, or GL mappings
- Changing invoice state or issuing invoices
- Defining GL debit/credit mappings in the UI (must come from backend results)
- DLQ management beyond surfacing a ‚Äúsent to DLQ‚Äù indicator and error details provided by backend

---

## 3. Actors & Stakeholders

- **Primary actor:** Accounting Ops user
- **Secondary stakeholders:** Finance Controller, Auditors, Support Engineers
- **System actors (informational):**
  - Event source: Work Execution / Billing emitting `InvoiceIssued`
  - Accounting backend ingestion service

---

## 4. Preconditions & Dependencies

1. User is authenticated in the Moqui frontend and has permission to access Accounting integration screens (exact permission name TBD).
2. Backend provides at least one API/service endpoint to:
   - List ingestion records for `InvoiceIssued`
   - Retrieve a single ingestion record detail by identifier
3. Backend persists ingestion outcome records including:
   - Status (processed/duplicate/rejected/quarantined/etc.)
   - Idempotency key values and/or processed log reference
   - Posting references (ledger/journal identifiers) when processed
   - Error code/message when rejected
4. Event schema referenced: ‚ÄúDurion Accounting Event Contract v1‚Äù (PDF linked in story) ‚Äî UI should display fields as provided by backend; UI must not attempt to validate schema beyond required filter inputs.

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Left nav (or Accounting module menu): **Accounting ‚Üí Integrations ‚Üí InvoiceIssued Ingestion**
- Direct route: `/accounting/integrations/invoice-issued` (proposed; final route must match repo conventions)

### Screens to create/modify
1. **Screen: `Accounting/Integrations/InvoiceIssued/List`**
   - List/search ingestion records
   - Filter by status, date range, invoiceId, eventId
   - Open detail view
2. **Screen: `Accounting/Integrations/InvoiceIssued/Detail`**
   - Read-only details:
     - Event envelope identifiers
     - Invoice identifiers and totals
     - Revenue items and tax items summary (as provided)
     - Processing status + timestamps
     - Posting references (ledgerTransactionId, etc.) if available
     - Error details if rejected
   - Optional ‚ÄúRetry‚Äù action if backend supports it (see Open Questions)

### Navigation context
- Breadcrumb: Accounting ‚Üí Integrations ‚Üí InvoiceIssued Ingestion ‚Üí (Record Detail)

### User workflows
**Happy path (monitoring processed events):**
1. User opens list screen
2. Filters for a date range and status=Processed
3. Opens a record to confirm posting references exist and credits/debits balanced flag (if provided)

**Alternate path (duplicate event):**
1. User filters status=Duplicate
2. Opens record to verify it was ignored and no new posting references were created

**Failure path (rejected/validation failure):**
1. User filters status=Rejected
2. Opens record, reviews error code/message and missing/unknown account details
3. (If supported) triggers retry after upstream fix; otherwise exports identifiers for backend investigation

---

## 6. Functional Behavior

### Triggers
- User navigates to list or detail screens
- User applies filters / pagination
- (Optional) User requests retry/reprocess for a failed ingestion record

### UI actions
- **List screen**
  - Filter form submit refreshes results
  - Clicking a row navigates to Detail screen with `ingestionId` (or equivalent key)
- **Detail screen**
  - Show status badge and processing timeline fields
  - Render sections conditionally based on status:
    - Processed/Duplicate: show idempotency evaluation and posting references
    - Rejected/Quarantined: show error details and DLQ indicator
  - (Optional) Retry button visible only for retry-eligible statuses and authorized users

### State changes (frontend)
- No local domain state; UI is read-only except optional retry action.
- UI must reflect backend state after actions (refresh detail after retry).

### Service interactions
- List call on initial load and on filter change
- Detail call on route enter
- Optional retry call that returns updated status or an async job reference

---

## 7. Business Rules (Translated to UI Behavior)

> Note: Accounting posting rules are backend-owned. UI enforces only presentation/guardrails.

1. **Idempotency visibility**
   - UI must display idempotency keys used by backend (at minimum `invoiceId` and `invoiceVersion`; also `eventId` if available).
   - For status=Duplicate, UI must clearly state ‚ÄúDuplicate ignored; no new postings created‚Äù (wording may vary but must be explicit).

2. **Revenue vs tax segregation visibility**
   - UI must render separate summaries for:
     - Revenue items (amount + revenueAccountCode per item if provided)
     - Tax items (amount + jurisdiction + taxLiabilityAccountCode per item if provided)

3. **Error messaging expectations**
   - If backend provides an error code (e.g., `SCHEMA_VALIDATION_FAILED`, `INGESTION_DUPLICATE_CONFLICT`, `UNKNOWN_GL_ACCOUNT`), UI must show:
     - Error code (verbatim)
     - User-safe message (verbatim from backend, but must not expose secrets)
     - Field-level details if provided (e.g., missing field list, unknown account code)

4. **Authorization/visibility**
   - If user lacks permission, screen must deny access (Moqui authz) and show standard unauthorized page.

---

## 8. Data Requirements

### Entities involved (frontend-read)
**Unclear‚Äîdepends on backend/Moqui entities.** UI needs a persistent entity representing ingestion results, e.g.:
- `AccountingEventIngestion`
- `ProcessedEventLog`
- `LedgerTransaction` / `JournalEntry` references

If existing entity names differ, map accordingly.

### Fields (type, required, defaults)

**Ingestion Record (List + Detail)**
- `ingestionId` (string/UUID, required, primary key for detail routing)
- `eventType` (string, required; should equal `InvoiceIssued`)
- `schemaVersion` (string, optional)
- `eventId` (string/UUID, required)
- `occurredAt` (datetime, optional if not provided)
- `receivedAt` (datetime, required)
- `sourceModule` (string, optional)
- `invoiceId` (string, required)
- `invoiceVersion` (string/int, required)
- `issueDate` (date/datetime, optional)
- `businessUnitId` (string, optional)
- `currencyUomId` (string, optional)

**Financial summary (Detail)**
- `totalAmount` (decimal, optional but expected)
- `revenueItems[]` (array, optional)
  - `amount` (decimal)
  - `description` (string)
  - `revenueAccountCode` (string)
- `taxItems[]` (array, optional)
  - `amount` (decimal)
  - `jurisdiction` (string)
  - `taxLiabilityAccountCode` (string)

**Processing outcome**
- `processingStatus` (enum string, required; see State Model)
- `processedAt` (datetime, optional)
- `duplicateOfIngestionId` (string/UUID, optional)
- `ledgerTransactionId` (string/UUID, optional)
- `journalEntryId` (string/UUID, optional) ‚Äî if applicable
- `errorCode` (string, optional)
- `errorMessage` (string, optional)
- `dlqRouted` (boolean, optional)
- `dlqRef` (string, optional)

### Read-only vs editable
- All fields read-only in UI (this story).
- Filter inputs editable: status/date/invoiceId/eventId.

### Derived/calculated fields (frontend)
- `creditsSum` / `debitsSum` **ONLY if provided by backend**. UI must not compute accounting balances as authoritative.
- Display-only label mapping for `processingStatus`.

---

## 9. Service Contracts (Frontend Perspective)

> Moqui implementation may use `service-call` to REST endpoints or local services; exact names TBD.

### Load/view calls
1. **List ingestion records**
   - **Service:** `accounting.invoiceIssuedIngestion.list` (placeholder)
   - **Inputs:**
     - `status` (optional)
     - `fromDate` / `thruDate` (optional)
     - `invoiceId` (optional)
     - `eventId` (optional)
     - `pageIndex`, `pageSize` (optional)
     - `orderBy` (default: `-receivedAt`)
   - **Outputs:**
     - `results[]` (records)
     - `totalCount`

2. **Get ingestion record detail**
   - **Service:** `accounting.invoiceIssuedIngestion.get` (placeholder)
   - **Inputs:** `ingestionId` (required)
   - **Outputs:** full record including payload summary + posting references + errors

### Create/update calls
- None (read-only story), unless retry is supported.

### Submit/transition calls (optional)
3. **Retry / Reprocess ingestion record**
   - **Service:** `accounting.invoiceIssuedIngestion.retry` (placeholder)
   - **Inputs:** `ingestionId` (required)
   - **Outputs:** updated status or `jobId`
   - **UI behavior:** disable button while in-flight; refresh detail on success.

### Error handling expectations
- 401/403: route to unauthorized
- 404: show ‚Äúrecord not found‚Äù
- 409: show conflict (e.g., cannot retry because status changed)
- 422/400: show validation message for filter inputs (if backend validates)
- 500: show generic error with correlationId if provided

---

## 10. State Model & Transitions

### Allowed states (processingStatus)
Because backend contract is not fully defined, UI must support at least:
- `RECEIVED` (optional)
- `PROCESSED`
- `DUPLICATE_IGNORED`
- `REJECTED`
- `QUARANTINED` (optional; for conflicts)
- `PROCESSING` (optional; async)

### Role-based transitions
- Standard users: no transitions
- Accounting Ops with elevated permission: may invoke `RETRY` if backend supports it
  - Allowed from: `REJECTED` (and possibly `QUARANTINED`)
  - Not allowed from: `PROCESSED`, `DUPLICATE_IGNORED`

### UI behavior per state
- `PROCESSED`: show posting references section (ledger/journal IDs)
- `DUPLICATE_IGNORED`: show idempotency/duplicate section; posting references should point to original processed record if backend provides link
- `REJECTED`: show error code/message; show DLQ indicator if routed
- `QUARANTINED`: show conflict details (if provided) and guidance ‚Äúrequires investigation‚Äù
- `PROCESSING`: show in-progress indicator; auto-refresh allowed only if safe default is permitted (see Applied Safe Defaults)

---

## 11. Alternate / Error Flows

1. **Empty state**
   - No results for filters ‚Üí show ‚ÄúNo ingestion records found‚Äù and suggest clearing filters.

2. **Backend unavailable**
   - List/detail service call fails (timeout/5xx) ‚Üí show retry affordance and preserve filter state.

3. **Concurrency**
   - Detail viewed while status changes (e.g., processing completes) ‚Üí refresh shows latest; if retry attempted and backend returns 409, show ‚ÄúRecord already processed / state changed‚Äù.

4. **Unauthorized access**
   - User lacks permission ‚Üí deny screen access; no data leakage.

5. **Partial payload**
   - Backend does not provide `revenueItems`/`taxItems` ‚Üí UI shows ‚ÄúNot available‚Äù and still displays envelope + identifiers.

---

## 12. Acceptance Criteria

### Scenario 1: List InvoiceIssued ingestion records
**Given** I am an authenticated user with permission to view Accounting integrations  
**When** I open the ‚ÄúInvoiceIssued Ingestion‚Äù list screen  
**Then** I see a paginated list of ingestion records including at minimum `receivedAt`, `invoiceId`, `invoiceVersion`, `eventId`, and `processingStatus`  
**And** I can filter by `processingStatus` and a date range  
**And** the list refreshes to show only matching records.

### Scenario 2: View processed ingestion record details
**Given** an ingestion record exists with `processingStatus = PROCESSED`  
**When** I open its detail screen  
**Then** I can see `invoiceId`, `invoiceVersion`, `eventId`, and `schemaVersion` (if available)  
**And** I can see revenue items and tax items in separate sections when provided by the backend  
**And** I can see at least one posting reference identifier (e.g., `ledgerTransactionId` or equivalent) when provided.

### Scenario 3: Duplicate event is clearly indicated and non-posting is visible
**Given** an ingestion record exists with `processingStatus = DUPLICATE_IGNORED`  
**When** I open its detail screen  
**Then** the UI explicitly indicates the event was identified as a duplicate and ignored  
**And** the UI displays the idempotency key values used (at minimum `invoiceId` and `invoiceVersion`)  
**And** the UI does not display new posting references for this duplicate record (unless the backend provides a link to the original processed record).

### Scenario 4: Rejected event shows actionable error details
**Given** an ingestion record exists with `processingStatus = REJECTED` and includes `errorCode` and `errorMessage`  
**When** I open its detail screen  
**Then** the UI displays `errorCode` and `errorMessage`  
**And** if the backend indicates DLQ routing, the UI displays that the event was routed to DLQ and shows any provided DLQ reference.

### Scenario 5: Unauthorized access is blocked
**Given** I am authenticated but do not have permission to view Accounting integrations  
**When** I navigate to the InvoiceIssued ingestion route  
**Then** access is denied and I do not see ingestion record data.

### Scenario 6 (Optional, only if backend supports retry): Retry a rejected ingestion record
**Given** an ingestion record exists with `processingStatus = REJECTED`  
**And** I have permission to retry ingestion  
**When** I click ‚ÄúRetry‚Äù  
**Then** the UI calls the retry service with the record identifier  
**And** on success the detail view refreshes and shows the updated processing status.

---

## 13. Audit & Observability

- UI must display user-visible traceability fields when available:
  - `eventId`, `invoiceId`, `invoiceVersion`, `ledgerTransactionId`/`journalEntryId`
  - timestamps: `receivedAt`, `processedAt`
- Moqui screen actions (list load, detail load, retry) should log:
  - screen path, userId, key identifiers (eventId/invoiceId/ingestionId), and correlationId if returned
- No sensitive payload fields beyond what backend already classifies as safe should be displayed.

---

## 14. Non-Functional UI Requirements

- **Performance:** List should support pagination; initial load should not fetch full payload bodies for all rows (detail fetch only).
- **Accessibility:** Quasar components must be keyboard navigable; status indicators must have text (not color-only).
- **Responsiveness:** List and detail usable on tablet; detail sections stack vertically.
- **i18n/timezone:** Display datetimes in user‚Äôs locale/timezone per app standard (do not invent timezone rules).
- **Currency:** Display amounts with `currencyUomId` when provided; do not assume USD formatting if currency missing.

---

## 15. Applied Safe Defaults

- SD-UX-EMPTY-STATE: Provide explicit empty-state messaging on list screens; safe because it does not affect domain policy. (Impacted: UX Summary, Alternate/Error Flows)
- SD-UX-PAGINATION: Use standard pagination with default sort by most recent `receivedAt`; safe as UI ergonomics only. (Impacted: UX Summary, Service Contracts)
- SD-ERR-STANDARD: Map HTTP 401/403/404/409/422/500 to standard user-facing error patterns; safe because it‚Äôs generic error handling without changing business rules. (Impacted: Service Contracts, Alternate/Error Flows)

---

## 16. Open Questions

1. **Backend contract (blocking):** What are the exact Moqui service names and input/output schemas for:
   - listing ingestion records
   - retrieving a record detail
   - (optional) retry/reprocess?
2. **Entity model (blocking):** What entity/entities in Moqui store ingestion outcomes and posting references (exact entity names and primary keys)?
3. **Permissions (blocking):** What permission(s) gate access to Accounting integration monitoring screens, and what permission gates ‚Äúretry‚Äù (if supported)?
4. **Status taxonomy (blocking):** What are the authoritative processing status values and their meanings (especially for DLQ/quarantine/conflict)?
5. **Posting references (blocking):** Which identifiers should UI display for traceability (ledgerTransactionId vs journalEntryId vs both), and what routes (if any) should deep-link to those records?
6. **Payload visibility (blocking/security):** Which parts of the `InvoiceIssued` event payload are approved to display in UI (full payload JSON vs curated fields only)?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Accounting: Ingest InvoiceIssued Event ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/181  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Accounting: Ingest InvoiceIssued Event

**Domain**: user

### Story Description

/kiro  
Post AR, revenue, and tax liabilities from issued invoices.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Actor
Accounting System

## Trigger
Receipt of `InvoiceIssued` event from Workorder Execution

## Main Flow
1. Validate invoice payload and idempotency
2. Create Accounts Receivable entry
3. Post revenue by classification
4. Post tax liabilities by jurisdiction
5. Persist posting references

## Business Rules
- Invoice is the legal revenue trigger
- Taxes must be posted separately from revenue
- Posting must be idempotent per invoice version

## Data Requirements
- Entities: Invoice, AR, RevenueAccount, TaxLiability
- Fields: invoiceId, totals, taxBreakdown

## Acceptance Criteria
- [ ] AR balance increases correctly
- [ ] Revenue posted to correct accounts
- [ ] Tax liabilities recorded accurately
- [ ] Duplicate events do not double-post

## References
- Durion Accounting Event Contract v1

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299815/Durion_Accounting_Event_Contract_v1.pdf)

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #182: [FRONTEND] [STORY] Accounting: Reverse Completion on Workorder Reopen ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/182
File: ./scripts/story-work/frontend/182/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Accounting: Reverse Completion on Workorder Reopen (Visibility + Reversal Controls)

### Primary Persona
Accountant / Accounting Operations User (with accounting reversal permissions)

### Business Value
Ensure accounting state accurately reflects reopened workorders, prevent premature invoicing, and provide a complete, user-visible audit trail for completion reversals.

---

## 2. Story Intent

### As a / I want / So that
**As an** Accounting Operations user,  
**I want** to view a workorder‚Äôs completion-related accounting postings and (when permitted) initiate or verify a reversal when a workorder is reopened,  
**so that** the ledger-facing state is consistent, the workorder is not invoice-ready, and all reversal actions are auditable.

### In-scope
- Frontend screens to:
  - View workorder accounting state, related journal entries, and reversal audit trail.
  - Trigger a ‚ÄúReverse completion postings‚Äù action (calls Moqui service) when eligible.
  - Reflect event-driven reversals (i.e., reversal created by backend upon `WorkorderReopened` event) in UI.
- UI enforcement of eligibility rules (disable action when not allowed; show reasons).
- Display errors for blocked reversal scenarios (e.g., already invoiced).

### Out-of-scope
- Defining GL debit/credit mappings, GL accounts, or posting rule content.
- Implementing the event consumer (`WorkorderReopened`) itself (backend responsibility).
- Creating or issuing invoices.
- Editing posted journal entries (must remain immutable).

---

## 3. Actors & Stakeholders
- **Primary user:** Accounting Operations / Accountant
- **Secondary stakeholders:** Financial Controller (auditability), Billing user (depends on invoice-ready flag correctness)
- **System integrations (read-only from UI):**
  - Accounting service/state for workorders
  - Journal entry and audit log storage

---

## 4. Preconditions & Dependencies
- A workorder exists in the system with an accounting record.
- Backend provides Moqui-accessible services/entities to:
  - Load workorder accounting status and invoice-ready flag
  - List completion journal entry and reversal journal entry (if any)
  - List audit events for reversal
  - Initiate reversal (command) OR at minimum expose reversal results after event processing
- Permissions exist and are enforceable by Moqui (e.g., `invoice.adjust`-like or accounting-specific permission for reversal).

**Dependency note:** The referenced backend story for reversal contains open questions about GL accounts and authorization; this frontend story is blocked until a concrete backend contract (services + permissions + entities/fields) is confirmed.

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- From an Accounting module navigation item: **Accounting ‚Üí Workorders ‚Üí Workorder Accounting Detail**
- From a Workorder detail screen (if exists): a link/tab ‚ÄúAccounting‚Äù

### Screens to create/modify
1. **New/Updated Screen:** `apps/accounting/screen/WorkorderAccountingDetail.xml` (name illustrative)
   - Shows accounting status, invoice-ready, related journal entries, and audit trail.
   - Provides an action button: ‚ÄúReverse completion postings‚Äù (when eligible).
2. **Optional supporting dialog screen:** `apps/accounting/screen/WorkorderReverseCompletionDialog.xml`
   - Captures/echoes reversal reason (reasonCode + optional reasonText) if required by backend.

### Navigation context
- Route pattern (proposed): `/accounting/workorders/{workorderId}`
- Breadcrumb: Accounting > Workorders > {workorderId}

### User workflows
**Happy path (manual reversal command)**
1. User opens Workorder Accounting Detail.
2. UI displays completion posting exists and status is Completed; invoice-ready is true.
3. User clicks ‚ÄúReverse completion postings‚Äù.
4. User confirms and provides reversal reason (if required).
5. UI calls reversal service; on success shows reversal journal entry reference, updates status to Reopened/InProgress and invoice-ready false, and appends audit event.

**Alternate path (event-driven reversal already processed)**
1. User opens screen after `WorkorderReopened` event processed.
2. UI shows status is Reopened and reversal journal entry exists; action button disabled with message ‚ÄúAlready reversed‚Äù.

**Blocked path (already invoiced)**
1. UI shows status Invoiced (or invoice exists).
2. Action button disabled; screen shows warning and explains reversal is not allowed.

---

## 6. Functional Behavior

### Triggers
- Screen load for a specific `workorderId`
- User action: click ‚ÄúReverse completion postings‚Äù
- Manual refresh action (or polling) to observe event-driven changes

### UI actions
- Load summary and detail sections:
  - Workorder accounting state
  - Completion journal entry reference (if any)
  - Reversal journal entry reference (if any)
  - Audit events list
- Action button states:
  - Enabled only when reversal is allowed
  - Disabled with explicit reason when not allowed
- Confirmation step before calling reversal command

### State changes (UI-observed)
- `isInvoiceReady`: `true` ‚Üí `false` after reversal
- `accountingStatus`: `Completed` ‚Üí `Reopened`/`InProgress` (exact state names must match backend)
- Append audit event row on success

### Service interactions
- Read: load workorder accounting and related records
- Command: request reversal (if frontend is responsible for initiating)
- Error mapping for conflicts/validation failures

---

## 7. Business Rules (Translated to UI Behavior)

### Validation (client-side, non-authoritative)
- `workorderId` required in route; if missing/invalid: show not-found view.
- If reversal dialog requires reason:
  - `reasonCode` required (dropdown if backend provides list)
  - `reasonText` optional unless backend enforces otherwise

### Enable/disable rules
‚ÄúReverse completion postings‚Äù button:
- **Enabled when all are true:**
  - Workorder accounting status is `Completed` (or backend-designated reversible status)
  - Completion journal entry exists (or backend indicates ‚Äúcompletion postings present‚Äù)
  - No invoice exists / not invoiced (hard stop)
  - User has reversal permission
  - No prior reversal exists (or backend indicates not yet reversed)
- **Disabled** otherwise, with inline explanation:
  - ‚ÄúAlready invoiced‚Äîreversal not permitted‚Äù
  - ‚ÄúNo completion posting found‚Äù
  - ‚ÄúAlready reversed‚Äù
  - ‚ÄúInsufficient permission‚Äù

### Visibility rules
- Journal entries section visible if any journal entry references exist; otherwise show empty state ‚ÄúNo accounting postings recorded for this workorder yet.‚Äù
- Audit section always visible; empty state if none.

### Error messaging expectations
- Conflict/blocked conditions must be shown as actionable messages:
  - `WORKORDER_ALREADY_INVOICED_REVERSAL_BLOCKED` (example code) ‚Üí ‚ÄúWorkorder already invoiced; completion reversal is not allowed.‚Äù
  - `ORIGINAL_COMPLETION_ENTRY_NOT_FOUND` ‚Üí ‚ÄúCannot reverse because original completion entry was not found. Contact support.‚Äù
  - `DUPLICATE_REQUEST` ‚Üí ‚ÄúThis reversal request was already processed.‚Äù

(Exact error codes must be confirmed by backend; see Open Questions.)

---

## 8. Data Requirements

### Entities involved (frontend-read)
> Names are placeholders until confirmed in Moqui entity definitions.

- `WorkorderAccounting` (or equivalent)
- `JournalEntry` (completion + reversal)
- `AccountingAuditEvent` (or `InvoiceAuditEvent`-like audit entity but for workorders)
- Optional: `Invoice` reference / link table to determine invoiced status

### Fields (type, required, defaults)
**WorkorderAccounting**
- `workorderId` (string/uuid, required)
- `accountingStatus` (string/enum, required)
- `isInvoiceReady` (boolean, required, default false)
- `completionJournalEntryId` (string, nullable)
- `reversalJournalEntryId` (string, nullable)
- `invoicedInvoiceId` (string, nullable) OR `isInvoiced` (boolean) (blocking‚Äîmust be defined)
- `lastUpdatedTxStamp` (timestamp, for optimistic concurrency display)

**JournalEntry (read-only)**
- `journalEntryId` (string, required)
- `transactionDate` (date, required)
- `description` (string, required)
- `originalJournalEntryId` (string, nullable)
- `status` (enum: Draft/Posted/etc., required)
- `currencyUomId` (string, required)

**AccountingAuditEvent (read-only)**
- `auditId` (string, required)
- `eventType` (string, required; e.g., `WORKORDER_COMPLETION_REVERSED`)
- `entityId` (string, required = workorderId)
- `userId` (string, required)
- `timestamp` (datetime, required)
- `detailsJson` (text/json, required)

**Reversal request (write)**
- `workorderId` (required)
- `reasonCode` (required if backend demands; unknown)
- `reasonText` (optional)

### Read-only vs editable by state/role
- All accounting state and journal/audit data is **read-only** in UI.
- Only action is initiating reversal (command), gated by permission.

### Derived/calculated fields (display-only)
- `eligibilityStatus`: derived on frontend from loaded data to drive button enablement and messaging.

---

## 9. Service Contracts (Frontend Perspective)

> Moqui service names/paths must be confirmed; below are **required contract shapes**.

### Load/view calls
1. **Load Workorder Accounting Detail**
   - Service: `accounting.WorkorderAccountingDetail` (example)
   - Input: `workorderId`
   - Output:
     - `workorderAccounting` object (fields above)
     - `completionJournalEntry` (optional)
     - `reversalJournalEntry` (optional)
     - `auditEvents[]`
     - `permissions` flags (optional but recommended): `canReverseCompletion`

2. **List Audit Events**
   - Service: `accounting.WorkorderAccountingAuditList`
   - Input: `workorderId`, paging params
   - Output: list + total

### Create/update calls (command)
1. **Request reversal**
   - Service: `accounting.reverseWorkorderCompletion`
   - Input: `workorderId`, `reasonCode?`, `reasonText?`
   - Output (success):
     - `reversalJournalEntryId`
     - updated `accountingStatus`
     - `isInvoiceReady=false`
     - created `auditId`
   - Output (failure): structured errors with code + message

### Submit/transition calls
- None beyond reversal command.

### Error handling expectations
- 401/403 ‚Üí show ‚ÄúNot authorized‚Äù and hide/disable reversal action.
- 404 workorder not found ‚Üí show not-found state.
- 409 conflict (already invoiced / already reversed / state mismatch) ‚Üí show inline error; do not mutate UI state; offer refresh.
- 422 validation (missing reasonCode, invalid state) ‚Üí highlight fields and show message.
- 500/503 ‚Üí show retry affordance; do not assume reversal happened.

---

## 10. State Model & Transitions

### Allowed states (UI must treat as enums)
Must be confirmed by backend; expected set (from backend reference):
- `InProgress`
- `Completed`
- `Reopened` (or use `InProgress` after reopen)
- `Invoiced`

### Role-based transitions
- Only users with reversal permission can request reversal from `Completed` ‚Üí `Reopened/InProgress`.
- No reversal allowed from `Invoiced` (hard stop).

### UI behavior per state
- `Completed`:
  - If completion JE exists and not invoiced and not reversed ‚Üí reversal action enabled
- `Reopened`/`InProgress`:
  - reversal action disabled; show ‚ÄúWorkorder not completed‚Äù or ‚ÄúAlready reopened‚Äù
- `Invoiced`:
  - reversal action disabled; show hard-stop warning
- Unknown state:
  - disable action; show ‚ÄúUnsupported status‚Äù; log client-side error for diagnostics

---

## 11. Alternate / Error Flows

### Validation failures
- Missing reasonCode (if required): keep dialog open; show required validation.
- Backend rejects due to invalid state: show message ‚ÄúWorkorder not eligible for reversal (status: X).‚Äù

### Concurrency conflicts
- If backend uses optimistic locking and returns conflict:
  - UI shows ‚ÄúThis record changed since you opened it. Refresh to continue.‚Äù
  - Provide ‚ÄúRefresh‚Äù button to reload.

### Unauthorized access
- If user can view but not reverse:
  - Screen loads read-only data.
  - Reversal action hidden or disabled with ‚ÄúYou do not have permission.‚Äù

### Empty states
- No journal entries:
  - Show empty ‚ÄúNo completion postings found; nothing to reverse.‚Äù
- No audit events:
  - Show empty ‚ÄúNo audit events recorded.‚Äù

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: View completed workorder with completion posting
Given I have permission to view workorder accounting  
And a workorder exists with accountingStatus "Completed"  
And the workorder has a completionJournalEntryId  
When I open the Workorder Accounting Detail screen for that workorderId  
Then I see the accountingStatus and isInvoiceReady value  
And I see the completion journal entry reference and details  
And I see the reversal action is enabled if no invoice exists and no reversal exists

### Scenario 2: Reverse completion successfully (manual command)
Given I have permission to reverse completion postings  
And a workorder exists with accountingStatus "Completed" and isInvoiceReady true  
And the workorder is not invoiced  
And no reversalJournalEntryId exists  
When I click "Reverse completion postings" and confirm (and provide a reason if required)  
Then the frontend calls the reversal service with workorderId (and reason fields if required)  
And I see a success confirmation  
And I see isInvoiceReady becomes false  
And I see accountingStatus changes to "Reopened" or "InProgress" per backend response  
And I see a reversal journal entry reference displayed  
And I see a new audit event entry for the reversal

### Scenario 3: Reversal blocked because workorder is invoiced
Given I have permission to view workorder accounting  
And a workorder exists that is invoiced (status "Invoiced" or invoice reference present)  
When I open the Workorder Accounting Detail screen  
Then the reversal action is disabled (or not shown)  
And I see a message stating reversal is not permitted because the workorder is already invoiced  
And no reversal service call is possible from the UI

### Scenario 4: Reversal fails because original completion entry is missing
Given I have permission to reverse completion postings  
And a workorder appears eligible in the UI  
But the backend cannot find the original completion journal entry  
When I attempt reversal  
Then the frontend shows an error message indicating the completion entry was not found  
And the UI does not change accountingStatus or isInvoiceReady  
And the user can retry after refresh

### Scenario 5: Duplicate/already reversed
Given a workorder already has reversalJournalEntryId populated  
When I open the Workorder Accounting Detail screen  
Then the reversal action is disabled  
And I see a message "Already reversed"  
And I can view both original and reversal journal entry references

### Scenario 6: Unauthorized reversal attempt
Given I can view the workorder accounting screen  
But I do not have permission to reverse completion postings  
When I open the Workorder Accounting Detail screen  
Then the reversal action is disabled or hidden  
And if I attempt to call reversal via direct navigation/UI manipulation  
Then the backend returns 403 and the UI shows a not-authorized error

---

## 13. Audit & Observability

### User-visible audit data
- Audit timeline/list showing:
  - eventType (`WORKORDER_COMPLETION_REVERSED`)
  - timestamp
  - userId (reopenedByUserId if event-driven, or current user if manual)
  - reasonCode and reasonText (if available)
  - originalJournalEntryId and reversalJournalEntryId (if available)

### Status history
- Display current accountingStatus and last updated timestamp.
- If backend provides status history, show it; otherwise show audit events only.

### Traceability expectations
- UI must display identifiers to support support/audit:
  - `workorderId`
  - `completionJournalEntryId`
  - `reversalJournalEntryId`
  - `auditId` (optional display)
- Frontend logs (console or app logger) should include `workorderId` on load and reversal attempt failures (no PII beyond IDs).

---

## 14. Non-Functional UI Requirements
- **Performance:** Detail screen should load core summary within 2s under normal conditions; audit list may paginate.
- **Accessibility:** All actions keyboard accessible; confirmation dialog focus trapped; labels for inputs; error text associated to fields.
- **Responsiveness:** Works on tablet widths typical for POS back office.
- **i18n/timezone/currency:**
  - Display timestamps in user locale/timezone.
  - Display currency amounts using `currencyUomId` if journal entry lines/amounts are shown (amount display is optional unless required).

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide explicit empty states for missing journal entries/audit events; safe because it does not change domain logic; impacts UX Summary, Alternate / Error Flows.
- SD-UX-PAGINATION: Paginate audit events list (default page size 25) if long; safe because it is a UI ergonomics choice; impacts UX Summary, Data Requirements.
- SD-ERR-STD-MAPPING: Map common HTTP errors (401/403/404/409/422/5xx) to user messages and retry; safe because it‚Äôs standard error handling; impacts Service Contracts, Alternate / Error Flows.

---

## 16. Open Questions

1. **Backend contract (blocking):** What are the exact Moqui service names, input/output fields, and entity names for:
   - Loading workorder accounting detail (status, invoice-ready, completion JE id, reversal JE id)
   - Listing audit events
   - Initiating reversal (if frontend should initiate), including required reason fields?
2. **Authorization (blocking):** What permission(s) gate the reversal action in the UI (exact permission ID/scope), and should the frontend rely on a `canReverseCompletion` flag from backend?
3. **State enum (blocking):** What are the authoritative `accountingStatus` values and which one represents ‚Äúreopened‚Äù (is it `Reopened` or `InProgress`)?
4. **Invoiced detection (blocking):** How does the frontend determine ‚Äúalready invoiced‚Äù‚Äîvia `accountingStatus=Invoiced`, an `invoiceId` reference, or a separate service call?
5. **Reason codes (blocking if required):** Is `reasonCode` mandatory for reversal requests, and if so what is the allowed value set and how is it loaded (enum vs service)?
6. **Event-driven vs user-driven (blocking):** For this frontend story, is reversal *only* event-driven on `WorkorderReopened`, or should users be able to manually request reversal from UI as an operational tool?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Accounting: Reverse Completion on Workorder Reopen ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/182

====================================================================================================

FRONTEND STORY (FULL CONTEXT)

====================================================================================================

Title: [FRONTEND] [STORY] Accounting: Reverse Completion on Workorder Reopen  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/182  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Accounting: Reverse Completion on Workorder Reopen

**Domain**: user

### Story Description

/kiro  
Safely reverse completion-related accounting state.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Actor
Accounting System

## Trigger
Receipt of `WorkorderReopened` event

## Main Flow
1. Validate reopen authorization
2. Reverse WIP/finished postings if present
3. Mark workorder as not invoice-ready
4. Record reversal audit trail

## Acceptance Criteria
- [ ] Accounting state matches reopened workorder
- [ ] Reversal is fully auditable

## References
- Durion Accounting Event Contract v1

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299815/Durion_Accounting_Event_Contract_v1.pdf)

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

====================================================================================================

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #183: [FRONTEND] [STORY] Accounting: Ingest WorkCompleted Event  
File: ./scripts/story-work/frontend/183/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Accounting: Ingest WorkCompleted Event (Ops UI for Monitoring, Replay, and Workorder Invoice-Eligibility)

### Primary Persona
Accounting Operations User (Back-office accountant / accounting ops) who monitors accounting event ingestion and resolves failures.

### Business Value
Ensure `WorkCompleted` events are ingested reliably and are traceable/auditable so WIP finalization (if enabled) and workorder invoice-eligibility are correctly applied, reducing billing delays and preventing duplicate/invalid financial processing.

---

## 2. Story Intent

### As a / I want / So that
- **As an** Accounting Operations User  
- **I want** a UI to view the status of ingested `WorkCompleted` events (including validation errors, duplicates, and processing outcomes) and to safely retry/replay failed events  
- **So that** completed workorders become invoice-eligible on time and ingestion problems can be triaged without engineering intervention.

### In-scope
- Moqui screens to:
  - List and filter `WorkCompleted` ingestion records.
  - View a single ingestion record details (payload envelope, validation results, processing outcome).
  - Trigger an operator-initiated **retry/reprocess** action for eligible failed records (subject to permissions).
- UI handling of backend error codes and status mapping (validation/duplicate/not-found/WIP failure).
- Audit/observability display fields (processed timestamps, correlation/event IDs, outcome reason).

### Out-of-scope
- Implementing the actual ingestion processor/business logic (backend-owned).
- Defining GL account mappings, journal entry lines, or posting semantics in the UI.
- Building/altering the canonical event schema (contract owned elsewhere).
- Creating AR, invoices, or revenue recognition flows.

---

## 3. Actors & Stakeholders

- **Accounting Operations User (Primary human actor):** monitors ingestion, investigates failures, initiates retries.
- **System (Accounting Ingestion Service):** produces ingestion status records and exposes APIs consumed by UI.
- **Work Execution domain/system:** upstream producer of `WorkCompleted` events (context only).
- **Billing domain/system:** downstream consumer of ‚Äúinvoice-eligible‚Äù status (context only).
- **Audit/Compliance stakeholder:** needs traceability (who retried what, when, why).

---

## 4. Preconditions & Dependencies

### Preconditions
- User is authenticated in the frontend and has access to Accounting module navigation.
- Backend exposes endpoints/services to:
  - Search ingestion records by filters.
  - Retrieve ingestion record details by ID.
  - Trigger retry/reprocess (operator action) for a specific ingestion record.

### Dependencies (Blocking if absent)
- The **backend contract** for ingestion records and retry is not defined in the provided inputs (only a backend story reference exists and is itself blocked). Frontend cannot be finalized without:
  - Entity/DTO field names
  - Status enums
  - Error code taxonomy
  - Retry eligibility rules
  - Authorization permission(s)

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main app nav: **Accounting ‚Üí Event Ingestion ‚Üí WorkCompleted** (or **Accounting ‚Üí Events ‚Üí Ingestion** if that‚Äôs the established pattern).

### Screens to create/modify
1. **Screen:** `apps/pos/accounting/events/WorkCompletedIngestionList.xml`
   - Search/list view for ingestion records.
2. **Screen:** `apps/pos/accounting/events/WorkCompletedIngestionDetail.xml`
   - Detail view for a single ingestion record with actions (retry) and payload inspection.

> Note: Exact screen path must match repo conventions; adjust to the project‚Äôs existing screen root and menu structure once confirmed.

### Navigation context
- From list ‚Üí click row ‚Üí detail screen
- From detail ‚Üí back to list preserving prior filters (via URL parameters or session-saved search)

### User workflows
#### Happy path (monitoring)
1. User opens list screen.
2. Filters by date range and status = `FAILED` (or equivalent).
3. Opens a record; reviews reason and payload.
4. If eligible, clicks **Retry**.
5. UI shows confirmation, submits retry, shows updated status (e.g., `RETRY_QUEUED` / `PROCESSING` / `SUCCEEDED`).

#### Alternate paths
- View `DUPLICATE` records (idempotency) and understand they are not retried.
- View `WORKORDER_NOT_FOUND` failures and optionally retry after upstream data issue is resolved.
- View `VALIDATION_ERROR` and see it is not retryable (unless policy allows manual override‚Äîcurrently unknown).

---

## 6. Functional Behavior

### Triggers
- User navigates to list screen.
- User selects a record to view details.
- User initiates retry action.

### UI actions
- **List Screen**
  - Filter controls:
    - `status` (single-select or multi-select)
    - `occurredAt` date/time range
    - `workorderId` (text)
    - `eventId` (text)
    - `sourceModule` (text)
  - Table columns (minimum):
    - occurredAt
    - eventId
    - workorderId
    - status
    - reasonCode / errorCode (if any)
    - processedAt (if any)
  - Row click navigates to detail.

- **Detail Screen**
  - Summary panel:
    - eventId, eventType, schemaVersion, occurredAt
    - workorderId, businessUnitId, currencyUomId
    - processingStatus, processedAt, attemptCount
    - lastErrorCode, lastErrorMessage (sanitized)
  - Payload viewer:
    - read-only formatted JSON (collapsed by default)
  - Actions:
    - **Retry/Reprocess** button visible only when record is retry-eligible and user has permission.
    - Confirmation dialog requiring ‚ÄúReason for retry‚Äù (if required by audit policy‚Äîcurrently unclear).

### State changes (frontend-observed)
- After retry submission, record status should transition to a queued/processing status or immediately re-evaluated. UI must refresh the record.

### Service interactions
- `searchIngestionRecords` (list)
- `getIngestionRecord` (detail)
- `retryIngestionRecord` (action)
- Optional: `getConfig` for WIP flag display (read-only), if exposed.

---

## 7. Business Rules (Translated to UI Behavior)

> Business rules provided are primarily backend semantics; UI must reflect them safely without inventing accounting policies.

### Validation
- Filters:
  - Date range: `from <= to`; show inline validation error.
  - `eventId` format: if UUID required, validate format client-side (optional) and server-side (authoritative).
- Retry action:
  - Must require confirmation.
  - Must block action while request in-flight to prevent double-submit.
  - Must show backend error codes and messages if retry rejected.

### Enable/disable rules
- Retry button enabled only if:
  - Record status is in a retryable terminal state (e.g., `FAILED_RETRYABLE`) **(needs clarification)**.
  - User has required permission (e.g., `accounting:events:retry`) **(needs clarification)**.

### Visibility rules
- Show WIP-related processing outcome fields only if present in record (do not assume WIP enabled/disabled unless explicitly provided).
- Do not expose sensitive/internal stack traces; display sanitized error message.

### Error messaging expectations
Map backend errors to user-facing messages (do not guess missing codes; see Open Questions). At minimum:
- Validation failure: ‚ÄúEvent payload failed validation; cannot be processed.‚Äù
- Not found: ‚ÄúWorkorder referenced by event was not found.‚Äù
- Duplicate conflict: ‚ÄúDuplicate event ID detected; already processed or conflicting payload.‚Äù
- WIP reconciliation failure: ‚ÄúWIP reconciliation failed; retry may be available.‚Äù

---

## 8. Data Requirements

### Entities involved (frontend-facing)
Because authoritative entity names are not provided, define placeholders to be replaced with actual Moqui entities/services:

- `AccountingEventIngestion` (or similar): ingestion record for canonical accounting events.
- `AccountingEventIngestionAttempt` (optional): per-attempt history.
- Related reference data:
  - Workorder reference (read-only link by `workorderId`), if a screen exists.

### Fields (type, required, defaults)
**Ingestion Record (minimum set)**
- `ingestionId` (string/UUID, required, read-only)
- `eventId` (UUID, required, read-only)
- `eventType` (string, required, read-only) ‚Äî expected `WorkCompleted`
- `schemaVersion` (string, required, read-only)
- `sourceModule` (string, required, read-only)
- `sourceEntityRef` (string/object, required?, read-only) *(unclear)*
- `occurredAt` (datetime, required, read-only)
- `receivedAt` (datetime, required, read-only)
- `businessUnitId` (string/UUID, required, read-only)
- `currencyUomId` (string, required, read-only)
- `workorderId` (UUID, required, read-only)
- `processingStatus` (enum/string, required, read-only)
- `processedAt` (datetime, optional, read-only)
- `attemptCount` (number, required, read-only; default 0)
- `lastErrorCode` (string, optional, read-only)
- `lastErrorMessage` (string, optional, read-only; sanitized)
- `payloadJson` (text/json, required, read-only)

**Attempt History (if available)**
- `attemptNo` (int)
- `attemptedAt` (datetime)
- `outcomeStatus` (enum)
- `errorCode`/`errorMessage`

### Read-only vs editable by state/role
- All ingestion record fields are read-only.
- Only operator action is `retry` (command), not editing payload.

### Derived/calculated fields
- `retryEligible` (boolean) derived by backend or computed from status; prefer backend-provided to avoid duplicating policy.

---

## 9. Service Contracts (Frontend Perspective)

> Moqui implementations may use `service-call` to invoke REST or local services; exact service names must be confirmed.

### Load/view calls
1. **Search**
   - Service: `accounting.events.IngestionSearch` *(placeholder)*
   - Inputs:
     - `eventType=WorkCompleted`
     - `status[]` (optional)
     - `occurredAtFrom`, `occurredAtTo` (optional)
     - `workorderId` (optional)
     - `eventId` (optional)
     - pagination: `pageIndex`, `pageSize`
     - sorting: `orderByField`, `orderByDirection`
   - Outputs:
     - `records[]` with fields listed above (subset ok for list)
     - `totalCount`

2. **Detail**
   - Service: `accounting.events.IngestionGet` *(placeholder)*
   - Inputs: `ingestionId` (or `eventId`)
   - Outputs: full ingestion record + attempt history + `retryEligible`

### Create/update calls
- None (UI does not create events).

### Submit/transition calls
1. **Retry**
   - Service: `accounting.events.IngestionRetry` *(placeholder)*
   - Inputs:
     - `ingestionId`
     - `operatorReason` (optional/required? **unclear**)
   - Outputs:
     - updated record status or an acknowledgment `{queued:true}`

### Error handling expectations
- 400 validation errors: show inline banner and field hints where applicable.
- 401/403: show ‚ÄúNot authorized‚Äù and hide retry action when permission missing.
- 404: record not found ‚Üí show not-found state.
- 409: conflict (already processed / not retryable) ‚Üí show conflict message and refresh record.
- Known domain error codes expected (from backend story/checklist examples):
  - `SCHEMA_VALIDATION_FAILED`
  - `INGESTION_DUPLICATE_CONFLICT`
  - `INVOICE_TOTAL_NEGATIVE_REQUIRES_CREDIT_MEMO` *(likely not applicable here; do not surface unless returned)*
  - `workorder_not_found`
  - `wip_reconciliation_failed`

---

## 10. State Model & Transitions

### Allowed states (display + filtering)
Backend-defined; UI must support at least:
- `RECEIVED` (optional)
- `VALIDATED` (optional)
- `PROCESSED_SUCCESS` (or `SUCCEEDED`)
- `FAILED`
- `DUPLICATE_IGNORED` / `DUPLICATE_CONFLICT`
- `RETRY_QUEUED` / `REPROCESSING`

### Role-based transitions
- Only authorized users can initiate `FAILED -> RETRY_QUEUED/REPROCESSING`.
- No UI transition for success states.

### UI behavior per state
- Success: show ‚ÄúProcessed‚Äù and processed timestamp.
- Failed: show error code/message and show Retry if eligible.
- Duplicate: show duplicate explanation; hide Retry unless policy says retryable (default: not retryable).
- Processing: disable Retry and show spinner/processing indicator.

---

## 11. Alternate / Error Flows

### Validation failures
- User enters invalid UUID filter ‚Üí UI prevents submission or shows server-side error.
- Backend returns `SCHEMA_VALIDATION_FAILED` for record details: show ‚ÄúPayload failed schema validation‚Äù and render payload viewer for analysis.

### Concurrency conflicts
- Retry clicked twice / two users retry simultaneously:
  - Backend returns 409 conflict ‚Äúalready queued/processing‚Äù; UI refreshes detail and shows latest status.

### Unauthorized access
- User without permission opens list: either deny access to screen or show empty + authorization error (per app convention).
- User can view but cannot retry: hide/disable Retry and show ‚ÄúInsufficient permissions‚Äù on attempt.

### Empty states
- No ingestion records match filters: show ‚ÄúNo events found‚Äù with suggestion to adjust date range/status.

---

## 12. Acceptance Criteria

### Scenario 1: View WorkCompleted ingestion records list
**Given** I am an authenticated user with access to Accounting event ingestion screens  
**When** I open the WorkCompleted ingestion list screen  
**Then** I see a paginated list of ingestion records filtered to `eventType = WorkCompleted`  
**And** each row shows `occurredAt`, `eventId`, `workorderId`, `processingStatus`, and `processedAt` (if present)

### Scenario 2: Filter by status and date range
**Given** I am on the WorkCompleted ingestion list screen  
**When** I set `status = FAILED` and set an `occurredAt` date range  
**And** I run the search  
**Then** only records matching those filters are displayed  
**And** the URL (or preserved navigation state) retains the applied filters

### Scenario 3: View ingestion record detail with payload
**Given** an ingestion record exists for a WorkCompleted event  
**When** I open its detail screen  
**Then** I can view its identifiers (`eventId`, `workorderId`, `schemaVersion`, `sourceModule`)  
**And** I can view the sanitized last error code/message if the record failed  
**And** I can view the raw payload JSON in a read-only viewer

### Scenario 4: Retry a retry-eligible failed ingestion record
**Given** I have permission to retry ingestion records  
**And** an ingestion record is in a backend-defined retry-eligible failed state  
**When** I click ‚ÄúRetry‚Äù and confirm the action  
**Then** the UI calls the retry service with the record identifier  
**And** the UI shows a success acknowledgment and refreshes the record status  
**And** the Retry action is disabled while the request is in-flight

### Scenario 5: Retry rejected due to conflict (already processed/queued)
**Given** I am viewing a failed ingestion record  
**When** I click ‚ÄúRetry‚Äù  
**And** the backend responds with HTTP 409 indicating the record is no longer retryable  
**Then** the UI shows a conflict message  
**And** refreshes the record detail to display the current status

### Scenario 6: Unauthorized user cannot retry
**Given** I can view ingestion records but do not have retry permission  
**When** I open a failed ingestion record detail  
**Then** I do not see an enabled Retry action (hidden or disabled per convention)  
**And** if I attempt the retry endpoint via UI controls, I receive an authorization error message

---

## 13. Audit & Observability

### User-visible audit data
- Display:
  - `attemptCount`
  - `processedAt`
  - last retry/attempt timestamp (if attempt history exists)
  - actor for operator-initiated retry (if returned)

### Status history
- If backend provides attempt history, render a chronological list of attempts (attempt no, timestamp, outcome, errorCode).

### Traceability expectations
- UI must surface identifiers for cross-system tracing:
  - `eventId`, `workorderId`, `businessUnitId`, correlationId/traceId if provided.

---

## 14. Non-Functional UI Requirements

- **Performance:** list search should return and render first page within 2 seconds for typical filter usage (dependent on backend).
- **Accessibility:** all actions reachable via keyboard; payload viewer supports screen readers (at minimum provides copy-to-clipboard and proper labels).
- **Responsiveness:** list and detail screens usable on tablet widths; table columns may collapse but must remain functional.
- **i18n/timezone:** all timestamps displayed in user‚Äôs locale/timezone with an option to view raw ISO timestamp in detail (read-only). Currency display is informational only (no calculations).

---

## 15. Applied Safe Defaults

- SD-UI-EMPTY-STATE: Provide explicit ‚ÄúNo results‚Äù empty state and guidance to adjust filters; qualifies as safe UI ergonomics; impacts UX Summary, Alternate / Error Flows.
- SD-UI-PAGINATION: Use standard pagination (pageSize default 25) and server-side paging; qualifies as safe UI ergonomics; impacts UX Summary, Service Contracts.
- SD-UI-INFLIGHT-GUARD: Disable action buttons while requests are in-flight to prevent double-submit; qualifies as safe error-prevention; impacts Functional Behavior, Alternate / Error Flows.

---

## 16. Open Questions

1. **Backend contract for ingestion records:** What are the exact API endpoints/service names, request parameters, and response field names for listing and fetching `WorkCompleted` ingestion records?
2. **Status model:** What are the authoritative `processingStatus` values for ingestion records (including ‚Äúduplicate‚Äù and ‚Äúretry queued/processing‚Äù)?
3. **Retry policy:** Which statuses/errors are retry-eligible (e.g., `wip_reconciliation_failed`, `workorder_not_found`) and which are not (e.g., `SCHEMA_VALIDATION_FAILED`, `INGESTION_DUPLICATE_CONFLICT`)?
4. **Authorization:** What permission(s)/scope(s) gate access to (a) viewing ingestion screens and (b) initiating a retry? (e.g., `SCOPE_accounting:events:ingest` is mentioned for service-to-service; what is the human/operator permission?)
5. **Operator reason/audit requirement:** Must the UI collect a mandatory ‚Äúretry reason‚Äù comment for audit? If yes, what are constraints (min/max length) and where is it stored?
6. **Payload access controls:** Is the full event payload always safe to display to ops users, or must some fields be masked/redacted?
7. **Moqui navigation conventions:** What is the expected screen root/module path and menu placement in `durion-moqui-frontend` for accounting event ingestion UIs?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Accounting: Ingest WorkCompleted Event  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/183  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Accounting: Ingest WorkCompleted Event

**Domain**: user

### Story Description

/kiro
Determine WIP finalization or readiness for invoicing.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Actor
Accounting System

## Trigger
Receipt of `WorkCompleted` event from Workorder Execution

## Main Flow
1. Validate completion event and source workorder
2. If WIP accounting enabled:
   - Transfer WIP to Finished Work
3. Mark workorder as invoice-eligible
4. Persist completion accounting state

## Business Rules
- Completion does not create AR or revenue
- WIP handling is configuration-driven

## Acceptance Criteria
- [ ] WIP is reconciled (if enabled)
- [ ] Workorder marked invoice-ready

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## References
- Durion Accounting Event Contract v1

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299815/Durion_Accounting_Event_Contract_v1.pdf)

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #184: [FRONTEND] [STORY] Accounting: Ingest InventoryAdjustment Event  
File: ./scripts/story-work/frontend/184/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

**Title:** [FRONTEND] [STORY] Accounting: Ingest InventoryAdjusted Event (View, Validate, Process Status + Audit Trail)

**Primary Persona:** Accounting Ops User (Finance/Accounting back-office user)

**Business Value:**  
Provide a front-end workflow to view and manage ingestion of `InventoryAdjusted` accounting events (including validation outcome, idempotency status, and traceability links) so inventory correction postings are auditable, diagnosable, and supportable without backend log access.

---

## 2. Story Intent

**As a** Accounting Ops User  
**I want** to see received `InventoryAdjusted` events and their processing outcomes (success/duplicate/rejected/quarantined), with links to created journal entries and the referenced source transaction  
**So that** I can verify auditability, investigate failures (schema issues, missing source transaction, negative inventory policy violations), and support reconciliation.

### In-scope
- A Moqui screen flow to:
  - List `InventoryAdjusted` ingestion records with filtering
  - View event details (envelope + payload fields relevant to accounting)
  - View processing status and failure reason (including DLQ/quarantine indicator)
  - Navigate to linked accounting artifacts (journal entry, source transaction reference) where available
- UI-driven reprocessing action **only if** the backend supports it (otherwise show as unavailable with clear messaging)

### Out-of-scope
- Implementing the ingestion consumer, DLQ, idempotency, or journal entry creation logic (backend-owned)
- Defining GL debit/credit mappings, valuation rules, or posting rule configuration (requires accounting policy + backend)
- Editing event payloads (must remain immutable)

---

## 3. Actors & Stakeholders

- **Primary Actor:** Accounting Ops User
- **Secondary Actors:**
  - Controller/Auditor (read-only audit verification)
  - Support Engineer (triage failures)
- **Upstream System:** Work Execution domain publishes `InventoryAdjusted`
- **Downstream / Related:** Accounting journal entry subsystem; GL export/integration (if present)

---

## 4. Preconditions & Dependencies

- An authoritative event contract exists: ‚ÄúDurion Accounting Event Contract v1‚Äù (referenced PDF) and includes `InventoryAdjusted` (`eventType`) payload details.
- Backend provides query endpoints/services for:
  - Listing ingested events and their processing status
  - Retrieving a single event by `eventId`
  - Retrieving linked journal entry id(s) created from the event (if applicable)
  - (Optional) triggering reprocess/retry for a failed/quarantined event
- Moqui authentication exists; permissions for viewing ingestion records are defined.

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main nav: **Accounting ‚Üí Event Ingestion ‚Üí Inventory Adjustments**
- Deep link: `/accounting/events/inventory-adjusted/view?eventId=...`

### Screens to create/modify
1. **Screen:** `apps/accounting/screen/events/InventoryAdjustedList.xml`
   - List view with filters and quick status chips
2. **Screen:** `apps/accounting/screen/events/InventoryAdjustedDetail.xml`
   - Read-only event detail + processing panel + linked artifacts panel
3. (Optional if repo convention supports) **Component:** `apps/accounting/screen/events/components/EventEnvelopeCard.xml` for reuse across event types

### Navigation context
- Breadcrumb: Accounting / Event Ingestion / Inventory Adjustments / (EventId)
- Back action returns to list preserving last-used filters (safe default UI ergonomics)

### User workflows
**Happy path**
1. User opens Inventory Adjustments list
2. Filters by date/status/location/product
3. Opens an event detail
4. Confirms status = Processed (Success) and sees linked Journal Entry reference

**Alternate paths**
- Status = Duplicate ‚Üí user sees ‚ÄúAlready processed‚Äù and the original processing timestamp and linked journal entry (if stored)
- Status = Rejected/Quarantined ‚Üí user sees error code, message, and recommended next action; if backend supports retry, user can trigger retry

---

## 6. Functional Behavior

### Triggers
- User navigates to list or detail screens
- User applies filters/sorts
- User requests ‚ÄúRetry processing‚Äù (if enabled)

### UI actions
**List Screen**
- Display table/grid of ingestion records
- Filter controls:
  - `occurredAt` range (from/to)
  - `processingStatus` multi-select
  - `locationId`
  - `productId`
  - free-text search on `eventId` / `sourceTransactionId` / `adjustmentId`
- Row action: ‚ÄúView‚Äù

**Detail Screen**
- Read-only sections:
  - **Envelope:** `eventId`, `eventType`, `schemaVersion`, `sourceModule`, `occurredAt`, `businessUnitId`, `currencyUomId`
  - **Payload:** `sourceTransactionId`, `adjustmentId`, `productId`, `locationId`, `originalQuantity`, `adjustedQuantity`, `adjustmentReasonCode`, `adjustingUserId`
  - **Processing:** `processingStatus`, `processedAt`, `idempotencyOutcome`, `failureCode`, `failureMessage`, `quarantineRef`/`dlqRef` (if applicable)
  - **Links:** Journal Entry Id(s), Source Transaction reference
- If processing failed and retry is supported:
  - Button ‚ÄúRetry Processing‚Äù
  - Confirmation modal includes warning about idempotency and audit trail
  - After retry: refresh status panel

### State changes
- Frontend does not mutate event payload
- Frontend may invoke a backend retry action which changes processing state; UI must reflect eventual result by refresh

### Service interactions
- List: call a backend service to fetch paginated results
- Detail: call a backend service to fetch full record, including links
- Retry: call a backend service/action; handle async vs sync response (see Open Questions)

---

## 7. Business Rules (Translated to UI Behavior)

> Note: Accounting-domain financial posting rules are backend-owned. Frontend reflects outcomes and enforces immutability + clarity.

### Validation (UI-level)
- Filters validate date range (`from <= to`)
- Retry action is disabled unless:
  - status is one of: `REJECTED`, `QUARANTINED`, `FAILED` (exact enum TBD)
  - user has permission `accounting.events.retry` (permission name TBD)
- Display warning banner on events where payload indicates potential negative inventory scenario:
  - If backend exposes a boolean like `wouldCauseNegativeInventory` or failure code indicates negative inventory policy violation, show banner ‚ÄúBlocked by negative inventory policy‚Äù

### Enable/disable rules
- ‚ÄúRetry Processing‚Äù disabled if status = `PROCESSED_SUCCESS` or `DUPLICATE`
- Links to Journal Entry only enabled if `journalEntryId`(s) present

### Visibility rules
- Failure details visible only when `processingStatus` in a failed category
- Raw payload JSON viewer (collapsible) shown for users with elevated permission `accounting.events.viewRaw` (permission name TBD)

### Error messaging expectations
- Backend error codes mapped to user-readable messages, while preserving code for support:
  - Example: `SCHEMA_VALIDATION_FAILED` ‚Üí ‚ÄúEvent schema validation failed. See details and contact integrations team.‚Äù
  - `SOURCE_TRANSACTION_NOT_FOUND` ‚Üí ‚ÄúReferenced source transaction was not found in accounting records.‚Äù
  - `NEGATIVE_INVENTORY_PROHIBITED` ‚Üí ‚ÄúAdjustment would create prohibited negative inventory position.‚Äù
  - `INGESTION_DUPLICATE_CONFLICT` ‚Üí ‚ÄúDuplicate eventId with conflicting payload. Quarantined for investigation.‚Äù

---

## 8. Data Requirements

### Entities involved (frontend perspective; exact Moqui entity names TBD)
- `AcctIngestedEvent` (or similar): stores event envelope + processing status
- `AcctIngestedEventPayload` or JSON field: stores payload
- `JournalEntry` (read-only link)
- `SourceTransactionRef` (read-only link to original posting / transaction record)

### Fields (type, required, defaults)
**Event Envelope**
- `eventId` (string/UUID; required; immutable)
- `eventType` (string; required; must equal `InventoryAdjusted` for these screens)
- `schemaVersion` (string; required)
- `sourceModule` (string; required)
- `occurredAt` (datetime; required)
- `businessUnitId` (string; required)
- `currencyUomId` (string; required)

**Event Payload (InventoryAdjusted)**
- `sourceTransactionId` (string/UUID; required)
- `adjustmentId` (string/UUID; required)
- `productId` (string; required)
- `locationId` (string; required)
- `originalQuantity` (decimal; required)
- `adjustedQuantity` (decimal; required)
- `adjustmentReasonCode` (string/enum; required)
- `adjustingUserId` (string; required)

**Processing / Audit**
- `processingStatus` (enum; required)
- `processedAt` (datetime; optional)
- `idempotencyOutcome` (enum/string; optional; e.g., `PROCESSED`, `DUPLICATE_SAME_PAYLOAD`, `DUPLICATE_CONFLICT`)
- `failureCode` (string; optional)
- `failureMessage` (string; optional, safe content)
- `quarantineRef` / `dlqRef` (string; optional)
- `createdAt`, `createdBy` (read-only)
- `lastUpdatedAt`, `lastUpdatedBy` (read-only)

### Read-only vs editable by state/role
- All event data is **read-only** for all roles
- Retry action available only for authorized role and only on failed/quarantined states

### Derived/calculated fields
- `quantityDelta = adjustedQuantity - originalQuantity` (display-only)
- `age = now - occurredAt` (display-only)
- `hasJournalEntryLinks` boolean (display-only)

---

## 9. Service Contracts (Frontend Perspective)

> Backend service names are unknown from provided inputs; define contract expectations and map to Moqui `service-call` placeholders.

### Load/view calls
1. **List ingestion records**
   - Service: `accounting.events.InventoryAdjusted.list`
   - Inputs:
     - `occurredFrom` (datetime, optional)
     - `occurredTo` (datetime, optional)
     - `statuses` (list<string>, optional)
     - `locationId` (string, optional)
     - `productId` (string, optional)
     - `q` (string, optional)
     - `pageIndex` (int, default 0)
     - `pageSize` (int, default 25)
     - `sortField` (string, default `occurredAt`)
     - `sortOrder` (`asc|desc`, default `desc`)
   - Output:
     - `items[]` with list-row fields
     - `totalCount`

2. **Get event detail**
   - Service: `accounting.events.InventoryAdjusted.get`
   - Inputs: `eventId` (required)
   - Output: full envelope, payload, processing fields, linked refs

### Create/update calls
- None (immutable)

### Submit/transition calls
1. **Retry processing (optional)**
   - Service: `accounting.events.InventoryAdjusted.retry`
   - Inputs: `eventId` (required), `retryReason` (string optional; see Open Questions), `expectedSchemaVersion` (string optional)
   - Output:
     - Either: immediate `processingStatus` + message
     - Or: `jobId` for async processing (TBD)

### Error handling expectations
- HTTP/service errors map to:
  - Validation error ‚Üí show inline error in filter panel or dialog
  - Unauthorized ‚Üí route to unauthorized screen or show ‚ÄúInsufficient permissions‚Äù
  - Not found ‚Üí show ‚ÄúEvent not found or purged‚Äù
  - Conflict (duplicate conflict) ‚Üí show banner ‚ÄúQuarantined due to duplicate conflict‚Äù and display code
- Never display raw stack traces; show `failureCode` + sanitized `failureMessage`

---

## 10. State Model & Transitions

### Allowed states (processingStatus) ‚Äî **TBD exact enum**
Frontend must support at minimum:
- `RECEIVED` (ingested but not processed)
- `PROCESSED_SUCCESS`
- `DUPLICATE` (same eventId, same payload)
- `QUARANTINED` (duplicate conflict or policy hold)
- `REJECTED` / `FAILED` (schema/validation/lookup failures)

### Role-based transitions
- Accounting Ops with permission may trigger: `REJECTED|QUARANTINED|FAILED` ‚Üí ‚ÄúRetry Requested‚Äù
- All other users: no transitions (read-only)

### UI behavior per state
- `PROCESSED_SUCCESS`: show linked journal entry; retry disabled
- `DUPLICATE`: show idempotency outcome; retry disabled
- `REJECTED/FAILED`: show failure details; retry enabled if supported
- `QUARANTINED`: show quarantine reason; retry may be disabled depending on backend policy (TBD)

---

## 11. Alternate / Error Flows

### Validation failures
- Invalid filter inputs ‚Üí show inline message and do not call list service
- Retry without permission ‚Üí show ‚ÄúInsufficient permissions‚Äù and do not call retry service

### Concurrency conflicts
- If status changes between list and detail load:
  - Detail screen must show latest status
  - If user hits retry but status is now success/duplicate ‚Üí show conflict message and refresh

### Unauthorized access
- If service returns authorization error:
  - Screen shows standard unauthorized panel
  - No sensitive payload fields rendered

### Empty states
- List returns 0 results ‚Üí show ‚ÄúNo InventoryAdjusted events found for current filters‚Äù
- Detail missing journal entry link ‚Üí show ‚ÄúNo journal entry linked (yet)‚Äù with status-dependent hint (e.g., still processing)

---

## 12. Acceptance Criteria

### Scenario 1: View list of InventoryAdjusted ingestion records
**Given** I am an authenticated Accounting Ops User with permission to view accounting ingestion events  
**When** I navigate to Accounting ‚Üí Event Ingestion ‚Üí Inventory Adjustments  
**Then** I see a paginated list of `InventoryAdjusted` events including `eventId`, `occurredAt`, `locationId`, `productId`, and `processingStatus`  
**And** I can filter by occurred date range and status  
**And** the list updates to only show matching events.

### Scenario 2: View event detail with audit and traceability
**Given** an `InventoryAdjusted` event exists with `eventId = X`  
**When** I open the event detail for `eventId = X`  
**Then** I see the event envelope fields (`eventId`, `eventType`, `schemaVersion`, `sourceModule`, `occurredAt`, `businessUnitId`, `currencyUomId`)  
**And** I see the payload fields (`sourceTransactionId`, `adjustmentId`, `productId`, `locationId`, `originalQuantity`, `adjustedQuantity`, `adjustmentReasonCode`, `adjustingUserId`)  
**And** I see processing fields including `processingStatus` and `processedAt` (if processed)  
**And** if journal entry links exist, I can navigate to the linked journal entry view.

### Scenario 3: Display failure details for rejected/quarantined event
**Given** an `InventoryAdjusted` event has `processingStatus = REJECTED` (or `QUARANTINED`)  
**When** I open the event detail  
**Then** I see `failureCode` and a user-readable `failureMessage`  
**And** the UI indicates whether the event is in DLQ/quarantine (if backend provides a reference)  
**And** no event payload fields are editable.

### Scenario 4: Retry processing (only if supported) from a failed event
**Given** an `InventoryAdjusted` event has `processingStatus = FAILED`  
**And** I have permission to retry ingestion processing  
**When** I click ‚ÄúRetry Processing‚Äù and confirm  
**Then** the frontend calls the retry service with `eventId`  
**And** the UI refreshes to show the latest processing status (success, still failed, or quarantined)  
**And** if the backend returns unauthorized/conflict, I see an actionable message and no duplicate retries are submitted.

### Scenario 5: Unauthorized user cannot retry
**Given** I do not have permission to retry ingestion processing  
**When** I view a failed `InventoryAdjusted` event  
**Then** the ‚ÄúRetry Processing‚Äù action is not shown or is disabled  
**And** direct access to the retry endpoint response is handled by showing an unauthorized message.

---

## 13. Audit & Observability

### User-visible audit data
- Display `createdAt/createdBy` for ingestion record (if available)
- Display `processedAt` and `idempotencyOutcome`
- Display immutable identifiers: `eventId`, `adjustmentId`, `sourceTransactionId`

### Status history
- If backend provides status history, show chronological list:
  - `RECEIVED` ‚Üí `FAILED` ‚Üí `RETRY_REQUESTED` ‚Üí `PROCESSED_SUCCESS` (example)
- If not available, show current status only and open question logged

### Traceability expectations
- Detail screen must show link references:
  - `eventId` ‚Üí journal entry id(s)
  - `sourceTransactionId` reference (even if it does not resolve, show as raw id)

---

## 14. Non-Functional UI Requirements

- **Performance:** List loads first page within 2 seconds for typical datasets (25 rows) assuming backend is responsive; use pagination (no unbounded loads).
- **Accessibility:** All actions keyboard accessible; status conveyed not by color alone; ARIA labels for buttons like ‚ÄúRetry Processing‚Äù.
- **Responsiveness:** Works on tablet widths; table can switch to stacked row layout on small screens (Quasar default patterns).
- **i18n/timezone/currency:** Display `occurredAt` and `processedAt` in user‚Äôs timezone; quantities shown with appropriate decimal precision (do not assume currency formatting for quantities). Currency shown as `currencyUomId` label if available.

---

## 15. Applied Safe Defaults

- **SD-UI-01 PaginationDefault**
  - **Assumed:** Default `pageSize = 25` with server-side pagination.
  - **Why safe:** UI ergonomics only; does not affect business logic or accounting policy.
  - **Impacted sections:** UX Summary, Service Contracts, Non-Functional UI Requirements.
- **SD-UI-02 FilterEmptyState**
  - **Assumed:** Standard empty-state message and ‚ÄúClear filters‚Äù action when no results.
  - **Why safe:** Presentation-only; no domain assumptions.
  - **Impacted sections:** UX Summary, Alternate / Error Flows.
- **SD-ERR-01 StandardErrorSurface**
  - **Assumed:** Show backend `failureCode` + sanitized `failureMessage`, never raw stack traces.
  - **Why safe:** Security/UX best practice; does not invent domain policy.
  - **Impacted sections:** Business Rules, Service Contracts, Alternate / Error Flows.

---

## 16. Open Questions

1. **Event contract fields (blocking):** What is the exact `InventoryAdjusted` event schema per ‚ÄúDurion Accounting Event Contract v1‚Äù (field names, types, required/optional, nesting)? The frontend needs exact payload paths to render without guessing.
2. **Processing status model (blocking):** What are the authoritative `processingStatus` and `idempotencyOutcome` enums and their meanings? (e.g., `DUPLICATE` vs `DUPLICATE_CONFLICT` vs `QUARANTINED`)
3. **Backend service availability (blocking):** What Moqui services/endpoints exist for listing/getting ingestion events and (optionally) retrying processing? Provide service names + input/output fields.
4. **Permissions (blocking):** What permission IDs/roles govern:
   - viewing ingestion events,
   - viewing raw payload JSON,
   - retrying processing?
5. **Retry semantics (blocking):** If retry is supported, is it synchronous (immediate result) or asynchronous (job queued)? If async, what is the polling mechanism (jobId + status endpoint)?
6. **Linked artifacts (blocking):** How are journal entry links represented (single `journalEntryId`, multiple IDs, or query by `eventId`)? Is there an existing Journal Entry view screen to link to?
7. **Negative inventory policy display (blocking for completeness):** When processing fails due to ‚Äúnegative inventory prohibited unless explicitly allowed‚Äù, what exact failure code is returned and should the UI show any override indicator from the payload (e.g., `allowNegativeOverride`)?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Accounting: Ingest InventoryAdjustment Event  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/184  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Accounting: Ingest InventoryAdjustment Event

**Domain**: user

### Story Description

/kiro  
Handle inventory corrections with full auditability.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Actor
Accounting System

## Trigger
Receipt of `InventoryAdjusted` event from Workorder Execution

## Main Flow
1. Validate adjustment reason and quantities
2. Reverse or adjust prior inventory/COGS entries
3. Apply corrected inventory quantities
4. Record adjustment journal with reason code

## Business Rules
- Adjustments must reference original issue
- Negative inventory positions are prohibited unless explicitly allowed

## Acceptance Criteria
- [ ] Adjustments reconcile inventory correctly
- [ ] Prior postings are traceable and reversible

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## References
- Durion Accounting Event Contract v1

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299815/Durion_Accounting_Event_Contract_v1.pdf)

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #185: [FRONTEND] [STORY] Accounting: Ingest InventoryIssued Event  
File: ./scripts/story-work/frontend/185/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Accounting: Ingest InventoryIssued Event (Ops UI for Ingestion Status, Idempotency, and Posting Traceability)

### Primary Persona
Accounting Operations User (Accountant / Finance Ops) monitoring and troubleshooting automated accounting event ingestion.

### Business Value
Provide a front-end operational interface to observe, validate, and troubleshoot `InventoryIssued` event ingestion so accounting postings are traceable, idempotency is verifiable, and failures can be investigated without backend access.

---

## 2. Story Intent

### As a / I want / So that
**As an** Accounting Operations user,  
**I want** to view the ingestion status and resulting accounting postings (journal entry references) for `InventoryIssued` events, including duplicate detection and failures,  
**so that** I can confirm inventory valuation postings occurred exactly once, investigate rejects/DLQ cases, and support audit traceability.

### In-scope
- A Moqui screen set to:
  - Search/list ingested accounting events filtered to `eventType=InventoryIssued`
  - View event details (payload fields + metadata + payload hash if available)
  - View processing outcome: status, errors, idempotency result (new vs duplicate), linked journal entry reference(s)
  - View traceability links: workorderId, inventoryIssueId, inventoryItemId
- Basic operational actions **if supported by backend**:
  - ‚ÄúRetry processing‚Äù for failed events (no guarantee; gated by Open Questions)
  - ‚ÄúMark as reviewed/acknowledged‚Äù note for ops workflow (only if entity exists)

### Out-of-scope
- Implementing actual ingestion, valuation, GL posting logic (backend responsibility)
- Defining GL account mappings, valuation method configuration, or COGS/WIP rules
- Editing inventory quantities or journal entry lines from the UI

---

## 3. Actors & Stakeholders
- **Primary actor:** Accounting Operations User
- **Secondary stakeholders:** Auditor (read-only access), Inventory Manager (read-only traceability), Engineering On-call (troubleshooting)
- **System actors (referenced):** Workorder Execution (event source), Accounting backend services (ingestion + posting)

---

## 4. Preconditions & Dependencies
- Backend has an ingestion pipeline that persists `InventoryIssued` events and processing results (status/errors/idempotency outcome).
- Backend exposes services/endpoints to:
  - List ingested events with filters and pagination
  - Fetch event detail by eventId
  - Fetch linked posting artifact(s) (e.g., JournalEntry) by source eventId
- Permissions exist for viewing event ingestion data (exact permission names are unclear ‚Üí Open Questions).
- Event schema is ‚ÄúDurion Accounting Event Contract v1‚Äù (PDF referenced) but field-level canonical names beyond those listed are not fully specified here.

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main nav: **Accounting ‚Üí Event Ingestion ‚Üí Inventory Issued**
- Deep link:
  - `/apps/accounting/events/inventory-issued` (list)
  - `/apps/accounting/events/inventory-issued/<eventId>` (detail)

### Screens to create/modify
Create new screen flow under an accounting app:
- `screen://accounting/events/InventoryIssuedList.xml`
- `screen://accounting/events/InventoryIssuedDetail.xml`

(Exact package path may vary per repo conventions; implement consistent with existing `apps/` screen structure in the frontend repo.)

### Navigation context
- Breadcrumb: Accounting ‚Üí Event Ingestion ‚Üí InventoryIssued ‚Üí (Event Detail)
- From detail, allow navigation to linked Journal Entry detail screen if it exists in frontend; otherwise show journalEntryId as a copyable reference.

### User workflows

#### Happy path: verify successful processing
1. User opens InventoryIssued events list
2. Filters by date range and/or workorderId
3. Opens an event row
4. Sees ‚ÄúProcessed Successfully‚Äù with linked journalEntryId and traceability fields
5. Copies references for audit/support

#### Alternate path: duplicate event confirmation
1. User searches by eventId
2. Opens event detail
3. Sees ‚ÄúDuplicate (Idempotent)‚Äù outcome and the original processing reference (original journalEntryId)

#### Error path: rejected/DLQ investigation
1. User filters status = Failed/Rejected
2. Opens event detail
3. Sees validation error code/message and where it was routed (e.g., DLQ)
4. (If supported) user clicks ‚ÄúRetry processing‚Äù and sees updated status

---

## 6. Functional Behavior

### Triggers
- Screen load triggers read-only retrieval of event ingestion records.
- Optional user action triggers ‚Äúretry‚Äù command for a failed event (only if backend supports).

### UI actions
**InventoryIssuedList**
- Search filters:
  - eventId (exact match)
  - workorderId (exact match)
  - inventoryIssueId (exact match)
  - inventoryItemId (exact match)
  - occurredAt date/time range
  - processingStatus (multi-select)
  - idempotencyResult (New / Duplicate / Conflict if available)
- Pagination + sort (default sort: occurredAt desc)
- Row click navigates to detail

**InventoryIssuedDetail**
- Read-only sections:
  - Event metadata: eventId, eventType, schemaVersion, sourceModule, occurredAt, businessUnitId, currencyUomId
  - Domain payload highlights: inventoryItemId, quantityIssued, unitOfMeasure, workorderId, inventoryIssueId, issueTimestamp/eventTimestamp (naming depends on backend)
  - Processing result: status, processedAt, idempotency outcome, errorCode, errorMessage, retryCount (if available)
  - Posting links: journalEntryId(s), transactionDate, postingStatus (if available)
- Actions:
  - Copy eventId / workorderId / journalEntryId
  - Retry (only visible when status in Failed/Rejected AND user has permission AND backend supports)

### State changes (frontend)
- Frontend does not mutate accounting data except optional retry command.
- Local UI state:
  - Loading / success / error
  - Retry in-progress, then refresh detail on success

### Service interactions
- List: call a Moqui service to retrieve records
- Detail: call a Moqui service to retrieve one record + linked journal entry refs
- Retry: call a Moqui service that requests reprocessing (if available), then re-fetch detail

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- List filter inputs:
  - eventId must be UUID format if provided (client-side validation; still allow submit if uncertain? **Blocking question**‚Äîsee Open Questions; default is fail-fast with message)
  - quantityIssued displayed as decimal; if backend provides negative quantity in failed events, display as-is but highlight as invalid per schema expectations
- Retry action:
  - Only enabled for statuses indicating not successfully processed
  - Must require user confirmation modal: ‚ÄúRetry processing this event? This may create postings if not idempotent.‚Äù (wording safe, but must not imply non-idempotent behavior)

### Enable/disable rules
- ‚ÄúRetry processing‚Äù button:
  - Visible only if backend indicates `canRetry=true` OR status in (FAILED, REJECTED) **and** permission granted
  - Disabled while request in-flight
- Journal Entry link:
  - Enabled only if journalEntryId exists and user has permission to view journal entries (unclear ‚Üí Open Questions)

### Visibility rules
- Show ‚ÄúDuplicate‚Äù badge if idempotency result indicates duplicate
- Show ‚ÄúConflict‚Äù badge if backend flags duplicate eventId with differing payload (DLQ/quarantine scenario) (concept in backend story; UI should support if fields exist)

### Error messaging expectations
- Map backend error codes to user-facing messages:
  - If errorCode present, display: `errorCode` + `errorMessage`
  - If HTTP/service error, show generic ‚ÄúUnable to load event data‚Äù with correlation/request ID if provided by Moqui
- Do not display sensitive internals; show sanitized message.

---

## 8. Data Requirements

### Entities involved (frontend perspective; exact entity names TBD)
Because the provided inputs do not include actual Moqui entity definitions, the frontend must rely on services returning these fields.

Expected data objects:

1) **AccountingEventIngestionRecord** (name TBD)
- `eventId` (string/UUID, required, read-only)
- `eventType` (string, required, read-only; must equal `InventoryIssued` in this screen set)
- `schemaVersion` (string, required)
- `sourceModule` (string, required)
- `sourceEntityRef` (string, optional)
- `occurredAt` (datetime, required)
- `businessUnitId` (string, required)
- `currencyUomId` (string, required)
- `payload` (object or JSON string, required; read-only)
- `payloadHash` (string, optional but desired for audit)
- `processingStatus` (enum string, required)
- `idempotencyResult` (enum string, optional; e.g., NEW, DUPLICATE, CONFLICT)
- `processedAt` (datetime, optional)
- `errorCode` (string, optional)
- `errorMessage` (string, optional)
- `dlqRouted` (boolean, optional)
- `retryCount` (integer, optional)

2) **Derived payload highlights** (may be extracted server-side or client-side)
From payload, display:
- `inventoryItemId` (string, required)
- `quantityIssued` (decimal, required; expected positive)
- `unitOfMeasure` (string, required)
- `workorderId` (string, required)
- `inventoryIssueId` (string, required)
- `eventTimestamp` or `issueTimestamp` (datetime, required/optional depending on contract)

3) **JournalEntryReference** (optional)
- `journalEntryId` (string, optional)
- `postingStatus` (string, optional)
- `transactionDate` (date, optional)
- `totalDebit` / `totalCredit` (money, optional read-only)
- `linkable` (boolean optional)

### Read-only vs editable by state/role
- All fields are read-only.
- Only command is ‚ÄúRetry processing‚Äù (no direct edits).

### Derived/calculated fields
- `valuationAmount` is mentioned in original inputs; if backend returns it, display as read-only.
- Display `quantityIssued √ó unitCost = totalValue` only if backend returns both unitCost and computed total; do not compute financial amounts client-side unless explicitly provided (accounting strictness).

---

## 9. Service Contracts (Frontend Perspective)

> Names are placeholders; implement as Moqui services invoked by screen actions. Exact service names/endpoints are **Open Questions**.

### Load/view calls
1) **List InventoryIssued events**
- Service: `accounting.event.IngestedEventList` (placeholder)
- Inputs:
  - `eventType = "InventoryIssued"` (fixed)
  - `eventId?`, `workorderId?`, `inventoryIssueId?`, `inventoryItemId?`
  - `occurredAt_from?`, `occurredAt_thru?`
  - `processingStatus?[]`, `idempotencyResult?[]`
  - `pageIndex`, `pageSize`, `orderByField`, `orderByDirection`
- Outputs:
  - `events[]` with summary fields (eventId, occurredAt, status, idempotencyResult, workorderId, inventoryItemId)
  - `totalCount`

2) **Get InventoryIssued event detail**
- Service: `accounting.event.IngestedEventDetail` (placeholder)
- Inputs: `eventId` (required)
- Outputs:
  - `event` object with metadata + payload + processing fields
  - `journalEntries[]` references (optional)

### Submit/transition calls
3) **Retry processing a failed event**
- Service: `accounting.event.RetryIngestedEvent` (placeholder)
- Inputs: `eventId` (required), `reasonNote?` (optional)
- Outputs: updated `processingStatus`, `processedAt`, and any new `journalEntryId`

### Error handling expectations
- Validation errors from services should return structured error codes where possible.
- UI must handle:
  - 401/403: show ‚ÄúNot authorized‚Äù and hide restricted actions
  - 404: show ‚ÄúEvent not found‚Äù
  - 409: show conflict if duplicate conflict/quarantine
  - 5xx: show generic error; allow retry reload

---

## 10. State Model & Transitions

### Allowed states (processingStatus) ‚Äî MUST be confirmed by backend
UI should support at minimum (display-only):
- `RECEIVED`
- `VALIDATED`
- `PROCESSED_SUCCESS`
- `PROCESSED_DUPLICATE` (or via idempotencyResult)
- `FAILED_SCHEMA_VALIDATION`
- `FAILED_UNKNOWN_ITEM`
- `FAILED_POSTING`
- `DLQ` / `QUARANTINED`

### Role-based transitions
- Only ‚ÄúRetry‚Äù transition is user-initiated:
  - Allowed from failure/DLQ states only
  - Requires explicit permission (Open Question)

### UI behavior per state
- Success: green status, show journalEntry link/ref
- Duplicate: show ‚ÄúDuplicate‚Äù badge, show reference to original journalEntry if provided
- Failed: show red status, show errorCode/errorMessage, show ‚ÄúRetry‚Äù if allowed
- Quarantined/Conflict: show warning, display conflict details if provided; no retry unless backend allows

---

## 11. Alternate / Error Flows

### Validation failures (client-side)
- Invalid UUID in eventId filter:
  - Show inline error and disable ‚ÄúSearch‚Äù **(needs confirmation)** OR allow search and rely on backend validation (Open Question)

### Concurrency conflicts
- If user retries while another process already retried:
  - Backend may return 409/conflict; UI shows conflict message and refreshes detail

### Unauthorized access
- User lacking permission:
  - List: either hide menu entry or show 403 screen
  - Detail: show 403 if direct-linked
  - Retry action hidden/disabled

### Empty states
- No events found: show empty state with guidance ‚ÄúAdjust filters or widen date range.‚Äù

---

## 12. Acceptance Criteria

### Scenario 1: View InventoryIssued events list
**Given** I have permission to view accounting event ingestion records  
**When** I open the InventoryIssued events list screen  
**Then** I see a paginated list of events filtered to `eventType = InventoryIssued`  
**And** each row shows at least `eventId`, `occurredAt`, `processingStatus`, and `workorderId` (if present)

### Scenario 2: Filter by workorderId
**Given** there are InventoryIssued events for `workorderId = "WO-12345"`  
**When** I filter the list by `workorderId = "WO-12345"`  
**Then** only events with that `workorderId` are returned  
**And** the totalCount reflects the filtered result set

### Scenario 3: View event detail with successful processing
**Given** an InventoryIssued event exists with `eventId = "uuid-abc-123"`  
**And** its processingStatus indicates success  
**When** I open the event detail screen for `eventId = "uuid-abc-123"`  
**Then** I see the event metadata (eventId, eventType, schemaVersion, sourceModule, occurredAt)  
**And** I see payload highlights including `inventoryItemId`, `quantityIssued`, and `workorderId`  
**And** I see at least one linked posting reference (e.g., `journalEntryId`) if provided by backend

### Scenario 4: View duplicate/idempotent outcome
**Given** an InventoryIssued event exists whose idempotencyResult indicates it is a duplicate  
**When** I open the event detail  
**Then** I see a ‚ÄúDuplicate‚Äù indicator  
**And** I see the original processing reference (original journalEntryId) if the backend provides it  
**And** no UI action implies a second posting occurred

### Scenario 5: View failed event and error details
**Given** an InventoryIssued event exists with processingStatus indicating failure  
**When** I open the event detail  
**Then** I see `errorCode` and `errorMessage` (if provided)  
**And** I see whether it was routed to DLQ/quarantine (if provided)

### Scenario 6: Retry is gated and refreshes status (if supported)
**Given** an InventoryIssued event exists with processingStatus = FAILED (or DLQ)  
**And** I have permission to retry processing  
**When** I click ‚ÄúRetry processing‚Äù and confirm  
**Then** the UI calls the retry service with the `eventId`  
**And** on success the UI refreshes the event detail  
**And** the updated processingStatus is displayed

### Scenario 7: Unauthorized user cannot retry
**Given** I can view event detail but do not have permission to retry processing  
**When** I open a failed event detail  
**Then** I do not see the ‚ÄúRetry processing‚Äù action (or it is disabled with an authorization message)

### Scenario 8: Backend/service error handling
**Given** the backend list service is unavailable (5xx)  
**When** I load the InventoryIssued events list  
**Then** I see a non-technical error message indicating the list could not be loaded  
**And** I can retry loading without a full app refresh

---

## 13. Audit & Observability

### User-visible audit data
- Display (read-only) audit fields if provided:
  - processedAt, retryCount, lastErrorAt
  - payloadHash (if available) for forensic comparison

### Status history
- If backend provides status history entries (timestamp + status + message), show them in chronological order on detail screen.
- If not available, show current status only (Open Question).

### Traceability expectations
- Event detail must show the chain:
  - `eventId` ‚Üí workorderId/inventoryIssueId/inventoryItemId ‚Üí journalEntryId (if created)
- All identifiers should be copyable and included in screen logs (Moqui logs) for support correlation (without printing full payload in logs by default).

---

## 14. Non-Functional UI Requirements
- **Performance:** list page should load first page within 2 seconds for typical dataset sizes (assumes backend paging).
- **Accessibility:** all actions keyboard accessible; status indicators include text (not color-only).
- **Responsiveness:** usable on tablet widths; list table supports horizontal scroll if needed.
- **i18n/timezone:** display occurredAt/processedAt in user locale timezone; store/transport in ISO8601 UTC from backend.
- **Currency:** display currencyUomId as code; do not format monetary amounts unless backend provides currency + amount explicitly.

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide a standard empty-state message and ‚ÄúClear filters‚Äù action; safe because it does not affect domain policy. (Impacted: UX Summary, Alternate/Error Flows)
- SD-UX-PAGINATION: Default page size = 25 with server-side pagination; safe as a UI ergonomics choice only. (Impacted: UX Summary, Service Contracts)
- SD-ERR-GENERIC: Use a generic load error banner with retry for 5xx/network errors; safe because it doesn‚Äôt change business behavior. (Impacted: Error Flows, Acceptance Criteria)

---

## 16. Open Questions
1. **Backend service/API contracts:** What are the exact Moqui services (names, input params, output fields) for listing ingested events, retrieving event details, and retrying processing (if allowed)?
2. **Entity/source of truth for ingestion records:** What Moqui entity (or view-entity) stores ingested accounting events and processing outcomes (status, errorCode, idempotencyResult, payload/payloadHash)?
3. **Processing status taxonomy:** What are the canonical values for `processingStatus` and `idempotencyResult` that the UI must support?
4. **Retry semantics & permissions:** Is a manual retry permitted from the UI? If yes, what permission name(s) gate it, and what states are eligible for retry?
5. **Journal entry linking:** How is the resulting posting represented and linked (single `journalEntryId`, multiple, or reference object)? Is there an existing frontend screen to view journal entries by ID?
6. **Payload field names:** In the canonical contract v1, is the timestamp field `eventTimestamp`, `issueTimestamp`, or `occurredAt` (and which should be displayed as the business timestamp)?
7. **Client-side UUID validation behavior:** Should the UI block searches with a non-UUID `eventId`, or allow submission and rely on backend validation?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Accounting: Ingest InventoryIssued Event  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/185  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Accounting: Ingest InventoryIssued Event

**Domain**: user

### Story Description

/kiro  
Focus on inventory valuation, COGS timing, and idempotent posting.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Actor
Accounting System

## Trigger
Receipt of `InventoryIssued` event from Workorder Execution

## Main Flow
1. Receive inventory issue event with part, quantity, and workorder reference
2. Validate event schema and idempotency key
3. Determine valuation method (configured, e.g., FIFO/average)
4. Reduce on-hand inventory quantity
5. Record corresponding COGS or WIP entry based on configuration
6. Persist posting references and source links

## Alternate / Error Flows
- Duplicate event ‚Üí ignore (idempotent)
- Invalid inventory reference ‚Üí reject and flag
- Posting failure ‚Üí retry or dead-letter

## Business Rules
- Inventory may only be reduced once per issued quantity
- Valuation method is configuration-driven
- Posting must be traceable to source workorder and part issue

## Data Requirements
- Entities: InventoryItem, InventoryTransaction, WorkorderRef
- Fields: quantity, valuationAmount, issueTimestamp

## Acceptance Criteria
- [ ] Inventory quantity is reduced correctly
- [ ] COGS/WIP is recorded per configuration
- [ ] Event is idempotent
- [ ] Posting references original workorder

## Classification (confirm labels)
- Type: Story
- Layer: Functional
- Domain: Accounting

## References
- Durion Accounting Event Contract v1

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299815/Durion_Accounting_Event_Contract_v1.pdf)

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #186: [FRONTEND] [STORY] Controls: Route Unmapped or Failed Events to Suspense Queue and Reprocess  
File: ./scripts/story-work/frontend/186/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Accounting Controls: Suspense Queue for Unmapped/Failed Events + Reprocess (Idempotent)

### Primary Persona
Accounting Admin (accountant with controls responsibility) / System Administrator

### Business Value
Ensures financial completeness and integrity by making posting/mapping failures visible, actionable, and safely reprocessable without duplicate postings, with full audit traceability.

---

## 2. Story Intent

### As a / I want / So that
**As an** Accounting Admin or System Administrator,  
**I want** a Suspense Queue UI to view unmapped/failed accounting events, see actionable failure details, and trigger reprocessing,  
**so that** posting failures can be resolved and re-run safely and idempotently with complete attempt history and posting traceability.

### In-scope
- A Moqui screen flow to:
  - List suspense entries with filtering/sorting
  - View suspense entry details (including immutable original event payload/reference and failure metadata)
  - Trigger reprocess for a single entry
  - View reprocess attempt history and final posting reference (if processed)
- UI behavior for idempotent reprocess conflicts (e.g., 409) and authorization failures (403)
- Display of status lifecycle (`SUSPENDED`, `PROCESSED`, optionally `FAILED`) as provided by backend

### Out-of-scope
- Editing/correcting mapping/rules in the UI (the backend story states corrections are ‚Äúexternally correctable‚Äù)
- Building/operating the ingestion pipeline, event broker consumer, or posting engine
- Purge/retention job UI or configuration
- Defining GL accounts, posting rule sets, or tax policies

---

## 3. Actors & Stakeholders
- **Accounting Admin (Accountant):** primary user; investigates failures, confirms resolution, triggers reprocess.
- **System Administrator:** triggers reprocess and investigates technical symptoms; may have broader access.
- **Auditor/Compliance reviewer:** reads history for traceability (view-only).
- **Accounting Posting Pipeline (backend):** source of suspense entries, idempotency and posting reference.

---

## 4. Preconditions & Dependencies
- User is authenticated in the Moqui/Quasar frontend.
- Backend provides APIs to:
  - List suspense entries
  - Retrieve suspense entry details including immutable original payload/ref
  - List attempt history for an entry
  - Trigger reprocess for an entry with idempotency guarantees
- Backend returns structured error responses and HTTP status codes (at minimum: 403, 409, 422/400, 500).
- Authorization permissions exist for viewing and reprocessing (exact permission strings not provided for frontend‚Äîsee Open Questions).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Admin navigation: **Accounting ‚Üí Controls ‚Üí Suspense Queue**
- Deep link: `/accounting/controls/suspense` (list) and `/accounting/controls/suspense/{suspenseEntryId}` (detail)

### Screens to create/modify
1. **Screen:** `Accounting/Controls/SuspenseQueue.xml` (list)
2. **Screen:** `Accounting/Controls/SuspenseEntryDetail.xml` (detail + actions)
3. **Reusable section/widget (optional):** `components/AttemptHistory.xml` (renders attempt list)

### Navigation context
- Breadcrumb: Accounting / Controls / Suspense Queue / {Entry}
- From list row ‚Üí detail screen
- From detail ‚Üí back to list retaining query parameters (filters/sort/page)

### User workflows
#### Happy path: investigate and reprocess successfully
1. User opens Suspense Queue list
2. Filters to `status=SUSPENDED`
3. Opens an entry
4. Reviews failure reason/details and original event payload/ref
5. Clicks **Reprocess**
6. UI shows attempt started and then success; status becomes `PROCESSED`
7. UI displays `final_posting_reference_id` and new attempt history record

#### Alternate path: reprocess fails again
- Reprocess returns failure; UI remains `SUSPENDED` (or `FAILED` if backend applies policy) and shows updated latest failure details + new attempt record.

#### Alternate path: reprocess an already processed entry
- Backend returns `409 Conflict`; UI shows ‚ÄúAlready processed‚Äù and does not duplicate anything; attempt history must **not** be incremented client-side (only reflect server truth after refresh).

---

## 6. Functional Behavior

### Triggers
- Screen load (list/detail)
- User selects filters/sorting/pagination
- User clicks **Reprocess** on detail screen

### UI actions
**List Screen**
- Render table/grid of suspense entries
- Controls:
  - Filter by `status` (default SUSPENDED)
  - Filter by `failure_reason_code`
  - Search by `event_type` and/or `final_posting_reference_id` and/or `suspense_entry_id`
  - Date range filter: `created_at` (optional but safe for UI ergonomics)
- Row action: ‚ÄúView‚Äù

**Detail Screen**
- Display read-only fields for the suspense entry (see Data Requirements)
- Show immutable original event payload/ref in a read-only viewer
- Show attempt history list (most recent first)
- Primary action: **Reprocess**
  - Enabled only when status is `SUSPENDED` (and optionally `FAILED` if backend permits; see Open Questions)
  - Confirmation modal: explains idempotency, that current rules will be used, and that an attempt will be logged

### State changes (frontend-observed)
- After successful reprocess: status changes to `PROCESSED`, `processed_at` populated, `final_posting_reference_id` populated, attempt history appended (server-side)
- After failed reprocess: status remains `SUSPENDED` (or becomes `FAILED`), `failure_details` may change, attempt_count increments

### Service interactions
- List: load suspense entries with query params
- Detail: load entry + attempt history (either separate calls or one composite)
- Reprocess: POST action; then refresh detail + history from server to ensure canonical truth

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- Reprocess requires a valid `suspense_entry_id` in route params; if missing/invalid ‚Üí show ‚ÄúNot found‚Äù and do not call backend.
- Reprocess action is blocked client-side when status is terminal (`PROCESSED`) to reduce erroneous calls; still must handle server 409 (source of truth).

### Enable/disable rules
- **Reprocess button enabled** when:
  - user has reprocess permission (if permission info available in session context; otherwise rely on backend 403)
  - entry status == `SUSPENDED` (and optionally `FAILED` if permitted)
- **Reprocess button disabled** when:
  - entry status == `PROCESSED`
  - a reprocess request is currently in-flight (prevent double-submit)

### Visibility rules
- Show `failure_reason_code` and `failure_details` prominently in detail.
- Show `final_posting_reference_id` only when present; otherwise show ‚ÄúNot yet processed‚Äù.
- Attempt history section visible even if empty (show ‚ÄúNo attempts yet‚Äù).

### Error messaging expectations
Map backend outcomes to user-visible messages:
- `403`: ‚ÄúYou are not authorized to reprocess suspense entries.‚Äù
- `404`: ‚ÄúSuspense entry not found or no longer available.‚Äù
- `409`: ‚ÄúThis entry is already processed; reprocess is blocked to prevent duplicate postings.‚Äù
- `422/400`: ‚ÄúCannot reprocess due to validation error: <backend message>‚Äù
- `500/503`: ‚ÄúReprocess failed due to system error; try again later.‚Äù

---

## 8. Data Requirements

### Entities involved (frontend read models)
(Backend-owned; frontend consumes via services)
- **SuspenseEntry**
- **ReprocessingAttemptHistory** (attempt records)

### Fields

#### SuspenseEntry (read-only in UI)
- `suspense_entry_id` (UUID, required, displayed)
- `status` (enum: `SUSPENDED`, `PROCESSED`, optionally `FAILED`; required)
- `event_type` (string, required)
- `failure_reason_code` (string/enum, required when SUSPENDED/FAILED)
- `failure_details` (string, optional but expected; display as multiline)
- `mapping_version_attempted` (string, nullable)
- `attempt_count` (int, required)
- `created_at` (datetime, required)
- `updated_at` (datetime, required)
- `processed_at` (datetime, nullable)
- `resolved_by_user_id` (string/UUID, nullable; display if provided)
- `final_posting_reference_id` (string, nullable)
- `original_event_payload` (JSON/text) **OR** `original_event_ref` (string) (one required)
  - UI must support either shape:
    - If payload is provided: display in JSON viewer
    - If ref is provided: display as immutable reference identifier

#### ReprocessingAttemptHistory (read-only list)
- `attempt_id` (string/UUID, required)
- `suspense_entry_id` (UUID, required)
- `attempted_at` (datetime, required)
- `triggered_by_user_id` (string/UUID, required)
- `outcome` (`SUCCESS` | `FAILURE`, required)
- `outcome_details` (string, nullable)

### Read-only vs editable by state/role
- All fields are read-only; the only mutation is the **Reprocess** command.

### Derived/calculated fields (UI-only)
- `statusBadge` derived from `status`
- `canReprocess` derived from `status` + permission + in-flight flag

---

## 9. Service Contracts (Frontend Perspective)

> Note: Exact endpoint names are not provided in inputs. The frontend must integrate with Moqui services; final naming depends on backend API. Below are required capabilities and suggested Moqui service names as placeholders.

### Load/view calls
1. **List suspense entries**
   - Capability: search/filter/paginate suspense entries
   - Suggested Moqui service: `accounting.suspense.SuspenseEntryFind`
   - Inputs (query params / service in-params):
     - `status` (optional; default `SUSPENDED`)
     - `failureReasonCode` (optional)
     - `eventType` (optional)
     - `createdFrom` / `createdThru` (optional)
     - `pageIndex`, `pageSize`, `orderByField` (optional)
   - Output:
     - `entries[]` (with key list fields)
     - `totalCount`

2. **Get suspense entry detail**
   - Suggested service: `accounting.suspense.SuspenseEntryGet`
   - Input: `suspenseEntryId`
   - Output: SuspenseEntry full record

3. **Get attempt history**
   - Suggested service: `accounting.suspense.SuspenseAttemptFindByEntry`
   - Input: `suspenseEntryId`
   - Output: `attempts[]`

### Submit/transition calls
4. **Trigger reprocess**
   - Suggested service: `accounting.suspense.SuspenseEntryReprocess`
   - Input:
     - `suspenseEntryId` (required)
     - (optional) `force` (NOT allowed as safe default; must be explicit if exists‚Äîdo not implement unless backend defines)
   - Output:
     - Return updated SuspenseEntry OR just success indicator; frontend must refresh afterward.

### Error handling expectations
- Backend uses HTTP status semantics as described in backend story:
  - 409 conflict for terminal reprocess
  - 403 forbidden for unauthorized
- Frontend must:
  - Display error banner/toast
  - Preserve user context (stay on page)
  - Offer retry where appropriate (non-409)

---

## 10. State Model & Transitions

### Allowed states (from backend story)
- `SUSPENDED` (actionable)
- `PROCESSED` (terminal)
- `FAILED` (optional terminal or semi-terminal per policy; not fully specified)

### Role-based transitions (frontend enforcement)
- Users with reprocess permission may request:
  - `SUSPENDED` ‚Üí (reprocess) ‚Üí `PROCESSED` on success
  - `SUSPENDED` ‚Üí (reprocess) ‚Üí `SUSPENDED` (or `FAILED`) on failure
- `PROCESSED` ‚Üí (reprocess) is **disallowed**; expect `409 Conflict`

### UI behavior per state
- `SUSPENDED`:
  - show failure info
  - Reprocess enabled
- `PROCESSED`:
  - show final posting reference and processed timestamp
  - Reprocess disabled; show info note about idempotency protection
- `FAILED` (if present):
  - show failure info
  - Reprocess behavior requires clarification (see Open Questions)

---

## 11. Alternate / Error Flows

### Validation failures
- Missing/invalid `suspenseEntryId` in route:
  - show 404-style not found state; do not show Reprocess
- Backend returns 400/422 on reprocess:
  - show message from backend; keep status as last loaded; offer retry

### Concurrency conflicts
- If two admins attempt reprocess simultaneously:
  - One succeeds ‚Üí entry becomes `PROCESSED`
  - Other receives 409 or sees updated status on refresh
  - Frontend must refresh detail after any reprocess attempt completion and handle 409 gracefully

### Unauthorized access
- If user can view list but cannot reprocess:
  - Reprocess button hidden or disabled (if permission known)
  - If not known, backend 403 triggers error banner and button remains disabled until refresh

### Empty states
- List returns no entries:
  - show ‚ÄúNo suspense entries found for current filters.‚Äù
- Attempt history empty:
  - show ‚ÄúNo attempts yet.‚Äù

---

## 12. Acceptance Criteria

### Scenario 1: View Suspense Queue list filtered to suspended
**Given** I am an authenticated user with access to Accounting Controls  
**When** I open the Suspense Queue screen  
**Then** I see a list of suspense entries filtered to `status = SUSPENDED` by default  
**And** each row shows `suspense_entry_id`, `event_type`, `failure_reason_code`, `attempt_count`, and `created_at`.

### Scenario 2: View suspense entry details including immutable original payload/ref
**Given** a suspense entry exists with status `SUSPENDED`  
**When** I open the entry detail screen  
**Then** I can view `failure_reason_code` and `failure_details`  
**And** I can view the immutable `original_event_payload` as read-only JSON **or** `original_event_ref` as read-only reference  
**And** I can view the reprocess attempt history for that entry.

### Scenario 3: Successful reprocess updates status and retains posting reference
**Given** a suspense entry is `SUSPENDED` and backend rules/mappings have been corrected externally  
**When** I click Reprocess and confirm  
**Then** the system triggers reprocessing  
**And** after completion the entry status is `PROCESSED`  
**And** `final_posting_reference_id` is displayed  
**And** a new attempt history record exists with outcome `SUCCESS` and my user as actor.

### Scenario 4: Reprocess failure retains suspense status and logs attempt
**Given** a suspense entry is `SUSPENDED`  
**When** I click Reprocess and backend returns a failure outcome  
**Then** the entry remains `SUSPENDED` (or is `FAILED` if backend applies such policy)  
**And** I see an error message describing the failure  
**And** attempt_count increases compared to before  
**And** attempt history includes a new record with outcome `FAILURE`.

### Scenario 5: Idempotency protection prevents reprocessing processed entry
**Given** a suspense entry is `PROCESSED`  
**When** I attempt to reprocess it (via UI or direct call)  
**Then** the UI prevents the action or the backend responds with `409 Conflict`  
**And** no duplicate posting is created  
**And** the UI shows a message that the entry is already processed.

### Scenario 6: Unauthorized user cannot reprocess
**Given** I do not have permission to reprocess suspense entries  
**When** I click Reprocess  
**Then** the backend responds with `403 Forbidden`  
**And** the UI shows an authorization error  
**And** the entry remains unchanged.

---

## 13. Audit & Observability

### User-visible audit data
- Display attempt history (who/when/outcome/details)
- Display `processed_at` and `resolved_by_user_id` (if provided)
- Display `final_posting_reference_id` for traceability

### Status history
- Attempt history acts as operational history; if backend exposes status-change audit events, show them (not required by inputs)

### Traceability expectations
- UI must preserve and display identifiers:
  - `suspense_entry_id`
  - `final_posting_reference_id`
  - (if present) event identifiers within `original_event_payload` (e.g., `eventId`, `eventType`, `schemaVersion`) as read-only

---

## 14. Non-Functional UI Requirements
- **Performance:** List loads must support pagination to avoid rendering extremely large datasets.
- **Accessibility:** All actions accessible via keyboard; confirmation dialog must trap focus; status conveyed with text (not color alone).
- **Responsiveness:** Works on standard desktop widths; list supports horizontal scroll for wide IDs/payload refs.
- **i18n/timezone:** Display datetimes in user‚Äôs locale/timezone as configured by Moqui; do not assume currency formatting (this UI is mostly identifiers and timestamps).

---

## 15. Applied Safe Defaults
- SD-UI-EMPTY-STATE: Provide explicit empty-state messaging for list and history; safe because it changes only presentation, not domain logic. Impacted sections: UX Summary, Alternate/waswo Error Flows.
- SD-UI-PAGINATION: Paginate list results with configurable page size; safe because it‚Äôs UI ergonomics and does not alter backend behavior. Impacted sections: UX Summary, Service Contracts, Non-Functional.
- SD-UI-DOUBLE-SUBMIT-GUARD: Disable Reprocess while request is in-flight; safe because it prevents accidental duplicate user actions without changing backend idempotency semantics. Impacted sections: Business Rules, Alternate/Error Flows.

---

## 16. Open Questions
1. What are the exact backend endpoints or Moqui service names/paths for:
   - suspense entry list, detail, attempt history, and reprocess?
2. What permission(s)/scope(s) should the frontend check to:
   - view suspense queue
   - reprocess entries
   (If not available client-side, should we hide/disable actions purely based on backend 403?)
3. Is `FAILED` a real status exposed to the UI? If yes:
   - Is reprocess allowed from `FAILED`, or is it terminal like `PROCESSED`?
4. For `original_event_payload`:
   - Will backend always return JSON (structured) or sometimes a string blob?
   - Are there size limits requiring truncation/download behavior?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Controls: Route Unmapped or Failed Events to Suspense Queue and Reprocess  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/186  
Labels: frontend, story-implementation, admin

## Frontend Implementation for Story

**Original Story**: [STORY] Controls: Route Unmapped or Failed Events to Suspense Queue and Reprocess

**Domain**: admin

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Reconciliation, Audit, and Controls

## Story
Controls: Route Unmapped or Failed Events to Suspense Queue and Reprocess

## Acceptance Criteria
- [ ] Unmapped/failed events go to Suspense with actionable missing-key details
- [ ] Admin can correct mapping/rules and reprocess
- [ ] Reprocess is idempotent (no duplicate postings)
- [ ] Attempt history and final posting references are retained


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #187: [FRONTEND] [STORY] Reconciliation: Support Bank/Cash Reconciliation Matching  
File: ./scripts/story-work/frontend/187/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Reconciliation: Bank/Cash Reconciliation Matching (Import/Enter Statement Lines, Match, Adjust, Finalize & Report)

### Primary Persona
Accountant (or Finance Manager acting as accountant)

### Business Value
Ensure cash/bank balances are accurate and auditable by matching bank statement activity to recorded POS payments/receipts, recording controlled adjustments (fees/interest) with correct accounting traceability, and producing a finalized reconciliation report.

---

## 2. Story Intent

### As a / I want / So that
**As an** Accountant,  
**I want** a reconciliation workspace to import or manually enter bank/cash statement lines and match them to system-recorded payments/receipts (or create controlled adjustments),  
**so that** I can reconcile a bank/cash account for a period with a complete audit trail and produce a finalized reconciliation report.

### In-scope
- Create a reconciliation for a selected bank/cash account and date range.
- Import statement lines (file upload) and/or manually enter statement lines.
- View unreconciled system transactions and match/unmatch to statement lines (manual; suggestions optional but not required unless backend provides).
- Create controlled adjustments (fees/interest) that generate proper accounting entries (frontend flow + validations + submission).
- Track matched/unmatched counts and reconciliation difference and prevent finalization if non-zero.
- Finalize reconciliation (immutability/read-only behavior).
- Generate/download a reconciliation report (or navigate to report screen) after finalization.
- Full audit visibility (who/when) for reconciliation actions.

### Out-of-scope
- Defining GL account mappings, posting rules, or journal entry debit/credit structure (owned by accounting backend configuration).
- Automated matching tolerance rules or auto-match heuristics unless explicitly provided by backend.
- Re-opening finalized reconciliations (explicitly disallowed by provided reference).
- Multi-currency reconciliation behavior (unless backend contract explicitly supports it).
- Bank connectivity / live bank feeds.

---

## 3. Actors & Stakeholders
- **Accountant (Primary):** Performs reconciliation, matching, adjustments, finalization, report.
- **Auditor (Secondary):** Reviews finalized reconciliation and audit trail.
- **Finance Admin (Secondary):** Ensures bank accounts and GL accounts exist (configuration outside this story‚Äôs UI unless already present in app).
- **Payment/Receipt Domain (Data Provider):** Supplies reconcilable transactions for matching (read-only from frontend perspective).

---

## 4. Preconditions & Dependencies

### Preconditions
- User is authenticated.
- User has permission to access reconciliation features and to create adjustments and finalize reconciliations (exact permission IDs are currently unspecified; see Open Questions).
- At least one bank/cash account exists and is selectable.
- Backend supports persistence and retrieval of reconciliations, statement lines, matches, adjustments, and report generation.

### Dependencies (blocking where unknown)
- **Backend API contracts** for:
  - Creating/loading reconciliations, listing statement lines, listing reconcilable system transactions.
  - Performing match/unmatch operations.
  - Creating adjustments (fees/interest) and resulting journal entry creation/posting behavior.
  - Finalization rules and report generation/download.
- **Supported import formats** and parsing rules (CSV/OFX/etc.).
- **GL account selection source** for adjustments (list/search endpoint).
- **Audit event visibility** (what endpoint returns history).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main navigation: **Accounting ‚Üí Reconciliation ‚Üí Bank/Cash Reconciliation**
- Deep link (if supported): `/accounting/reconciliation` (list) and `/accounting/reconciliation/{reconciliationId}` (detail workspace)

### Screens to create/modify (Moqui)
1. **`Accounting/Reconciliation/ReconciliationList.xml`** (new)
   - List prior reconciliations with filters (account, date range, status).
   - Action: ‚ÄúStart Reconciliation‚Äù.

2. **`Accounting/Reconciliation/ReconciliationCreate.xml`** (new)
   - Form: select bankAccountId, periodStartDate, periodEndDate (and optionally statementClosingBalance if required by backend).
   - Create action transitions to detail workspace.

3. **`Accounting/Reconciliation/ReconciliationDetail.xml`** (new)
   - Workspace with:
     - Reconciliation header (account, period, opening/closing balance fields as read-only unless backend allows edits).
     - Tabs/sections:
       - Statement Lines (import/enter, matched/unmatched, select line)
       - System Transactions (unreconciled payments/receipts, select txn)
       - Matches (view/remove)
       - Adjustments (create/view)
       - Audit Trail (view events)
     - Primary actions: Import Statement, Add Statement Line, Match, Unmatch, Create Adjustment, Finalize, Download Report (enabled by state).

4. **`Accounting/Reconciliation/ReconciliationReport.xml`** (optional new)
   - If report is rendered as a screen; otherwise ‚ÄúDownload‚Äù triggers file response.

### Navigation context
- Breadcrumb: Accounting > Reconciliation > {Bank Account Name} > {Period}
- Back to list from detail.

### User workflows
- **Happy path**
  1. Create reconciliation (Draft).
  2. Import statement lines (or manually enter).
  3. Load unreconciled system transactions.
  4. Select statement line + transaction(s) ‚Üí Match.
  5. For lines without system transactions ‚Üí Create Adjustment ‚Üí line becomes matched.
  6. Difference becomes zero ‚Üí Finalize.
  7. Download/view report.

- **Alternate paths**
  - Manual entry only (no import).
  - Many-to-one match (multiple system txns match one statement line) if backend allows.
  - One-to-many match (one system txn matched to multiple statement lines) **likely disallowed**; must be explicit (Open Question).
  - Unable to finalize due to non-zero difference; user continues matching/adjusting.

---

## 6. Functional Behavior

### Triggers
- User starts reconciliation from list.
- User imports statement file or adds statement line manually.
- User matches/unmatches.
- User creates adjustment.
- User finalizes reconciliation.
- User requests report.

### UI actions & expected system behavior

#### 6.1 Create reconciliation
- UI submits create form.
- On success, navigate to reconciliation detail workspace in **Draft**.

#### 6.2 Import statement lines
- User selects file and submits.
- UI shows import progress and results summary (imported count, failed count, failure reasons).
- Imported lines appear in Statement Lines list with status **Unmatched** by default.

#### 6.3 Manually enter statement line
- User opens ‚ÄúAdd Statement Line‚Äù modal/form.
- Required fields validated client-side (date, amount, debit/credit or signed amount, description).
- On save, line appears in Statement Lines list as **Unmatched**.

#### 6.4 Load unreconciled system transactions
- UI loads a list filtered by:
  - bankAccountId (or payment account mapping)
  - periodStartDate..periodEndDate
  - unreconciled only
- Transactions display key match fields: date, amount, reference, counterparty/payer/payee if available, transactionId.

#### 6.5 Match / unmatch
- **Match** action enabled when:
  - reconciliation is Draft
  - at least 1 statement line selected and at least 1 system transaction selected (cardinality rules TBD by backend; see Open Questions)
- UI submits match command; on success:
  - statement line(s) status becomes Matched
  - system transaction(s) marked ‚Äúmatched/cleared‚Äù within this reconciliation (and excluded from ‚Äúunreconciled‚Äù list)
  - reconciliation difference recalculated/displayed

- **Unmatch** action enabled when:
  - reconciliation is Draft
  - a selected statement line or match record is currently matched
- UI submits unmatch command; on success, items return to Unmatched/unreconciled pools and difference updates.

#### 6.6 Create adjustment (fee/interest)
- From a statement line (typically unmatched), user chooses ‚ÄúCreate Adjustment‚Äù.
- UI presents adjustment form:
  - adjustmentType (e.g., Bank Fee, Interest Earned) (source TBD)
  - glAccountId (required)
  - amount (required; default to statement line amount)
  - description (required or optional per backend)
  - linkToStatementLineId (pre-filled)
- On submit:
  - backend creates adjustment and journal entry reference
  - statement line becomes Matched (per provided backend reference)
  - adjustment appears in Adjustments list with journalEntryId link (if provided)

#### 6.7 Finalize
- Finalize action enabled only when:
  - reconciliation is Draft
  - reconciliation difference == 0.00 (as computed by backend; UI should display backend-provided ‚Äúdifference‚Äù)
- On finalize success:
  - status becomes Finalized
  - all mutation actions disabled (import, add line, match/unmatch, create adjustment)
  - report actions enabled (download/view)
  - audit shows finalization event with user and timestamp.

---

## 7. Business Rules (Translated to UI Behavior)

> Note: Accounting domain rules prohibit inventing posting semantics; UI enforces workflow gating and required inputs.

### Validation
- Cannot finalize unless **difference is zero**.
- Adjustments require **glAccountId**.
- If backend rejects adjustment because it would make totals negative / invalid, show backend error verbatim with friendly prefix (see Error handling).

### Enable/disable rules
- If status == `FINALIZED`:
  - All editing and command actions disabled.
  - Screen is read-only.
- Match/unmatch/adjustment actions disabled when required selections missing.

### Visibility rules
- Show matched vs unmatched sections or filters for both statement lines and system transactions.
- Show audit trail section always; if backend doesn‚Äôt provide, show ‚ÄúAudit unavailable‚Äù with error code.

### Error messaging expectations
- Import parsing errors must show:
  - file-level error (unsupported format) OR
  - row-level errors (line number + reason)
- Finalize attempt with non-zero difference must show:
  - ‚ÄúReconciliation cannot be finalized with a non-zero difference.‚Äù (exact message may come from backend; ensure consistent user-visible text)
- Unauthorized operations show ‚ÄúYou do not have permission to perform this action.‚Äù

---

## 8. Data Requirements

### Entities involved (frontend view models)
> Exact entity names may differ; use Moqui services/entities as implemented by backend. Frontend must not assume entity schema beyond contracts returned.

- `Reconciliation`
- `BankStatementLine`
- `ReconciliationMatch`
- `ReconciliationAdjustment`
- `SystemTransaction` (from payment/receipt domain; read-only projection)
- `GLAccount` (for adjustment selection)
- `ReconciliationAuditEvent` (or generic audit log)

### Fields (type, required, defaults)

#### Reconciliation
- `reconciliationId` (string/UUID, required, read-only)
- `bankAccountId` (string, required, read-only after create)
- `periodStartDate` (date, required, read-only after create)
- `periodEndDate` (date, required, read-only after create)
- `openingBalance` (decimal, read-only; source backend)
- `statementClosingBalance` (decimal, **unknown if required**; see Open Questions)
- `bookClosingBalance` (decimal, read-only; source backend)
- `difference` (decimal, read-only; source backend)
- `status` (`DRAFT`|`FINALIZED`, read-only)
- `finalizedAt` (datetime, read-only)
- `finalizedByUserId` (string, read-only)

#### BankStatementLine
- `statementLineId` (string/UUID, read-only)
- `transactionDate` (date, required)
- `description` (string, required)
- `amount` (decimal, required)
- `direction` (`DEBIT`|`CREDIT` OR signed amount; **TBD**)
- `status` (`UNMATCHED`|`MATCHED`, read-only except via match/unmatch commands)
- `reference` (string, optional; if import provides)

#### SystemTransaction (reconcilable payment/receipt)
- `systemTransactionId` (string, read-only)
- `transactionDate` (date/datetime, read-only)
- `amount` (decimal, read-only)
- `type` (enum/string, optional)
- `reference` (string, optional)
- `counterpartyName` (string, optional)
- `reconciliationStatus` (unreconciled/matched, read-only)

#### ReconciliationMatch
- `matchId` (string, read-only)
- `statementLineId` (string, required)
- `systemTransactionId` (string, required)
- `createdAt`, `createdByUserId` (read-only)

#### ReconciliationAdjustment
- `adjustmentId` (string, read-only)
- `statementLineId` (string, optional/likely required in this UX path)
- `glAccountId` (string, required)
- `amount` (decimal, required)
- `description` (string, optional/required TBD)
- `journalEntryId` (string, read-only)
- `createdAt`, `createdByUserId` (read-only)

### Read-only vs editable by state/role
- Draft: statement lines editable only via create/import; match/unmatch and adjustments allowed.
- Finalized: all above are read-only.
- Role-based editing depends on permissions (Open Question).

### Derived/calculated fields
- `difference` and balances should be treated as backend-calculated authoritative values; UI must not compute financial difference beyond display formatting.

---

## 9. Service Contracts (Frontend Perspective)

> Moqui implementation should call services via screen transitions/actions. Exact service names are TBD; below are required capabilities and suggested service naming conventions.

### Load/view calls
- `Accounting.Reconciliation.getReconciliationDetail`
  - Inputs: `reconciliationId`
  - Returns: reconciliation header + computed fields (openingBalance, bookClosingBalance, statementClosingBalance?, difference, status)
- `Accounting.Reconciliation.listStatementLines`
  - Inputs: `reconciliationId`, optional filters (status)
- `Accounting.Reconciliation.listSystemTransactionsForReconciliation`
  - Inputs: `bankAccountId`, `periodStartDate`, `periodEndDate`, `reconciliationId` (to exclude already matched), pagination
- `Accounting.Reconciliation.listMatches`
  - Inputs: `reconciliationId`
- `Accounting.Reconciliation.listAdjustments`
  - Inputs: `reconciliationId`
- `Accounting.GLAccount.search`
  - Inputs: query, activeOnly=true, effectiveDate (optional)
- `Accounting.Reconciliation.listAuditEvents`
  - Inputs: `reconciliationId`

### Create/update calls
- `Accounting.Reconciliation.createReconciliation`
  - Inputs: `bankAccountId`, `periodStartDate`, `periodEndDate`, (maybe) `statementClosingBalance`
  - Returns: `reconciliationId`
- `Accounting.Reconciliation.createStatementLine`
  - Inputs: `reconciliationId`, `transactionDate`, `description`, `amount`, `direction`/signedAmount, `reference?`
- `Accounting.Reconciliation.importStatementLines`
  - Inputs: `reconciliationId`, `file` (binary), `format` (optional)
  - Returns: summary + per-line errors

### Submit/transition calls
- `Accounting.Reconciliation.createMatch`
  - Inputs: `reconciliationId`, `statementLineId(s)`, `systemTransactionId(s)`
  - Returns: updated statuses + updated reconciliation computed fields
- `Accounting.Reconciliation.removeMatch`
  - Inputs: `reconciliationId`, `matchId` OR (`statementLineId`,`systemTransactionId`)
- `Accounting.Reconciliation.createAdjustment`
  - Inputs: `reconciliationId`, `statementLineId?`, `glAccountId`, `amount`, `description`, `adjustmentType?`
  - Returns: `adjustmentId`, `journalEntryId`, updated reconciliation fields, updated statement line status
- `Accounting.Reconciliation.finalizeReconciliation`
  - Inputs: `reconciliationId`
  - Errors: non-zero difference -> conflict/validation with specific code

### Error handling expectations
- Moqui screen should map service errors into:
  - Field-level errors for validation (missing glAccountId, invalid amount).
  - Top-level notification for conflicts (finalize when difference != 0).
  - Import errors displayed as structured results.
- Error codes are not defined in provided inputs for reconciliation; must be confirmed (Open Question). UI should still display backend `errorMessage` and log `errorCode` if present.

---

## 10. State Model & Transitions

### Allowed states
- `DRAFT`
- `FINALIZED`

### Role-based transitions
- `DRAFT -> FINALIZED` requires permission (TBD).
- No transitions out of `FINALIZED` (immutable).

### UI behavior per state
- **DRAFT**
  - Editable workspace; actions enabled as per selection rules.
  - Show ‚ÄúDifference‚Äù prominently; show what remains unmatched.
- **FINALIZED**
  - Read-only; show finalized metadata; allow report download/view and audit review.

---

## 11. Alternate / Error Flows

### Validation failures
- Missing required fields on create reconciliation: show inline errors.
- Import file missing/unsupported: show file-level error and keep prior data unchanged.
- Create adjustment without glAccountId: prevent submit; if backend rejects, show returned validation.

### Concurrency conflicts
- If match/unmatch/adjustment/finalize fails due to concurrent update (optimistic lock / stale status):
  - UI refreshes reconciliation detail and shows ‚ÄúThis reconciliation was updated by another user. Please review the latest status.‚Äù

### Unauthorized access
- If user lacks permission for create/match/adjust/finalize:
  - Disable action buttons when permission flags are known.
  - If backend rejects, show 403-style message and keep UI state unchanged.

### Empty states
- No statement lines: show ‚ÄúNo statement lines yet. Import a file or add one manually.‚Äù
- No reconcilable system transactions: show ‚ÄúNo unreconciled transactions found for this period/account.‚Äù
- No matches/adjustments: show empty placeholders.

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: Create a draft reconciliation
**Given** I am an authenticated Accountant with permission to create reconciliations  
**When** I start a new reconciliation and select a bank/cash account and a period start and end date  
**Then** a new reconciliation is created in `DRAFT` status  
**And** I am navigated to the reconciliation detail workspace showing the selected account and period.

### Scenario 2: Import bank statement lines successfully
**Given** I have a `DRAFT` reconciliation  
**When** I upload a supported bank statement file for that reconciliation  
**Then** the system imports statement lines and displays them as `UNMATCHED` statement lines  
**And** any line-level import failures are listed with reasons without importing invalid lines.

### Scenario 3: Manually add a statement line
**Given** I have a `DRAFT` reconciliation  
**When** I add a statement line with a transaction date, description, and amount  
**Then** the new statement line appears in the statement lines list as `UNMATCHED`.

### Scenario 4: Match a statement line to a system transaction (1-to-1)
**Given** I have a `DRAFT` reconciliation with an imported statement line of amount 55.50 on 2026-07-10  
**And** the system shows an unreconciled payment/receipt transaction of amount 55.50 on 2026-07-10  
**When** I select the statement line and the system transaction and perform ‚ÄúMatch‚Äù  
**Then** the statement line is marked `MATCHED`  
**And** the system transaction is no longer shown as unreconciled for this reconciliation  
**And** the reconciliation difference shown in the header is updated based on backend-calculated values.

### Scenario 5: Create an adjustment for a bank fee and auto-match the line
**Given** I have a `DRAFT` reconciliation with an unmatched statement line described as ‚ÄúMonthly Service Fee‚Äù  
**When** I choose ‚ÄúCreate Adjustment‚Äù for that statement line  
**And** I select a GL account and submit the adjustment with the amount equal to the statement line amount  
**Then** an adjustment is created and listed under Adjustments  
**And** the adjustment includes a reference to a journal entry identifier if provided by the backend  
**And** the statement line is marked `MATCHED`.

### Scenario 6: Prevent finalize when difference is non-zero
**Given** I have a `DRAFT` reconciliation where the displayed difference is not 0.00  
**When** I attempt to finalize the reconciliation  
**Then** the finalize action is rejected  
**And** I see an error message indicating finalization is not allowed with a non-zero difference  
**And** the reconciliation remains in `DRAFT` status.

### Scenario 7: Finalize when difference is zero and enforce immutability
**Given** I have a `DRAFT` reconciliation where the displayed difference is 0.00  
**When** I finalize the reconciliation  
**Then** the reconciliation status becomes `FINALIZED`  
**And** matching, unmatching, importing, adding statement lines, and creating adjustments are no longer available  
**And** I can download or view the reconciliation report.

---

## 13. Audit & Observability

### User-visible audit data
In the reconciliation detail screen, provide an Audit Trail view that lists, at minimum:
- event type (Created, Statement Imported, Statement Line Added, Matched, Unmatched, Adjustment Created, Finalized)
- timestamp
- actor (userId/displayName if available)
- related entity references (statementLineId, systemTransactionId, adjustmentId)

### Status history
- Reconciliation status transitions visible with `finalizedAt` and `finalizedBy`.

### Traceability expectations
- UI should display identifiers (reconciliationId, statementLineId, adjustmentId, journalEntryId if present) in a copyable manner for support/audit.

---

## 14. Non-Functional UI Requirements

- **Performance:** Lists (statement lines, system transactions) must support pagination/virtual scroll if backend returns many rows; avoid loading everything at once.
- **Accessibility:** All actions accessible via keyboard; forms have labels; errors announced and associated to inputs.
- **Responsiveness:** Usable on tablet widths; two-list matching UI may stack vertically on small screens.
- **i18n/timezone/currency:** Display dates in user locale/timezone; display amounts with currency formatting using currencyUomId if backend provides. If not provided, default formatting must not assume currency (Open Question).

---

## 15. Applied Safe Defaults
- SD-UI-EMPTY-STATES: Added explicit empty-state messages for no data in lists; qualifies as safe because it affects only UX guidance and not business policy. Impacted sections: UX Summary, Alternate/waswo Flows.
- SD-UI-PAGINATION: Require pagination/virtual scroll for potentially large lists; safe because it‚Äôs UI ergonomics and does not change domain rules. Impacted sections: Non-Functional UI Requirements, UX Summary.
- SD-ERROR-GENERIC-MAPPING: Display backend errorMessage/errorCode when present; safe because it doesn‚Äôt invent business logic and preserves authoritative backend messaging. Impacted sections: Service Contracts, Error Flows.

---

## 16. Open Questions

1. **Domain label conflict cleanup:** The frontend issue currently carries a legacy `payment` label, but the capability is accounting reconciliation. Confirm we should label this story `domain:accounting` and treat payment/receipt as read-only data providers.
2. **Permissions/authorization:** What are the exact permissions/scopes to:
   - view reconciliation,
   - create reconciliation,
   - import/enter statement lines,
   - match/unmatch,
   - create adjustments,
   - finalize,
   - view/download reports?
3. **Import formats & schemas:** Which bank statement formats are supported (CSV/OFX/BAI2)? If CSV, what columns and date/amount conventions are required?
4. **Statement line amount model:** Does the backend represent statement line amount as:
   - signed `amount` (negative for debit), or
   - `amount` + `type/direction` (`DEBIT`/`CREDIT`)?
   The UI needs the authoritative representation for entry, display, and validation.
5. **Matching cardinality rules:** Are matches strictly 1-to-1, or do we support:
   - many system transactions to one statement line,
   - one system transaction to many statement lines (likely disallowed)?
   Also, must amounts sum exactly, or can there be partial matches?
6. **Closing/ending balance inputs:** Does reconciliation creation (or finalization) require capturing a **statement closing balance** entered by the user? If yes, at what step is it entered, and can it be edited in Draft?
7. **Adjustment types & defaults:** Are there predefined adjustment reason codes/types (e.g., Bank Fee, Interest Earned) and default GL accounts per type, or must the user always choose GL account manually?
8. **Report contract:** Is the report:
   - a downloadable file (PDF/CSV), or
   - a rendered screen view?
   What exact required report contents/sections/fields must be included?
9. **Reconcilable system transactions contract:** What is the precise API to retrieve ‚Äúunreconciled payments/receipts‚Äù? What fields are guaranteed, and how does the backend determine ‚Äúreconcilable‚Äù for the selected bank/cash account?
10. **Currency handling:** Will reconciliations always be single-currency per bank account? Will the backend return `currencyUomId` for formatting?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Reconciliation: Support Bank/Cash Reconciliation Matching  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/187  
Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] Reconciliation: Support Bank/Cash Reconciliation Matching

**Domain**: payment

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Reconciliation, Audit, and Controls

## Story
Reconciliation: Support Bank/Cash Reconciliation Matching

## Acceptance Criteria
- [ ] Import/enter bank statement lines and match to payments/receipts
- [ ] Track matched/unmatched items with audit trail
- [ ] Allow controlled adjustments (fees/interest) via proper entries
- [ ] Produce reconciliation report


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #188: [FRONTEND] [STORY] Audit: Maintain Immutable Ledger Audit Trail and Explainability ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/188
File: ./scripts/story-work/frontend/188/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

# 1. Story Header

## Title
[FRONTEND] [STORY] Audit: Ledger Traceability & Explainability Viewer (JE ‚Üî Ledger Lines ‚Üî Source Event ‚Üî Mapping/Rule Versions)

## Primary Persona
Financial Controller / Auditor

## Business Value
Enable audit, reconciliation, and compliance workflows by providing an internal, read-only, end-to-end traceability view from any posted Journal Entry or Ledger Line back to the originating business event and the accounting configuration versions (mapping/rules) used‚Äîwithout allowing any mutation of posted accounting records.

---

# 2. Story Intent

## As a / I want / So that
- **As a** Financial Controller / Auditor  
- **I want** a read-only ‚ÄúExplainability‚Äù view that shows the chain **Source Event ‚Üí Mapping Version ‚Üí Rule Version ‚Üí Journal Entry ‚Üí Ledger Lines** (and reversal relationships)  
- **So that** I can explain how a financial posting was produced, prove immutability, and trace any GL impact back to its source business document/event.

## In-scope
- Moqui frontend screens to **search and view** posted Journal Entries and Ledger Lines with:
  - Traceability identifiers: `sourceEventId`, `sourceEventType`, `mappingVersionId`, `ruleVersionId`
  - Immutable `sourceEventSnapshot` (rendered read-only)
  - Reversal linkage via `originalJournalEntryId` and/or `reversalJournalEntryId` (if present)
- UI affordances that make immutability explicit (read-only forms, no edit/delete actions for POSTED records)
- Navigation/drilldown between:
  - JE detail ‚Üí ledger lines list
  - JE detail ‚Üí mapping version detail (read-only)
  - JE detail ‚Üí rule version detail (read-only)
  - JE detail ‚Üí referenced original JE (reversal chain)
  - Ledger line detail ‚Üí parent JE
- Frontend handling of backend immutability errors (e.g., attempted mutation returns 409) by ensuring the UI does not present mutation actions.

## Out-of-scope
- Creating/reversing/posting Journal Entries (command operations)
- Public-facing explainability endpoint design (backend owns API shape)
- Defining GL account mappings, posting rules, or chart-of-accounts semantics
- Changing backend data model, enforcement, or audit event emission

---

# 3. Actors & Stakeholders
- **Primary user:** Financial Controller / Auditor
- **Secondary users:** Accounting Ops, Support Engineer (internal troubleshooting)
- **Systems:** Moqui frontend, Accounting backend services/APIs (data source), Identity/permissions

---

# 4. Preconditions & Dependencies
- Backend persists and serves (per backend reference #124) Journal Entry fields:
  - `journalEntryId`, `status`, `postedTimestamp`, `sourceEventId`, `sourceEventType`, `mappingVersionId`, `ruleVersionId`, `originalJournalEntryId` (nullable), `sourceEventSnapshot` (JSON)
- Backend exposes read endpoints for:
  - Searching/listing Journal Entries and Ledger Lines
  - Viewing JE detail and its Ledger Lines
  - Viewing mapping version and rule version referenced by a JE (or at minimum IDs with a resolvable view)
- Permissions exist to allow read-only access for audit users (exact permission tokens are not defined in provided inputs)
- Moqui screen framework and project conventions available in `durion-moqui-frontend` README (dependency for routing/screen structure)

---

# 5. UX Summary (Moqui-Oriented)

## Entry points
- Main navigation: **Accounting ‚Üí Audit / Traceability**
- Deep links:
  - `/accounting/audit/journal-entry/{journalEntryId}`
  - `/accounting/audit/ledger-line/{ledgerLineId}`

## Screens to create/modify
Create new screens under an Accounting/Audit space (screen names indicative; align to repo conventions during implementation):
1. **AuditTraceabilitySearch** (search hub)
2. **JournalEntryDetail** (read-only)
3. **LedgerLinesByJournalEntry** (embedded section or sub-screen)
4. **LedgerLineDetail** (read-only)
5. **MappingVersionDetail** (read-only; if backend supports)
6. **RuleVersionDetail** (read-only; if backend supports)

## Navigation context
- Breadcrumbs: Accounting ‚Üí Audit/Traceability ‚Üí (Search | JE {id} | Ledger Line {id})
- Consistent ‚ÄúBack to results‚Äù behavior when arriving from search.

## User workflows
### Happy path (JE-centered)
1. User opens **Audit/Traceability Search**
2. Searches by `journalEntryId` or `sourceEventId` (optional additional filters)
3. Opens a **Journal Entry Detail**
4. Sees:
   - Status (POSTED/REVERSED/DRAFT if present but focus on POSTED)
   - Traceability IDs and timestamps
   - Source event snapshot (read-only JSON viewer)
   - Linked Mapping Version and Rule Version (click to open detail screens if available)
   - Ledger lines list (drill into a ledger line)
   - Reversal relationship (link to original JE if this JE is a reversal)

### Alternate path (Ledger-line-centered)
1. User searches or opens Ledger Line detail via deep link
2. Views Ledger Line detail and navigates to parent JE
3. Continues traceability chain from JE

### Alternate path (missing linked resources)
- If mapping/rule version details are not retrievable, UI still displays IDs and provides a ‚ÄúCopy ID‚Äù action; linked navigation is disabled with explanatory text.

---

# 6. Functional Behavior

## Triggers
- User navigates to the Audit/Traceability screens.
- User submits a search form.
- User opens a JE or Ledger Line detail page.
- User clicks drilldown links (to ledger lines, mapping version, rule version, original JE).

## UI actions
- Search form submit
- Result row click ‚Üí navigate to detail
- Copy-to-clipboard for IDs (`journalEntryId`, `sourceEventId`, `mappingVersionId`, `ruleVersionId`)
- Expand/collapse source event snapshot rendering (read-only)

## State changes (frontend)
- No domain state transitions initiated by this story.
- Frontend state is purely view state: loading, loaded, empty, error.

## Service interactions (Moqui)
- Use Moqui screen transitions to invoke services that load:
  - JE list (search)
  - JE detail by ID
  - Ledger lines by JE ID
  - Ledger line detail by ID
  - Mapping version by ID (if available)
  - Rule version by ID (if available)

---

# 7. Business Rules (Translated to UI Behavior)

## Validation
- Search inputs:
  - If `journalEntryId` is provided, it must be a valid UUID format (UUIDv7 is still UUID format). If invalid, block submit and show inline error: `Invalid ID format`.
  - If `sourceEventId` is provided, validate UUID format similarly.
- Detail routes:
  - If route param is not a UUID, show Not Found / Invalid URL message and do not call backend.

## Enable/disable rules
- If JE `status` is `POSTED`:
  - UI must show **no edit/delete** actions.
- If JE `status` is `DRAFT` (if reachable):
  - Still treat as read-only in this story (since mutation/reversal is out-of-scope).
- If JE has `originalJournalEntryId`:
  - Show ‚ÄúReversal of: {originalJournalEntryId}‚Äù and enable navigation link to original JE.
- If mapping/rule version endpoints are not available or return 404:
  - Disable navigation to those details; show IDs only.

## Visibility rules
- Always display traceability block for any JE:
  - `sourceEventId`, `sourceEventType`, `mappingVersionId`, `ruleVersionId`
  - If any is null/missing, display as ‚ÄúMissing‚Äù and flag as audit concern (non-blocking UI warning), because backend AC requires these for POSTED.

## Error messaging expectations
- Backend returns 401/403: show ‚ÄúYou do not have access to view this audit data.‚Äù
- Backend returns 404: show ‚ÄúNot found.‚Äù
- Backend returns 409 on mutation attempts: should not be reachable via UI; if encountered (e.g., user hits an old route), show ‚ÄúThis record is immutable; changes are not allowed.‚Äù

---

# 8. Data Requirements

## Entities involved (frontend view models)
- `JournalEntry`
- `LedgerLine` (or `LedgerEntry` depending on backend naming; must match actual API/entity)
- `PostingMappingVersion` (name TBD)
- `PostingRuleVersion` (name TBD)

## Fields (type, required, defaults)

### JournalEntry (read-only)
- `journalEntryId` (UUID, required)
- `status` (enum: DRAFT/POSTED/REVERSED, required)
- `postedTimestamp` (datetime UTC, required when status=POSTED; optional otherwise)
- `sourceEventId` (UUID, **required when status=POSTED**)
- `sourceEventType` (string, required when status=POSTED)
- `mappingVersionId` (UUID, required when status=POSTED)
- `ruleVersionId` (UUID, required when status=POSTED)
- `originalJournalEntryId` (UUID, optional)
- `sourceEventSnapshot` (JSON, required when status=POSTED per backend reference; render read-only)
- Standard audit fields if available: `createdAt`, `createdBy`, `updatedAt`, `updatedBy` (read-only)

### LedgerLine (read-only)
(Exact shape not provided; must be pulled from backend contract. UI should at minimum support:)
- `ledgerLineId` (UUID, required)
- `journalEntryId` (UUID, required)
- `glAccountId` or `glAccountCode` (string/UUID, optional if provided)
- `debitAmount` (decimal, optional)
- `creditAmount` (decimal, optional)
- `currencyUomId` (string, required if amounts shown)
- `postedTimestamp` (datetime, optional)
- Additional dimensions (optional, display if present)

## Read-only vs editable by state/role
- All fields are read-only in this story regardless of role.
- UI must not include form controls that imply editability for POSTED records.

## Derived/calculated fields (frontend-only)
- `isImmutable = (status == POSTED)` used to hide any mutation affordances
- Display helper: formatted timestamps in user locale while preserving UTC value in tooltip/details

---

# 9. Service Contracts (Frontend Perspective)

> Note: Provided inputs do not define actual Moqui services/endpoints. The frontend must integrate with whichever Moqui services are exposed. Below are required capabilities and suggested service names to be aligned during implementation.

## Load/view calls
- **Search Journal Entries**
  - Capability: list JEs by filters: `journalEntryId`, `sourceEventId`, `sourceEventType`, `status`, `postedTimestamp` range
  - Suggested service: `accounting.JournalEntrySearch`
  - Returns: paged list with summary fields
- **Get Journal Entry Detail**
  - Input: `journalEntryId`
  - Suggested service: `accounting.JournalEntryGet`
  - Returns: full JE record including `sourceEventSnapshot`
- **List Ledger Lines for a Journal Entry**
  - Input: `journalEntryId`
  - Suggested service: `accounting.LedgerLineListByJournalEntry`
- **Get Ledger Line Detail**
  - Input: `ledgerLineId`
  - Suggested service: `accounting.LedgerLineGet`
- **Get Mapping Version Detail (optional but desired)**
  - Input: `mappingVersionId`
  - Suggested service: `accounting.PostingMappingVersionGet`
- **Get Rule Version Detail (optional but desired)**
  - Input: `ruleVersionId`
  - Suggested service: `accounting.PostingRuleVersionGet`

## Create/update calls
- None (read-only story)

## Submit/transition calls
- None

## Error handling expectations
- 400 validation errors: surface field-level errors on search form
- 401/403: route to an ‚ÄúUnauthorized‚Äù state (screen message) without exposing data
- 404: show not found
- 409: show immutable/conflict message; log client-side as unexpected for read-only screens
- Network/timeouts: show retry action; do not partially render stale data without labeling it

---

# 10. State Model & Transitions

## Allowed states (displayed, not mutated)
- Journal Entry: `DRAFT`, `POSTED`, `REVERSED`

## Role-based transitions
- None initiated in UI (out-of-scope).  
- UI must assume backend enforces immutability: POSTED records cannot be updated/deleted; corrections via reversal JE.

## UI behavior per state
- `POSTED`:
  - Highlight immutability (read-only)
  - Require traceability fields displayed; if missing, show warning banner ‚ÄúTraceability data missing (unexpected for POSTED).‚Äù
- `REVERSED`:
  - Show reversal relationship fields if present (original JE link)
- `DRAFT`:
  - Read-only display only; no actions (this story)

---

# 11. Alternate / Error Flows

## Validation failures
- Invalid UUID in search fields ‚Üí inline error; no service call
- Invalid UUID in route param ‚Üí show invalid request page/state

## Concurrency conflicts
- If backend indicates the JE changed between list and detail (e.g., ETag mismatch), simply reload detail; since read-only, no merge required.

## Unauthorized access
- 401/403 from any load call ‚Üí show access denied message; do not render partial sensitive content; provide link back to home/accounting.

## Empty states
- Search returns 0 results ‚Üí show ‚ÄúNo journal entries found‚Äù with tips (search by JE ID, source event ID)
- JE exists but has 0 ledger lines (unexpected) ‚Üí show empty state ‚ÄúNo ledger lines available‚Äù and allow user to copy JE ID for support.

---

# 12. Acceptance Criteria

## Scenario 1: Search journal entries by source event id
**Given** I have permission to view accounting audit data  
**And** I am on the Audit/Traceability Search screen  
**When** I enter a valid `sourceEventId` and submit the search  
**Then** the system displays a list of matching Journal Entries (paged)  
**And** each result shows `journalEntryId`, `status`, and `postedTimestamp` when available.

## Scenario 2: Prevent invalid ID input
**Given** I am on the Audit/Traceability Search screen  
**When** I enter an invalid UUID value into `journalEntryId`  
**And** I submit the search  
**Then** the UI blocks the request  
**And** shows an inline validation error indicating the ID format is invalid.

## Scenario 3: View JE explainability chain
**Given** I have opened a Journal Entry detail page for a `POSTED` entry  
**When** the page loads  
**Then** I can see `sourceEventId`, `sourceEventType`, `mappingVersionId`, and `ruleVersionId`  
**And** I can view the `sourceEventSnapshot` in a read-only format  
**And** I can view the list of Ledger Lines associated to the JE  
**And** each Ledger Line can be opened to see its details.

## Scenario 4: Reversal traceability navigation
**Given** I have opened a Journal Entry detail page for a JE that has `originalJournalEntryId` populated  
**When** I click the ‚ÄúOriginal Journal Entry‚Äù link  
**Then** I am navigated to the detail view for `originalJournalEntryId`  
**And** the system loads and displays that JE‚Äôs traceability and ledger lines.

## Scenario 5: Missing mapping/rule version details
**Given** I am on a Journal Entry detail page  
**And** the backend does not provide a retrievable detail for `mappingVersionId` (404 or capability absent)  
**When** the page renders  
**Then** the UI still displays the `mappingVersionId` value  
**And** disables the drilldown link with an explanation ‚ÄúMapping version details unavailable.‚Äù

## Scenario 6: Unauthorized access
**Given** I do not have permission to view accounting audit data  
**When** I navigate to a Journal Entry detail URL  
**Then** the system shows an access denied state  
**And** does not display journal entry fields or ledger lines.

---

# 13. Audit & Observability

## User-visible audit data
- Display audit identifiers and timestamps:
  - `journalEntryId`, `postedTimestamp`, `status`
  - `sourceEventId`, `sourceEventType`
  - `mappingVersionId`, `ruleVersionId`
  - Reversal link (`originalJournalEntryId`) when present

## Status history
- If backend provides status history for JE, display as read-only timeline (optional). If not available, omit.

## Traceability expectations
- From JE detail, user can traverse to:
  - Ledger Lines
  - Mapping/Rule versions (when available)
  - Original JE (when reversal relationship exists)

---

# 14. Non-Functional UI Requirements

- **Performance:** JE detail page should load core JE header quickly; ledger lines and snapshot may load in parallel. Target: initial content rendered within 2s on typical broadband for average payload sizes.
- **Accessibility:** All interactive elements keyboard reachable; snapshot viewer supports scrolling and copy; labels for ID fields.
- **Responsiveness:** Works on tablet widths used in back-office; content stacks appropriately.
- **i18n/timezone/currency:** Timestamps displayed in user locale with UTC preserved; currency formatting based on `currencyUomId` when amounts shown (do not assume multi-currency beyond display).

---

# 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide explicit empty-state messaging for zero search results and zero ledger lines; qualifies as safe UX ergonomics; impacts UX Summary, Alternate/Error Flows, Acceptance Criteria.
- SD-UX-PAGINATION: Use standard pagination for search results; safe and reversible UI behavior; impacts UX Summary, Service Contracts, Acceptance Criteria.
- SD-ERR-HTTP-MAP: Standard mapping of 401/403/404/409/network errors to UI states; safe because it does not change domain policy; impacts Service Contracts, Alternate/Error Flows.

---

# 16. Open Questions
1. What are the **exact Moqui services / REST endpoints** (names, parameters, response shapes) for:
   - JournalEntry search, get-by-id
   - LedgerLine list-by-JE, get-by-id
   - MappingVersion get-by-id
   - RuleVersion get-by-id
2. What permission(s)/scope(s) should gate access to these audit screens (e.g., `accounting.audit.view`), and which roles are expected to have them?
3. What is the canonical naming: **LedgerLine vs LedgerEntry** in the frontend/backend contract for posted lines?
4. Should the UI include a dedicated search by **GL account** and/or **posted date range**, or is MVP limited to ID-based lookups?
5. Is `sourceEventSnapshot` always present for POSTED entries, and are there any redaction requirements for sensitive fields in the snapshot before displaying it?

---

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Audit: Maintain Immutable Ledger Audit Trail and Explainability ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/188

====================================================================================================

FRONTEND STORY (FULL CONTEXT)

====================================================================================================

Title: [FRONTEND] [STORY] Audit: Maintain Immutable Ledger Audit Trail and Explainability  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/188  
Labels: frontend, story-implementation, general

## Frontend Implementation for Story

**Original Story**: [STORY] Audit: Maintain Immutable Ledger Audit Trail and Explainability

**Domain**: general

### Story Description

/kiro  
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Reconciliation, Audit, and Controls

## Story
Audit: Maintain Immutable Ledger Audit Trail and Explainability

## Acceptance Criteria
- [ ] Ledger lines and JEs are immutable once posted (corrections via reversal)
- [ ] Store rule version and mapping version used for each posting
- [ ] Provide explainability view: event ‚Üí mapping ‚Üí rules ‚Üí JE ‚Üí ledger lines
- [ ] Full traceability from any GL line to source event/business document


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #189: [FRONTEND] [STORY] Reporting: Produce Core Financial Statements with Drilldown  
File: ./scripts/story-work/frontend/189/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

**Title:** [FRONTEND] Reporting: Produce Core Financial Statements (P&L, Balance Sheet) with Drilldown and Export

**Primary Persona:** Financial Controller / Accountant

**Business Value:** Enable finance users to reliably generate reproducible financial statements from posted ledger data, investigate balances via drilldown to source, and export reports for review/audit.

---

## 2. Story Intent

### As a / I want / So that
**As a** Financial Controller or Accountant,  
**I want** to generate a Profit & Loss and Balance Sheet for a selected period/as-of date with drilldowns to underlying accounts, journal lines, and source events,  
**So that** I can analyze financial performance/position, support period close activities, and satisfy audit/review needs.

### In-scope
- UI flows to:
  - Generate **P&L** for a date range
  - Generate **Balance Sheet** as-of an end date
  - Drilldown path: **statement line ‚Üí contributing accounts ‚Üí journal/ledger lines ‚Üí source event reference**
  - Export generated statement output (format(s) TBD) with access control enforcement
- Deterministic/reproducible report results for identical parameters (frontend must not introduce nondeterminism; rely on backend reproducibility)
- Handling empty states, validation errors, unauthorized access, and service failures

### Out-of-scope
- Defining or editing Chart of Accounts, statement definitions, posting rules, or accounting periods
- Performing postings, closing periods, or making adjustments
- Multi-entity consolidation and multi-currency presentation (unless backend explicitly supports it; TBD)
- Custom report builder / ad-hoc reporting beyond basic P&L and Balance Sheet

---

## 3. Actors & Stakeholders

- **Financial Controller / Accountant (Primary):** Runs reports, drills into balances, exports for review.
- **Auditor (Indirect):** Consumes exports and drilldown evidence; needs traceability to source events.
- **System Administrator / Security Admin:** Configures permissions for viewing and exporting reports.
- **Support/Operations:** Needs logs/trace IDs to troubleshoot report generation failures or latency.

---

## 4. Preconditions & Dependencies

### Preconditions
- User is authenticated.
- Posted ledger/journal data exists (or UI must show ‚Äúno data‚Äù state).
- Backend provides endpoints/services to:
  - Retrieve statement results for given parameters
  - Retrieve drilldown levels (line‚Üíaccounts‚Üíjournal lines‚Üísource event)
  - Export statement output (or provide export-ready payload)

### Dependencies (blocking if absent)
- **Backend reporting contract** for statement + drilldown is not defined in provided inputs (must be clarified).
- **Authorization model/permissions** for:
  - Viewing statements
  - Drilling down
  - Exporting  
  is not defined in provided inputs (must be clarified).
- **Statement structure/mapping** (how accounts map to statement lines) is not defined here; must be backend-defined or configured elsewhere (clarify).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main navigation: `Accounting ‚Üí Reports ‚Üí Financial Statements`
- Direct routes (proposed, final routes must align with repo conventions; see Open Questions):
  - `/accounting/reports/financial-statements`
  - Optional deep links with query params for reproducibility:
    - `?reportType=PL&from=YYYY-MM-DD&thru=YYYY-MM-DD`
    - `?reportType=BS&asOf=YYYY-MM-DD`

### Screens to create/modify (Moqui)
1. **Screen:** `apps/pos/screen/accounting/reports/FinancialStatements.xml` (container)
2. **Subscreens (or embedded sections):**
   - `ProfitLoss.xml` (parameter form + results)
   - `BalanceSheet.xml` (parameter form + results)
   - `StatementDrilldown.xml` (reusable drilldown panel/modal or nested screen)
3. **Shared components/widgets:**
   - Parameter form (date pickers, business unit selector if applicable)
   - Results table/tree renderer (statement lines)
   - Breadcrumb drilldown navigation component

### Navigation context
- Breadcrumb: `Accounting > Reports > Financial Statements > {P&L|Balance Sheet}`
- Results maintain state in URL query params to support refresh/reload and reproducibility.

### User workflows
#### Happy path: Generate P&L
1. User selects **Profit & Loss** tab.
2. User enters **From date** and **Thru date**.
3. User clicks **Run Report**.
4. UI loads statement results and displays lines with totals.
5. User clicks a statement line to drill down.

#### Happy path: Drilldown
1. Click statement line ‚Üí UI loads contributing accounts list.
2. Click an account ‚Üí UI loads posted journal/ledger lines for that account within parameter context.
3. Click a journal line ‚Üí UI shows source event reference details (minimum: event id/type + link if available).

#### Happy path: Export
1. User clicks **Export** from report view.
2. UI prompts for format (if multiple) and triggers export download.

#### Alternate path: No data
- UI shows explicit ‚ÄúNo data available for selected period‚Äù with guidance to adjust filters.

---

## 6. Functional Behavior

### Triggers
- Screen load:
  - If URL contains valid query params, auto-run report (optional; see safe defaults applied).
- User action:
  - Run Report
  - Click statement line
  - Click account row
  - Click journal line
  - Export

### UI actions
- Parameter input:
  - P&L: `fromDate`, `thruDate` (required)
  - Balance Sheet: `asOfDate` (required)
  - Optional filters (only if backend supports; otherwise omit): businessUnitId, accountingPeriodId
- Results:
  - Render statement lines with:
    - line name/label
    - amount (currency formatted)
    - indicator if drilldown available
- Drilldown:
  - Use nested panel or modal with breadcrumb:
    - `Statement Line` ‚Üí `Accounts` ‚Üí `Journal Lines` ‚Üí `Source Event`
- Export:
  - Export button enabled only when a report result is present and user has export permission.

### State changes (frontend)
- Local UI state:
  - `idle | loading | loaded | error`
  - Drilldown state with breadcrumb selection and loaded datasets
- No domain state mutation in frontend (read/reporting only).

### Service interactions
- Run report ‚Üí call backend to compute/fetch statement for parameters.
- Drilldown level calls:
  - statementLineId (or lineKey) ‚Üí accounts
  - accountId ‚Üí journal lines
  - journalLineId/sourceRef ‚Üí source event details (or external link)

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- P&L:
  - `fromDate` required
  - `thruDate` required
  - `fromDate <= thruDate` else show inline validation error and prevent call
- Balance Sheet:
  - `asOfDate` required
- If backend returns validation errors, surface them at form level and on relevant fields when possible.

### Enable/disable rules
- **Run Report** disabled until required parameters valid.
- **Export** disabled when:
  - no report currently loaded
  - user lacks export permission
  - report is loading

### Visibility rules
- Drilldown controls visible only when report loaded.
- For statement lines with no children (backend indicates `drilldownAvailable=false` or returns empty), clicking shows ‚ÄúNo underlying accounts‚Äù message and does not error.

### Error messaging expectations
- Unauthorized (401/403): show ‚ÄúAccess denied‚Äù page or inline blocking banner; do not display financial data remnants.
- No data: show friendly empty state (not an error).
- Backend error: show non-technical message + trace/request id if provided.

---

## 8. Data Requirements

### Entities involved (conceptual; frontend reads via services)
- `GeneralLedgerEntry` / `LedgerEntry` (posted lines)
- `JournalEntry` / `JournalLine`
- `GLAccount` (Chart of Accounts)
- `FinancialStatementDefinition` (line structure and mapping; may be implicit in backend)
- `AccountingPeriod` (only if used for filtering or reproducibility metadata)

### Fields (UI-facing; exact names TBD by backend contract)
#### Statement run parameters
- `reportType`: enum `{PL, BS}` (required)
- `fromDate`: date (required for PL)
- `thruDate`: date (required for PL)
- `asOfDate`: date (required for BS)
- `businessUnitId`: id (optional; **cannot assume** without clarification)
- `currencyUomId`: id/code (display-only; **cannot assume**)
- `includeZeroLines`: boolean (optional; UI can default off if backend supports)

#### Statement result
- `reportId` or `resultHash` (string; used for export and reproducibility) (TBD)
- `generatedAt` (datetime, display)
- `parameters` (echo of inputs)
- `lines[]` each:
  - `lineKey` (string, stable identifier for drilldown)
  - `label` (string)
  - `amount` (decimal)
  - `accountType` or section grouping (optional)
  - `drilldownAvailable` (boolean)

#### Drilldown: accounts
- `accounts[]` each:
  - `glAccountId`
  - `accountCode`
  - `accountName`
  - `amount`

#### Drilldown: journal/ledger lines
- `entries[]` each:
  - `postedDate` / `transactionDate`
  - `journalEntryId` / `ledgerEntryId`
  - `description`
  - `debitAmount` / `creditAmount` or signed `amount`
  - `sourceEventId` (or `sourceEntityRef`)
  - `sourceEventType` (if available)

#### Source event reference (minimum)
- `eventId`
- `eventType`
- `occurredAt`
- `sourceModule`
- `sourceEntityRef` (string)
- Link behavior:
  - If backend provides a URL, render as ‚ÄúView source‚Äù external/internal link.
  - If not, display identifiers only.

### Read-only vs editable
- All fields are read-only except report parameters.

### Derived/calculated fields (frontend)
- Currency formatting only; no financial calculations beyond displaying backend-provided totals.
- Breadcrumb labels derived from selected items.

---

## 9. Service Contracts (Frontend Perspective)

> **Blocking:** actual Moqui service names, parameters, and response schemas are not provided. Below are required contracts; implementation must align with backend.

### Load/view calls
1. **Run statement**
   - Service (proposed): `accounting.reporting.FinancialStatementService.run`
   - Inputs:
     - `reportType`, date params
     - optional filters (businessUnitId, etc. if supported)
   - Returns:
     - `statementResult` (see Data Requirements)

2. **Fetch drilldown accounts for statement line**
   - Service (proposed): `accounting.reporting.FinancialStatementService.getLineAccounts`
   - Inputs: `reportType`, same parameters, `lineKey`
   - Returns: `accounts[]`

3. **Fetch journal/ledger lines for account**
   - Service (proposed): `accounting.reporting.FinancialStatementService.getAccountEntries`
   - Inputs: `reportType`, parameters, `glAccountId`
   - Returns: `entries[]`

4. **Fetch source event details**
   - Service (proposed): `accounting.event.EventService.getEvent`
   - Inputs: `eventId` (or `sourceEntityRef`)
   - Returns: `event` summary

### Create/update calls
- None (reporting is read-only)

### Submit/transition calls
- Export request:
  - Service (proposed): `accounting.reporting.FinancialStatementService.export`
  - Inputs:
    - `reportType`, parameters or `reportId/resultHash`
    - `format` (TBD)
  - Returns:
    - File download response or `downloadUrl`

### Error handling expectations
- 400 validation: map field errors to inputs; show message.
- 401/403: redirect to access denied screen; clear sensitive state.
- 409 conflict (if reproducibility token expired): show ‚ÄúReport changed; rerun report‚Äù (only if backend uses tokens).
- 500/503: show retry option; preserve parameters.

---

## 10. State Model & Transitions

### Allowed states (UI)
- `idle` (no result yet)
- `loading` (running report or drilldown fetch)
- `loaded` (result displayed)
- `error` (error banner + retry)

### Role-based transitions
- If user lacks `report.view` permission (name TBD), they cannot enter `loaded` state; access denied screen shown.
- Export requires `report.export` permission (name TBD); otherwise export action hidden or disabled with tooltip.

### UI behavior per state
- `idle`: show parameter form, no results.
- `loading`: disable actions; show progress indicator.
- `loaded`: show results + export + drilldown affordances.
- `error`: show error summary + retry; keep parameters intact.

---

## 11. Alternate / Error Flows

### Validation failures
- From > thru (P&L): block run; show inline message.
- Missing dates: block run; required field indicators.

### Concurrency conflicts / reproducibility
- If backend indicates statement definitions changed or data changed:
  - If backend guarantees reproducibility for closed periods only, UI must display a warning banner for open periods: ‚ÄúResults may change until period is closed.‚Äù (**Requires clarification**)
  - If backend returns a `resultHash`/`asOfLedgerVersion`, UI displays it and reuses it for export (if supported).

### Unauthorized access
- Navigating directly to route without permission results in Access Denied screen.
- If permissions revoked mid-session and a call returns 403, UI clears current results and shows Access Denied.

### Empty states
- No posted lines for parameters: show ‚ÄúNo data available for selected period/as-of date.‚Äù
- Drilldown returns empty list: show ‚ÄúNo underlying entries for this selection.‚Äù

### Service unavailable
- Show retry; log requestId/traceId if provided.

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: Generate Profit & Loss for a date range
**Given** the user has permission to view financial statements  
**And** posted ledger/journal lines exist for the selected date range  
**When** the user selects ‚ÄúProfit & Loss‚Äù and enters a valid From date and Thru date  
**And** clicks ‚ÄúRun Report‚Äù  
**Then** the system displays a P&L statement generated from posted ledger lines only  
**And** each statement line shows an amount formatted in the reporting currency  
**And** the results remain visible on refresh when the same parameters are present in the URL (if implemented)

### Scenario 2: Generate Balance Sheet as of a date
**Given** the user has permission to view financial statements  
**And** posted ledger/journal lines exist up to the selected as-of date  
**When** the user selects ‚ÄúBalance Sheet‚Äù and enters an as-of date  
**And** clicks ‚ÄúRun Report‚Äù  
**Then** the system displays a Balance Sheet as of that date generated from posted ledger lines only

### Scenario 3: Validate invalid date range for P&L
**Given** the user is on the Profit & Loss report screen  
**When** the user enters a From date after the Thru date  
**And** attempts to run the report  
**Then** the UI prevents the request from being sent  
**And** displays an inline validation message indicating the date range is invalid

### Scenario 4: Drilldown from statement line to accounts
**Given** a financial statement is loaded  
**And** at least one statement line is drilldown-enabled  
**When** the user clicks a drilldown-enabled statement line  
**Then** the system displays the contributing GL accounts and their amounts for that same report context  
**And** the user can navigate back to the statement lines without losing the report parameters

### Scenario 5: Drilldown from account to journal/ledger lines
**Given** the user is viewing the contributing accounts for a statement line  
**When** the user selects a specific GL account  
**Then** the system displays the posted journal/ledger lines contributing to that account balance for the report context  
**And** each line includes a reference to its source event (at least an identifier)

### Scenario 6: Drilldown to source event reference
**Given** the user is viewing journal/ledger lines for a GL account  
**When** the user selects a journal/ledger line with a source event reference  
**Then** the system displays source event identifiers (event id and type at minimum)  
**And** if a navigable link is provided by the backend, the UI provides a ‚ÄúView source‚Äù link

### Scenario 7: Export a generated statement
**Given** the user has permission to export financial statements  
**And** a financial statement is loaded  
**When** the user clicks ‚ÄúExport‚Äù and selects an available export format  
**Then** the system downloads or provides a download link for the exported report  
**And** the exported content corresponds to the on-screen report parameters

### Scenario 8: Unauthorized user cannot access financial statements
**Given** the user does not have permission to view financial statements  
**When** the user navigates to the Financial Statements route  
**Then** the system shows an Access Denied screen  
**And** no financial statement data is displayed

### Scenario 9: No data for selected period
**Given** the user has permission to view financial statements  
**And** there are no posted ledger/journal lines for the selected parameters  
**When** the user runs the report  
**Then** the system shows a ‚ÄúNo data available for the selected period/as-of date‚Äù empty state  
**And** does not show an error

---

## 13. Audit & Observability

### User-visible audit data
- Display (if provided by backend) on the report results:
  - `generatedAt`
  - `report parameters`
  - `resultHash/reportId` (for reproducibility and support)

### Status history
- Not applicable (no stateful entity transitions in UI). If backend returns report run history, it is out-of-scope.

### Traceability expectations
- Each run/drilldown/export call should:
  - include correlation/request id headers if platform supports it
  - log (frontend console/log pipeline) minimal identifiers:
    - reportType, dates, businessUnitId (if used), and backend requestId/traceId
  - avoid logging financial amounts in client logs unless workspace standard allows (not specified; default to avoid).

---

## 14. Non-Functional UI Requirements

- **Performance:** Initial statement results should render progressively; drilldown calls should be lazy-loaded on click. Target: first results visible within 3 seconds for typical periods (exact SLA TBD).
- **Accessibility:** Keyboard navigable drilldown (tab/enter), proper table semantics, ARIA labels for expandable/drilldown controls.
- **Responsiveness:** Usable on tablet width; tables allow horizontal scroll when needed.
- **i18n/timezone/currency:**
  - Dates displayed in user locale; query params use ISO `YYYY-MM-DD`.
  - Currency formatting uses backend-provided currency code/uom when available; otherwise display as plain decimal with warning (**requires clarification**).

---

## 15. Applied Safe Defaults

- **SD-UI-EMPTY-STATE**
  - **Assumed:** Provide explicit empty states (‚ÄúNo data available‚Ä¶‚Äù) for no-results at statement and drilldown levels.
  - **Why safe:** UI-only ergonomics; does not affect accounting meaning.
  - **Impacted sections:** UX Summary, Alternate / Error Flows, Acceptance Criteria.
- **SD-UI-URL-PARAM-STATE**
  - **Assumed:** Persist report parameters in URL query params to support refresh/back and reproducibility UX.
  - **Why safe:** Navigation ergonomics only; does not change backend calculations or policies.
  - **Impacted sections:** UX Summary, Functional Behavior, Acceptance Criteria.
- **SD-UI-RETRY-ON-TRANSIENT**
  - **Assumed:** Provide a retry button for transient backend failures (5xx/503) without auto-retrying financial queries.
  - **Why safe:** Conservative error-handling; avoids unintended repeated queries.
  - **Impacted sections:** Alternate / Error Flows, Non-Functional UI Requirements.

---

## 16. Open Questions

1. **Routes / IA:** What are the canonical Moqui screen paths and menu locations in `durion-moqui-frontend` for accounting reports (exact route/screen naming conventions)?
2. **Backend service/API contracts:** What are the exact endpoints/services, request params, and response schemas for:
   - running P&L / Balance Sheet
   - drilldown (line‚Üíaccounts, accounts‚Üíentries, entry‚Üísource event)
   - export (and whether it uses `reportId/resultHash` vs rerun-by-params)?
3. **Permissions:** What are the exact permission names/scopes for:
   - viewing financial statements
   - drilling down
   - exporting  
   Are these distinct permissions or one?
4. **Statement definition & mapping:** Is the statement line structure:
   - fixed and backend-defined, or
   - configurable per business unit / CoA, or
   - user-selectable ‚Äústatement definition‚Äù parameter?
5. **Export formats:** Which formats are required for MVP (CSV, PDF, XLSX)? Any formatting standards (e.g., include headers, subtotals, sign conventions)?
6. **Reproducibility rules:** Are reports reproducible:
   - always (via ledger versioning/snapshots), or
   - only for closed periods?  
   If only closed periods, what UI indicator should be shown for open periods?
7. **Currency & multi-entity:** Is this strictly single business unit + single currency for this story, or should UI include businessUnit and/or currency selectors?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Reporting: Produce Core Financial Statements with Drilldown  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/189  
Labels: frontend, story-implementation, reporting

## Frontend Implementation for Story

**Original Story**: [STORY] Reporting: Produce Core Financial Statements with Drilldown

**Domain**: reporting

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Period Close, Adjustments, and Reporting

## Story
Reporting: Produce Core Financial Statements with Drilldown

## Acceptance Criteria
- [ ] Produce P&L and Balance Sheet (basic) from posted ledger lines
- [ ] Drilldown: statement line ‚Üí accounts ‚Üí journal lines ‚Üí source events
- [ ] Reports are reproducible for the same parameters
- [ ] Exports supported and access controls enforced


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #190: [FRONTEND] [STORY] Adjustments: Create Manual Journal Entry with Controls  
File: ./scripts/story-work/frontend/190/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

STOP: Clarification required before finalization

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Adjustments: Create Manual Journal Entry (JE) with Controls

### Primary Persona
Accountant / Controller (authorized financial user)

### Business Value
Enable controlled, auditable manual GL adjustments directly from the POS frontend while preventing unbalanced entries, enforcing accounting period controls, and ensuring immutability once posted.

---

## 2. Story Intent

### As a / I want / So that
**As an** authorized financial user (Accountant/Controller),  
**I want** a frontend workflow to create and post a manual Journal Entry with a required reason code and balanced debit/credit lines,  
**So that** necessary accounting adjustments can be recorded accurately, within open periods, with a complete audit trail.

### In-scope
- A ‚ÄúCreate Manual Journal Entry‚Äù UI to enter header + multiple lines.
- Client-side and server-side validation handling:
  - reasonCode required
  - at least 2 lines
  - each line must have either debit or credit (not both)
  - totals must balance before posting
- Posting submission and resulting immutable ‚ÄúPOSTED‚Äù record behavior in UI.
- Error display for:
  - unbalanced entry
  - closed period
  - invalid/inactive GL account
  - missing required fields
  - insufficient permissions
- Read-only view of a posted JE (no edit/delete actions).

### Out-of-scope
- Editing or deleting posted JEs (explicitly disallowed).
- Creating reversing/reversal JEs (mentioned as correction mechanism, but not implemented here unless separately specified).
- Managing GL accounts, accounting periods, or reason code master data (assumed existing).
- Reporting screens (trial balance, JE listings) unless required for navigation entry points.

---

## 3. Actors & Stakeholders
- **Accountant/Controller (Primary)**: creates and posts manual JEs.
- **Auditor (Stakeholder)**: needs immutable records and visible audit metadata.
- **System**: enforces period status, balancing, immutability, and permissions.

---

## 4. Preconditions & Dependencies
1. User is authenticated in the frontend and has permission to create manual JEs (permission name TBD; backend reference uses `ACCOUNTING_ADJUSTMENT_CREATE`).
2. Backend exposes:
   - list/lookup of active GL accounts
   - list/lookup of valid reason codes for manual adjustments
   - create+post manual JE endpoint (single command or create then post)
   - (optional) retrieve JE by id for post-submit view
3. Accounting period status is enforced server-side based on `postingDate`.

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main navigation: **Accounting ‚Üí Adjustments ‚Üí Manual Journal Entry ‚Üí Create**
- Optional secondary entry: ‚ÄúCreate Manual JE‚Äù action from an accounting dashboard.

### Screens to create/modify
- **New screen**: `accounting/adjustments/manualJe/Create`  
  - Form for JE header + repeating line entry grid.
- **New screen**: `accounting/adjustments/manualJe/View`  
  - Read-only detail view (primarily for POSTED JEs; may also display just-created result).
- **Optional**: add menu entry in Accounting screens/menu definition.

### Navigation context
- Breadcrumb: Accounting > Adjustments > Manual Journal Entry > Create
- After successful post: redirect to View screen for created JE.

### User workflows
**Happy path**
1. User opens Create Manual JE screen.
2. Selects postingDate, enters description, selects reason code.
3. Adds 2+ lines, selecting GL account and entering debit or credit amounts.
4. UI shows running totals (debits, credits, difference).
5. User submits ‚ÄúPost Journal Entry‚Äù.
6. On success, user is redirected to View screen showing JE status `POSTED` and audit fields.

**Alternate paths**
- User attempts submit with missing header fields ‚Üí inline validation + blocking submit.
- User enters both debit and credit on one line ‚Üí inline validation, block submit.
- User enters unbalanced totals ‚Üí UI blocks submit (client-side) and also handles server validation error if it occurs.
- Posting date in closed period ‚Üí server rejects; UI shows error and keeps draft form values.

---

## 6. Functional Behavior

### Triggers
- Screen load: fetch reference data (reason codes, GL account search capability).
- Line edits: recalculate totals/difference.
- Submit: call backend to validate+post JE.

### UI actions
- Add line / remove line (cannot remove below 2 lines; if attempted, show validation).
- GL account selection per line:
  - Prefer searchable select (typeahead) to avoid loading entire CoA if large.
- Debit/Credit inputs:
  - Numeric currency input; enforce >= 0.
  - Mutually exclusive: entering debit clears credit and vice versa (or prevents entry).
- Submit button enabled only when client validations pass.

### State changes (frontend)
- Local ‚Äúdraft‚Äù state for form entry.
- On successful post:
  - transition to ‚Äúposted view mode‚Äù by navigation to View screen with `journalEntryId`.

### Service interactions
- Load reason codes list.
- Search/select GL accounts.
- Submit JE create+post request.
- Load JE detail for view.

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- **Header required**: postingDate, description, reasonCode must be present before submit.
- **Lines required**: minimum 2 JE lines.
- **Per line**:
  - glAccountId required
  - exactly one of debitAmount or creditAmount must be > 0 (or allow 0? see Open Questions)
  - memo optional
- **Balanced**:
  - Sum(debitAmount) must equal Sum(creditAmount) exactly (currency-scale precision).
  - UI shows difference and blocks submit if non-zero.
- **Period control**:
  - UI cannot determine open/closed reliably without API; must handle server rejection `PERIOD_CLOSED` with clear message.
- **Immutability**:
  - If viewing a `POSTED` JE, all fields read-only and no edit/delete actions present.

### Enable/disable rules
- ‚ÄúPost Journal Entry‚Äù disabled until:
  - header fields valid
  - >= 2 valid lines
  - balanced totals
- ‚ÄúAdd line‚Äù always enabled.
- ‚ÄúRemove line‚Äù disabled if only 2 lines remain.

### Visibility rules
- Show totals panel (debits, credits, difference) whenever at least one line exists.
- Show server error banner on submission failures with error code + user-friendly message.

### Error messaging expectations
Map backend error codes (examples from backend reference) to UI messages:
- `VALIDATION_ERROR:UNBALANCED_ENTRY` ‚Üí ‚ÄúEntry is not balanced. Debits must equal credits.‚Äù
- `VALIDATION_ERROR:PERIOD_CLOSED` ‚Üí ‚ÄúPosting date is in a closed accounting period. Choose a date in an open period.‚Äù
- `VALIDATION_ERROR:INVALID_ACCOUNT` ‚Üí ‚ÄúOne or more selected accounts are invalid or inactive.‚Äù
- `VALIDATION_ERROR:MISSING_REQUIRED_FIELD` ‚Üí ‚ÄúComplete all required fields before posting.‚Äù
- `IMMUTABLE_RECORD` ‚Üí ‚ÄúThis journal entry is posted and cannot be changed.‚Äù

(Exact error code strings require confirmation; see Open Questions.)

---

## 8. Data Requirements

### Entities involved (frontend-facing)
- `JournalEntry` (header)
- `JournalEntryLine` (lines)
- `GLAccount` (reference/lookup)
- `ReasonCode` (reference/lookup)
- `AccountingPeriod` (enforced server-side; optionally displayed)

### Fields

#### JournalEntry (Create payload)
- `postingDate` (date, required)
- `description` (string, required)
- `reasonCode` (string/enum, required)
- `lines[]` (array, required, min 2)

#### JournalEntryLine (Create payload)
- `glAccountId` (id/uuid/string, required)
- `debitAmount` (money/decimal string, required as 0 if credit used; see Open Questions)
- `creditAmount` (money/decimal string, required as 0 if debit used; see Open Questions)
- `memo` (string, optional)

#### JournalEntry (View)
- `journalEntryId` (id)
- `status` (expect `POSTED`)
- `transactionDate` (datetime)
- `createdByUserId` (id) and/or display name if available
- Echo of header + lines
- Optional audit metadata if exposed (createdAt, etc.)

### Read-only vs editable by state/role
- Create screen: editable for authorized users only.
- View screen:
  - if status `POSTED`: read-only for all users with view permission.
  - if other statuses exist (e.g., DRAFT) not defined here; if returned, treat as read-only unless explicitly supported.

### Derived/calculated fields (UI-only)
- `totalDebits` = sum of debitAmount across lines (currency-scale rounding consistent with backend)
- `totalCredits` = sum of creditAmount across lines
- `difference` = totalDebits - totalCredits

---

## 9. Service Contracts (Frontend Perspective)

> Moqui note: exact service names/paths must match the backend/Moqui component; these are contract placeholders pending confirmation.

### Load/view calls
1. **Get reason codes**
   - Operation: `GET /accounting/reason-codes?type=MANUAL_JE` (placeholder)
   - Returns: `[{ reasonCode, description, active }]`
2. **Search GL accounts**
   - Operation: `GET /accounting/gl-accounts?query=...&active=true` (placeholder)
   - Returns: `[{ glAccountId, accountCode, name, type, active }]`
3. **Get Journal Entry by id**
   - Operation: `GET /accounting/journal-entries/{journalEntryId}` (placeholder)
   - Returns: JE header + lines + status + audit fields.

### Create/update calls
- None (no ‚Äúsave draft‚Äù defined).

### Submit/transition calls
1. **Create and post manual JE**
   - Operation: `POST /accounting/journal-entries/manual:post` (placeholder)
   - Request body: header + lines
   - Response: `{ journalEntryId, status: "POSTED" }` plus full entity optionally.

### Error handling expectations
- 400 validation errors include machine-readable code(s) listed in Business Rules section.
- 403 for insufficient permissions.
- 409 for state/immutability conflicts (e.g., attempting to modify POSTED, if such endpoint exists).
- Network/timeouts: show retry-able error message and keep form state.

---

## 10. State Model & Transitions

### Allowed states (as visible to frontend)
- `POSTED` (required by story)
- Other possible states referenced by backend: `REVERSED` (mentioned conceptually)
- Unknown states: display as read-only with status badge.

### Role-based transitions
- Authorized user can perform: `Create ‚Üí Post` (single action).
- No UI supports `Edit` or `Delete` after `POSTED`.

### UI behavior per state
- **Create (local draft)**: editable, validations active.
- **POSTED (server)**: view-only; show status and immutable notice.

---

## 11. Alternate / Error Flows

### Validation failures (client-side)
- Missing header fields: highlight required fields, prevent submit.
- Less than 2 lines: show message ‚ÄúAt least two lines are required.‚Äù
- Per-line invalidity: show line-level error and prevent submit.
- Unbalanced totals: show difference prominently, prevent submit.

### Server-side validation failures
- Show error banner with mapped message.
- Keep user inputs intact for correction.
- If backend returns field-specific errors, map them to specific fields/lines where possible.

### Concurrency conflicts
- Not applicable for create-only flow; if backend indicates duplicate/idempotency conflict, show error and provide support reference (see Open Questions on idempotency).

### Unauthorized access
- If user lacks permission:
  - Hide navigation entry if possible (based on frontend auth model).
  - If direct URL access: show ‚ÄúNot authorized‚Äù screen/message.

### Empty states
- No reason codes returned: disable submit and show ‚ÄúNo reason codes configured; contact administrator.‚Äù
- No GL accounts found for search: show ‚ÄúNo accounts match your search.‚Äù

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: Successful creation and posting of a balanced manual JE
**Given** an authenticated user with permission to create manual journal entries  
**And** the accounting period for the selected posting date is Open  
**When** the user enters a posting date, description, and selects a reason code  
**And** the user adds at least two lines with valid GL accounts  
**And** the total debits equal the total credits  
**And** the user clicks ‚ÄúPost Journal Entry‚Äù  
**Then** the frontend submits the JE to the backend  
**And** the user is redirected to a Journal Entry view screen for the created JE  
**And** the JE status is displayed as `POSTED`  
**And** no edit/delete controls are available on the posted JE view.

### Scenario 2: Client blocks posting when entry is unbalanced
**Given** an authenticated user is on the Create Manual JE screen  
**When** the user enters lines where total debits do not equal total credits  
**Then** the UI shows the debit total, credit total, and a non-zero difference  
**And** the ‚ÄúPost Journal Entry‚Äù action is disabled  
**And** the user cannot submit until the difference is zero.

### Scenario 3: Server rejects posting date in a closed period
**Given** an authenticated user with permission to create manual journal entries  
**And** the user enters a posting date that is in a Closed accounting period  
**And** the entry is otherwise balanced and valid client-side  
**When** the user clicks ‚ÄúPost Journal Entry‚Äù  
**Then** the backend returns an error indicating the period is closed  
**And** the frontend displays an error message stating posting is not allowed in a closed period  
**And** the user‚Äôs entered form values remain available for correction.

### Scenario 4: Server rejects invalid or inactive GL account
**Given** an authenticated user is creating a manual JE  
**When** the user submits an entry containing a GL account that is invalid or inactive  
**Then** the backend returns an invalid-account validation error  
**And** the frontend displays an error message indicating an account is invalid/inactive  
**And** the entry is not posted.

### Scenario 5: Posted JEs are immutable in the UI
**Given** a user navigates to a Journal Entry that is `POSTED`  
**When** the Journal Entry view loads  
**Then** all fields are displayed read-only  
**And** no UI actions to edit or delete the JE are present  
**And** if the user attempts to access any edit route (if it exists), the UI blocks it and shows an ‚Äúimmutable‚Äù message.

---

## 13. Audit & Observability

### User-visible audit data
On the JE View screen display (if provided by backend):
- `journalEntryId`
- `status`
- `transactionDate` (created timestamp)
- `createdBy` (user id or name)
- `postingDate`
- reason code + description (if reason code metadata available)

### Status history
- Not required unless backend provides. If available, show status history table (status, changedAt, changedBy).

### Traceability expectations
- After posting, the JE identifier must be visible and copyable.
- Frontend logs (console/telemetry if configured) should include `journalEntryId` on success and error code on failure (avoid sensitive data).

---

## 14. Non-Functional UI Requirements
- **Performance**: GL account lookup must be searchable; avoid loading entire chart if large.
- **Accessibility**: All form controls labeled; error messages associated to fields; keyboard operable line grid.
- **Responsiveness**: Works on typical POS tablet widths; line-entry table should scroll horizontally if needed.
- **i18n/timezone/currency**:
  - postingDate uses user locale date input but submits an unambiguous date (ISO).
  - Money inputs display currency consistent with business unit/currency context (currency selection not defined; see Open Questions).

---

## 15. Applied Safe Defaults
- **SD-UX-EMPTY-STATE-01**: Provide explicit empty-state messaging for missing reason codes / no GL accounts found; qualifies as safe UI ergonomics; impacts UX Summary, Error Flows.
- **SD-UX-SEARCH-LOOKUP-01**: Use typeahead/search for GL account selection to avoid large payloads; qualifies as safe performance/ergonomics; impacts UX Summary, Service Contracts.
- **SD-ERR-MAP-01**: Standard mapping of backend validation/permission errors to inline/banner UI messages; qualifies as safe error-handling boilerplate; impacts Business Rules, Error Flows, Acceptance Criteria.

---

## 16. Open Questions
1. **Backend/Moqui contract**: What are the exact Moqui screen paths, service names, and/or REST endpoints for:
   - reason code list,
   - GL account search,
   - create+post manual JE,
   - JE retrieval by id?
2. **Permissions**: What is the authoritative permission string (frontend auth check) for creating manual JEs? Backend reference uses `ACCOUNTING_ADJUSTMENT_CREATE`; confirm mapping used in this Moqui frontend.
3. **Reason code source**: Is `reasonCode` an enum in Moqui, an entity list (e.g., `ReasonCode`), or pulled from another service? Is it scoped by business unit?
4. **Money & currency**: What currency applies to the JE? Is it implicitly the business unit‚Äôs base currency (`currencyUomId`) or user-selected? How should rounding/scale be enforced client-side?
5. **Line amount rules**: Are zero-amount lines allowed? Must exactly one of debit/credit be **> 0** vs allowing 0 with the other side set?
6. **Error code taxonomy**: What exact error codes/messages does the backend return for:
   - unbalanced,
   - period closed,
   - invalid account,
   - missing required fields,
   - immutable record?
7. **Draft vs post**: Is there a concept of saving a JE in DRAFT before posting (two-step), or is it strictly ‚Äúcreate and post‚Äù in one action?
8. **Idempotency**: Does the create/post endpoint support idempotency keys to prevent double-posting if the user retries after a timeout? If yes, what header/key should frontend send?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Adjustments: Create Manual Journal Entry with Controls  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/190  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Adjustments: Create Manual Journal Entry with Controls

**Domain**: user

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Period Close, Adjustments, and Reporting

## Story
Adjustments: Create Manual Journal Entry with Controls

## Acceptance Criteria
- [ ] Authorized users can create manual JEs with reason code
- [ ] System blocks unbalanced manual JEs
- [ ] Posted manual JEs are immutable (corrections via reversal)
- [ ] Posting respects period controls and audit requirements


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #191: [FRONTEND] [STORY] Close: Open/Close Accounting Periods with Locks  
File: ./scripts/story-work/frontend/191/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Accounting Periods: Create / Close / Reopen with Posting Locks (per Business Unit)

### Primary Persona
Finance / Accounting Manager (with period management permissions)

### Business Value
Enforce deterministic posting controls by accounting period per business unit, protect financial reporting integrity, and provide auditable exception handling for reopening closed periods.

---

## 2. Story Intent

### As a / I want / So that
**As a** Finance / Accounting Manager,  
**I want** to create, close, and (with elevated permission) reopen accounting periods per business unit,  
**so that** postings are blocked in closed periods unless explicitly reopened with an audit reason.

### In-scope
- Frontend screens to:
  - list/filter accounting periods by business unit and date range
  - create accounting periods with non-overlap validation feedback
  - close an open period
  - reopen a closed period with mandatory reason and elevated permission gate
  - view audit/history for period actions (create/close/reopen)
- Frontend handling of ‚Äúposting blocked because period closed‚Äù errors (surface deterministic error message/code to user).

### Out-of-scope
- Implementing backend posting enforcement logic itself (frontend only consumes and displays errors).
- Defining GL accounts, posting rules, or journal entry behavior.
- Designing business unit master data (frontend only selects an existing business unit reference).
- Reporting UI beyond the period/audit views.

---

## 3. Actors & Stakeholders

### Actors
- **Accounting Manager**: can create and close periods.
- **Privileged Accounting Manager / Controller**: can reopen periods (requires special permission).
- **Auditor / Finance Reviewer**: reads period history/audit events.
- **System (Moqui app)**: enforces permissions and displays backend validation errors.

### Stakeholders
- Finance/Accounting leadership (controls and auditability)
- Operations (impacts ability to post transactions)
- Engineering (screen/service wiring, permission gating)
- Compliance/audit (exception logging for reopen)

---

## 4. Preconditions & Dependencies

### Preconditions
- User authentication is available in Moqui.
- Permission concepts exist and are checkable in UI (names TBD; see Open Questions).
- A Business Unit concept exists and is selectable (entity + id + display name).

### Dependencies (backend/API)
The frontend needs backend endpoints/services to:
- list periods (by businessUnitId, date filters)
- create period (validate overlap)
- close period
- reopen period (requires reason + permission)
- fetch audit/history for a period (or embedded history in period detail)

If these contracts do not exist yet, this frontend story is blocked until confirmed.

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main navigation: **Accounting ‚Üí Periods** (exact menu location TBD by app conventions)

### Screens to create/modify (Moqui)
1. **`AccountingPeriods`** (list)
   - search/filter form + results grid
2. **`AccountingPeriodDetail`** (view + actions)
   - period header fields
   - action buttons: Close / Reopen (conditional)
   - history/audit section
3. **`AccountingPeriodCreate`** (create form)
   - business unit + date range fields
4. (Optional) modal dialogs implemented as separate subscreens or screen dialogs:
   - Close confirmation
   - Reopen dialog (requires reason)

### Navigation context
- From list ‚Üí click period row ‚Üí detail screen
- From list ‚Üí ‚ÄúCreate Period‚Äù ‚Üí create screen ‚Üí success redirects to detail
- From detail ‚Üí Close/Reopen actions remain on detail and refresh state/history

### User workflows

#### Happy path: create period
1. User opens Accounting Periods list
2. Clicks Create Period
3. Selects Business Unit, Start Date, End Date
4. Submits
5. Sees created period in detail as **OPEN**

#### Happy path: close period
1. User opens an OPEN period detail
2. Clicks Close Period
3. Confirms
4. Period becomes **CLOSED**; close metadata visible (who/when)

#### Happy path: reopen period
1. Privileged user opens a CLOSED period detail
2. Clicks Reopen Period
3. Enters mandatory reason and confirms
4. Period becomes **OPEN**; reopen audit entry visible (who/when/why)

#### Alternate: posting blocked by closed period
- When user attempts a posting flow elsewhere in the app and backend responds with period-closed error, UI shows a deterministic error that references:
  - business unit
  - transaction date (if available)
  - period status = CLOSED
  - next action: contact finance or request reopen (no reopen action from that screen unless already implemented)

---

## 6. Functional Behavior

### Triggers
- Screen load triggers fetch/list calls.
- Form submit triggers create/close/reopen service calls.
- Backend errors trigger UI error mapping.

### UI actions
- **List screen**
  - Select business unit filter (required to avoid cross-BU ambiguity; if not possible, see Open Questions)
  - Optional date filters (from/to) and status filter (OPEN/CLOSED/ALL)
  - Open detail from row click
- **Create screen**
  - Input: businessUnitId, startDate, endDate
  - Submit/cancel
- **Detail screen**
  - Display: businessUnit, start/end (inclusive), status, created metadata, closed metadata (if any)
  - Close button visible only when status=OPEN and user has manage permission
  - Reopen button visible only when status=CLOSED and user has reopen permission
  - Audit/history visible read-only

### State changes (frontend-visible)
- Status transitions reflected immediately after successful service response:
  - OPEN ‚Üí CLOSED
  - CLOSED ‚Üí OPEN
- History section refreshes after transitions.

### Service interactions (Moqui)
- Use screen `actions` to call services for:
  - list/load
  - create
  - close
  - reopen (requires reason)

---

## 7. Business Rules (Translated to UI Behavior)

### Validation (client-side, then server-side authoritative)
- **Create Period**
  - businessUnitId: required
  - startDate: required
  - endDate: required
  - startDate <= endDate (client-side validation)
  - Non-overlap with existing periods for the business unit (server-side validation; UI must render conflict clearly)
- **Close Period**
  - Allowed only if current status is OPEN (UI hides/disabled if not)
- **Reopen Period**
  - Allowed only if current status is CLOSED
  - Requires elevated permission (UI hides action if lacking permission)
  - **Reason is mandatory** (client-side required, server enforces)
  - Reason min/max length is undefined ‚Üí must be confirmed; UI should enforce whatever backend returns.

### Enable/disable rules
- Disable submit while service call in flight.
- Disable Close/Reopen buttons while action in flight to prevent double submits.
- In detail view, actions must re-check current status from latest loaded data (avoid stale UI).

### Visibility rules
- Reopen action only visible if user has `ACCOUNTING_PERIOD_REOPEN` (name TBD) and period is CLOSED.
- Close action only visible if user has `ACCOUNTING_PERIOD_MANAGE` (name TBD) and period is OPEN.

### Error messaging expectations
- Overlap conflict: show message like ‚ÄúDate range overlaps an existing period for this business unit.‚Äù Include conflicting period identifiers/date range if returned.
- Period closed posting error: show deterministic message and preserve backend error code (e.g., `ERR_ACCOUNTING_PERIOD_CLOSED`).
- Unauthorized: show ‚ÄúYou do not have permission to perform this action.‚Äù Preserve HTTP 403.
- Concurrency conflict (optimistic locking or stale update): show ‚ÄúThis period was changed by another user. Refresh and try again.‚Äù

---

## 8. Data Requirements

### Entities involved (frontend perspective)
- `AccountingPeriod`
- `BusinessUnit` (or equivalent entity representing business unit)
- `User` (for display of closedBy/reopenedBy if returned)
- `PeriodReopenAuditEvent` or generic audit log entity (naming TBD)

### Fields (type, required, defaults)

#### AccountingPeriod (minimum required for UI)
- `accountingPeriodId` (string/UUID) ‚Äî required, read-only
- `businessUnitId` (string/UUID) ‚Äî required, editable on create only
- `businessUnitName` (string) ‚Äî read-only (derived via join)
- `startDate` (date) ‚Äî required, editable on create only (unless backend allows edits; not specified)
- `endDate` (date) ‚Äî required, editable on create only
- `status` (enum: `OPEN`, `CLOSED`) ‚Äî read-only except via transitions
- `createdAt` (datetime) ‚Äî read-only
- `createdByUserId` (string) ‚Äî read-only
- `closedAt` (datetime, nullable) ‚Äî read-only
- `closedByUserId` (string, nullable) ‚Äî read-only
- `updatedAt` (datetime) ‚Äî read-only
- `updatedByUserId` (string) ‚Äî read-only
- `version` or `lastUpdatedStamp` (if used for optimistic locking) ‚Äî read-only but submitted back on transitions if required by backend

#### Reopen audit event (for display)
- `eventId` (string/UUID) ‚Äî read-only
- `accountingPeriodId` ‚Äî read-only
- `action` (enum/string: CREATED/CLOSED/REOPENED) ‚Äî read-only
- `actorUserId` ‚Äî read-only
- `occurredAt` ‚Äî read-only
- `reason` (text, nullable except required for REOPENED) ‚Äî read-only
- `clientIpAddress` (string, optional) ‚Äî read-only (display optional)

### Read-only vs editable by state/role
- Only create form fields are editable (businessUnitId, startDate, endDate).
- Close/Reopen are transitions only (no direct edit of status).
- Reason is editable only within the reopen action dialog and not stored on period itself unless backend does so (unknown).

### Derived/calculated fields
- Display label ‚ÄúPeriod: YYYY-MM-DD to YYYY-MM-DD‚Äù
- Status badge from `status`
- ‚ÄúLocked for posting‚Äù derived as `status == CLOSED`

---

## 9. Service Contracts (Frontend Perspective)

> Backend endpoints/service names are not provided in inputs. The frontend must integrate with Moqui services; exact service names/paths require confirmation. Below are required contracts, not invented definitive names.

### Load/view calls
1. **List periods**
   - Input: `businessUnitId` (recommended required), optional `status`, optional `fromDate`, `toDate`, pagination
   - Output: list of `AccountingPeriod` summary fields
2. **Get period detail**
   - Input: `accountingPeriodId`
   - Output: full `AccountingPeriod` + optionally history entries
3. **Get period audit/history** (if not embedded)
   - Input: `accountingPeriodId`
   - Output: ordered events (desc by occurredAt)

### Create/update calls
4. **Create period**
   - Input: `businessUnitId`, `startDate`, `endDate`
   - Output: created `accountingPeriodId` and resulting record

### Submit/transition calls
5. **Close period**
   - Input: `accountingPeriodId` (+ optimistic lock token if required)
   - Output: updated record
6. **Reopen period**
   - Input: `accountingPeriodId`, `reason` (+ optimistic lock token if required)
   - Output: updated record + audit event reference (optional)

### Error handling expectations (mapping)
- `400 Bad Request`: validation errors (missing reason, start>end)
- `403 Forbidden`: permission denied
- `409 Conflict`: overlap on create OR period already in target state OR optimistic lock conflict
- Domain-specific error code expected for posting rejection:
  - `ERR_ACCOUNTING_PERIOD_CLOSED` (from backend reference); UI must surface code + friendly message

Moqui screen actions must capture these errors and present them via standard message rendering used in the project.

---

## 10. State Model & Transitions

### Allowed states (AccountingPeriod.status)
- `OPEN`
- `CLOSED`

### Transitions
- `OPEN` ‚Üí `CLOSED` via **Close Period**
  - Permission: `ACCOUNTING_PERIOD_MANAGE` (name TBD)
- `CLOSED` ‚Üí `OPEN` via **Reopen Period**
  - Permission: `ACCOUNTING_PERIOD_REOPEN` (name TBD)
  - Requires: reason (non-empty)

### UI behavior per state
- OPEN:
  - Show ‚ÄúClose Period‚Äù if permitted
  - Hide ‚ÄúReopen Period‚Äù
  - Indicate posting allowed
- CLOSED:
  - Show ‚ÄúReopen Period‚Äù if permitted
  - Hide ‚ÄúClose Period‚Äù
  - Indicate posting locked/blocked for dates in range

---

## 11. Alternate / Error Flows

### Validation failures
- Create with missing fields ‚Üí inline field errors + no request (client-side)
- Create overlap detected server-side ‚Üí show non-field error at top + keep form values
- Reopen without reason ‚Üí inline reason error, no request (client-side)

### Concurrency conflicts
- If close/reopen returns conflict indicating stale version:
  - show message ‚ÄúPeriod was updated by another user‚Äù
  - provide ‚ÄúReload‚Äù action on the detail screen

### Unauthorized access
- If user navigates directly to create/detail URL without permission:
  - screen should show 403-style message and not render action controls
  - do not leak data if backend denies load

### Empty states
- List with no periods ‚Üí show empty-state guidance: ‚ÄúNo periods found for selected business unit/date range.‚Äù

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: List periods for a business unit
**Given** I am authenticated  
**And** I have permission to view accounting periods  
**When** I open the Accounting Periods screen and select a business unit  
**Then** I see a list of accounting periods for that business unit  
**And** each row shows start date, end date, and status  

### Scenario 2: Create an accounting period successfully
**Given** I am authenticated  
**And** I have permission to manage accounting periods  
**When** I create a period for business unit ‚ÄúBU-1‚Äù with start date ‚Äú2026-01-01‚Äù and end date ‚Äú2026-01-31‚Äù  
**Then** the period is created with status ‚ÄúOPEN‚Äù  
**And** I am navigated to the period detail screen  
**And** the detail screen shows the correct business unit and date range  

### Scenario 3: Reject creating an overlapping accounting period
**Given** an accounting period exists for business unit ‚ÄúBU-1‚Äù from ‚Äú2026-01-01‚Äù to ‚Äú2026-01-31‚Äù  
**And** I have permission to manage accounting periods  
**When** I attempt to create another period for ‚ÄúBU-1‚Äù from ‚Äú2026-01-15‚Äù to ‚Äú2026-02-15‚Äù  
**Then** the system rejects the request with a conflict error  
**And** the UI displays a non-overlap validation message  
**And** the form remains editable with my entered values preserved  

### Scenario 4: Close an open period successfully
**Given** I am authenticated  
**And** I have permission to manage accounting periods  
**And** an accounting period exists with status ‚ÄúOPEN‚Äù  
**When** I click ‚ÄúClose Period‚Äù and confirm  
**Then** the period status becomes ‚ÄúCLOSED‚Äù  
**And** the UI displays closed metadata (closed by, closed at) if provided by the backend  
**And** the ‚ÄúClose Period‚Äù action is no longer available  

### Scenario 5: Reopen a closed period with reason (authorized)
**Given** I am authenticated  
**And** I have permission to reopen accounting periods  
**And** an accounting period exists with status ‚ÄúCLOSED‚Äù  
**When** I click ‚ÄúReopen Period‚Äù  
**And** I enter the reason ‚ÄúCorrecting mis-categorized invoice #123‚Äù  
**And** I confirm the reopen action  
**Then** the period status becomes ‚ÄúOPEN‚Äù  
**And** the period history/audit section includes a ‚ÄúREOPENED‚Äù entry with my user and reason  

### Scenario 6: Reopen a closed period without reason (client validation)
**Given** I am authenticated  
**And** I have permission to reopen accounting periods  
**And** an accounting period exists with status ‚ÄúCLOSED‚Äù  
**When** I click ‚ÄúReopen Period‚Äù and submit without a reason  
**Then** the UI prevents submission  
**And** the reason field shows a required validation error  

### Scenario 7: Reopen denied without permission
**Given** I am authenticated  
**And** I do not have permission to reopen accounting periods  
**And** an accounting period exists with status ‚ÄúCLOSED‚Äù  
**When** I view the period detail screen  
**Then** I do not see the ‚ÄúReopen Period‚Äù action  
**And** if I attempt to call reopen (e.g., via direct request), I receive a 403 error and the UI shows a permission error  

### Scenario 8: Posting attempt blocked by closed period is shown deterministically
**Given** an accounting period for business unit ‚ÄúBU-1‚Äù is ‚ÄúCLOSED‚Äù for dates including ‚Äú2026-01-10‚Äù  
**When** I attempt a posting operation elsewhere in the app for business unit ‚ÄúBU-1‚Äù with transaction date ‚Äú2026-01-10‚Äù  
**And** the backend responds with error code ‚ÄúERR_ACCOUNTING_PERIOD_CLOSED‚Äù  
**Then** the UI shows an error message indicating posting is blocked due to a closed accounting period  
**And** the UI displays or logs the backend error code ‚ÄúERR_ACCOUNTING_PERIOD_CLOSED‚Äù  

---

## 13. Audit & Observability

### User-visible audit data
- Period detail must display a history list including:
  - created (who/when)
  - closed (who/when)
  - reopened (who/when/why)
- For reopen, display the reason text.

### Status history
- Must be ordered by occurredAt descending.
- Must be refreshable after an action without full page reload (screen rerender is acceptable).

### Traceability expectations
- Frontend logs (where project supports it) should include:
  - `accountingPeriodId`
  - action name (CREATE/CLOSE/REOPEN)
  - correlation/request id if available from Moqui
- Do not log sensitive free-text beyond what is required; reason text should not be echoed to console logs in production if that violates policy (policy not provided ‚Üí see Open Questions).

---

## 14. Non-Functional UI Requirements

### Performance
- List view should load within 2 seconds for typical business unit period counts (assume < 200); if pagination exists, fetch first page only.

### Accessibility
- All actions must be keyboard accessible.
- Dialogs must trap focus and provide accessible labels for confirm/cancel and reason field.
- Validation errors must be announced (aria-live) per Quasar defaults.

### Responsiveness
- List and detail usable on tablet widths used in POS back-office.
- Action buttons should collapse into a menu on narrow screens (implementation detail allowed by UI library).

### i18n/timezone/currency
- Dates displayed in the user‚Äôs locale/timezone as configured in the app.
- No currency behavior involved.

---

## 15. Applied Safe Defaults

- SD-UX-EMPTY-STATE: Provide a standard empty-state message and ‚ÄúCreate Period‚Äù CTA on the list screen; qualifies as safe because it does not alter domain policy, only improves usability. (Impacted sections: UX Summary, Alternate/Empty states)
- SD-UX-INFLIGHT-DISABLE: Disable submit/action buttons during in-flight requests to prevent duplicate actions; qualifies as safe because it is UI-only idempotency protection. (Impacted sections: Functional Behavior, Error Flows)
- SD-ERR-STANDARD-MAPPING: Map 400/403/409 to inline vs banner errors consistently; qualifies as safe because it only renders backend outcomes without changing business rules. (Impacted sections: Service Contracts, Business Rules, Error Flows)

---

## 16. Open Questions

1. **Backend service contracts (blocking):** What are the exact Moqui service names and request/response shapes for:
   - list periods, get detail, create, close, reopen, and fetch audit/history?
2. **Permissions (blocking):** Confirm the permission identifiers and how the frontend should check them (e.g., `ACCOUNTING_PERIOD_MANAGE`, `ACCOUNTING_PERIOD_REOPEN`, or different names).
3. **Business Unit entity (blocking):** What entity represents a ‚ÄúBusiness Unit‚Äù in this system (e.g., `Organization`, `Party`, `Facility`, `Store/Location`), and what fields should be displayed/selected in the UI?
4. **Edit policy (blocking):** Are start/end dates editable after creation while OPEN, or immutable once created? Current story assumes create-only.
5. **Audit/history source (blocking):** Is period history returned as part of period detail, or via a separate endpoint/entity? What fields are available (reason, clientIp, actor display name)?
6. **Reopen reason constraints:** Are there min/max length, allowed characters, or required templates for the reopen reason?
7. **Posting-blocked UX integration:** Which existing posting flows in the frontend must surface `ERR_ACCOUNTING_PERIOD_CLOSED` (and where), or is this story limited to period management screens only?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Close: Open/Close Accounting Periods with Locks  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/191  
Labels: frontend, story-implementation, reporting

## Frontend Implementation for Story

**Original Story**: [STORY] Close: Open/Close Accounting Periods with Locks

**Domain**: reporting

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Period Close, Adjustments, and Reporting

## Story
Close: Open/Close Accounting Periods with Locks

## Acceptance Criteria
- [ ] Periods can be created and closed per business unit
- [ ] Closed periods block posting unless reopened with permission
- [ ] Reopen requires reason and is audit-logged
- [ ] Posting logic enforces period policy deterministically


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #193: [FRONTEND] [STORY] AP: Approve and Schedule Payments with Controls  
File: ./scripts/story-work/frontend/193/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

STOP: Clarification required before finalization

---

# 1. Story Header

## Title
[FRONTEND] [STORY] AP: Approve and Schedule Payments with Controls

## Primary Persona
- AP Clerk
- AP Manager

## Business Value
Enable controlled, auditable progression of Bills from Draft to Approved to Scheduled, enforcing approval thresholds and permissions so the organization pays vendors accurately and reduces fraud/unauthorized disbursements.

---

# 2. Story Intent

## As a / I want / So that
**As an** AP Clerk or AP Manager,  
**I want** to approve Draft bills and schedule Approved bills for payment from the POS frontend,  
**so that** AP obligations can be managed with appropriate controls, audit trail, and readiness for payment execution.

## In-scope
- View bill details including current status and relevant audit fields.
- Perform **Approve** action on `DRAFT` bills (if authorized and within threshold).
- Perform **Schedule Payment** action on `APPROVED` bills (if authorized), capturing `scheduledFor` and `paymentMethod`.
- Display server validation/authorization/threshold errors clearly.
- Display bill status history/audit entries related to approval and scheduling (read-only).

## Out-of-scope
- Executing payments (owned by `domain:payment`).
- Editing bill header/lines, vendor data, or bill creation flow (unless already exists; not defined here).
- Configuration UI for approval policy/thresholds (owned by accounting configuration; not requested).
- Downstream payment outcome handling (`Payment.Executed.v1`, `Payment.Failed.v1`) UI (not requested here).

---

# 3. Actors & Stakeholders

## Actors
- **AP Clerk**: prepares bills; may request approval; may schedule if permitted.
- **AP Manager**: approves bills (higher thresholds); may schedule payments.
- **System (Moqui app)**: enforces status prerequisites, permission checks, threshold checks; records audit entries.

## Stakeholders
- **Finance/AP leadership**: needs controlled approval and cashflow scheduling.
- **Auditors/Compliance**: require immutable, queryable audit trail.
- **Payments/Treasury team**: relies on scheduled payments being valid and approved.

---

# 4. Preconditions & Dependencies

## Preconditions
- A Bill exists and is retrievable by `billId`.
- Bill has a status in `{DRAFT, APPROVED, SCHEDULED, ...}`.
- User is authenticated in the frontend and has server-evaluated permissions.

## Dependencies
- Backend capability for:
  - Loading bill details (including status, amount, vendor, and audit-related fields).
  - Approving a bill: transition `DRAFT ‚Üí APPROVED` with threshold validation and audit entry.
  - Scheduling a bill: transition `APPROVED ‚Üí SCHEDULED` capturing schedule inputs, audit entry, and emitting `Accounting.PaymentScheduled.v1`.

## Blocking dependency (needs clarification)
- Concrete Moqui service names/endpoints and entity names used by this frontend project are not provided in the inputs (see **Open Questions**).

---

# 5. UX Summary (Moqui-Oriented)

## Entry points
- From an AP Bills list screen (if exists): select a bill ‚Üí navigate to Bill Detail.
- Direct route deep link: `/ap/bills/:billId` (proposed; must align with repo conventions‚Äîclarification needed).

## Screens to create/modify
1. **Bill List Screen (optional / if exists)**  
   - Add visible status badges and row actions or a ‚ÄúDetails‚Äù navigation.
2. **Bill Detail Screen (required)**  
   - Summary section (read-only): billNumber, vendor, amount, currency, status.
   - Actions panel (contextual):
     - `Approve` button visible/enabled only when bill is `DRAFT` and user has permission.
     - `Schedule Payment` button visible/enabled only when bill is `APPROVED` and user has permission.
   - Schedule dialog/form (on Schedule action): fields for `scheduledFor`, `paymentMethod` (+ instrumentId if required).
   - Audit/history panel (read-only): approval and scheduling audit entries.

## Navigation context
- Breadcrumb: AP ‚Üí Bills ‚Üí Bill {billNumber}
- After successful transitions, remain on Bill Detail and refresh state from backend (show updated status and audit entries).

## User workflows

### Happy path A: Approve bill
1. User opens Bill Detail (status `DRAFT`).
2. Clicks **Approve**.
3. Frontend confirms intent (optional) and submits approve request.
4. On success: status updates to `APPROVED`, approval audit is visible.

### Happy path B: Schedule payment
1. User opens Bill Detail (status `APPROVED`).
2. Clicks **Schedule Payment**.
3. User enters `scheduledFor` and `paymentMethod` (and instrument if applicable).
4. Submit schedule request.
5. On success: status updates to `SCHEDULED`, scheduling audit visible; display paymentId (read-only) if returned.

### Alternate path: Not authorized or exceeds threshold
- Server rejects; UI shows error banner and keeps bill state unchanged.

---

# 6. Functional Behavior

## Triggers
- Screen load: Bill Detail is opened.
- User actions: Approve button click; Schedule Payment submit.

## UI actions
- **Load bill** on screen init and after any successful transition.
- **Approve**
  - Prompt (optional): ‚ÄúApprove this bill?‚Äù with billNumber and amount.
  - Submit approve request.
- **Schedule**
  - Open modal form with fields.
  - Validate required fields client-side (presence and basic format only).
  - Submit schedule request.

## State changes (frontend perspective)
- Optimistic UI is **not** permitted for financial state; update only after server success.
- After server success:
  - Refresh bill state from backend
  - Update action button availability based on returned status

## Service interactions
- `bill/load`: fetch details, including current status and audit info.
- `bill/approve`: transition to APPROVED (server enforces permissions + threshold).
- `bill/schedulePayment`: transition to SCHEDULED with schedule fields (server enforces permissions + state prerequisite).

(Exact service names/paths must be confirmed; see Open Questions.)

---

# 7. Business Rules (Translated to UI Behavior)

## Validation
- Approve action:
  - UI must only offer Approve when status is `DRAFT`.
  - Server is authoritative for:
    - permission (`approve`)
    - threshold policy (approval limit)
- Schedule action:
  - UI must only offer Schedule when status is `APPROVED`.
  - Client-side required-field validation:
    - `scheduledFor` is required and must be a valid date.
    - `paymentMethod.type` is required.
    - `paymentMethod.instrumentId` required **only if** backend contract requires it for selected type (needs clarification).

## Enable/disable rules
- Disable all action buttons while a transition request is in-flight.
- Disable Approve button if bill status ‚â† `DRAFT`.
- Disable Schedule button if bill status ‚â† `APPROVED`.

## Visibility rules
- Hide actions entirely if user lacks permission (preferred) OR show disabled with tooltip ‚ÄúNot authorized‚Äù (needs project convention; clarify).
- Audit panel always visible if data exists; otherwise show ‚ÄúNo audit events yet.‚Äù

## Error messaging expectations
- Authorization failures: show ‚ÄúYou are not authorized to approve/schedule this bill.‚Äù Include backend error code if provided.
- Threshold failure: show ‚ÄúApproval amount exceeds your approval limit.‚Äù Include limit/required role only if backend returns safe details.
- Invalid state transition: show ‚ÄúBill must be Approved before it can be scheduled.‚Äù
- Generic: show ‚ÄúUnable to complete action. Try again or contact support.‚Äù

---

# 8. Data Requirements

## Entities involved (frontend view models)
> Note: Backend entity names are not provided; below is the required data contract for UI.

### Bill
- `billId` (UUID, required, read-only)
- `billNumber` (string, required, read-only)
- `vendorId` (UUID, required, read-only)
- `vendorName` (string, required for UI display, read-only) **(if available)**
- `status` (enum, required, read-only): `DRAFT`, `APPROVED`, `SCHEDULED`, (others allowed but treated read-only)
- `amount.value` (decimal, required, read-only)
- `amount.currencyUomId` (string, required, read-only)
- `approvedByUserId` (UUID, nullable, read-only)
- `approvedAt` (timestamp, nullable, read-only)

### Scheduling (when status ‚â• SCHEDULED)
- `paymentId` (UUID, nullable until scheduled; read-only)
- `scheduledFor` (date, nullable until scheduled; read-only after scheduled)
- `paymentMethod.type` (string/enum, nullable until scheduled; read-only after scheduled)
- `paymentMethod.instrumentId` (string/UUID, nullable; read-only after scheduled)
- `scheduledByUserId` (UUID, nullable; read-only)
- `scheduledAt` (timestamp, nullable; read-only)

### Audit entries (read-only list)
- `auditId` (UUID/string, required)
- `billId` (UUID, required)
- `eventType` (string, required) e.g., `BILL_APPROVED`, `PAYMENT_SCHEDULED`
- `oldStatus` (string, required)
- `newStatus` (string, required)
- `principalUserId` (UUID, required)
- `occurredAt` (timestamp, required)
- `notes` (string, optional) (if exists)

## Derived/calculated fields (frontend-only)
- `canApprove` = (status == `DRAFT`) AND (permission flag from backend if provided; else UI only uses status and relies on server for permission)
- `canSchedule` = (status == `APPROVED`) AND (permission flag if provided)

---

# 9. Service Contracts (Frontend Perspective)

> Moqui implementations typically use screen transitions and services. Exact service names are not provided; define required interfaces below and map them to Moqui `service-call` / REST as implemented in this repo.

## Load/view calls
### Get Bill Detail
- **Request**: `{ billId }`
- **Response**: Bill object + (optional) audit list + (optional) permissions for current user (e.g., `allowedActions: ['APPROVE','SCHEDULE']`)

## Create/update calls
### Approve Bill
- **Request**: `{ billId }`
- **Response**: updated Bill (status `APPROVED`, approvedBy/approvedAt populated) and/or success flag

### Schedule Payment
- **Request**:
  - `{ billId, scheduledFor, paymentMethod: { type, instrumentId? } }`
- **Response**: updated Bill (status `SCHEDULED`, schedule fields populated incl `paymentId`) and/or success flag

## Submit/transition calls
- Treat approve and schedule as **commands** that may return `409 Conflict` for invalid state transitions and `403 Forbidden` for unauthorized.

## Error handling expectations
Frontend must map backend errors to user-visible messages:
- `403` or errorCode `UNAUTHORIZED` ‚Üí show authorization message
- `409` or errorCode `INVALID_STATE_TRANSITION` ‚Üí show state prerequisite message
- `422` or errorCode `APPROVAL_THRESHOLD_EXCEEDED` ‚Üí show threshold message
- `400/422` validation ‚Üí show field-level errors for schedule form when possible
- Network/5xx ‚Üí show retryable error banner; do not change UI state

(Exact error codes need confirmation; see Open Questions.)

---

# 10. State Model & Transitions

## Allowed states (in scope)
- `DRAFT`
- `APPROVED`
- `SCHEDULED`

Other states may exist; they are read-only for this story.

## Role-based transitions
- `DRAFT ‚Üí APPROVED`: requires permission for approval and passing threshold policy (server-side).
- `APPROVED ‚Üí SCHEDULED`: requires permission for scheduling (server-side).

## UI behavior per state
- `DRAFT`:
  - Show Approve action if permitted
  - Hide/disable Schedule action
- `APPROVED`:
  - Show Schedule action if permitted
  - Hide/disable Approve action
- `SCHEDULED`:
  - No approval/schedule actions
  - Show schedule details (paymentId, scheduledFor, method) read-only

---

# 11. Alternate / Error Flows

## Validation failures (schedule form)
- Missing `scheduledFor` ‚Üí inline error; block submit
- Missing `paymentMethod.type` ‚Üí inline error; block submit
- Invalid date format ‚Üí inline error; block submit

## Threshold exceeded on approval
- Server rejects; UI shows non-field error banner; keep status `DRAFT`.

## Concurrency conflicts
- If bill status changed since load (e.g., another user approved it):
  - Approve or Schedule call returns conflict
  - UI shows ‚ÄúBill was updated by another user; reloading.‚Äù
  - Auto-refresh bill details.

## Unauthorized access
- If user can load bill but cannot act:
  - Actions hidden/disabled; attempt via direct call results in server 403 and UI shows authorization error.

## Empty states
- Audit panel empty: show ‚ÄúNo audit events recorded yet.‚Äù
- Missing schedule details in `SCHEDULED` due to partial data: show ‚ÄúScheduling details unavailable‚Äù and log client error (without PII).

---

# 12. Acceptance Criteria

## Scenario 1: View bill details with contextual actions
**Given** I am an authenticated AP user  
**And** a bill exists with status `DRAFT`  
**When** I open the Bill Detail screen for that bill  
**Then** I can see billNumber, vendor, amount, currency, and status  
**And** I see an Approve action available (if I am authorized)  
**And** I do not see Schedule Payment available

## Scenario 2: Approve a draft bill successfully
**Given** I am authorized to approve bills and within my approval threshold  
**And** a bill exists in status `DRAFT`  
**When** I click Approve and confirm the action  
**Then** the frontend submits an approve request for that bill  
**And** on success the bill status updates to `APPROVED`  
**And** the approval audit entry is visible with approver and timestamp

## Scenario 3: Approval blocked due to threshold
**Given** I am authenticated  
**And** a bill exists in status `DRAFT`  
**And** the bill amount exceeds my approval threshold  
**When** I attempt to approve the bill  
**Then** the backend rejects the request  
**And** the frontend shows an error indicating the approval limit was exceeded  
**And** the bill remains in status `DRAFT`

## Scenario 4: Schedule payment successfully for approved bill
**Given** I am authorized to schedule payments  
**And** a bill exists in status `APPROVED`  
**When** I open Schedule Payment, enter a scheduled date and payment method, and submit  
**Then** the frontend submits the scheduling request  
**And** on success the bill status updates to `SCHEDULED`  
**And** scheduling audit entry is visible  
**And** a paymentId is displayed if returned by the backend

## Scenario 5: Scheduling blocked when bill not approved
**Given** I am authenticated  
**And** a bill exists in status `DRAFT`  
**When** I attempt to schedule payment for the bill  
**Then** the backend rejects the request  
**And** the frontend shows an error that the bill must be approved first  
**And** the bill remains in status `DRAFT`

## Scenario 6: Unauthorized approve/schedule
**Given** I am authenticated but not authorized to approve (or schedule)  
**And** a bill exists in the corresponding prerequisite status  
**When** I attempt the action  
**Then** the backend returns an authorization error  
**And** the frontend shows a ‚Äúnot authorized‚Äù message  
**And** no state change is shown in the UI

---

# 13. Audit & Observability

## User-visible audit data
- Bill detail shows:
  - `approvedByUserId` + `approvedAt` (if approved)
  - `scheduledByUserId` + `scheduledAt` + `scheduledFor` + `paymentMethod` (if scheduled)
- Audit list shows immutable events for status transitions with actor and timestamp.

## Status history
- Display chronological history of status changes (at least approval and scheduling).
- If backend provides only latest fields, UI must still show what is available; missing history triggers Open Question for audit API.

## Traceability expectations
- All UI actions log (client-side) structured info (no PII) for debugging:
  - `billId`, action (`approve` / `schedule`), result (`success` / `error`), backend errorCode if present.

---

# 14. Non-Functional UI Requirements

## Performance
- Bill Detail load time: target < 1s on typical network for average bill payload (excluding large attachments; not in scope).
- Action calls should show spinner/loading state immediately and prevent duplicate submissions.

## Accessibility
- Buttons and form controls must be keyboard accessible.
- Error messages must be announced to screen readers (use Quasar accessible components).

## Responsiveness
- Bill Detail usable on tablet width and above; mobile support acceptable but not required beyond responsive stacking.

## i18n/timezone/currency
- Display amount formatted using `currencyUomId`.
- Display timestamps in user locale/timezone (project convention; if not defined, use browser locale‚Äîneeds confirmation).
- `scheduledFor` is a **date** (not datetime); display and submit as date without timezone conversion.

---

# 15. Applied Safe Defaults

- SD-UX-EMPTY-STATE: Show explicit empty-state copy for missing audit/history; safe because it doesn‚Äôt alter domain behavior; impacts UX Summary, Alternate/Empty states.
- SD-UX-INFLIGHT-DISABLE: Disable actions while request in-flight to prevent double submit; safe UI ergonomics; impacts Functional Behavior, Error Flows.
- SD-ERR-MAP-GENERIC: Map unknown server/network errors to a generic retryable banner; safe because it avoids guessing business meaning; impacts Service Contracts, Error Flows.

---

# 16. Open Questions

1. **Moqui routing/screen conventions:** What is the correct screen path and URL pattern for AP Bill list/detail in `durion-moqui-frontend` (e.g., `/ap/bills`, `/ap/bills/:billId`), and should we modify an existing screen or create new?  
2. **Backend service/API contract:** What are the exact Moqui services (or REST endpoints) for:
   - load bill detail (including audit/history if available),
   - approve bill,
   - schedule payment?
3. **Error codes & response shapes:** What canonical error codes/messages does backend return for:
   - threshold exceeded,
   - invalid state transition,
   - unauthorized?
   (Needed for deterministic UI mapping and tests.)
4. **Payment method model:** What are allowed `paymentMethod.type` values and when is `instrumentId` required? Is there an API to list available instruments for the vendor/company?  
5. **Permission UX convention:** Should unauthorized actions be hidden entirely or shown disabled with tooltip? (Project-wide UX consistency.)
6. **Audit/history source:** Is there a dedicated audit endpoint/entity for Bill status transitions, or do we rely only on fields like `approvedAt/approvedBy` and `scheduledAt/scheduledBy`?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] AP: Approve and Schedule Payments with Controls  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/193  
Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] AP: Approve and Schedule Payments with Controls

**Domain**: payment

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Accounts Payable (Bill ‚Üí Payment)

## Story
AP: Approve and Schedule Payments with Controls

## Acceptance Criteria
- [ ] Bill workflow supports Draft ‚Üí Approved ‚Üí Scheduled
- [ ] Approval thresholds and role permissions enforced
- [ ] Payment scheduling records date/method and audit trail
- [ ] Payment execution blocked unless approved


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #194: [FRONTEND] [STORY] AP: Create Vendor Bill from Purchasing/Receiving Event  
File: ./scripts/story-work/frontend/194/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] AP: Create & Review Vendor Bill Created from Purchasing/Receiving Event

### Primary Persona
AP Clerk (Accounts Payable)

### Business Value
Ensure vendor liabilities created from upstream receiving/invoice events are reviewable, traceable, and ready for downstream approval/payment, with clear idempotency/duplicate visibility and audit links (event ‚Üî bill ‚Üî journal entry preview).

---

## 2. Story Intent

### As a / I want / So that
**As an** AP Clerk,  
**I want** a UI to find and open a Vendor Bill that was automatically created from a Goods Received or Vendor Invoice Received event,  
**So that** I can verify the bill details, confirm traceability to the source event and staged GL impact, and route issues (duplicates/invalid references) to investigation.

### In-scope
- Read-only review UI for system-created Vendor Bills originating from:
  - `GoodsReceivedEvent` and/or `VendorInvoiceReceivedEvent` (final trigger policy TBD)
- Ability to search/list Vendor Bills by vendor, PO, source event id, vendor invoice reference, status, date range
- Bill detail view including:
  - header fields, line items, totals
  - traceability links (source event, PO/receipt refs)
  - staged GL impact preview (Dr inventory/expense, Cr AP) as displayed data (no posting configuration editing)
  - idempotency/duplicate indicators (where available)
- Standard error handling and empty states

### Out-of-scope
- Creating/editing Vendor Bills manually
- Approving, paying, voiding bills
- Defining GL accounts, posting categories, or posting rule sets
- Implementing event ingestion (backend responsibility)
- Three-way match resolution workflow beyond displaying discrepancies (policy TBD)

---

## 3. Actors & Stakeholders
- **AP Clerk (Primary):** reviews bills created by events.
- **Accounting System (Secondary):** produces bills, audit, and GL preview data.
- **Auditor:** needs traceability and immutable audit trail visibility.
- **Purchasing/Receiving stakeholders:** need linkage to PO/receipts for investigation.

---

## 4. Preconditions & Dependencies
- Backend provides an authoritative Vendor Bill record created from an event (ingestion already occurred).
- Backend exposes read endpoints to:
  - list Vendor Bills with filters
  - view a single Vendor Bill with lines, refs, traceability
  - view staged GL impact (journal entry preview/staged entry id)
  - view source event envelope (or at least event metadata)
- Authentication is configured and user has permission to view AP bills.

**Dependency on backend story #130 outcomes:** trigger policy, initial bill state, discrepancy handling, and concrete API contracts are not finalized in the provided inputs.

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main nav: **Accounting ‚Üí Accounts Payable ‚Üí Vendor Bills**
- Deep link: `/ap/vendor-bill/<billId>` (screen path to be aligned with repo conventions)

### Screens to create/modify
1. **APVendorBillList** (new)
   - Filter/search Vendor Bills
   - List results
   - Navigate to detail screen
2. **APVendorBillDetail** (new)
   - View bill header + status
   - View line items
   - View traceability panel (source event, PO/receipt refs)
   - View GL impact preview (staged journal entry lines summary)
   - View audit/status history (createdAt/by, sourceModule if available)
3. Optional (if backend supports): **APSourceEventView** (new modal or sub-screen)
   - Read-only JSON or field rendering of the source event envelope

### Navigation context
- Breadcrumbs:
  - Accounting ‚Üí Accounts Payable ‚Üí Vendor Bills ‚Üí Vendor Bill Detail
- From detail, links out to:
  - Purchase Order detail (if a screen exists; otherwise display id only)
  - Receipt/Goods Received reference (if a screen exists; otherwise display id only)
  - Journal Entry detail (if it exists and user permitted) OR keep as preview-only

### User workflows
**Happy path**
1. User opens Vendor Bills list
2. Filters by vendor or date range or status ‚ÄúPending Approval/Draft‚Äù
3. Opens bill detail
4. Confirms:
   - source event id and type
   - PO/receipt refs
   - amounts/lines
   - GL impact preview is present
5. Copies identifiers for downstream approval/payment workflow (out of scope)

**Alternate paths**
- User searches by `sourceEventId` and finds:
  - exactly one bill (expected)
  - none (shows empty with guidance)
  - multiple (should not happen under idempotency; show warning and list all)
- User opens a bill flagged as ‚Äúduplicate ignored / conflict‚Äù (if represented by backend) and sees investigation guidance.

---

## 6. Functional Behavior

### Triggers
- User navigates to Vendor Bill list screen
- User submits filters/search
- User opens a bill detail from the list or deep link

### UI actions
- Search/filter actions submit to Moqui transition calling a service (or REST facade)
- Row click navigates to detail transition with `billId`
- ‚ÄúView Source Event‚Äù opens modal/sub-screen (if supported)
- ‚ÄúCopy‚Äù actions for `billId`, `sourceEventId`, `vendorInvoiceReference` (UI-only convenience)

### State changes
- No domain state changes in this frontend story (read-only).
- If backend supplies ‚ÄúviewedAt‚Äù tracking, do **not** implement without explicit requirement (denylist: audit policy).

### Service interactions
- List screen calls a backend service to retrieve paged results
- Detail screen calls backend service to retrieve bill + lines + traceability + GL preview
- Optional call to retrieve event metadata/payload

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- Filter validation:
  - date range: `fromDate <= toDate` else show inline error ‚ÄúFrom date must be on or before To date.‚Äù
  - if `sourceEventId` provided, treat as exact match (no partial guessing)
- Deep link validation:
  - if `billId` not found, show not-found state with link back to list

### Enable/disable rules
- Actions are read-only; no edit/save controls.
- ‚ÄúView Journal Entry‚Äù link only enabled if backend provides `journalEntryId` and user has permission (permission name TBD ‚Üí Open Question).

### Visibility rules
- Show traceability panel only if at least one of:
  - `sourceEventId`
  - `purchaseOrderId`
  - receipt/GRN reference
- Show GL preview section if backend provides staged lines; otherwise show ‚ÄúGL impact not available‚Äù informational message.

### Error messaging expectations
- Display backend error message with a stable UI wrapper:
  - ‚ÄúUnable to load Vendor Bills. Please retry.‚Äù + technical `errorCode` if provided
- For authorization failures: show ‚ÄúYou do not have access to view Vendor Bills.‚Äù

---

## 8. Data Requirements

### Entities involved (frontend-facing)
(Exact Moqui entity names TBD; this story treats these as backend resources.)
- `VendorBill`
- `VendorBillLineItem`
- `Vendor` (display name only)
- `PurchaseOrder` (reference only)
- `GoodsReceipt` / `Receipt` (reference only)
- `JournalEntry` (preview or reference)
- `AccountingEvent` / Source Event metadata (reference)

### Fields
**VendorBill (header)**
- `billId` (string/UUID, required, read-only)
- `vendorId` (string/UUID, required, read-only)
- `vendorName` (string, optional display)
- `purchaseOrderId` (string/UUID, optional, read-only)
- `sourceEventId` (string/UUID, optional but expected for system-created bills, read-only)
- `sourceEventType` (string, optional; e.g., `GoodsReceivedEvent` / `VendorInvoiceReceivedEvent`)
- `vendorInvoiceReference` (string, optional)
- `status` (string enum; values TBD by backend, read-only)
- `billDate` (date, required/optional TBD)
- `dueDate` (date, optional)
- `currencyUomId` (string, required)
- `totalAmount` (decimal, required)
- `createdAt`, `createdBy` (datetime/string, required for audit display if available)

**VendorBillLineItem**
- `lineId` (string/UUID, required)
- `productId` (string/UUID, optional)
- `description` (string, required/optional TBD)
- `quantity` (decimal, required)
- `unitPrice` (decimal, required)
- `lineTotal` (decimal, required)
- `debitAccountRef` (string/UUID or code, optional display-only; do not infer)
- `taxAmount` / `feeAmount` (optional; only display if provided)

**GL Impact Preview**
- `journalEntryId` (string/UUID, optional)
- lines:
  - `glAccountRef` (string/code, required)
  - `debitAmount` (decimal, optional)
  - `creditAmount` (decimal, optional)
  - `memo` (string, optional)

### Read-only vs editable
- All fields are read-only in this story.

### Derived/calculated fields (UI-only)
- Display totals formatted using `currencyUomId`
- Display ‚ÄúOrigin‚Äù badge derived from `sourceEventType`:
  - ‚ÄúGoods Received‚Äù or ‚ÄúVendor Invoice Received‚Äù (no business logic beyond mapping string to label)

---

## 9. Service Contracts (Frontend Perspective)

> Concrete endpoint names are not provided in inputs; below defines required capabilities and expected shapes. Implementations should map to Moqui services or REST calls per repo convention.

### Load/list calls
**`ap.vendorBill.list`**
- Inputs:
  - `status` (optional, multi)
  - `vendorId` (optional)
  - `purchaseOrderId` (optional)
  - `sourceEventId` (optional, exact)
  - `vendorInvoiceReference` (optional, exact or contains? **TBD**)
  - `billDateFrom` / `billDateTo` (optional)
  - paging: `pageIndex`, `pageSize`
  - sorting: `sortBy`, `sortOrder`
- Returns:
  - `items[]` minimal fields: `billId`, `vendorName/vendorId`, `status`, `billDate`, `dueDate`, `totalAmount`, `currencyUomId`, `sourceEventId`, `vendorInvoiceReference`, `purchaseOrderId`
  - `pageIndex`, `pageSize`, `totalCount`

### View/detail calls
**`ap.vendorBill.get`**
- Inputs: `billId`
- Returns: full header + `lineItems[]` + traceability refs + optional `glPreview`

### Optional source event call
**`accounting.event.get`**
- Inputs: `eventId` (== `sourceEventId`)
- Returns: event envelope fields and/or payload (read-only)

### Error handling expectations
- 401/403 ‚Üí show unauthorized page/state
- 404 (bill not found) ‚Üí not-found state on detail screen
- 409 (conflict) ‚Üí show ‚ÄúData changed; reload‚Äù CTA (if backend uses optimistic locking for reads, unlikely but safe)
- 5xx/timeouts ‚Üí show retry affordance

---

## 10. State Model & Transitions

### Allowed states (displayed)
Backend-defined. UI must support at minimum the states mentioned in provided reference:
- `DRAFT` or `PENDING_APPROVAL` (initial; exact one TBD)
- `APPROVED`
- `PAID`
- `VOID`

### Role-based transitions
- None implemented (read-only). If approval/payment transitions exist, they belong to separate stories.

### UI behavior per state
- Show state badge and explanatory text:
  - If `PENDING_APPROVAL`/`DRAFT`: ‚ÄúNot payable until approved.‚Äù
  - If `PAID`: show payment status (only if backend provides payment refs; otherwise just state)
  - If `VOID`: show void reason (only if backend provides; do not invent)

---

## 11. Alternate / Error Flows

### Validation failures
- Invalid filter date range ‚Üí inline error, prevent search submit.

### Concurrency conflicts
- If detail fetch returns 409 or stale indicator (if provided), show message ‚ÄúThis bill was updated. Reload to view latest.‚Äù

### Unauthorized access
- If user lacks permission:
  - list screen shows access denied
  - direct link to detail shows access denied (do not leak existence)

### Empty states
- No results: show ‚ÄúNo Vendor Bills match your filters.‚Äù with ‚ÄúClear filters‚Äù action.
- Missing GL preview: show informational empty state, not an error.

---

## 12. Acceptance Criteria

### Scenario 1: List Vendor Bills by status and date
**Given** I am an authenticated AP Clerk with permission to view Vendor Bills  
**When** I open the Vendor Bills list screen  
**And** I filter by status `PENDING_APPROVAL` and a bill date range  
**Then** I see a paged list of Vendor Bills matching the filters  
**And** each row shows `billId`, vendor, status, bill date, due date, and total amount with currency.

### Scenario 2: Search by sourceEventId
**Given** a Vendor Bill exists with `sourceEventId = E123`  
**When** I search the Vendor Bills list by `sourceEventId` = `E123`  
**Then** the results include the Vendor Bill linked to `E123`  
**And** opening the bill shows `sourceEventId` = `E123` in the traceability section.

### Scenario 3: View bill detail with line items and GL preview
**Given** a Vendor Bill exists with line items and an available GL impact preview  
**When** I open the Vendor Bill detail screen for that bill  
**Then** I see all line items with quantity, unit price, and line total  
**And** I see a GL impact preview showing debit-side account refs and a credit-side AP account ref (as provided by backend)  
**And** I see a traceability link to the associated purchase order id (if present).

### Scenario 4: Bill detail not found
**Given** I navigate directly to a Vendor Bill detail URL with a non-existent `billId`  
**When** the screen loads  
**Then** I see a ‚ÄúVendor Bill not found‚Äù message  
**And** I can navigate back to the Vendor Bills list.

### Scenario 5: Unauthorized access
**Given** I am authenticated but do not have permission to view Vendor Bills  
**When** I open the Vendor Bills list screen  
**Then** I see an access denied state  
**And** no bill data is displayed.

### Scenario 6: Missing GL preview data
**Given** a Vendor Bill exists but backend does not provide GL preview/journal entry reference  
**When** I open the Vendor Bill detail screen  
**Then** I see the bill header and lines  
**And** the GL preview section displays ‚ÄúGL impact not available‚Äù without failing the page load.

---

## 13. Audit & Observability

### User-visible audit data
- Display (if provided):
  - `createdAt`, `createdBy`
  - `sourceModule` / source system identifier from event metadata
  - `sourceEventId` and `sourceEventType`

### Status history
- If backend provides `statusHistory[]`, render it chronologically:
  - status, changedAt, changedBy
- If not provided, do not fabricate; just show current status.

### Traceability expectations
- Bill detail must display identifiers to support audit tracing:
  - `sourceEventId`
  - `purchaseOrderId`
  - `journalEntryId` (if available)

---

## 14. Non-Functional UI Requirements

- **Performance:** list screen initial load under 2s for first page on typical network; paginate rather than infinite load by default.
- **Accessibility:** all interactive controls keyboard accessible; ensure form inputs have labels; table supports screen reader summaries.
- **Responsiveness:** usable on tablet widths; columns may collapse to stacked layout per Quasar patterns.
- **i18n/timezone/currency:** format money using `currencyUomId`; dates displayed in user locale/timezone as provided by frontend settings (do not change backend semantics).

---

## 15. Applied Safe Defaults
- SD-UI-EMPTY-STATE: Added standard empty-state messaging and ‚ÄúClear filters‚Äù action; qualifies as UI ergonomics only; impacts UX Summary, Alternate/ Error Flows, Acceptance Criteria.
- SD-UI-PAGINATION: Use paged list with `pageIndex/pageSize` and server-side totalCount; qualifies as UI ergonomics/performance; impacts UX Summary, Service Contracts, Non-Functional UI Requirements.
- SD-ERR-STD-MAPPING: Standard mapping of 401/403/404/5xx to UI states with retry; qualifies as standard error-handling; impacts Service Contracts, Alternate / Error Flows, Acceptance Criteria.

---

## 16. Open Questions

1. **Authoritative trigger & labeling:** Is the Vendor Bill created from `GoodsReceivedEvent`, `VendorInvoiceReceivedEvent`, or both? If both, how should UI represent the origin and matching status (three-way match) without guessing policy?
2. **Initial bill status enum:** What is the exact initial status for an auto-created bill (`DRAFT` vs `PENDING_APPROVAL`), and what are the canonical status values the UI must support?
3. **Backend read API contract:** What are the exact Moqui service names (or REST endpoints), request params, and response schemas for:
   - listing bills
   - bill detail (including lines)
   - GL preview / journal entry reference
   - source event metadata/payload
4. **Idempotency/duplicate visibility:** Will the backend expose any explicit flags/records for ‚Äúduplicate event ignored‚Äù or ‚Äúconflicting duplicate quarantined‚Äù? If yes, what fields should the UI display to support investigation?
5. **Permissions:** What permission(s) gate viewing Vendor Bills and viewing linked Journal Entries/Source Events (e.g., `ap.bill.view`, `journalEntry.view`, `accounting.event.view`)?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] AP: Create Vendor Bill from Purchasing/Receiving Event  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/194  
Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] AP: Create Vendor Bill from Purchasing/Receiving Event

**Domain**: payment

### Story Description

/kiro  
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Accounts Payable (Bill ‚Üí Payment)

## Story
AP: Create Vendor Bill from Purchasing/Receiving Event

## Acceptance Criteria
- [ ] VendorInvoiceReceived (or GoodsReceived) event creates an AP bill with PO/receipt refs
- [ ] GL postings: Dr Expense/Inventory, Cr AP (per rules)
- [ ] Traceability links bill ‚Üî event ‚Üî journal entry
- [ ] Idempotent by vendorInvoiceRef/eventId


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #195: [FRONTEND] [STORY] AR: Issue Credit Memo / Refund with Traceability ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/195  
File: ./scripts/story-work/frontend/195/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] AR: Create & Post Credit Memo Against Issued Invoice (Traceable, Audited)

### Primary Persona
Accounts Receivable (AR) Clerk

### Business Value
Enable AR to correct billing errors or returns by issuing an auditable credit memo tied to an issued invoice, ensuring accurate AR balance impact and traceability for audit/compliance (with downstream refund handled separately).

---

## 2. Story Intent

### As a / I want / So that
**As an** AR Clerk,  
**I want** to create and post a Credit Memo that references a specific issued invoice with a required reason code and justification,  
**so that** the customer‚Äôs AR balance is reduced appropriately and the action is fully traceable for audit review.

### In-scope
- Frontend screens and flows to:
  - Locate an issued invoice and initiate ‚ÄúIssue Credit Memo‚Äù.
  - Enter credit memo details (amount, reason code, justification).
  - Submit to backend to create/post the credit memo.
  - View created credit memo details including link back to original invoice and audit metadata.
- UI validation enforcing required fields and basic constraints (non-negative, cannot exceed allowable amount per backend).
- Display backend-calculated results (e.g., totals, status, timestamps, reference IDs).
- Error handling for invalid state, validation failures, concurrency, and unauthorized access.

### Out-of-scope
- Executing a **cash refund** or payment transaction (Payment domain).
- Defining GL account mappings, debit/credit lines, tax jurisdiction rules, or period-close accounting policies (must be backend-defined).
- Approval workflows unless explicitly confirmed.

---

## 3. Actors & Stakeholders
- **AR Clerk (primary user):** creates/posts credit memo.
- **Accounting Manager / Approver (stakeholder):** may require review/approval depending on policy (unknown).
- **Auditor (stakeholder):** needs immutable traceability (who/when/why/what changed).
- **Billing domain / Invoice system (dependency):** provides invoice lifecycle and ‚Äúissued‚Äù status.
- **Payment module (downstream):** may later refund cash using credit balance (explicitly out-of-scope here).

---

## 4. Preconditions & Dependencies

### Preconditions
- User is authenticated in Moqui and has permission to create credit memos (exact permission string TBD).
- Target invoice exists and is **Issued/Finalized** (exact status values TBD).
- Reason codes list is configured and retrievable.

### Dependencies (frontend contracts required)
- Backend endpoints/services to:
  - Load invoice summary/details including outstanding balance and currency.
  - Load credit memo reason codes.
  - Create/post credit memo against invoice.
  - Load credit memo details after creation.
- Moqui security artifacts for permissions (screen auth + service auth).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- From **Invoice Detail** screen: action button/link ‚ÄúIssue Credit Memo‚Äù.
- (Optional) From AR menu: ‚ÄúCredit Memos‚Äù ‚Üí ‚ÄúCreate from Invoice‚Äù (only if existing nav supports it; otherwise only via invoice detail).

### Screens to create/modify
1. **Modify** existing Invoice Detail screen (path TBD)  
   - Add action: ‚ÄúIssue Credit Memo‚Äù (enabled only when invoice is in eligible state).
2. **Create** Credit Memo Create screen  
   - Screen shows immutable invoice context + input form for credit memo.
3. **Create/Modify** Credit Memo Detail screen  
   - View-only credit memo data + traceability (linked invoice, createdBy/postedAt/reason/notes/status).

> Moqui implementation expectation: `screen` with `subscreens`, `forms`, `actions` invoking services, and `transitions` for submit/cancel navigation.

### Navigation context
- Breadcrumb: AR / Invoices / {invoiceId} / Issue Credit Memo
- After successful submit: redirect to Credit Memo Detail screen; include link back to invoice.

### User workflows

#### Happy path
1. AR Clerk opens an issued invoice.
2. Clicks ‚ÄúIssue Credit Memo‚Äù.
3. System loads invoice context + reason code list.
4. Clerk enters credit amount (full or partial), selects reason code, optionally enters justification note.
5. Submit.
6. System creates/posts credit memo and shows resulting credit memo detail with reference to invoice.

#### Alternate paths
- Credit amount equals full invoice outstanding balance.
- Partial credit; backend returns computed allocation (e.g., tax reversal) to display.
- Cancel: returns to invoice detail without changes.

---

## 6. Functional Behavior

### Triggers
- User clicks ‚ÄúIssue Credit Memo‚Äù on an invoice.
- User submits the Credit Memo form.

### UI actions
- **On entering create screen:**
  - Load invoice details (`invoiceId`).
  - Load reason codes for credit memos.
- **On submit:**
  - Perform client-side validations (required fields, numeric formatting, non-negative).
  - Call create/post service.
  - On success, navigate to credit memo detail.
  - On failure, show field errors or banner error with actionable message.

### State changes (frontend-observable)
- Invoice itself is not edited in UI; it may show updated outstanding balance after memo creation (reload invoice detail or show returned values).
- Credit Memo is created in backend with a status (e.g., `Posted`).

### Service interactions
- `loadInvoice` (read)
- `listCreditMemoReasonCodes` (read)
- `createCreditMemo` (write/post)
- `getCreditMemo` (read)

(Exact names TBD; see Service Contracts section.)

---

## 7. Business Rules (Translated to UI Behavior)

### Validation (UI-enforced; backend remains source of truth)
- **BR-UI-1 Required reason code:** cannot submit without selecting a reason code; show inline error ‚ÄúReason code is required.‚Äù
- **BR-UI-2 Credit amount required:** cannot submit with empty amount; show inline error.
- **BR-UI-3 Non-negative amount:** disallow negative input; show inline error ‚ÄúAmount must be ‚â• 0.00‚Äù.
- **BR-UI-4 Invoice eligibility:** if invoice is not in eligible issued/final state, hide/disable ‚ÄúIssue Credit Memo‚Äù action; if navigated directly, show blocking error state.

### Enable/disable rules
- ‚ÄúIssue Credit Memo‚Äù action enabled only when:
  - invoice status is eligible (exact values TBD), AND
  - user has permission.
- Submit button disabled while request in-flight to prevent double-submit.

### Visibility rules
- Invoice context fields always read-only (invoice number/id, customer, totals, outstanding balance, currency).
- Credit memo status/timestamps visible on detail after creation.

### Error messaging expectations
- Map backend error codes to user-friendly messages when provided (see Service Contracts).

---

## 8. Data Requirements

### Entities involved (conceptual; backend SoR)
- `Invoice` (owned by Billing for lifecycle; Accounting for financial totals per domain guide‚Äîmust be clarified which fields frontend reads here)
- `CreditMemo` (Accounting-owned)
- `ReasonCode` / `CreditMemoReasonCode` (Accounting configuration)
- `AuditEvent` / `InvoiceAuditEvent` (immutable audit trail)

### Fields

#### Inputs (Credit Memo Create Form)
- `invoiceId` (string/UUID; required; from route)
- `creditAmount` (decimal; required; currency-scale; >= 0)
- `reasonCodeId` or `reasonCode` (string; required; from list)
- `justificationNote` (string; optional; max length TBD)

#### Read-only invoice context (display)
- `invoiceNumber` (string)
- `invoiceStatus` (string/enum)
- `customerId` + display name (string)
- `currencyUomId` (string)
- `invoiceTotal` (decimal)
- `outstandingBalance` (decimal) **(required to support ‚Äúcannot exceed outstanding‚Äù UX; backend authoritative)**

#### Credit Memo (display on success/detail)
- `creditMemoId` (string/UUID)
- `creditMemoNumber` (string, if exists)
- `status` (enum; expected includes `Draft`/`Posted` etc. but must be confirmed)
- `totalAmount` (decimal)
- `taxAmountReversed` (decimal) (if backend returns)
- `createdAt`, `createdBy`
- `postedAt`, `postedBy` (if applicable)
- `originalInvoiceId` / `invoiceId`
- `reasonCode`
- `justificationNote`

### Read-only vs editable by state/role
- On Create screen: only the four input fields editable; invoice context read-only.
- On Detail screen:
  - Everything read-only (this story assumes posted credit memo is immutable).
  - If backend supports Draft saving/editing, that is out-of-scope unless confirmed.

### Derived/calculated fields
- UI may compute and display ‚ÄúRemaining balance after credit‚Äù as a **preview**:
  - `remaining = outstandingBalance - creditAmount`
  - Must be labeled as ‚ÄúEstimated‚Äù until backend confirms.
- Tax reversal allocation is backend-calculated; UI only displays returned values.

---

## 9. Service Contracts (Frontend Perspective)

> Exact endpoints/service names are not provided in inputs; these are required for buildability. Until confirmed, frontend should integrate via Moqui service calls defined by backend module.

### Load/view calls
1. **Get invoice detail**
   - Request: `{ invoiceId }`
   - Response must include: invoice status, currency, total, outstandingBalance, customer display.
   - Errors:
     - `404 INVOICE_NOT_FOUND`
     - `403 FORBIDDEN`

2. **List credit memo reason codes**
   - Request: none or `{ activeOnly: true }`
   - Response: list of `{ reasonCode, description, activeFlag }`
   - Errors: `403 FORBIDDEN`

3. **Get credit memo detail**
   - Request: `{ creditMemoId }`
   - Response: all display fields + linked invoice reference.
   - Errors: `404 CREDIT_MEMO_NOT_FOUND`, `403 FORBIDDEN`

### Create/update calls
4. **Create/Post credit memo**
   - Request:
     - `invoiceId` (required)
     - `creditAmount` (required)
     - `reasonCode` (required)
     - `justificationNote` (optional)
     - (Optional but recommended) `idempotencyKey` (string) to prevent double submit
   - Response:
     - `creditMemoId` (required)
     - updated `outstandingBalance` (optional but helpful)
   - Errors (examples expected from backend):
     - `VALIDATION_FAILED` (field-level)
     - `INVOICE_NOT_ISSUED` / `INVALID_INVOICE_STATE` (409)
     - `CREDIT_EXCEEDS_OUTSTANDING` (422/409)
     - `ACCOUNTING_PERIOD_CLOSED_POLICY_BLOCK` or similar (409) if policy disallows (unclear)
     - `UNAUTHORIZED` / `FORBIDDEN`

### Error handling expectations
- Field-level errors: map to form field messages.
- Conflict/state errors: show banner with next action (e.g., ‚ÄúInvoice is not eligible for credit memo. Refresh invoice.‚Äù).
- Idempotency duplicate: treat as success and navigate to returned/existing credit memo if backend supports.

---

## 10. State Model & Transitions

### Invoice (relevant states only; exact enums TBD)
- Eligible: `Issued` / `Finalized` (must confirm)
- Ineligible: `Draft`, `Void`, etc.

UI behavior:
- If eligible: show enabled ‚ÄúIssue Credit Memo‚Äù.
- If not: hide/disable and show tooltip/help text (if visible).

### Credit Memo (assumed minimal states; must confirm)
- `Posted` (created and immutable)
- (Optional future) `Draft`, `Voided`, `Applied`

UI behavior per state:
- `Posted`: view-only detail; show posted timestamp/user.
- If backend returns other states, UI must display status badge and remain view-only unless explicitly required.

Role-based transitions
- AR Clerk can create/post (permission TBD).
- No void/apply transitions in this story.

---

## 11. Alternate / Error Flows

### Validation failures
- Missing reason code ‚Üí inline error, no service call.
- Missing/invalid amount format ‚Üí inline error.
- Amount > outstanding balance:
  - If UI has outstanding balance, can warn and block submit client-side.
  - Backend remains authoritative; if backend rejects, show returned error message.

### Concurrency conflicts
- If invoice outstanding balance changed since screen load (another credit memo/payment applied):
  - Backend rejects with conflict code; UI shows banner ‚ÄúInvoice balance changed. Reload and try again.‚Äù
  - Provide ‚ÄúReload invoice‚Äù action.

### Unauthorized access
- If user lacks permission:
  - Hide action on invoice detail.
  - If direct navigation to create screen: show ‚ÄúNot authorized‚Äù page/section and do not load sensitive data beyond minimal.

### Empty states
- Reason code list empty:
  - Block submission; show message ‚ÄúNo credit memo reason codes configured. Contact administrator.‚Äù
  - Provide link back to invoice.

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: Create full credit memo successfully
**Given** an invoice `INV-123` is in an eligible issued/finalized status with `outstandingBalance = 110.00` in currency `USD`  
**And** the user has permission to issue credit memos  
**And** credit memo reason code `RETURNED_GOODS` is available  
**When** the user initiates ‚ÄúIssue Credit Memo‚Äù from `INV-123`  
**And** enters credit amount `110.00`  
**And** selects reason code `RETURNED_GOODS`  
**And** submits the form  
**Then** the system creates a credit memo and returns a `creditMemoId`  
**And** the UI navigates to the Credit Memo Detail screen for that `creditMemoId`  
**And** the Credit Memo Detail displays a reference/link to invoice `INV-123`  
**And** the Credit Memo Detail displays the selected reason code and the submitting user and timestamp.

### Scenario 2: Create partial credit memo successfully
**Given** invoice `INV-123` is eligible with `outstandingBalance = 110.00`  
**And** reason code `PRICING_ERROR` is available  
**When** the user creates a credit memo for amount `55.00` with reason `PRICING_ERROR`  
**Then** the created credit memo total shown on the detail screen is `55.00` (or displays backend-returned total)  
**And** the credit memo remains linked to `INV-123`.

### Scenario 3: Block submit when reason code missing
**Given** the user is on the Issue Credit Memo screen for an eligible invoice  
**When** the user enters a valid credit amount  
**And** does not select a reason code  
**And** clicks Submit  
**Then** the UI does not call the create credit memo service  
**And** the UI shows an inline validation error that a reason code is required.

### Scenario 4: Backend rejects credit exceeding outstanding balance
**Given** invoice `INV-123` is eligible with `outstandingBalance = 50.00`  
**When** the user submits a credit memo for `60.00`  
**Then** the backend responds with an error indicating the credit exceeds the allowable amount  
**And** the UI displays an error banner/message explaining the issue  
**And** no navigation to credit memo detail occurs.

### Scenario 5: Invoice not eligible
**Given** invoice `INV-999` is in `Draft` (or any ineligible status)  
**When** the user views the invoice detail screen  
**Then** the ‚ÄúIssue Credit Memo‚Äù action is disabled or hidden  
**And** if the user navigates directly to the Issue Credit Memo URL for `INV-999`  
**Then** the UI displays a blocking error indicating the invoice is not eligible.

---

## 13. Audit & Observability

### User-visible audit data
- Credit Memo Detail must display:
  - created timestamp and user
  - posted timestamp and user (if distinct)
  - reason code
  - justification note
  - linked invoice reference

### Status history
- If backend provides status history/events, show a read-only list; otherwise omit.

### Traceability expectations
- UI must include identifiers in logs/telemetry (where available):
  - `invoiceId`, `invoiceNumber`, `creditMemoId`
- Ensure correlation ID (if Moqui provides) is preserved across requests and surfaced in error details for support (do not show sensitive internals).

---

## 14. Non-Functional UI Requirements
- **Performance:** Invoice + reason codes load within 2s on typical network; show loading state; avoid duplicate loads.
- **Accessibility:** All form controls labeled; validation errors announced; keyboard navigable.
- **Responsiveness:** Works on tablet widths used in POS backoffice.
- **i18n/timezone/currency:** Display money using `currencyUomId` formatting; display timestamps in user timezone (must use Moqui/Quasar standard utilities).

---

## 15. Applied Safe Defaults
- none

---

## 16. Open Questions

1. **Refund scope confirmation (blocking):** Should this frontend story explicitly exclude refund execution and only create/post the credit memo (Accounting), with a separate Payment story for refunds? (The provided inputs mention ‚Äúrefund‚Äù.)
2. **Invoice eligibility statuses (blocking):** What are the exact invoice states considered ‚Äúfinalized/issued‚Äù in this system (enum values) for enabling the action and for backend validation messaging?
3. **Service/API contract names (blocking):** What are the Moqui service names (or REST endpoints) for: load invoice, list reason codes, create/post credit memo, and fetch credit memo details?
4. **Credit memo state model (blocking):** Does the system support Draft vs Posted credit memos (save draft, edit, then post), or is creation always immediately Posted?
5. **Period-close behavior exposure (blocking):** If the original invoice period is closed, what should the UI show? (e.g., informational banner ‚ÄúPosted as prior period adjustment‚Äù and which fields indicate that.)
6. **Permissions (blocking):** What is the exact permission(s) required to see the action and submit the credit memo (`AR:CreateCreditMemo` was referenced in backend draft; needs confirmation in this Moqui app)?
7. **Reason code source (blocking):** What entity/service provides reason codes and what fields are required (code, description, active flag, effective dating)?
8. **Max justification length and requirements (blocking):** Any limits or required formatting for `justificationNote`? Is it required for some reason codes?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] AR: Issue Credit Memo / Refund with Traceability ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/195  
Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] AR: Issue Credit Memo / Refund with Traceability

**Domain**: payment

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Accounts Receivable (Invoice ‚Üí Cash Application)

## Story
AR: Issue Credit Memo / Refund with Traceability

## Acceptance Criteria
- [ ] Credit memo references original invoice and offsets balances
- [ ] GL postings reverse revenue/tax and reduce AR (or drive refund payment)
- [ ] Reason code required and actions audited
- [ ] Period-close policies handled (adjusting entries if needed)


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #196: [FRONTEND] [STORY] AR: Apply Payment to Open Invoice(s)  
File: ./scripts/story-work/frontend/196/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] AR: Apply Payment to Open Invoice(s)

### Primary Persona
Back Office Accountant (AR Clerk)

### Business Value
Enable accurate, auditable cash application by allocating a posted/settled customer payment across one or more open invoices, updating invoice settlement status, and recording unapplied cash when payment exceeds open balances.

---

## 2. Story Intent

### As a / I want / So that
**As a** Back Office Accountant,  
**I want** to apply a posted/settled customer payment to one or more open invoices (full/partial),  
**so that** AR balances and invoice settlement statuses are correct, and the allocation is traceable and idempotent.

### In-scope
- UI to search/select a customer payment that is eligible for application (posted/settled, with unapplied amount).
- UI to list eligible customer invoices (Open / Partially Paid) and allocate payment amounts across invoices.
- Submit payment application to Accounting (SoR for allocation), receive computed results (applied allocations + unapplied amount), and display outcome.
- Enforce UI validations (amounts, currency consistency, invoice eligibility) and show backend errors.
- View allocation history for a payment (read-only) if returned by backend.

### Out-of-scope
- Capturing/settling payments (Payments domain).
- Issuing/voiding invoices (Billing domain).
- Creating credit memos automatically for overpayments.
- Write-offs, reversals, refunds, or dispute workflows.
- Defining GL account mappings or posting rule configuration UI (no CoA/PostingRuleSet management here).

---

## 3. Actors & Stakeholders
- **Back Office Accountant (User):** Performs allocations and reviews results.
- **Accounting Domain (SoR):** Validates and persists `PaymentApplication` records; updates invoice settlement state/open balance; generates accounting postings.
- **Payments Domain (External/Upstream):** Owns payment lifecycle; provides posted/settled payment data and reference identifiers.
- **Billing Domain (Downstream/Adjacent):** Owns invoice lifecycle; consumes settlement state changes as needed (read-only from frontend POV).
- **Auditor/Compliance:** Requires immutable allocation record with actor/time and idempotent behavior.

---

## 4. Preconditions & Dependencies
1. A payment exists with:
   - `paymentId`
   - `customerId`
   - `currencyUomId`
   - `totalAmount`
   - `unappliedAvailableAmount`
   - `status` = posted/settled (not authorized/pending)
   - `effectiveAt` (accounting date basis)
2. One or more invoices exist for the same `customerId` in eligible settlement status:
   - `Open` or `Partially Paid`
   - with `openBalance > 0`
   - same currency as payment
3. User has permission to apply payments (exact permission string TBD; see Open Questions).
4. Backend service endpoints exist (or will be created) for:
   - Loading payment + eligible invoices
   - Submitting an application (idempotent)

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main menu: **Accounting ‚Üí Accounts Receivable ‚Üí Apply Payment**
- Secondary entry: From **Payment Detail** screen: action **Apply to Invoices** (if the app already has payment detail navigation; otherwise only main menu entry)

### Screens to create/modify
1. **Screen:** `apps/accounting/ar/ApplyPayment.xml` (new)
   - Search/lookup for an eligible payment (by paymentRef/paymentId/customer)
   - Displays payment summary + eligible invoices grid + allocation form
2. **Screen (optional):** `apps/accounting/ar/PaymentDetail.xml` (modify if exists)
   - Add transition link to ApplyPayment with `paymentId`

### Navigation context
- Breadcrumb: Accounting / AR / Apply Payment
- Deep link supports `?paymentId=<id>` to load directly into allocation UI.

### User workflows
#### Happy path (manual allocation)
1. User navigates to Apply Payment.
2. User selects a payment.
3. System loads:
   - payment summary (amount, currency, effective date, unapplied available)
   - eligible invoices list (invoice number/date, open balance, settlement status)
4. User enters applied amounts per invoice (one or more).
5. User submits.
6. System shows confirmation with:
   - allocations actually applied
   - resulting invoice settlement statuses
   - unapplied amount remaining

#### Alternate path (auto-allocation)
- User clicks ‚ÄúAuto-allocate‚Äù (if supported by backend policy) to populate suggested amounts, then reviews and submits.

#### Alternate path (no eligible invoices)
- If none eligible, screen shows empty state and indicates payment will remain unapplied unless invoices are opened/created (no mutation).

---

## 6. Functional Behavior

### Triggers
- Screen load with `paymentId` (deep link) triggers fetch of payment and eligible invoices.
- Payment selection triggers same fetch.
- Submit triggers creation of `PaymentApplication`.

### UI actions
- **Select Payment**
  - Provide search inputs: payment reference (external ref), paymentId, customerId/name (if available)
  - Result list shows only payments with unapplied available amount > 0 and status posted/settled.
- **Allocate amounts**
  - Each invoice row has an editable `appliedAmount` input (currency).
  - Provide ‚ÄúApply max‚Äù action per row to fill `min(openBalance, remainingUnapplied)`.
  - Provide ‚ÄúApply remaining to oldest‚Äù (optional) if auto allocation supported; otherwise omit.
- **Submit Application**
  - Disabled until:
    - at least one `appliedAmount > 0`
    - sum(appliedAmount) <= payment.unappliedAvailableAmount
    - all `appliedAmount <= invoice.openBalance`
    - currency consistency (payment vs invoices)

### State changes (frontend visible)
- After successful submit:
  - Show resulting allocations and backend-calculated unapplied amount.
  - Mark invoices in the list with updated settlement status and new open balances (if returned; otherwise refresh from backend).
  - Lock inputs (read-only) if backend indicates payment is fully applied or application is immutable.

### Service interactions
- Load payment & eligible invoices (read-only).
- Submit application (create).
- Optional: load application history for payment (read-only) after submit.

---

## 7. Business Rules (Translated to UI Behavior)

### Validation (client-side, before submit)
1. **Eligibility**
   - Payment must be posted/settled and have `unappliedAvailableAmount > 0` to enable allocation UI.
2. **Allocation amount rules**
   - `appliedAmount` must be numeric, >= 0.
   - `appliedAmount` cannot exceed invoice `openBalance`.
   - Total applied cannot exceed payment `unappliedAvailableAmount`.
3. **Currency**
   - Payment currency must match invoice currency; otherwise invoice is not selectable/editable and UI shows ‚ÄúCurrency mismatch‚Äù message.
4. **Overpayment handling**
   - UI must allow submitting less than full unapplied amount (remaining becomes unapplied cash per accounting policy).
   - UI must not auto-create credit memo.

### Enable/disable rules
- Submit button disabled if validations fail or if backend indicates payment not eligible.
- Invoice row input disabled if invoice not eligible (Paid/Closed/Void, openBalance=0, currency mismatch).

### Visibility rules
- Show ‚ÄúUnapplied after apply‚Äù computed preview (client-side) = payment.unappliedAvailableAmount - sum(appliedAmount).
- If backend returns an application record id, show it in confirmation panel.

### Error messaging expectations
- Surface backend error codes/messages verbatim in a user-friendly banner and map common cases:
  - `PAYMENT_NOT_SETTLED` ‚Üí ‚ÄúPayment is not posted/settled and cannot be applied.‚Äù
  - `INVOICE_NOT_ELIGIBLE` ‚Üí ‚ÄúOne or more selected invoices can‚Äôt receive payments.‚Äù
  - `ALLOCATION_EXCEEDS_OPEN_BALANCE` ‚Üí ‚ÄúApplied amount exceeds invoice balance.‚Äù
  - `ALLOCATION_EXCEEDS_UNAPPLIED` ‚Üí ‚ÄúTotal applied exceeds payment‚Äôs available amount.‚Äù
  - `IDEMPOTENT_REPLAY` ‚Üí ‚ÄúThis payment application was already processed; showing existing result.‚Äù
  - (Exact codes TBD; see Open Questions)

---

## 8. Data Requirements

### Entities involved (conceptual; Moqui entity names TBD)
- `Payment` (SoR: Payments domain; Accounting reads)
- `Invoice` (SoR: Billing for lifecycle; Accounting for financial settlement fields per backend story)
- `PaymentApplication` (SoR: Accounting)
- `PaymentApplicationAllocation` (line-level allocations to invoices)

### Fields (type, required, defaults)

#### Payment (read-only in this UI)
- `paymentId` (string/UUID, required)
- `paymentRef` (string, optional)
- `customerId` (string/UUID, required)
- `currencyUomId` (string, required)
- `totalAmount` (decimal, required)
- `unappliedAvailableAmount` (decimal, required)
- `status` (enum, required) ‚Äî must be posted/settled
- `effectiveAt` (datetime, required)

#### Invoice (read-only except appliedAmount input)
- `invoiceId` (string/UUID, required)
- `invoiceNumber` (string, required for display)
- `invoiceDate` (date/datetime, required for sorting)
- `settlementStatus` (enum: Open/Partially Paid/Paid, required)
- `openBalance` (decimal, required)
- `currencyUomId` (string, required)

#### PaymentApplication (created by submit; read-only afterwards)
- `paymentId` (string/UUID, required)
- `applicationEventId` (UUID, required for idempotency)
- `applicationDate` (datetime/date, required; defaults to payment.effectiveAt unless overridden‚ÄîTBD)
- `unappliedAmount` (decimal, returned by backend)
- `allocations[]` (required; at least one allocation with appliedAmount > 0)

#### Allocation (input per invoice row)
- `invoiceId` (string/UUID, required)
- `appliedAmount` (decimal, required)

### Read-only vs editable by state/role
- Read-only: Payment summary, invoice openBalance/status fields.
- Editable: allocation amounts only while payment eligible and user authorized.
- After successful application: allocation inputs become read-only for the submitted application result.

### Derived/calculated fields (frontend)
- `totalToApply` = sum(all appliedAmount inputs)
- `previewUnappliedAfter` = payment.unappliedAvailableAmount - totalToApply

---

## 9. Service Contracts (Frontend Perspective)

> Moqui naming/paths are placeholders until confirmed; frontend must integrate via Moqui screen transitions calling services.

### Load/view calls
1. **Get eligible payment by id**
   - Service: `accounting.ar.PaymentApplicationFacade.getPaymentForApplication`
   - Inputs: `paymentId`
   - Outputs: payment summary fields + eligibility flags
2. **List eligible invoices for customer/payment**
   - Service: `accounting.ar.PaymentApplicationFacade.listEligibleInvoices`
   - Inputs: `customerId`, `currencyUomId` (and optionally `asOfDate=effectiveAt`)
   - Outputs: list of invoices with openBalance, settlementStatus
3. **(Optional) Load existing applications for payment**
   - Service: `accounting.ar.PaymentApplicationFacade.listPaymentApplications`
   - Inputs: `paymentId`
   - Outputs: application records + allocations

### Create/update calls
1. **Apply payment**
   - Service: `accounting.ar.PaymentApplicationFacade.applyPaymentToInvoices`
   - Inputs:
     - `paymentId` (required)
     - `applicationEventId` (required; generated client-side UUIDv7 preferred, else server-generated‚ÄîTBD)
     - `applicationDate` (optional/required‚ÄîTBD)
     - `allocations[] = { invoiceId, appliedAmount }` (required)
   - Outputs:
     - `paymentApplicationId` (or composite key)
     - `allocationsApplied[]` with appliedAmount per invoice
     - updated invoice balances/statuses (preferred)
     - `unappliedAmount`
     - `idempotentReplay` flag (optional)

### Submit/transition calls (Moqui)
- Screen transition `applyPayment` calls `applyPaymentToInvoices` service.
- On success: transition to same screen with `paymentId` and a `paymentApplicationId` (optional) to show confirmation.
- On error: stay on same screen and show error banner, keeping user inputs.

### Error handling expectations
- Validation errors return structured messages; UI maps them to field errors where possible.
- Concurrency/idempotency:
  - If payment unapplied amount changed since load, backend should return a conflict; UI prompts refresh.
  - If idempotent replay, backend returns prior result; UI displays it without reapplying.

---

## 10. State Model & Transitions

### Allowed states (relevant to UI)

#### Payment eligibility state (derived)
- `EligibleForApplication` (posted/settled AND unappliedAvailableAmount > 0)
- `NotEligible` (not settled OR no unapplied amount)

#### Invoice settlement status (display-only but updated by result)
- `Open`
- `Partially Paid`
- `Paid`

### Role-based transitions
- User with AR apply permission can:
  - create `PaymentApplication` for eligible payment
- User without permission:
  - can view payment/invoice info (if allowed) but cannot submit (exact policy TBD)

### UI behavior per state
- Payment NotEligible: show explanation; disable allocation grid and submit.
- Invoice Paid/NotEligible: row disabled and excluded from totals.
- After application: show immutable result; disable editing for that application.

---

## 11. Alternate / Error Flows

### Validation failures (client-side)
- User enters appliedAmount > openBalance ‚Üí row error; submit disabled.
- Total applied > unappliedAvailableAmount ‚Üí summary error; submit disabled.
- No allocations > 0 ‚Üí submit disabled.

### Backend validation failures
- Payment not settled/eligible ‚Üí show banner; refresh payment eligibility.
- Invoice not tied to customer / not eligible ‚Üí show banner and mark rows if identifiable.
- Currency mismatch ‚Üí show banner; disable mismatched invoices.

### Concurrency conflicts
- Another user/process applies the same payment, reducing available unapplied amount:
  - Backend returns conflict (409 or service error code)
  - UI shows message: ‚ÄúPayment availability changed. Refresh to continue.‚Äù
  - Provide ‚ÄúRefresh‚Äù action to reload payment+invoices and keep user inputs where possible.

### Unauthorized access
- Backend denies (403): show ‚ÄúNot authorized to apply payments‚Äù and disable submit.

### Empty states
- No eligible payments in search ‚Üí show ‚ÄúNo posted payments with unapplied amount found.‚Äù
- No eligible invoices for customer ‚Üí show ‚ÄúNo open invoices to apply this payment to. Unapplied amount will remain as unapplied cash unless applied later.‚Äù

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: Apply payment across multiple invoices (full/partial)
Given I am an authorized AR user  
And a customer has a posted/settled payment with unapplied available amount 100.00 in currency USD  
And the customer has two eligible invoices with open balances 60.00 and 80.00 USD  
When I allocate 60.00 to the first invoice and 40.00 to the second invoice and submit  
Then the system creates a payment application record linked to the payment  
And the first invoice open balance becomes 0.00 and settlement status becomes Paid  
And the second invoice open balance becomes 40.00 and settlement status becomes Partially Paid  
And the payment shows unapplied amount 0.00 remaining (or unapplied available amount reduced to 0.00)  
And reloading the screen shows the same application result

### Scenario 2: Overpayment leaves unapplied cash (no auto credit memo)
Given I am an authorized AR user  
And a customer has a posted/settled payment with unapplied available amount 200.00 USD  
And the customer has eligible invoices totaling 150.00 USD open balance  
When I apply 150.00 across the invoices and submit  
Then the system records allocations totaling 150.00  
And the system records the remaining 50.00 as unapplied amount for the payment/customer  
And the UI does not create or prompt an automatic credit memo creation

### Scenario 3: Short-pay leaves invoice partially paid (no write-off)
Given I am an authorized AR user  
And a customer has a posted/settled payment with unapplied available amount 25.00 USD  
And the customer has an invoice with open balance 100.00 USD  
When I allocate 25.00 to the invoice and submit  
Then the invoice remains Partially Paid  
And the invoice open balance becomes 75.00  
And no write-off is created by default

### Scenario 4: Prevent applying more than invoice open balance (client-side)
Given I have loaded an eligible payment and an eligible invoice with open balance 10.00  
When I enter an applied amount of 11.00 for that invoice  
Then the UI shows a field error for that row  
And the Submit action is disabled

### Scenario 5: Backend rejects ineligible invoice
Given I am an authorized AR user  
And I allocate an amount to an invoice that becomes ineligible before I submit  
When I submit the payment application  
Then the backend returns an ineligible-invoice error  
And the UI shows an error banner describing the failure  
And no allocation is persisted (no partial apply)

### Scenario 6: Idempotent replay returns existing result
Given I am an authorized AR user  
And I submit a payment application with applicationEventId X  
When I submit the same application again with the same applicationEventId X  
Then the backend returns success with the original application outcome  
And the UI shows the existing allocations without double-applying amounts

---

## 13. Audit & Observability

### User-visible audit data
- Display (if available from backend):
  - paymentApplicationId / application reference
  - applied by (userId/displayName)
  - applied at (timestamp)
  - applicationEventId
  - allocations list
  - unapplied amount remaining

### Status history
- Provide a read-only ‚ÄúApplication History‚Äù panel listing prior applications for the payment (if backend supports).

### Traceability expectations
- All service calls log/trace with correlationId (Moqui requestId) and include `paymentId`, `customerId`, and `applicationEventId`.
- UI should propagate correlation headers if frontend gateway supports it (implementation detail; non-blocking).

---

## 14. Non-Functional UI Requirements
- **Performance:** Load eligible invoices within 2 seconds for up to 200 invoices; if more, require pagination/filtering.
- **Accessibility:** Keyboard navigable allocation inputs; proper labels; error messages announced to screen readers.
- **Responsiveness:** Usable on tablet widths; invoice list supports horizontal scroll if needed.
- **i18n/timezone/currency:**
  - Currency formatting based on `currencyUomId`
  - Dates shown in user locale/timezone
  - No multi-currency conversion assumptions

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATES: Provide explicit empty states for ‚Äúno eligible invoices‚Äù and ‚Äúno eligible payments‚Äù because it‚Äôs UI ergonomics and does not change domain policy. (Impacted: UX Summary, Error Flows)
- SD-UX-PAGINATION: Paginate invoice list when >200 rows to preserve performance; does not alter business logic. (Impacted: Non-Functional UI Requirements, UX Summary)
- SD-ERR-STANDARD-MAPPING: Map backend validation/conflict/unauthorized errors to banner + field errors when identifiers provided; standard error-handling pattern only. (Impacted: Business Rules, Error Flows, Service Contracts)

---

## 16. Open Questions
1. **Permissions/roles:** What exact permission(s) gate ‚Äúapply payment‚Äù in this frontend (e.g., `ar.payment.apply`, `invoice.adjust`, etc.) and should read-only access be allowed without it?
2. **Backend contract names:** What are the definitive Moqui service names/paths and request/response payload schemas for:
   - load payment eligibility
   - list eligible invoices
   - apply payment (including returned updated invoice balances/statuses)?
3. **Idempotency identifier:** Should the frontend generate `applicationEventId` (UUIDv7) or must the backend generate it? If frontend-generated, where is it stored for retry UX?
4. **Application date:** Can/should the user edit `applicationDate` (accounting date) or must it always equal `payment.effectiveAt`? If editable, what constraints apply (open accounting period, not future date, etc.)?
5. **Auto-allocation:** Does backend support an ‚Äúapply by policy‚Äù mode when allocations are omitted, or must the user always specify allocations explicitly?
6. **Invoice settlement fields ownership:** Will the backend return updated `openBalance` and `settlementStatus` directly in the apply response, or must the UI refetch invoices after submit?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] AR: Apply Payment to Open Invoice(s)  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/196  
Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] AR: Apply Payment to Open Invoice(s)

**Domain**: payment

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Accounts Receivable (Invoice ‚Üí Cash Application)

## Story
AR: Apply Payment to Open Invoice(s)

## Acceptance Criteria
- [ ] Payment can be applied to one or more invoices (full/partial)
- [ ] GL postings: Dr Cash/Bank, Cr AR (per rules)
- [ ] Unapplied and overpayment scenarios are supported per policy
- [ ] Idempotent by paymentRef/eventId


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #197: [FRONTEND] [STORY] AR: Create Customer Invoice from Invoice-Issued Event ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/197  
File: ./scripts/story-work/frontend/197/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] AR: View AR Invoice Created from `InvoiceIssued` Event (Traceability + Idempotency Indicators)

### Primary Persona
Accounting Clerk / Finance User (AR) and Accounting Support Analyst

### Business Value
Enable finance users to verify that `InvoiceIssued` events resulted in an AR invoice and corresponding journal entry, with clear traceability and idempotency visibility to support reconciliation, auditing, and operational support.

---

## 2. Story Intent

### As a / I want / So that
- **As an** AR/Accounting user  
- **I want** to view an AR invoice record that was created from an `InvoiceIssued` event, including links to the source event and resulting journal entry  
- **So that** I can confirm financial recording correctness, diagnose failures/duplicates, and provide audit-ready traceability.

### In-scope
- Moqui UI screens to **search and view** AR invoices created from `InvoiceIssued` events.
- Display of **traceability identifiers**: `sourceInvoiceId`, `sourceEventId`, and `journalEntryId` (or equivalent).
- Display of key header amounts/dates: invoice date, due date, currency, totals, status.
- Read-only view of journal entry summary lines (account code + debit/credit + amount) if available via backend service.
- Indication of **idempotency behavior** (e.g., ‚ÄúDuplicate event processed as no-op‚Äù) if backend exposes it.

### Out-of-scope
- Creating AR invoices from events (backend responsibility).
- Editing AR invoices or journal entries (posted/immutable).
- Defining GL account mappings, payment terms configuration, or posting rules.
- DLQ management UI (unless explicitly exposed by backend).

---

## 3. Actors & Stakeholders
- **Primary user:** Accounting Clerk (AR)
- **Secondary users:** Controller/Auditor (read-only verification), Support Analyst (troubleshooting)
- **Upstream system:** Billing domain emits `InvoiceIssued`
- **Downstream/related:** GL posting subsystem / journal entry records

---

## 4. Preconditions & Dependencies
- Backend provides an API/service to:
  - List/search AR invoices (filter by `sourceInvoiceId`, `customerId`, date range, status).
  - Retrieve AR invoice detail including `sourceEventId` and link to journal entry.
  - Retrieve journal entry detail/summary by `journalEntryId` (or via invoice detail payload).
- Backend enforces immutability; frontend treats invoice and journal entry as read-only.
- User has appropriate permission(s) to view AR invoices and journal entries (permission names TBD).
- Routing conventions for Moqui screens in this repo (from README) must be followed (not available in provided inputs).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main navigation: **Accounting ‚Üí Accounts Receivable ‚Üí Invoices**
- Deep link: from a Billing invoice view (optional) using `sourceInvoiceId` query param.

### Screens to create/modify
1. **`Accounting/AR/InvoiceList`** (new or extend existing)
   - Search/filter AR invoices
2. **`Accounting/AR/InvoiceDetail`** (new or extend existing)
   - Read-only detail view with traceability section
3. **`Accounting/GL/JournalEntryDetail`** (optional if exists; otherwise create read-only summary screen)
   - Read-only journal entry view linked from invoice

### Navigation context
- From InvoiceList ‚Üí InvoiceDetail via `arInvoiceId`
- From InvoiceDetail ‚Üí JournalEntryDetail via `journalEntryId`
- Optional: InvoiceDetail shows a link to ‚ÄúSource Event‚Äù detail if backend exposes an event view endpoint.

### User workflows
- **Happy path**
  1. User opens AR Invoice List
  2. Filters by `sourceInvoiceId` (from Billing invoice) or date/customer
  3. Opens an invoice
  4. Verifies due date, totals, and sees `sourceEventId` + journal entry link
  5. Opens journal entry and verifies AR/Revenue/Tax payable lines
- **Alternate paths**
  - No results: user sees empty state with guidance to broaden filters.
  - Invoice exists but journal entry missing: user sees warning banner and fields show ‚ÄúNot available‚Äù.
  - User lacks permission for journal entry: link is hidden/disabled with an authorization message.

---

## 6. Functional Behavior

### Triggers
- Entering list screen loads initial results (with default date range if allowed by safe defaults).
- Submitting search form triggers reload.
- Opening invoice detail triggers load by primary key.
- Clicking journal entry link triggers navigation to JE screen.

### UI actions
- Search actions:
  - Filter by `sourceInvoiceId`
  - Filter by `customerId`
  - Filter by invoice date range
  - Filter by status (Open/Posted/etc. ‚Äî backend-driven)
- Detail actions:
  - Copy-to-clipboard for `sourceEventId` and `sourceInvoiceId`
  - Navigate to journal entry detail

### State changes
- None to domain records (read-only).
- UI state: loading, loaded, empty, error.

### Service interactions
- `searchArInvoices` (list)
- `getArInvoice` (detail)
- `getJournalEntry` (optional detail)
- Optional: `getAccountingEvent` for `sourceEventId` if supported

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- Search form validation:
  - `sourceInvoiceId` max length (TBD; enforce only if backend provides constraint)
  - Date range: `from <= to` (UI-level validation)
- If backend returns ‚Äúmissing terms/missing revenue mapping‚Äù errors, UI must show them as non-editable informational errors on related diagnostic screens only (no mutation).

### Enable/disable rules
- Journal Entry link enabled only when `journalEntryId` is present **and** user has permission to view journal entries.
- Source Event link enabled only when `sourceEventId` present and endpoint exists.

### Visibility rules
- Traceability section always visible; fields show placeholder if values null.
- Audit fields visible if backend returns them (createdAt/createdBy).

### Error messaging expectations
- Map backend errors to:
  - Not found ‚Üí ‚ÄúAR Invoice not found or you do not have access.‚Äù
  - Unauthorized ‚Üí ‚ÄúYou do not have permission to view this resource.‚Äù
  - Server error ‚Üí ‚ÄúUnable to load. Try again. If the issue persists, contact support with Trace ID.‚Äù

---

## 8. Data Requirements

### Entities involved (frontend-known)
> Exact Moqui entity names are not provided in inputs; treat as backend/domain concepts until confirmed.

- **AR Invoice** (Accounting-owned)
- **AR Invoice Line** (optional display)
- **Journal Entry** (Accounting-owned)
- **Journal Entry Line**
- **Source Event reference** (`InvoiceIssued`), by `sourceEventId` (if queryable)

### Fields
**AR Invoice (header)**
- `arInvoiceId` (string/UUID; required; identifier) ‚Äî read-only
- `sourceInvoiceId` (string; required) ‚Äî read-only
- `sourceEventId` (UUID; required) ‚Äî read-only
- `customerId` (string; required) ‚Äî read-only
- `invoiceDate` (date; required) ‚Äî read-only
- `dueDate` (date; required) ‚Äî read-only
- `currencyUomId` or `currency` (string; required) ‚Äî read-only
- `subtotalAmount` (decimal; required) ‚Äî read-only
- `taxAmount` (decimal; required) ‚Äî read-only
- `totalAmount` (decimal; required) ‚Äî read-only
- `amountDue` (decimal; required) ‚Äî read-only
- `status` (string; required) ‚Äî read-only
- `journalEntryId` (string/UUID; nullable) ‚Äî read-only
- Audit: `createdAt`, `createdBy` (optional; read-only)

**Journal Entry (summary/detail)**
- `journalEntryId` ‚Äî read-only
- `transactionDate` ‚Äî read-only
- `sourceEventId` ‚Äî read-only
- `lines[]`: `glAccountCode`, `debitCreditFlag`, `amount` ‚Äî read-only

### Read-only vs editable by state/role
- All fields in this story are **read-only** regardless of state/role; only visibility differs by permission.

### Derived/calculated fields
- UI may display formatted currency amounts; no recalculation of totals in frontend.

---

## 9. Service Contracts (Frontend Perspective)
> Moqui service names and request/response shapes must be confirmed. Below defines required capabilities.

### Load/view calls
1. **Search AR invoices**
   - Input: `sourceInvoiceId?`, `customerId?`, `invoiceDateFrom?`, `invoiceDateTo?`, `status?`, `pageIndex`, `pageSize`
   - Output: list of invoice headers with minimal fields for table display; include `arInvoiceId`, `sourceInvoiceId`, `customerId`, `invoiceDate`, `dueDate`, `totalAmount`, `currency`, `status`, `journalEntryId?`
2. **Get AR invoice detail**
   - Input: `arInvoiceId`
   - Output: full header + optional lines + `sourceEventId` + `journalEntryId`
3. **Get journal entry detail (optional)**
   - Input: `journalEntryId`
   - Output: header + lines

### Submit/transition calls
- None (read-only story).

### Error handling expectations
- Standard HTTP/JSON error mapping:
  - 400 validation ‚Üí show inline error for filter inputs when applicable
  - 401/403 ‚Üí show permission message and hide restricted links/data
  - 404 ‚Üí not found empty state on detail
  - 409 conflict ‚Üí show ‚Äúdata changed‚Äù and offer reload (if backend uses optimistic locking semantics even for reads)
  - 5xx ‚Üí error panel with retry

---

## 10. State Model & Transitions

### Allowed states (display-only)
- AR invoice status values are backend-defined; UI must treat as enumerated strings and display as-is.
- Expected examples from backend story: `Posted/Open` (but not guaranteed).

### Role-based transitions
- None (no transitions in UI).

### UI behavior per state
- If status indicates posted/open: normal display.
- If status indicates void/closed (if exists): still viewable read-only.

---

## 11. Alternate / Error Flows

### Validation failures (search)
- Date range invalid ‚Üí block search, show inline message.
- Unsupported status filter ‚Üí backend 400; UI shows error and suggests clearing filter.

### Concurrency conflicts
- If invoice deleted/merged between list and detail ‚Üí detail load returns 404; show not found with link back to list.

### Unauthorized access
- User can access list but not detail: detail returns 403; show permission error.
- User can view invoice but not journal entry: JE link hidden/disabled; attempting navigation shows 403 message.

### Empty states
- No matching invoices ‚Üí empty state with suggestion to search by `sourceInvoiceId` from Billing invoice.

---

## 12. Acceptance Criteria

### Scenario 1: Search AR invoices by sourceInvoiceId
**Given** I have permission to view AR invoices  
**When** I open the AR Invoice List screen and search by a valid `sourceInvoiceId`  
**Then** I see a list including invoices matching that `sourceInvoiceId`  
**And** each row shows `invoiceDate`, `dueDate`, `totalAmount`, `currency`, `status`  
**And** selecting a row navigates to AR Invoice Detail for that invoice.

### Scenario 2: View AR invoice detail with traceability
**Given** an AR invoice exists that was created from an `InvoiceIssued` event  
**When** I open the AR Invoice Detail screen for that invoice  
**Then** I see `sourceInvoiceId` and `sourceEventId` displayed in a Traceability section  
**And** I see a `journalEntryId` displayed when present  
**And** I can navigate to the journal entry detail from the invoice when allowed.

### Scenario 3: Journal entry not available
**Given** an AR invoice exists but `journalEntryId` is null or journal entry retrieval fails with 404  
**When** I view the AR Invoice Detail screen  
**Then** the UI shows ‚ÄúJournal entry not available‚Äù (non-blocking warning)  
**And** no journal entry navigation action is enabled.

### Scenario 4: Unauthorized to view journal entry
**Given** I can view AR invoice details but I do not have permission to view journal entries  
**When** I open an AR invoice that has a `journalEntryId`  
**Then** the journal entry link/action is hidden or disabled  
**And** the UI indicates I lack permission to view journal entry details.

### Scenario 5: Invoice not found
**Given** I navigate to AR Invoice Detail with an invalid or inaccessible `arInvoiceId`  
**When** the screen loads  
**Then** I see a ‚ÄúNot found or no access‚Äù message  
**And** I can return to the AR Invoice List.

---

## 13. Audit & Observability

### User-visible audit data
- Display (if available): `createdAt`, `createdBy`, and invoice status.
- Display traceability IDs: `sourceEventId`, `sourceInvoiceId`, `journalEntryId`.

### Status history
- If backend provides status history, show read-only timeline; otherwise omit.

### Traceability expectations
- Users can copy `sourceEventId` to provide to support.
- Logs/telemetry should include `arInvoiceId`, `sourceInvoiceId`, `sourceEventId` on load failures (frontend console/logging abstraction per project convention).

---

## 14. Non-Functional UI Requirements
- **Performance:** List search should return and render within 2s for typical page size (assumes backend paging).
- **Accessibility:** All interactive controls keyboard accessible; labels for inputs; sufficient contrast.
- **Responsiveness:** Works on tablet viewport used in POS back-office contexts.
- **i18n/timezone/currency:** Dates shown in user locale/timezone; currency formatted by `currency`/`currencyUomId` from data without conversion.

---

## 15. Applied Safe Defaults
- SD-UI-EMPTY-STATE: Provide a standard empty state message and ‚ÄúClear filters‚Äù action; safe because it does not alter domain behavior. (UX Summary, Alternate / Error Flows)
- SD-UI-PAGINATION: Use standard paginated list behavior with `pageSize` and `pageIndex`; safe because it is presentation-only. (UX Summary, Service Contracts)
- SD-ERR-MAP-STD: Map HTTP 401/403/404/409/5xx to standard UI error patterns; safe because it does not invent business rules. (Service Contracts, Alternate / Error Flows)

---

## 16. Open Questions
1. What are the **actual Moqui service names** and request/response fields for:
   - searching AR invoices
   - fetching AR invoice detail
   - fetching journal entry detail?
2. What are the **Moqui screen route conventions** in this repo (base path/module name), and do AR/GL screens already exist that must be extended rather than created?
3. What are the **frontend permissions/authorization signals**?
   - Required permission(s) to view AR invoices?
   - Required permission(s) to view journal entries?
4. Does backend expose **idempotency/duplicate event indicators** (e.g., a processing log by `sourceEventId`), and should the UI show it? If yes, what endpoint/fields?
5. Should the AR invoice list support searching by **eventId (`sourceEventId`)** directly (useful for support workflows)?

---

## Original Story (Unmodified ‚Äì For Traceability)
Title: [FRONTEND] [STORY] AR: Create Customer Invoice from Invoice-Issued Event ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/197  
Labels: frontend, story-implementation, customer

**Original Story**: [STORY] AR: Create Customer Invoice from Invoice-Issued Event

**Domain**: customer

### Story Description

/kiro  
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Accounts Receivable (Invoice ‚Üí Cash Application)

## Story
AR: Create Customer Invoice from Invoice-Issued Event

## Acceptance Criteria
- [ ] InvoiceIssued event creates an AR invoice record with terms/due date
- [ ] GL postings: Dr AR, Cr Revenue, Cr Tax Payable (per rules)
- [ ] Traceability links invoice ‚Üî event ‚Üî journal entry
- [ ] Idempotent by invoiceId/eventId

### Frontend Requirements
- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack
- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #198: [FRONTEND] [STORY] GL: Provide Trial Balance and Drilldown to Source  
File: ./scripts/story-work/frontend/198/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] GL: Provide Trial Balance and Drilldown to Source (Moqui Screens)

### Primary Persona
Controller (Finance)

### Business Value
Enable finance to validate General Ledger integrity and support period-end close/audits by generating a Trial Balance with traceable drilldown from balances to ledger lines, journal entries, and originating source events, including CSV export for offline workflows.

---

## 2. Story Intent

### As a / I want / So that
- **As a** Controller  
- **I want** to generate a Trial Balance for a selected accounting period with optional account and dimension filters, and drill down from balances to underlying ledger/journal/source details  
- **So that** I can reconcile the ledger, investigate anomalies, and produce evidence for audit and close.

### In-scope
- Moqui **screens, forms, transitions** for:
  - Trial Balance criteria selection and on-screen results
  - Drilldown flow: Trial Balance ‚Üí account ledger lines ‚Üí journal entry ‚Üí source event view
  - CSV export of the displayed Trial Balance
- Frontend enforcement of permissions via server responses (do not rely on UI-only hiding)
- Basic empty/error states for no data, validation errors, and access denied

### Out-of-scope
- Implementing accounting calculations/posting logic
- Defining or changing the Chart of Accounts, posting rules, or period close logic
- Designing/implementing canonical source event schemas (beyond displaying returned fields)
- PDF export (not requested; CSV only)

---

## 3. Actors & Stakeholders
- **Controller (primary):** runs Trial Balance, exports CSV, drills into sources.
- **Finance Manager/Accountant (secondary):** uses reports for reconciliation/close.
- **Auditor (stakeholder):** consumes exported CSV and drilldown evidence (may be read-only access).
- **System (GL/Accounting services):** provides report and drilldown data; enforces access control.

---

## 4. Preconditions & Dependencies

### Preconditions
- User is authenticated in the frontend.
- User has appropriate permissions to view GL reporting (exact permission names TBD; see Open Questions).
- Accounting periods exist and posted journal entries/ledger entries exist for selected period.

### Dependencies
- Backend endpoints/services must exist for:
  - Listing available periods (or accepting a period ID)
  - Generating Trial Balance with filters
  - Retrieving ledger lines for an account/period/filter context
  - Retrieving a journal entry by ID
  - Retrieving a source event by reference (type/id), or returning a URL/reference payload
- Backend must enforce access controls at API level and return appropriate error codes/status.

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main navigation: **Accounting ‚Üí General Ledger ‚Üí Trial Balance**
- Deep-link support:
  - `/gl/trial-balance`
  - `/gl/trial-balance/ledger?glAccountId=...`
  - `/gl/journal-entry?journalEntryId=...`
  - `/gl/source-event?sourceType=...&sourceId=...` (or equivalent; depends on backend contract)

### Screens to create/modify (Moqui Screen definitions)
1. **`apps/accounting/screen/gl/TrialBalance.xml`**
   - Criteria form + results table + export action
2. **`apps/accounting/screen/gl/LedgerLines.xml`**
   - List ledger lines for selected account/context
3. **`apps/accounting/screen/gl/JournalEntryView.xml`**
   - Journal entry header + lines; link to source event
4. **`apps/accounting/screen/gl/SourceEventView.xml`**
   - Generic ‚Äúsource event details‚Äù renderer (based on returned payload)

### Navigation context
- Maintain a ‚Äúreport context‚Äù so drilldown preserves filters (period + dimensions + account range if applicable).
- Provide ‚ÄúBack to Trial Balance‚Äù action that restores criteria and results (server-side reload permitted).

### User workflows
#### Happy path
1. Open Trial Balance screen.
2. Select Period (required), optionally set account filter and dimension filters.
3. Generate report ‚Üí view results with totals.
4. Click an account balance (e.g., closing balance) ‚Üí view ledger lines.
5. Click a ledger line ‚Üí view journal entry.
6. Click source reference ‚Üí view source event details.
7. Export CSV of Trial Balance.

#### Alternate paths
- Generate report with no results ‚Üí show ‚ÄúNo data‚Äù state and allow criteria adjustment.
- Attempt drilldown to missing source ‚Üí show ‚ÄúSource unavailable‚Äù with reference ID.
- Permission denied ‚Üí show access denied state; do not leak restricted data.

---

## 6. Functional Behavior

### Triggers
- User submits ‚ÄúGenerate Trial Balance‚Äù
- User clicks on a Trial Balance line (drilldown)
- User clicks on a ledger line (drilldown)
- User clicks on a source reference (drilldown)
- User clicks ‚ÄúExport CSV‚Äù

### UI actions
- **Generate:** validate criteria; call backend; render table with debit/credit totals.
- **Drilldown 1:** navigate to LedgerLines screen with context params.
- **Drilldown 2:** navigate to JournalEntryView with `journalEntryId`.
- **Drilldown 3:** navigate to SourceEventView with reference payload/params.
- **Export:** request CSV from backend using same filters; trigger file download.

### State changes (frontend)
- Store current criteria and last-generated timestamp in screen state (request parameters or session; Moqui context).
- No financial state mutations in frontend.

### Service interactions (Moqui)
- Use Moqui `service-call` (or REST via Moqui tools if backend is separate) for:
  - Loading filter dropdown data (periods, dimensions)
  - Fetching trial balance results
  - Fetching ledger lines
  - Fetching journal entry
  - Fetching source event details
  - Export request returning CSV

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- Period is **required** before generating report.
- If dimensions are supported, each selected dimension must have a value (no ‚Äúdimension name only‚Äù).
- Account filter validation (if provided):
  - If range-based: `fromAccount <= toAccount` (lexicographic or numeric per backend definition; clarify).
  - If list-based: at least one account selected.

### Enable/disable rules
- ‚ÄúGenerate‚Äù disabled until required period provided.
- ‚ÄúExport CSV‚Äù disabled until a report has been successfully generated (has `reportRunId` or equivalent context).
- Drilldown links disabled/hidden if the corresponding identifiers are missing (e.g., ledger line without journalEntryId).

### Visibility rules
- Show imbalance warning banner if backend indicates debits ‚â† credits (or includes a boolean `isBalanced=false`).
- Hide/redact restricted accounts/dimensions only if backend already filtered them; UI must not attempt to infer.

### Error messaging expectations
- Validation errors: inline field errors + summary at top.
- Permission errors (401/403): show ‚ÄúAccess denied‚Äù and stop rendering sensitive data.
- Not found (404) for journal entry/source: show ‚ÄúNot found‚Äù with the requested ID/reference.
- Backend business-rule errors should display backend error code and message in a user-friendly wrapper, without exposing sensitive payload.

---

## 8. Data Requirements

> Note: Exact entity names in Moqui may differ; below is a frontend contract view. Backend contract must confirm.

### Entities involved (conceptual)
- AccountingPeriod
- GLAccount
- TrialBalanceReport (computed/view)
- LedgerEntry / GLTransactionLine (posted lines)
- JournalEntry + JournalEntryLine
- SourceEvent reference (from canonical event envelope or source system)

### Fields (type, required, defaults)

#### Trial Balance Criteria (inputs)
- `periodId` (string/ID, **required**)
- `accountFilterType` (enum: `NONE|RANGE|LIST`, default `NONE`) **(clarify if supported)**
- `fromAccountCode` (string, required if RANGE)
- `toAccountCode` (string, required if RANGE)
- `glAccountIds[]` (array<ID>, required if LIST)
- `dimensions` (map<string,string> or array of `{dimensionTypeId, dimensionValueId}`, optional; **requires clarification**)

#### Trial Balance Result (display)
- `generatedAt` (datetime, required)
- `filtersApplied` (object/string, required)
- `lines[]` (required)
  - `glAccountId` (ID, required)
  - `accountCode` (string, required)
  - `accountName` (string, required)
  - `openingBalance` (decimal, required)
  - `totalDebits` (decimal, required)
  - `totalCredits` (decimal, required)
  - `closingBalance` (decimal, required)
- `reportTotalDebits` (decimal, required)
- `reportTotalCredits` (decimal, required)
- `isBalanced` (boolean, optional but preferred)

#### Ledger Lines (display)
- `ledgerLines[]`
  - `ledgerEntryId` (ID, required)
  - `postingDate` (date, required)
  - `description` (string, optional)
  - `debitAmount` (decimal, required)
  - `creditAmount` (decimal, required)
  - `journalEntryId` (ID, optional but needed for drilldown)
  - `sourceEventRef` (object/string, optional)

#### Journal Entry (display)
- `journalEntryId` (ID, required)
- `postingDate` (date, required)
- `status` (string enum: `DRAFT|POSTED|...`, required)
- `description` (string, optional)
- `sourceEventRef` (required for drilldown to source if available)
- `lines[]`
  - `glAccountId` (ID, required)
  - `accountCode` (string, preferred)
  - `accountName` (string, preferred)
  - `debitAmount` (decimal, required)
  - `creditAmount` (decimal, required)

#### Source Event (display)
- `sourceSystem` (string, required)
- `sourceEntityType` (string, required)
- `sourceEntityId` (string, required)
- `occurredAt` (datetime, optional)
- `displayFields` (map<string, any>), optional (generic renderer)

### Read-only vs editable
- All fields in these screens are **read-only** (reporting).

### Derived/calculated fields
- None calculated client-side besides formatting; all balances are backend-authoritative.

---

## 9. Service Contracts (Frontend Perspective)

> **Blocking**: actual service names/paths are not provided. Below are required contracts to implement the frontend; backend must confirm.

### Load/view calls
1. `AccountingPeriod.list` (or REST `GET /api/accounting/periods`)
   - Response: periods with `periodId`, `name`, `startDate`, `endDate`, `status`

2. `GL.Dimension.listSupported` (optional)
   - Response: dimension types + allowed values (if UI needs picklists)

### Create/update calls
- None (reporting only).

### Submit/transition calls
1. `GL.TrialBalance.generate`
   - Request: criteria fields above
   - Response: trial balance result payload + optionally `reportRunId`

2. `GL.LedgerLines.getByAccount`
   - Request: `periodId`, `glAccountId`, plus same dimension filters
   - Response: list of ledger lines + totals for that account (optional)

3. `GL.JournalEntry.get`
   - Request: `journalEntryId`
   - Response: journal entry header + lines

4. `GL.SourceEvent.get`
   - Request: `sourceSystem`, `sourceEntityType`, `sourceEntityId` (or a single `sourceEventId`)
   - Response: details for display

5. `GL.TrialBalance.exportCsv`
   - Request: same criteria or `reportRunId`
   - Response: `text/csv` stream + filename

### Error handling expectations
- 400: field validation errors with machine-readable codes per field.
- 401/403: access denied (no partial data returned).
- 404: missing journal entry/source event.
- 409: stale context/reportRunId invalid (if used).
- 500/503: show retryable error and keep criteria intact.

---

## 10. State Model & Transitions

### Allowed states (screen-level)
- `Idle` (criteria not yet run)
- `Loading` (fetching report/lines)
- `Loaded` (results displayed)
- `Error` (non-field error)
- `AccessDenied`

### Role-based transitions
- Only authorized users can transition from `Idle` ‚Üí `Loaded` by successfully calling report services.
- Unauthorized transitions result in `AccessDenied`.

### UI behavior per state
- `Idle`: show criteria form; no results table; export disabled.
- `Loading`: disable actions; show loading indicator.
- `Loaded`: show results + drilldown links + export enabled.
- `Error`: show error summary + allow retry.
- `AccessDenied`: show access denied message; no data tables rendered.

---

## 11. Alternate / Error Flows

1. **No data**
   - If report returns empty `lines[]`, show ‚ÄúNo data found for selected criteria‚Äù and keep export disabled (unless export of empty is required‚Äîclarify).

2. **Unbalanced report**
   - If `reportTotalDebits != reportTotalCredits` (or `isBalanced=false`), display prominent warning banner and still render results.

3. **Broken source link**
   - If journal entry lacks source reference or source lookup returns 404, show non-blocking message: ‚ÄúSource event not available‚Äù with reference details if safe.

4. **Concurrency / stale params**
   - If backend uses `reportRunId` and it expires, show ‚ÄúReport expired, please regenerate‚Äù and route back with criteria preserved.

5. **Unauthorized access**
   - If any drilldown call returns 403, show access denied and do not render previously cached sensitive details for that view.

---

## 12. Acceptance Criteria (Gherkin)

### AC1: Generate Trial Balance by period
Given I am authenticated as a Controller with permission to view trial balance  
And posted journal entries exist for period "2024-08"  
When I open the Trial Balance screen  
And I select period "2024-08"  
And I click "Generate"  
Then the system displays a Trial Balance with account lines for the selected period  
And the report shows total debits and total credits.

### AC2: Balanced totals indication
Given a Trial Balance is generated for period "2024-08"  
When the report totals are returned  
Then if total debits equal total credits, the UI shows the report as balanced  
And if total debits do not equal total credits, the UI shows a prominent imbalance warning while still displaying results.

### AC3: Drilldown from Trial Balance to ledger lines
Given a Trial Balance is displayed for period "2024-08"  
When I click the closing balance (or account line drilldown action) for account "Revenue"  
Then I am navigated to the Ledger Lines view for that account and period  
And I see the list of posted ledger lines that comprise that balance.

### AC4: Drilldown from ledger line to journal entry
Given I am viewing ledger lines for an account  
And at least one ledger line has a journalEntryId  
When I select a ledger line with a journalEntryId  
Then I am navigated to the Journal Entry view  
And I see the journal entry header and all journal entry lines.

### AC5: Drilldown from journal entry to source event
Given I am viewing a journal entry that includes a source event reference  
When I click the source event reference  
Then I am navigated to the Source Event view  
And I see source event details returned by the backend for that reference.

### AC6: Export Trial Balance to CSV
Given a Trial Balance report is displayed for selected criteria  
When I click "Export CSV"  
Then a CSV file downloads  
And the CSV contains a header row  
And the CSV rows match exactly the data displayed in the Trial Balance table for the same criteria.

### AC7: Access control enforcement (restricted accounts/dimensions)
Given my user is restricted from viewing certain accounts or dimension values  
When I generate a Trial Balance for a period containing restricted activity  
Then the UI does not display any restricted account lines or restricted amounts  
And if the backend returns 403, the UI shows ‚ÄúAccess denied‚Äù and displays no report data.

### AC8: Error handling for missing source event
Given I am viewing a journal entry with a source reference  
When the source event request returns 404 Not Found  
Then the UI displays a ‚ÄúSource event not found‚Äù message including the reference identifier  
And the UI allows me to navigate back to the journal entry without losing context.

---

## 13. Audit & Observability

### User-visible audit data
- Display on report header:
  - `generatedAt`
  - ‚ÄúGenerated by <current user>‚Äù if backend returns (otherwise omit; do not guess)
- Display on journal entry:
  - `journalEntryId`, `postingDate`, `status`
  - source reference identifiers

### Status history
- Not required to display full audit trail; but the drilldown chain must preserve identifiers:
  - TrialBalance criteria ‚Üí glAccountId ‚Üí ledgerEntryId ‚Üí journalEntryId ‚Üí source reference.

### Traceability expectations
- Include identifiers in client logs (non-PII):
  - `periodId`, `glAccountId`, `journalEntryId`, `sourceEntityId` (only if not sensitive; otherwise hash or omit per security policy‚Äîclarify).

---

## 14. Non-Functional UI Requirements

### Performance
- Trial Balance generation may be slow; UI must:
  - show loading state
  - prevent double-submit
  - allow cancellation via navigation (no special cancel API assumed)

### Accessibility
- All actionable elements keyboard accessible.
- Table supports screen reader labels for totals and warnings.
- Error summary uses ARIA live region (or Quasar equivalent).

### Responsiveness
- Works on tablet widths; tables may scroll horizontally.

### i18n/timezone/currency
- Currency formatting must use currency code returned by backend (or a single system currency‚Äîclarify).
- Dates/times displayed in user locale/timezone as configured by frontend/Moqui.

---

## 15. Applied Safe Defaults
- SD-UI-EMPTY-STATE: Display a standard ‚ÄúNo data found‚Äù empty state when the report returns zero lines; qualifies as safe UI ergonomics; impacts UX Summary, Error Flows, Acceptance Criteria.
- SD-UI-LOADING-STATE: Use standard loading/disable interactions during service calls to prevent duplicate requests; qualifies as safe UI ergonomics; impacts Functional Behavior, Non-Functional Requirements.
- SD-ERR-GENERIC-RETRY: For 500/503, show a generic retryable error while preserving criteria; qualifies as safe error-handling boilerplate; impacts Error Flows, Service Contracts.

---

## 16. Open Questions

1. **Dimensions scope (blocking):** Which dimensions must be supported for filtering in the initial release (e.g., Location, Department, Project, Cost Center)? Are multiple dimensions combinable (AND) and can each have multiple values (IN)?
2. **Access control model (blocking):** What is the exact authorization model for ‚Äúsensitive accounts/dimensions‚Äù? Is restriction applied by GL account, account type, posting category, dimension value, business unit, or combinations? Should unauthorized data be filtered (200 with redaction) or hard-denied (403)?
3. **Period definition/selection (blocking):** How does the frontend select a ‚Äúperiod‚Äù‚Äîby `periodId` (AccountingPeriod entity), by date range, or both? Must we support custom fiscal calendars (e.g., 4-4-5)?
4. **Backend service/API contracts (blocking):** What are the actual Moqui service names or REST endpoints, request/response schemas, and error codes for:
   - trial balance generation
   - ledger lines query
   - journal entry fetch
   - source event fetch
   - CSV export
5. **CSV format (blocking):** What is the exact required column order, naming, and numeric formatting (e.g., separate debit/credit columns vs signed balance)? Must totals appear as rows in the CSV?
6. **Source event rendering (blocking):** What fields must be displayed on the Source Event view? Is it a generic key/value display from a canonical envelope, or do we need type-specific renderers (Invoice, Repair Order, Inventory Move)?
7. **Currency handling (blocking):** Is trial balance always single-currency per business unit, or can it include multiple currencies? If multi-currency is possible, what is the display and export requirement?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] GL: Provide Trial Balance and Drilldown to Source  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/198  
Labels: frontend, story-implementation, general

## Frontend Implementation for Story

**Original Story**: [STORY] GL: Provide Trial Balance and Drilldown to Source

**Domain**: general

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Post Journal Entries to the General Ledger

## Story
GL: Provide Trial Balance and Drilldown to Source

## Acceptance Criteria
- [ ] Trial balance can be generated by period/account/dimensions
- [ ] Drilldown exists: balance ‚Üí ledger lines ‚Üí journal entry ‚Üí source event
- [ ] Exports supported (CSV) for controller workflows
- [ ] Access controls enforced for sensitive accounts/dimensions


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #199: [FRONTEND] [STORY] GL: Support Accrual vs Cash Basis Modes  
File: ./scripts/story-work/frontend/199/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

STOP: Clarification required before finalization

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Accounting Policy: Configure Accrual vs Cash Basis per Business Unit (AR scope)

### Primary Persona
Finance Manager / Accountant (with accounting admin privileges)

### Business Value
Enable correct GL posting behavior and reporting consistency by configuring and auditing whether a business unit operates on accrual or cash basis for AR/revenue-cycle postings.

---

## 2. Story Intent

### As a / I want / So that
**As a** Finance Manager / Accountant,  
**I want** to view and change the accounting basis (Accrual or Cash) for a business unit with an effective fiscal-period boundary,  
**so that** journal entry posting behavior is consistent, permission-controlled, and auditable.

### In-scope
- A Moqui UI to:
  - View current accounting basis for a business unit
  - View basis history (effective-dated)
  - Propose a new basis change with an effective-from date/time aligned to fiscal period start
  - Save the change (server-side validated)
- Permission-gated access and UI affordances (read vs edit)
- User-visible audit/trace fields for changes (who/when/old/new/effectiveFrom)

### Out-of-scope
- Defining debit/credit mappings, GL accounts, posting rule configuration UI
- Journal entry creation/posting UI
- AP behavior (explicitly out of scope per backend reference)
- Retroactive re-posting and ‚Äúcatch-up conversion‚Äù workflows

---

## 3. Actors & Stakeholders
- **Finance Manager / Accountant (interactive user):** configures basis and reviews history
- **Auditor (interactive user):** reviews basis change history/audit records (read-only)
- **Accounting Service (system):** validates and persists basis policy and audit trail
- **Billing/Payments services (external producers):** referenced only for downstream behavior context; not directly controlled in this frontend story

---

## 4. Preconditions & Dependencies
- Business unit(s) exist and are selectable in the UI.
- Backend provides endpoints/services to:
  - Read current basis for a business unit
  - Read basis policy history (effective-dated)
  - Create a new basis policy change with validation:
    - allowed values: `ACCRUAL` or `CASH`
    - effective date must align to fiscal period start
    - permission-controlled
- User authentication/authorization is configured in Moqui.
- Fiscal period boundary concept exists in backend (at least ‚Äústart of fiscal month‚Äù or equivalent boundary rule).

**Dependency note:** The frontend cannot safely implement the fiscal boundary rule without a backend-provided ‚Äúvalid effectiveFrom options‚Äù or a validation error contract (see Open Questions).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main navigation: **Accounting ‚Üí Policies ‚Üí Accounting Basis**
- Alternative entry: **Business Unit detail ‚Üí Accounting tab ‚Üí Accounting Basis**

### Screens to create/modify
1. **Screen:** `Accounting/Policy/AccountingBasis.xml` (new)
   - Business unit selector/context header
   - Current basis summary card/section
   - Effective-dated history list
   - ‚ÄúChange basis‚Äù action (permission gated)
2. **Dialog/Subscreen:** `Accounting/Policy/AccountingBasisChangeDialog.xml` (new)  
   - Form to select new basis and effectiveFrom
3. (Optional) **Reusable component/form:** `Accounting/Policy/AccountingBasisForm.xml` (new) used by dialog

### Navigation context
- Screen requires a `businessUnitId` context; if missing, prompt user to select one.
- After successful save, return to basis screen with refreshed ‚Äúcurrent‚Äù + history and a confirmation message.

### User workflows
**Happy path**
1. User navigates to Accounting Basis screen.
2. Selects a business unit (if not already in context).
3. Views current basis and history.
4. Clicks ‚ÄúChange Basis‚Äù.
5. Chooses `ACCRUAL` or `CASH` and selects an effective-from date/time that is at a fiscal period start.
6. Submits; sees success toast; screen refreshes showing new policy scheduled/effective.

**Alternate paths**
- User lacks permission ‚Üí screen shows read-only; change action hidden/disabled.
- Invalid effectiveFrom ‚Üí inline error returned from backend displayed near effectiveFrom field.
- Backend rejects due to closed/locked period ‚Üí show blocking error and do not update UI.
- Concurrency conflict (policy changed by someone else) ‚Üí show conflict banner and reload history.

---

## 6. Functional Behavior

### Triggers
- Screen load with `businessUnitId`
- Business unit selection change
- User clicks ‚ÄúChange Basis‚Äù
- User submits basis change form

### UI actions
- **On load / BU change:** call load service to fetch:
  - current basis (as of now)
  - basis policy history (effective-dated, descending by effectiveFrom)
- **On Change Basis click:** open dialog with:
  - current basis prefilled read-only for reference
  - new basis selection required
  - effectiveFrom required (date/time)
- **On submit:**
  - client-side required-field validation (basis, effectiveFrom present)
  - call backend update/create policy service
  - on success: close dialog, refresh data, show confirmation
  - on error: keep dialog open, show field errors and/or top-level error

### State changes (frontend-local)
- Loading states for:
  - initial screen load
  - history reload after mutation
  - submit in progress (disable submit, show spinner)
- No client-side state machine beyond reflecting backend policy/historical records.

### Service interactions
- `loadAccountingBasisPolicy` (read)
- `createOrChangeAccountingBasisPolicy` (write)
- Optional: `loadFiscalPeriods` or `validateEffectiveFrom` if backend supports (see Open Questions)

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- `basis` must be one of: `ACCRUAL`, `CASH`.
- `effectiveFrom` is required and must align to fiscal period boundary rule.
- Only authorized users can create/change policy:
  - If unauthorized: UI hides ‚ÄúChange Basis‚Äù and backend returns 403 if attempted.

### Enable/disable rules
- Disable submit button while request in flight.
- Disable ‚ÄúChange Basis‚Äù if:
  - no businessUnit selected
  - user lacks permission
- If backend indicates there is a ‚Äúpending future-dated change‚Äù and policy disallows stacking changes, UI must reflect that (unknown‚Äîneeds clarification).

### Visibility rules
- Show ‚ÄúAudit/History‚Äù section to all users with read permission.
- Show ‚ÄúChange Basis‚Äù action only to users with admin permission.

### Error messaging expectations
- Map backend validation errors to:
  - field-level messages for `basis` and `effectiveFrom`
  - top-level alert for permission/period-locked/conflict/system errors
- Errors must not expose sensitive information.

---

## 8. Data Requirements

### Entities involved (frontend view models)
- **BusinessUnit**
  - `businessUnitId` (string/ID)
  - `businessUnitName` (string)
  - `accountingBasis` (enum) ‚Äî if backend exposes directly on BU
- **BusinessUnitAccountingBasisPolicy** (recommended by backend)
  - `businessUnitId` (ID, required)
  - `basis` (enum `ACCRUAL|CASH`, required)
  - `effectiveFrom` (timestamp, required)
  - `changedByUserId` (ID, read-only)
  - `changedAt` (timestamp, read-only)

### Fields (type, required, defaults)
**Form fields**
- `businessUnitId`: ID, required (from screen context)
- `newBasis`: enum, required, no default (to avoid accidental changes)
- `effectiveFrom`: datetime, required, no default unless backend provides ‚Äúnext period start‚Äù

### Read-only vs editable
- Read-only:
  - current basis display
  - history rows
  - `changedByUserId`, `changedAt`
- Editable (only with permission):
  - `newBasis`, `effectiveFrom`

### Derived/calculated fields
- ‚ÄúCurrent basis‚Äù derived by backend as basis effective at ‚Äúnow‚Äù (or latest effectiveFrom <= now).
- ‚ÄúStatus‚Äù for history row (derived in UI):
  - `EFFECTIVE` if effectiveFrom <= now and is the latest such record
  - `SCHEDULED` if effectiveFrom > now
(If backend provides explicit status, prefer backend value.)

---

## 9. Service Contracts (Frontend Perspective)

> **Clarification required:** exact Moqui service names/paths and request/response shapes are not provided. Below defines required contracts.

### Load/view calls
1. **Service:** `AccountingServices.getBusinessUnitAccountingBasis`
   - **Inputs:** `businessUnitId`
   - **Outputs:**
     - `currentBasis` (`ACCRUAL|CASH`)
     - `currentEffectiveFrom` (timestamp, optional)
     - `history[]` list of policy records (see Data Requirements)
   - **Errors:**
     - 401/403 unauthorized
     - 404 businessUnit not found

### Create/update calls
2. **Service:** `AccountingServices.changeBusinessUnitAccountingBasis`
   - **Inputs:**
     - `businessUnitId`
     - `basis`
     - `effectiveFrom`
   - **Outputs:**
     - `policyId` (optional)
     - updated `currentBasis` (optional)
   - **Errors:**
     - 400 invalid basis
     - 422 invalid effectiveFrom (not at fiscal boundary)
     - 409 conflict (concurrency / overlapping effective-dated record)
     - 403 insufficient permission
     - 423 locked/closed period (or 409 with specific code)

### Submit/transition calls
- None beyond the change service.

### Error handling expectations
- Backend error response must include:
  - stable `errorCode`
  - human-readable `message`
  - optional `fieldErrors` map: `{ fieldName: message }`
Frontend mapping:
- `fieldErrors.effectiveFrom` ‚Üí show under effectiveFrom picker
- `fieldErrors.basis` ‚Üí show under basis select
- other codes ‚Üí show banner/toast and log correlation id if provided

---

## 10. State Model & Transitions

### Allowed states
Policy records are effective-dated; user-facing states:
- `EFFECTIVE` (current as-of now)
- `HISTORICAL` (past)
- `SCHEDULED` (future effective)

### Role-based transitions
- Users with `ACCOUNTING_ADMIN` (exact permission string TBD) can create a new scheduled/effective policy record.
- Non-admin users can only view.

### UI behavior per state
- If `SCHEDULED` exists:
  - display it distinctly in history
  - indicate ‚Äúwill become effective on <effectiveFrom>‚Äù
  - whether it can be edited/cancelled is **not defined** (Open Question)

---

## 11. Alternate / Error Flows

### Validation failures
- Missing basis/effectiveFrom ‚Üí block submit client-side with required-field message.
- Backend rejects effectiveFrom boundary ‚Üí keep dialog open, show backend message on field.

### Concurrency conflicts
- If backend returns 409 due to overlapping effective-dated policy or stale data:
  - show conflict banner: ‚ÄúAccounting basis was updated by another user. Reloading‚Ä¶‚Äù
  - refresh history and current basis
  - keep dialog open but require user to re-confirm values (do not auto-resubmit)

### Unauthorized access
- If load returns 403:
  - show ‚ÄúYou do not have access to view accounting basis policy for this business unit.‚Äù
- If change returns 403:
  - show ‚ÄúYou do not have permission to change accounting basis.‚Äù and keep dialog open read-only or close (TBD; recommend close and refresh permissions)

### Empty states
- No history returned:
  - show empty state ‚ÄúNo basis history found. Current basis: <value or unknown>‚Äù
- No business units available to user:
  - show empty state with guidance to contact admin

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: View current basis and history
**Given** I am an authenticated user with permission to view accounting policies  
**And** I am on the Accounting Basis screen with a selected business unit  
**When** the screen loads  
**Then** I see the current accounting basis for the business unit  
**And** I see a list of effective-dated basis policy history entries (or an empty-state message if none)

### Scenario 2: Authorized user changes basis with valid effective date
**Given** I have permission `ACCOUNTING_ADMIN` (or equivalent)  
**And** a business unit currently has basis `ACCRUAL`  
**When** I submit a change to basis `CASH` with an effectiveFrom aligned to the fiscal period start  
**Then** the system saves the new basis policy  
**And** the UI shows a success confirmation  
**And** the history list refreshes showing the new record with the correct effectiveFrom  
**And** audit fields (changedAt/changedBy) are visible for the new record (if returned by backend)

### Scenario 3: Unauthorized user cannot change basis
**Given** I do not have permission to change accounting basis  
**When** I view the Accounting Basis screen  
**Then** I do not see an enabled ‚ÄúChange Basis‚Äù action  
**And** if I attempt to submit a change via direct request, the backend returns 403 and the UI displays an authorization error

### Scenario 4: Effective date not aligned to fiscal period boundary is rejected
**Given** I have permission to change accounting basis  
**When** I submit a basis change with an effectiveFrom that is not at a fiscal period start  
**Then** the backend rejects the request with a validation error  
**And** the UI displays an error on the effectiveFrom field  
**And** no change is reflected in current basis or history after refresh

### Scenario 5: Conflict due to concurrent change
**Given** I have permission to change accounting basis  
**And** another admin changes the basis policy for the same business unit while my dialog is open  
**When** I submit my change  
**Then** the backend returns a 409 conflict (or equivalent)  
**And** the UI informs me of the conflict  
**And** the UI reloads current basis and history  
**And** my change is not applied unless I re-submit with updated context

---

## 13. Audit & Observability

### User-visible audit data
- For each history row, show:
  - `basis`
  - `effectiveFrom`
  - `changedAt`
  - `changedBy` (username if resolvable, else userId)
- If backend emits/returns an `AccountingBasisChanged` event reference or id, show it as read-only metadata (optional).

### Status history
- History list is the authoritative status history for basis changes.

### Traceability expectations
- All change requests include:
  - `businessUnitId`
  - `basis`
  - `effectiveFrom`
- Frontend logs (console/app log) must include correlation id if provided by backend response headers.

---

## 14. Non-Functional UI Requirements
- **Performance:** initial load should render within 2s on typical WAN once backend responds; show skeleton/loading indicator.
- **Accessibility:** dialog and form fields must be keyboard navigable; labels associated with inputs; errors announced via aria-live region (Quasar patterns).
- **Responsiveness:** screen usable on tablet resolutions; history list scrolls.
- **i18n/timezone:** effectiveFrom must be displayed and selected in the user‚Äôs timezone, but submitted as an unambiguous timestamp format expected by backend (needs clarification on timezone handling).

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide explicit empty-state messaging for no history / no business units; safe as UI-only and does not affect domain logic. Impacted sections: UX Summary, Alternate / Error Flows.
- SD-UX-LOADING: Use standard loading/skeleton and disable submit during requests; safe UI ergonomics. Impacted sections: Functional Behavior, Non-Functional.
- SD-ERR-MAP-STD: Standard mapping of backend `fieldErrors` and `errorCode` to field/banners; safe because it relies on backend-provided contract and does not invent business rules. Impacted sections: Service Contracts, Error Flows.

---

## 16. Open Questions
1. **Backend service/API contract:** What are the exact Moqui service names/paths, input/output fields, and error response schema for:
   - loading current basis + history
   - creating a basis change (effective-dated)?
2. **Authorization:** What is the exact permission(s)/authz condition for:
   - viewing basis policy
   - changing basis (is it `ACCOUNTING_ADMIN`, `CoA:Manage`, or another permission string)?
3. **Fiscal boundary rule details:** Is ‚Äústart of fiscal period‚Äù always **start of fiscal month at 00:00:00** in the business unit‚Äôs timezone, or can fiscal periods be custom? Can the frontend fetch valid period start options?
4. **Timezone expectations:** In which timezone should `effectiveFrom` be interpreted and validated (business unit timezone vs user timezone vs UTC)? What timestamp format does backend expect?
5. **Future-dated changes policy:** Are multiple scheduled future changes allowed? If not, should UI block creation when a scheduled change exists, or allow overwrite/cancel?
6. **Closed/locked period handling:** Does backend return a specific error code/status for locked periods (e.g., 423) and should UI show a specialized message?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] GL: Support Accrual vs Cash Basis Modes  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/199  
Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] GL: Support Accrual vs Cash Basis Modes

**Domain**: payment

### Story Description

/kiro  
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Post Journal Entries to the General Ledger

## Story
GL: Support Accrual vs Cash Basis Modes

## Acceptance Criteria
- [ ] Business unit can be configured as accrual or cash basis
- [ ] Accrual: invoices post AR/AP and payments clear AR/AP
- [ ] Cash basis behavior is policy-defined and consistent across posting/reporting
- [ ] Basis changes are audited and permission-controlled

### Frontend Requirements
- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack
- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---  
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #200: [FRONTEND] [STORY] GL: Post Journal Entry with Period Controls and Atomicity  
File: ./scripts/story-work/frontend/200/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] GL: Post Journal Entry with Period Controls and Atomicity

### Primary Persona
GL Accountant / Controller (back-office user responsible for posting journal entries)

### Business Value
Enable controlled, auditable posting of journal entries to the ledger with strict period enforcement and atomic commit semantics, preventing financial corruption and ensuring traceability from source events to posted entries.

---

## 2. Story Intent

### As a / I want / So that
- **As a** GL Accountant / Controller  
- **I want** to review a draft journal entry and post it to the ledger only when the accounting period is eligible  
- **So that** ledger balances and trial balance aggregates remain consistent, and the originating source event is marked Posted with a permanent journal entry reference.

### In-scope
- A Moqui screen flow to **view a Journal Entry** and **initiate posting**
- UI display of **period status** for the JE posting date (Open/Closed/other if returned)
- Posting action that calls a backend ‚Äúpost‚Äù service and handles:
  - atomic success
  - period-closed rejection (or alternate policy if defined)
  - validation failures (unbalanced, invalid account, etc.)
  - concurrency conflicts
- Display of post results: posted timestamp/status, JE reference, and source event linkage

### Out-of-scope
- Creating/editing journal entries and journal entry lines
- Defining accounting periods, opening/closing periods
- Defining GL accounts, posting rule sets, or mappings
- Any GL account balance drilldown UI (only confirm that posting updates are reflected via returned status/data)
- Implementing backend atomicity/period logic (frontend consumes it)

---

## 3. Actors & Stakeholders
- **GL Accountant / Controller (primary user):** initiates posting, needs clear blocking reasons and audit evidence.
- **Auditor (secondary stakeholder):** expects immutable traceability and viewable status history.
- **Upstream Source System / Module (stakeholder):** needs the source event marked Posted with JE reference.
- **System Admin (stakeholder):** expects permission enforcement and safe error messaging.

---

## 4. Preconditions & Dependencies

### Preconditions
- A `JournalEntry` exists in a **postable pre-post state** (exact state names TBD; see Open Questions) and is balanced per backend validation rules.
- User is authenticated in the frontend.

### Dependencies (must exist or be stubbed)
- Backend endpoints/services to:
  - Load a journal entry by ID (including lines, totals, postingDate, status)
  - Fetch accounting period status for a posting date **or** provide it on JE load
  - Post a journal entry (atomic operation)
- Authorization contract defining what permission is required to post (TBD; see Open Questions)

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- From a GL work queue/list (if exists) linking to:  
  `#/gl/journal-entry/<journalEntryId>` (route/path TBD to match repo conventions; see Open Questions)
- Direct navigation via URL with `journalEntryId`

### Screens to create/modify
1. **Screen: `GL/JournalEntryDetail` (new or modify existing)**
   - Shows JE header + lines + computed totals + current status
   - Contains primary action: **Post Journal Entry**
   - Shows accounting period status for JE posting date (Open/Closed/etc.)

2. **Dialog/Subscreen: `GL/PostJournalEntryConfirm` (recommended)**
   - Confirmation step summarizing impacts:
     - posting date & derived period
     - JE balanced status (as known by backend)
     - source event reference (if present)
   - Action: Confirm Post

### Navigation context
- Breadcrumb: GL ‚Üí Journal Entries ‚Üí Journal Entry Detail
- After successful posting:
  - Stay on detail screen and refresh state (preferred)
  - Show success banner with posted reference info

### User workflows
**Happy path**
1. User opens JE detail
2. User confirms JE is ready, sees period is Open
3. User clicks Post ‚Üí confirm dialog ‚Üí Confirm
4. UI calls post service
5. UI displays Posted state + JE/ledger references and disables further posting

**Alternate paths**
- Period closed: user attempts post, backend rejects; UI shows blocking reason and next-step guidance per policy (policy unclear ‚Üí see Open Questions)
- Validation failure (unbalanced/invalid accounts): UI shows actionable errors; user cannot post
- Concurrency: JE already posted/changed; UI prompts refresh and shows latest state

---

## 6. Functional Behavior

### Triggers
- Screen load with `journalEntryId`
- User clicks **Post Journal Entry**
- User confirms posting in dialog

### UI actions
- **On load:** call load service; render header/lines/totals/status
- **Post button enabled only when:**
  - user has permission to post (if permission is exposed to UI or returned via service)
  - JE status is in ‚ÄúReady/Draft/Approved‚Äù (exact states TBD)
  - JE is not already Posted
  - Period status is Open (or policy-driven)
- **On Post confirm:**
  - call post service with `journalEntryId` (and any required parameters, e.g., expectedVersion)

### State changes (frontend-visible)
- JE status transitions to `Posted` on success
- Source event status shown as `Posted` with JE reference (if source event is displayed/returned)
- UI becomes read-only for posting action (post button hidden/disabled)
- Status history/audit section updates with posting attempt outcome (if returned)

### Service interactions (Moqui)
- Use Moqui screen actions (`service-call` or `entity-find` as appropriate) to:
  - load JE data
  - post JE
- Use transitions for:
  - refresh after post
  - error routing (remain on same screen with messages)

---

## 7. Business Rules (Translated to UI Behavior)

### Validation (UI behavior)
- UI must treat backend as authoritative for:
  - balanced check
  - period eligibility
  - account validity/locked status
  - atomic posting eligibility
- UI must display backend validation errors inline at top as message list and near relevant fields where possible.

### Enable/disable rules
- Disable Post action when JE is already Posted.
- Disable Post action when backend indicates period is Closed (unless policy allows override/redirect; TBD).
- Disable Post action while a post request is in flight (prevent double-submit).

### Visibility rules
- If JE status is Posted:
  - Show posted timestamp (if returned)
  - Show posting user (if returned)
  - Show immutable banner ‚ÄúPosted entries cannot be modified; corrections require a reversing entry‚Äù (text-only informational)

### Error messaging expectations
Backend error codes should be surfaced with user-friendly messages, while retaining a technical code for support (e.g., ‚ÄúPeriod is closed (BusinessRule:PeriodClosed)‚Äù).

---

## 8. Data Requirements

> Note: Exact entity field names are not provided in inputs; below is the **frontend data contract expectation** and must be mapped to actual Moqui entities/services during implementation.

### Entities involved (conceptual)
- `JournalEntry`
- `JournalEntryLine`
- `AccountingPeriod` (lookup by posting date, or embedded in JE response)
- `SourceEventRef` (reference to originating event/document)
- `LedgerEntry` (not required to display line-by-line, but JE should reflect that ledger posting occurred)

### Fields (type, required, defaults)

**JournalEntry (read-only in this story)**
- `journalEntryId` (string/UUID) ‚Äî required
- `status` (string/enum) ‚Äî required
- `postingDate` (date) ‚Äî required
- `currencyUomId` (string) ‚Äî required
- `description` (string) ‚Äî optional
- `sourceEventId` (string/UUID) ‚Äî optional (but required to satisfy ‚Äúsource event transitions‚Äù AC if applicable)
- `sourceEventType` (string) ‚Äî optional
- `totalDebit` (decimal) ‚Äî required (display)
- `totalCredit` (decimal) ‚Äî required (display)
- `isBalanced` (boolean) ‚Äî optional (if backend provides; otherwise derived visually by totals equality but **do not** treat as authoritative)
- `postedAt` (datetime) ‚Äî optional (present if Posted)
- `postedByUserId` (string) ‚Äî optional (present if Posted)
- `version` / `lastUpdatedStamp` (for optimistic locking) ‚Äî optional but recommended

**JournalEntryLine (read-only)**
- `lineSeqId` or `lineId` ‚Äî required
- `glAccountId` ‚Äî required
- `glAccountName` ‚Äî optional
- `debitAmount` (decimal >= 0) ‚Äî required
- `creditAmount` (decimal >= 0) ‚Äî required
- `memo` (string) ‚Äî optional

**AccountingPeriod (read-only)**
- `accountingPeriodId` ‚Äî optional
- `startDate` / `endDate` ‚Äî optional
- `status` (Open/Closed/‚Ä¶) ‚Äî required if shown

### Read-only vs editable by state/role
- All fields are **read-only** in this story.
- Only action is ‚ÄúPost‚Äù (state transition).

### Derived/calculated fields (frontend display only)
- ‚ÄúOut of balance amount‚Äù = abs(totalDebit - totalCredit) (for display); **backend still enforces** balanced rule.

---

## 9. Service Contracts (Frontend Perspective)

> Service names/endpoints are not provided; Moqui developer must bind to actual services. The following is the required contract shape.

### Load/view calls
1. **Get Journal Entry Detail**
   - Input: `journalEntryId`
   - Output: JournalEntry header + lines + (optional) period info + permissions hints
   - Errors:
     - `NOT_FOUND` ‚Üí show ‚ÄúJournal Entry not found‚Äù
     - `UNAUTHORIZED`/`FORBIDDEN` ‚Üí show access denied screen/message

2. **Get Accounting Period Status** (if not embedded)
   - Input: `postingDate` (and possibly `businessUnitId`)
   - Output: period status + id/date range
   - Errors: service unavailable ‚Üí show warning ‚ÄúPeriod status unavailable; posting will be validated on submit.‚Äù

### Submit/transition calls
3. **Post Journal Entry (atomic)**
   - Input: `journalEntryId`
   - Optional inputs (TBD): `expectedVersion` for concurrency, `overridePolicyFlag` if overrides exist
   - Output on success:
     - updated JE status = Posted
     - `postedAt`, `postedBy`
     - reference(s) confirming ledger update and source event link (at minimum `journalEntryId` plus source event updated flag/id)
   - Error handling expectations (non-exhaustive):
     - `BusinessRule:PeriodClosed` ‚Üí show blocking message; do not change UI state
     - `Validation:Unbalanced` ‚Üí show validation message; do not change UI state
     - `Validation:InvalidAccount` ‚Üí show validation message (include which account/line if returned)
     - `CONFLICT` (already posted / version mismatch) ‚Üí prompt refresh and reload JE
     - `SERVER_ERROR` ‚Üí show generic failure, keep user on page, allow retry if safe

---

## 10. State Model & Transitions

> Exact statuses are not defined in inputs; frontend must be tolerant to backend-provided values.

### Allowed states (minimum)
- `Draft` or `ReadyForPosting` (pre-post)
- `Posted` (terminal/immutable)

### Role-based transitions
- User with posting permission can transition:
  - pre-post ‚Üí Posted (only if period eligible and validations pass)
- Users without permission:
  - cannot invoke post; should see disabled action or be blocked with a forbidden error if they attempt direct transition

### UI behavior per state
- **Pre-post:** show Post action (if permitted) and warnings if period not Open / period unknown.
- **Posted:** hide/disable Post; show posted metadata; show immutable info banner.

---

## 11. Alternate / Error Flows

### Validation failures
- Backend returns one or more validation errors:
  - UI displays error summary
  - Keeps user on detail screen
  - Post action remains available only if errors are transient (generally remains available after user refresh; no edits in this story)

### Concurrency conflicts
- If backend returns conflict indicating JE already posted/changed:
  - UI shows ‚ÄúThis journal entry changed since you opened it‚Äù
  - Provide action: Refresh (re-load JE detail)
  - After refresh, reflect new status and disable posting if posted

### Unauthorized access
- If load fails with forbidden:
  - show access denied state, no JE data rendered

### Empty states
- JE has zero lines:
  - show ‚ÄúNo lines available‚Äù
  - Post must be disabled; backend likely rejects as invalid (still handle if user tries via direct call)

---

## 12. Acceptance Criteria

### Scenario 1: Successful posting to an open period
**Given** I have permission to post journal entries  
**And** a journal entry exists in a pre-post status with debits equal credits  
**And** the journal entry posting date is within an Open accounting period  
**When** I open the Journal Entry detail screen  
**And** I click ‚ÄúPost Journal Entry‚Äù and confirm  
**Then** the system posts the journal entry successfully  
**And** the UI refreshes to show status ‚ÄúPosted‚Äù with posted timestamp/user (if provided)  
**And** the UI disables further posting actions for that entry  
**And** the UI shows that the source event is marked Posted with a journal entry reference (when source event info is provided by backend).

### Scenario 2: Attempted posting to a closed period is blocked
**Given** I have permission to post journal entries  
**And** a balanced journal entry exists in a pre-post status  
**And** the posting date is within a Closed accounting period  
**When** I attempt to post the journal entry  
**Then** the UI shows a blocking error indicating the period is closed (including backend error code `BusinessRule:PeriodClosed`)  
**And** the journal entry remains in the pre-post status in the UI after refresh  
**And** no posted metadata is shown.

### Scenario 3: Attempted posting of an unbalanced entry is rejected
**Given** I have permission to post journal entries  
**And** a journal entry exists where total debits do not equal total credits  
**When** I attempt to post the journal entry  
**Then** the UI shows a validation error including code `Validation:Unbalanced`  
**And** the journal entry status does not change to Posted.

### Scenario 4: Backend transaction failure results in no partial posting
**Given** I have permission to post journal entries  
**And** a balanced journal entry exists in an Open period  
**When** I attempt to post the journal entry  
**And** the backend responds with an internal error after beginning posting  
**Then** the UI shows a non-success error message and does not show Posted status  
**And** when I refresh the journal entry detail, it is still not Posted.

### Scenario 5: Concurrency conflict (already posted)
**Given** I have permission to post journal entries  
**And** I am viewing a pre-post journal entry  
**And** the journal entry is posted by another user/session  
**When** I attempt to post it  
**Then** the UI shows a conflict message and prompts me to refresh  
**And** after refresh, the UI shows status Posted and disables posting.

### Scenario 6: Unauthorized user cannot post
**Given** I do not have permission to post journal entries  
**When** I open the journal entry detail screen  
**Then** the Post action is not available (hidden or disabled)  
**And** if I attempt to invoke posting via direct URL/action, the UI shows an access denied error.

---

## 13. Audit & Observability

### User-visible audit data
- Display (when provided):
  - `postedAt`
  - `postedByUserId` (or username)
  - JE status history entries (if backend returns history)

### Status history
- At minimum, the UI should show current status.
- If backend returns history events (recommended), show chronological list including:
  - attempted posting (success/fail) with timestamp and actor

### Traceability expectations
- On success, UI must show a persistent link/reference between:
  - `sourceEventId` (if present) and `journalEntryId`
- UI must preserve and display backend-provided correlation identifiers in an expandable ‚ÄúTechnical details‚Äù section (if provided), without exposing secrets.

---

## 14. Non-Functional UI Requirements
- **Performance:** JE detail loads within 2 seconds for up to 200 lines on typical network; show loading skeleton/spinner during fetch.
- **Accessibility:** All actions keyboard accessible; confirmation dialog focus-trapped; error summary announced via ARIA live region.
- **Responsiveness:** Usable on tablet widths; line table supports horizontal scroll if needed.
- **i18n/timezone/currency:**
  - Format currency amounts using `currencyUomId`
  - Display datetimes in user‚Äôs timezone; do not alter postingDate semantics.

---

## 15. Applied Safe Defaults
- SD-UI-EMPTY-STATE: Provide explicit empty-state messaging for ‚Äúno lines‚Äù and ‚Äúnot found‚Äù; safe because it affects only UX clarity, not domain policy. (Impacted: UX Summary, Alternate/Empty states)
- SD-UI-DOUBLE-SUBMIT-GUARD: Disable Post button while request in-flight to prevent duplicate submits; safe because it reduces accidental repeats without changing business behavior. (Impacted: Functional Behavior, Error Flows)
- SD-ERR-MAP-GENERIC: Map unknown backend errors to a generic failure message while retaining technical code when available; safe because it doesn‚Äôt change outcomes, only presentation. (Impacted: Service Contracts, Error Flows)

---

## 16. Open Questions

1. **Closed period policy (blocking):** The requirement says ‚Äúblock posting or redirect per policy (with recorded rationale)‚Äù. What is the approved policy?
   - A) Strict block (reject)  
   - B) Redirect to next open period (auto-adjust date)  
   - C) Allow with override permission (requires explicit permission + audit reason capture UI)

2. **Posting permission contract (blocking):** What permission/scope controls posting journal entries in this system (e.g., `gl.je.post`, `accounting:gl:post`)? Should UI rely on:
   - a permissions payload returned by backend, or
   - a fixed permission name checked via Moqui artifact authz?

3. **JournalEntry state names (blocking for enable/disable rules):** What are the exact backend statuses for JE lifecycle (e.g., Draft/Approved/Ready/Posted/Void)? Which are eligible for posting?

4. **Service/API names and response shapes (blocking for Moqui wiring):** What are the actual Moqui services/endpoints for:
   - load JE detail (+ lines)
   - retrieve accounting period status (if separate)
   - post JE (and required request params like `expectedVersion`)?

5. **Source event linkage fields (blocking for AC completeness):** How is ‚ÄúSource event status transitions to Posted with JE reference‚Äù exposed to the frontend?
   - Is there a `sourceEvent` object returned on post?
   - Or must the UI call a separate service to verify/update source event status?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] GL: Post Journal Entry with Period Controls and Atomicity  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/200  
Labels: frontend, story-implementation, general

## Frontend Implementation for Story

**Original Story**: [STORY] GL: Post Journal Entry with Period Controls and Atomicity

**Domain**: general

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Post Journal Entries to the General Ledger

## Story
GL: Post Journal Entry with Period Controls and Atomicity

## Acceptance Criteria
- [ ] Posting is atomic (all lines committed or none)
- [ ] Closed periods block posting or redirect per policy (with recorded rationale)
- [ ] Posting updates ledger/trial-balance aggregates
- [ ] Source event status transitions to Posted with JE reference


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #201: [FRONTEND] [STORY] GL: Build Balanced Journal Entry from Event  
File: ./scripts/story-work/frontend/201/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] GL: Build Balanced Journal Entry from Event (Draft JE creation & review UI)

### Primary Persona
Accountant / GL Specialist (back-office user) who monitors and reviews draft Journal Entries generated from source events.

### Business Value
Provide an auditable, UI-accessible representation of automatically generated draft Journal Entries (JEs) created from domain events, enabling review/troubleshooting and ensuring only balanced, traceable entries proceed toward posting workflows.

---

## 2. Story Intent

### As a / I want / So that
- **As a** GL Specialist  
- **I want** to view the draft Journal Entry created from a source event, including header traceability (eventId/source refs/rule version) and balanced lines per currency  
- **So that** I can verify correctness, investigate mapping failures, and support downstream posting controls without needing database access.

### In-scope
- Moqui screen(s) to:
  - Search/list draft Journal Entries and open a JE detail view
  - View JE header traceability fields (event references, mapping rule version)
  - View JE lines including account/category/dimensions and debit/credit amounts
  - Display balance status **per currency** (balanced vs not balanced) as a computed UI check
- Error/empty states for missing data, unauthorized access, and load failures
- Basic navigation entry points from an Accounting/GL menu

### Out-of-scope
- Creating JEs from events in the frontend (event consumption/transformation is backend-owned)
- Editing JE lines or headers (draft generation is automated; story does not define manual correction)
- Posting JEs to the ledger (separate capability/story)
- Defining/maintaining mapping rules, suspense policies, or chart of accounts data management (separate stories)

---

## 3. Actors & Stakeholders
- **Primary user:** Accountant / GL Specialist
- **Secondary stakeholders:**
  - Auditor (needs traceability and immutable history visibility)
  - System Admin (triages mapping/rule issues)
  - Upstream domain owners (Billing, POS, Work Execution) as event producers

---

## 4. Preconditions & Dependencies
- Backend provides persisted draft Journal Entries generated from events, including:
  - Header refs: `eventId`, `sourceModule/sourceSystem`, `sourceEntityRef`, `mappingRuleVersionId` (or equivalent)
  - Lines with: account references, category references, dimension references, debit/credit amounts, currency
- Backend provides an API/service to:
  - List/search JEs
  - Load JE detail with lines
- Authorization permissions exist for viewing accounting/GL journal entries.

**Dependency note (blocking):** The frontend cannot be fully buildable until service names/endpoints, entity names, and permission strings are confirmed (see Open Questions).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main menu: **Accounting ‚Üí General Ledger ‚Üí Journal Entries**
- Optional deep link: `/accounting/gl/journal-entry/<journalEntryId>` (exact path TBD per repo conventions)

### Screens to create/modify
1. **Screen: `Accounting/GL/JournalEntryList`**
   - Search/list journal entries (default filter Draft)
2. **Screen: `Accounting/GL/JournalEntryDetail`**
   - Read-only header + lines
   - Balance-by-currency summary panel
3. (Optional) **Screen: `Accounting/GL/EventProcessingFailures`** (only if backend exposes failure records; otherwise out-of-scope)

### Navigation context
- From list ‚Üí click JE row ‚Üí detail
- From detail ‚Üí back to list (preserving prior filters in parameters where possible)

### User workflows
#### Happy path
1. User opens Journal Entry list
2. User filters by status = Draft, date range, source module, eventId
3. User opens a JE
4. User reviews header traceability + mapping rule version
5. User reviews lines and confirms balanced per currency (UI computed check matches backend indicator if present)

#### Alternate paths
- User searches by `eventId`; no results ‚Üí empty state explaining no JE found for that event
- User opens JE detail but lacks permission ‚Üí access denied screen/message
- JE loads but lines missing/invalid ‚Üí show data integrity warning banner and allow copy of identifiers for support

---

## 6. Functional Behavior

### Triggers
- User navigates to JE list or JE detail screens.

### UI actions
- List screen:
  - Apply filters (status, date range, eventId, source system/module, currency)
  - Open JE detail
- Detail screen:
  - View header fields
  - View lines table
  - View balance summary per currency
  - Copy key identifiers (journalEntryId, eventId, mappingRuleVersionId) to clipboard (UI-only convenience)

### State changes
- None (read-only in this story). No transitions or edits.

### Service interactions
- `searchJournalEntries` (list)
- `getJournalEntryDetail` (header + lines)
- (Optional) `getJournalEntryAuditTrail` if backend exposes JE audit events

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- Filters:
  - `eventId` input must be a valid UUID format if provided; otherwise show inline validation error and do not submit search.
  - Date range must have `from <= to` else inline error.
- JE detail display:
  - If JE has multiple currencies, compute balancing per currency group and display per currency totals.
  - If any currency group is not balanced, show **prominent warning**: ‚ÄúNot balanced for currency <CUR>: debits X != credits Y‚Äù. (This should be possible only if backend allowed it; still display defensively.)

### Enable/disable rules
- ‚ÄúView detail‚Äù action disabled until a row is selected (if using selection model) or always enabled via row click.
- Any ‚ÄúPost‚Äù, ‚ÄúEdit‚Äù, ‚ÄúRebuild‚Äù buttons **must not** be present unless explicitly required by a future story.

### Visibility rules
- Show mapping rule version only if present; if absent, show ‚ÄúNot available‚Äù and a warning badge ‚ÄúMissing mapping reference‚Äù.

### Error messaging expectations
- Map backend errors to user-facing messages:
  - 401/403: ‚ÄúYou don‚Äôt have access to General Ledger journal entries.‚Äù
  - 404 on detail: ‚ÄúJournal Entry not found (may have been deleted or you may not have access).‚Äù
  - 409/422: show backend-provided error code + message (sanitized) and include IDs for support.

---

## 8. Data Requirements

### Entities involved (conceptual; exact Moqui entity names TBD)
- `JournalEntry` (header)
- `JournalEntryLine` (lines)
- (Optional) `PostingRuleSetVersion` or `MappingRuleVersion`
- (Optional) `GLAccount`, `PostingCategory`, `Dimension` references for display names

### Fields (type, required, defaults)
**JournalEntry (Header)**
- `journalEntryId` (string/UUID, required, read-only)
- `status` (enum: at least `Draft`; required, read-only)
- `transactionDate` (date/datetime, required, read-only)
- `sourceEventId` / `eventId` (UUID, required, read-only)
- `sourceModule` or `sourceSystem` (string, required, read-only)
- `sourceEntityRef` (string, required, read-only)
- `schemaVersion` (string, optional, read-only) ‚Äî if stored
- `mappingRuleVersionId` (string/UUID, required for traceability; if missing, UI flags)
- `businessUnitId` (string/UUID, optional; display if available)
- `currencyUomId` (string; optional if multi-currency at line level)

**JournalEntryLine**
- `journalEntryLineId` (string/UUID, required)
- `lineNumber` (int, optional but preferred for stable ordering)
- `postingCategoryId` / `glCategoryId` (string/UUID, required)
- `glAccountId` (string/UUID, required)
- `dimensions` (object or separate fields; optional but may be required by rule)
  - examples: `locationId`, `departmentId`, `customerId`, etc. (do not invent which ones are required)
- `currencyUomId` (string, required)
- `debitAmount` (decimal, nullable)
- `creditAmount` (decimal, nullable)
  - Exactly one of debit/credit should be non-zero per line (if backend supports); UI displays both columns.
- `memo/description` (string, optional)

### Read-only vs editable by state/role
- All fields are read-only for all roles in this story.

### Derived/calculated fields (frontend)
- For each `currencyUomId`:
  - `totalDebits = sum(debitAmount)`
  - `totalCredits = sum(creditAmount)`
  - `isBalanced = (totalDebits == totalCredits)` using currency-scale comparison (see Open Question about rounding/scale in UI)

---

## 9. Service Contracts (Frontend Perspective)

> **Blocking:** Actual Moqui service names, parameters, and response structures must be confirmed.

### Load/view calls
1. **List/search**
   - Service: `AccountingServices.searchJournalEntries` (placeholder)
   - Inputs (query params):
     - `status` (default `Draft`)
     - `fromDate`, `toDate`
     - `eventId`
     - `sourceModule`
     - `currencyUomId`
     - pagination: `pageIndex`, `pageSize`
     - sorting: `orderBy` (default newest first by transactionDate/createdAt)
   - Output:
     - array of JE headers + `totalCount`

2. **Detail**
   - Service: `AccountingServices.getJournalEntry` (placeholder)
   - Input: `journalEntryId`
   - Output:
     - header
     - lines[]
     - (optional) computed backend balance status per currency (if provided)

### Create/update calls
- None.

### Submit/transition calls
- None.

### Error handling expectations
- Standard Moqui service error structure surfaced to UI with:
  - `errorCode` (preferred)
  - `message`
  - field errors (for filter validation if backend validates)
- For list/detail failures, UI must show a retry action.

---

## 10. State Model & Transitions

### Allowed states
- `Draft` (required for this story)
- `Posted`, `Cancelled` may exist but are view-only if returned.

### Role-based transitions
- None in this story.

### UI behavior per state
- Draft: normal view
- Posted/Cancelled (if shown in list/detail): show status badge; still read-only.

---

## 11. Alternate / Error Flows

### Validation failures
- Invalid `eventId` format on list filter ‚Üí inline error; do not call backend.
- Invalid date range ‚Üí inline error; do not call backend.

### Concurrency conflicts
- If JE disappears between list and detail:
  - Detail load returns 404 ‚Üí show not found message and link back to list.

### Unauthorized access
- 403 on list or detail:
  - Show access denied page; do not reveal existence of specific JE IDs beyond user-provided input.

### Empty states
- No JEs match filters:
  - Show ‚ÄúNo journal entries found‚Äù with suggestions (clear filters, search by eventId).

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: View draft journal entries list with default Draft filter
**Given** the user has permission to view GL journal entries  
**When** the user navigates to Accounting ‚Üí General Ledger ‚Üí Journal Entries  
**Then** the system displays a list of journal entries filtered to status ‚ÄúDraft‚Äù by default  
**And** each row shows at minimum journalEntryId, transactionDate, status, sourceEventId/eventId, and sourceModule/sourceSystem  
**And** the user can open a journal entry detail from the list.

### Scenario 2: Search journal entries by eventId
**Given** the user is on the Journal Entries list screen  
**When** the user enters a valid UUID into the Event ID filter and submits  
**Then** the system requests results filtered by that eventId  
**And** if a matching journal entry exists it is shown in the results  
**And** if no matching journal entry exists the UI shows an empty state indicating no results.

### Scenario 3: Prevent search with invalid eventId
**Given** the user is on the Journal Entries list screen  
**When** the user enters an invalid Event ID value (not a UUID) and submits  
**Then** the UI shows an inline validation error for Event ID  
**And** no backend search request is sent.

### Scenario 4: View journal entry detail with traceability header fields
**Given** a draft Journal Entry exists  
**And** the user has permission to view it  
**When** the user opens the Journal Entry detail screen  
**Then** the UI displays the JE header including sourceEventId/eventId, sourceEntityRef, sourceModule/sourceSystem, transactionDate, status, and mappingRuleVersionId  
**And** the UI displays all journal entry lines with debit and credit columns, currency, glAccount reference, posting category reference, and dimension references (if present).

### Scenario 5: Balance check is shown per currency
**Given** a journal entry detail is displayed with lines in one or more currencies  
**When** the UI computes totals grouped by currency  
**Then** the UI shows total debits and total credits for each currency  
**And** for each currency where totals are equal the UI indicates ‚ÄúBalanced‚Äù  
**And** for each currency where totals are not equal the UI indicates ‚ÄúNot balanced‚Äù and shows the mismatch values.

### Scenario 6: Unauthorized user cannot access journal entries
**Given** the user does not have permission to view GL journal entries  
**When** the user navigates to the Journal Entries list or opens a JE detail URL directly  
**Then** the system shows an access denied message  
**And** does not display journal entry header or line data.

### Scenario 7: Journal entry not found
**Given** the user has permission to view GL journal entries  
**When** the user opens a journalEntryId that does not exist (or is not accessible)  
**Then** the system shows ‚ÄúJournal Entry not found‚Äù  
**And** provides a link back to the Journal Entries list.

---

## 13. Audit & Observability

### User-visible audit data
- Display immutable identifiers for traceability:
  - `journalEntryId`, `sourceEventId/eventId`, `mappingRuleVersionId`, `sourceModule/sourceSystem`, `sourceEntityRef`
- If backend supports, show:
  - created timestamp and createdBy (read-only)
  - processing status / last processed timestamp (if JE is tied to event ingestion pipeline)

### Status history
- Not required unless backend already provides status history; if available, render a read-only timeline component.

### Traceability expectations
- Provide ‚ÄúCopy identifiers‚Äù action to copy a block containing:
  - journalEntryId
  - eventId
  - mappingRuleVersionId
  - sourceModule
  - transactionDate

---

## 14. Non-Functional UI Requirements
- **Performance:** List screen should load first page within 2s under normal conditions; show loading states.
- **Accessibility:** All tables and badges must be keyboard navigable; status conveyed with text (not color only).
- **Responsiveness:** List and detail usable on tablet widths; lines table supports horizontal scroll.
- **i18n/timezone/currency:**
  - Dates displayed in user locale/timezone.
  - Currency amounts formatted with currency code; do not assume symbol-only.
  - No multi-currency conversion performed in UI.

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide standard empty state messaging and ‚ÄúClear filters‚Äù action; safe because it does not change domain behavior. (Impacted: UX Summary, Alternate/Empty states)
- SD-UX-PAGINATION: Paginate list results with page size default (e.g., 25) and server-side pagination parameters; safe because it is a UI ergonomics concern. (Impacted: Service Contracts, UX Summary)
- SD-ERR-STD: Standard mapping of HTTP 401/403/404 to user-friendly messages with retry/back link; safe because it does not alter business rules. (Impacted: Business Rules, Error Flows)

---

## 16. Open Questions

1. **Backend API/service contract (blocking):** What are the exact Moqui services (names, input params, output fields) to:
   - search/list Journal Entries
   - load Journal Entry detail (including lines)
   - (optional) load JE audit/status history?
2. **Permissions (blocking):** What are the exact permission strings/roles for viewing GL journal entries in the frontend (e.g., `gl.je.view`, `accounting.je.view`)?
3. **Entity/field naming (blocking):** Are the canonical fields named `sourceEventId` vs `eventId`, and `mappingRuleVersionId` vs something else? What are the exact dimension fields available on JE lines?
4. **Rounding/scale for UI balance check (blocking):** Should the UI compare debits/credits using:
   - exact decimal equality as provided by backend, or
   - currency-scale rounding before comparison (and what scale per currency)?
5. **Failure policy visibility (clarification):** The requirement mentions ‚ÄúMapping failures route to suspense or rejection per policy.‚Äù Should the frontend expose a view of:
   - failed events / quarantined items / DLQ references,
   - or is that handled in another admin tool/story?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] GL: Build Balanced Journal Entry from Event  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/201  
Labels: frontend, story-implementation, general

## Frontend Implementation for Story

**Original Story**: [STORY] GL: Build Balanced Journal Entry from Event

**Domain**: general

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Post Journal Entries to the General Ledger

## Story
GL: Build Balanced Journal Entry from Event

## Acceptance Criteria
- [ ] Mapped events create a draft journal entry with header refs (eventId/source refs/rule version)
- [ ] JE is balanced per currency (debits=credits)
- [ ] Each JE line includes category, account, and dimension references
- [ ] Mapping failures route to suspense or rejection per policy (no partial postings)

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #202: [FRONTEND] [STORY] Mapping: Configure EventType ‚Üí Posting Rule Set
File: ./scripts/story-work/frontend/202/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

STOP: Clarification required before finalization

---

## 1. Story Header

**Title**: [FRONTEND] [STORY] Mapping: Configure EventType ‚Üí Posting Rule Set

**Primary Persona**: Financial Controller / System Administrator

**Business Value**: Enables controlled, auditable configuration of versioned posting rules that deterministically generate balanced journal entries and provide traceability (journal entry ‚Üí ruleset + version), reducing accounting errors and audit risk.

---

## 2. Story Intent

### As a / I want / So that
- **As a** Financial Controller or System Administrator  
- **I want** to create, version, validate, publish, and archive Posting Rule Sets that map a business `EventType` to accounting postings (with conditional logic)  
- **So that** journal entry generation is balanced, deterministic, and traceable to the exact rule version used.

### In-scope
- Frontend screens to:
  - List Posting Rule Sets and versions
  - View a Posting Rule Set (including version, status, eventType, rules definition)
  - Create a new Posting Rule Set (version 1)
  - Create a new version from an existing rule set/version
  - Publish a DRAFT version (only if it balances / passes server validation)
  - Archive a version (per backend policy)
- Validation UX:
  - Show server-side validation results (including ‚Äúunbalanced‚Äù details)
  - Prevent publish action when backend reports imbalance/invalid references
- Traceability UX (read-only):
  - Display `postingRuleSetId` + `version` metadata clearly on detail views

### Out-of-scope
- Designing the internal semantics of debit/credit mappings (owned by backend rules engine)
- Creating or managing Chart of Accounts, Posting Categories, GL mappings (separate stories)
- Event ingestion processing UI, journal entry creation UI
- Defining or inventing `EventType` values (must come from upstream/canonical list)

---

## 3. Actors & Stakeholders
- **Primary actor:** Financial Controller / System Administrator
- **Stakeholders:**
  - Accounting operations team (needs safe configuration + auditability)
  - Auditors/Compliance (needs immutable version history + traceability)
  - Developers/Integrators (need predictable `EventType` mapping behavior)
- **Systems:**
  - Moqui frontend (this story)
  - Accounting backend service(s) exposing Posting Rule Set APIs (authoritative)

---

## 4. Preconditions & Dependencies
- User is authenticated in the POS admin UI.
- User has required permissions to manage accounting configuration (exact permission strings **TBD**; see Open Questions).
- Backend endpoints exist for:
  - Listing rule sets and versions
  - Viewing a rule set/version
  - Creating rule set and new versions
  - Publishing and archiving
  - Validation errors returned with actionable codes/messages
- Backend provides a source of valid/recognized `EventType` values (endpoint **TBD**; see Open Questions).
- Backend validates referenced GL accounts and rule balancing and returns structured validation failures.

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Admin navigation: **Accounting ‚Üí Posting Rules ‚Üí Posting Rule Sets** (exact menu placement may vary; implement as a screen entry under accounting configuration)

### Screens to create/modify
1. **Screen:** `apps/accounting/PostingRuleSet/List.xml`
   - List/search table of Posting Rule Sets (latest version summary at minimum)
2. **Screen:** `apps/accounting/PostingRuleSet/Detail.xml`
   - Detail view of a specific `postingRuleSetId`
   - Versions subview (list of versions with status)
3. **Screen:** `apps/accounting/PostingRuleSet/EditVersion.xml`
   - Create version 1 (new rule set) or create new version from an existing one
4. **Dialog/Screen section:** Publish confirmation + results display (could be a transition returning validation result)

### Navigation context
- From list ‚Üí select rule set ‚Üí detail
- From detail ‚Üí select version ‚Üí view version detail
- From version view ‚Üí ‚ÄúCreate New Version‚Äù (clone) ‚Üí edit ‚Üí save as DRAFT
- From DRAFT version ‚Üí ‚ÄúPublish‚Äù (runs backend validation; if fails, remain DRAFT and show errors)
- From PUBLISHED version ‚Üí ‚ÄúArchive‚Äù (if allowed)

### User workflows
- **Happy path: create & publish**
  1. User opens Posting Rule Set list
  2. Clicks ‚ÄúNew Posting Rule Set‚Äù
  3. Selects `EventType`, defines rules JSON/structure, saves as DRAFT (version 1)
  4. Clicks Publish ‚Üí backend validates balance and references ‚Üí success ‚Üí status becomes PUBLISHED
- **Alternate path: create new version**
  1. User opens existing ruleset detail
  2. Chooses a PUBLISHED version ‚Üí ‚ÄúCreate New Version‚Äù
  3. Edits rules; saves as DRAFT version N+1
  4. Publishes after backend validation
- **Error path: unbalanced**
  - Publish returns validation error describing imbalance and/or failing condition; UI shows error and blocks publish.

---

## 6. Functional Behavior

### Triggers
- User navigates to Posting Rule Set configuration screens
- User submits create/update version form
- User triggers publish or archive actions

### UI actions
- **List screen**
  - Filter/search (by `eventType`, `status`, date range; pagination)
  - Navigate to detail
- **Detail screen**
  - View metadata (ruleSetId, eventType)
  - View versions (version, status, createdAt/createdBy)
  - Actions:
    - Create New Version (clone)
- **Edit version screen**
  - Fields:
    - `eventType` (required; selection from canonical list)
    - `rulesDefinition` (required; JSON/structured editor‚Äîsee Open Questions)
    - `status` displayed as read-only (DRAFT after save)
  - Save action creates DRAFT version (new or next version)
- **Publish action**
  - Confirmation prompt
  - Calls publish transition/service
  - On success: route back to version view; show success message; status now PUBLISHED
  - On failure: remain on version view/edit; show validation errors; status remains DRAFT
- **Archive action**
  - Confirmation prompt
  - Calls archive transition/service
  - On success: status becomes ARCHIVED; UI disables publish/edit actions

### State changes (frontend reflects backend state)
- DRAFT ‚Üí PUBLISHED (publish)
- PUBLISHED ‚Üí ARCHIVED (archive)
- Any ‚Äúedit‚Äù operation results in **new version** (immutability enforced by backend); frontend must not attempt in-place update of a published/used version.

### Service interactions
- Load list/detail/version data from backend via Moqui service calls (REST or service facade)
- Submit create/version/publish/archive actions to backend
- Display backend validation results and error codes

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- `eventType` is required.
- `rulesDefinition` is required and must be valid JSON if entered as JSON text.
- Publishing is blocked if backend validation fails:
  - Unbalanced debits/credits for any supported condition
  - Invalid GL account references
  - Unknown/invalid `EventType`
- Frontend must display backend error code(s) and messages in a user-actionable manner.

### Enable/disable rules
- If version `status=PUBLISHED` or `ARCHIVED`, editing fields are disabled (read-only).
- ‚ÄúPublish‚Äù button is visible/enabled only for `status=DRAFT`.
- ‚ÄúArchive‚Äù button visible/enabled only for `status=PUBLISHED` (unless backend allows otherwise; treat other states as disabled).
- ‚ÄúCreate New Version‚Äù enabled on any existing rule set, but source version selection is required.

### Visibility rules
- Always show `postingRuleSetId` and `version` prominently on version detail.
- Show status badge for each version (DRAFT/PUBLISHED/ARCHIVED).

### Error messaging expectations
- For publish failures, show:
  - Summary: ‚ÄúPublish blocked: rule set failed validation‚Äù
  - Detail list including backend-provided reasons (e.g., imbalance per condition)
- For unknown `EventType`, show actionable: ‚ÄúSelect a recognized EventType (refresh list if newly added).‚Äù

---

## 8. Data Requirements

### Entities involved (frontend view models; backend-owned)
- `PostingRuleSet` (rule set identity + eventType)
- `PostingRuleSetVersion` (versioned configuration)
- (Reference) `EventType` catalog/list (source-of-truth upstream/back-end exposed)

### Fields (type, required, defaults)
**PostingRuleSet (logical)**
- `postingRuleSetId` (UUID, read-only)
- `eventType` (string, required, editable only when creating version 1 unless backend allows per-version eventType changes‚Äîsee Open Questions)

**PostingRuleSetVersion**
- `postingRuleSetId` (UUID, required, read-only)
- `version` (int, required, read-only)
- `status` (`DRAFT|PUBLISHED|ARCHIVED`, required, read-only except via actions)
- `rulesDefinition` (JSON, required, editable only for DRAFT before publish)
- `createdAt` (datetime, read-only)
- `createdBy` (string/userId, read-only)
- `updatedAt` (datetime, read-only)
- `updatedBy` (string/userId, read-only)

### Read-only vs editable by state/role
- **DRAFT**: editable `rulesDefinition` (and `eventType` if creating new ruleset)
- **PUBLISHED/ARCHIVED**: all fields read-only; only ‚ÄúCreate New Version‚Äù allowed
- Role-based enforcement must also be performed by backend; frontend should hide/disable actions when backend indicates unauthorized.

### Derived/calculated fields
- ‚ÄúLatest version‚Äù computed for list view display (either backend provides `latestVersion` or frontend calculates after loading versions)
- Validation result details displayed after publish attempt (from backend response)

---

## 9. Service Contracts (Frontend Perspective)

> Endpoint/service names are **TBD**; frontend must integrate via Moqui service calls consistent with project conventions. Define these as Moqui `service-call` stubs that map to backend REST until concrete names are confirmed.

### Load/view calls
- **List rule sets**
  - Input: optional filters (`eventType`, `status`, paging)
  - Output: list of rule sets with latest version summary
- **Get rule set detail**
  - Input: `postingRuleSetId`
  - Output: rule set + versions list
- **Get version detail**
  - Input: `postingRuleSetId`, `version`
  - Output: version record including `rulesDefinition`

- **List recognized EventTypes**
  - Input: optional search
  - Output: array of `eventType` strings (and optional description/schemaVersion)

### Create/update calls (via new version)
- **Create new rule set (version 1, DRAFT)**
  - Input: `eventType`, `rulesDefinition`
  - Output: `postingRuleSetId`, `version=1`, `status=DRAFT`
- **Create new version (clone + edit)**
  - Input: `postingRuleSetId`, `baseVersion` (optional but recommended), `rulesDefinition`
  - Output: `version=baseVersion+1`, `status=DRAFT`

### Submit/transition calls
- **Publish version**
  - Input: `postingRuleSetId`, `version`
  - Output success: updated version with `status=PUBLISHED`
  - Output failure: `400` with structured validation errors, including imbalance details
- **Archive version**
  - Input: `postingRuleSetId`, `version`
  - Output: updated version with `status=ARCHIVED` (or backend-defined result)

### Error handling expectations
- Map HTTP errors to UI:
  - `400` validation: show field/summary errors (do not retry automatically)
  - `401/403`: show ‚ÄúNot authorized‚Äù and disable actions; offer navigation away
  - `404`: show ‚ÄúRule set/version not found‚Äù and return to list
  - `409`: show conflict (e.g., publishing non-DRAFT, concurrent version creation); prompt reload
  - `5xx`: show generic error + correlation id if provided; allow retry

---

## 10. State Model & Transitions

### Allowed states (version status)
- `DRAFT`
- `PUBLISHED`
- `ARCHIVED`

### Role-based transitions
- Users with posting-rule management permission can:
  - Create DRAFT versions
  - Publish DRAFT ‚Üí PUBLISHED
  - Archive PUBLISHED ‚Üí ARCHIVED
- Users without permission: read-only access (if allowed) or blocked entirely (TBD; see Open Questions)

### UI behavior per state
- **DRAFT**: editable rules; show ‚ÄúPublish‚Äù primary action
- **PUBLISHED**: read-only; show ‚ÄúCreate New Version‚Äù action; show ‚ÄúArchive‚Äù secondary action
- **ARCHIVED**: read-only; hide publish/archive; allow ‚ÄúCreate New Version‚Äù (if business allows) else disable (TBD)

---

## 11. Alternate / Error Flows

### Validation failures
- Invalid JSON in rulesDefinition:
  - Block save client-side with ‚ÄúInvalid JSON‚Äù
- Backend validation on publish:
  - Show list of failing conditions and debit/credit totals (as provided)
  - Keep version as DRAFT
  - Do not silently modify rulesDefinition

### Concurrency conflicts
- If another user creates a newer version while current user is editing:
  - Save attempt may return `409` (or similar)
  - UI should prompt to reload versions list and rebase (create a new version from latest)

### Unauthorized access
- If user lacks permission:
  - Hide ‚ÄúNew‚Äù, ‚ÄúPublish‚Äù, ‚ÄúArchive‚Äù, ‚ÄúCreate New Version‚Äù actions
  - If direct URL access attempted, show error and route to list or unauthorized screen

### Empty states
- No rule sets exist:
  - Show empty state with ‚ÄúCreate Posting Rule Set‚Äù
- No EventTypes returned:
  - Show message: ‚ÄúNo EventTypes available. Check integration configuration.‚Äù

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: List posting rule sets
**Given** I am an authenticated user with permission to view posting rule sets  
**When** I navigate to Accounting ‚Üí Posting Rules ‚Üí Posting Rule Sets  
**Then** I see a paginated list of existing posting rule sets  
**And** each row shows at least `eventType`, `postingRuleSetId`, and latest version `status`

### Scenario 2: Create a new rule set as DRAFT
**Given** I have permission to manage posting rule sets  
**And** the system provides a list of recognized `EventType` values  
**When** I create a new posting rule set with a selected `eventType` and a valid `rulesDefinition`  
**Then** the system creates version `1` with `status=DRAFT`  
**And** I can view the new rule set version detail showing `postingRuleSetId` and `version=1`

### Scenario 3: Publish a balanced DRAFT version
**Given** a posting rule set version exists with `status=DRAFT`  
**When** I click ‚ÄúPublish‚Äù and confirm  
**Then** the frontend calls the publish service for that `postingRuleSetId` and `version`  
**And** on success the version status updates to `PUBLISHED`  
**And** the UI disables editing for that published version

### Scenario 4: Reject publish for unbalanced rules
**Given** a posting rule set version exists with `status=DRAFT`  
**And** its rules are unbalanced for at least one supported condition  
**When** I click ‚ÄúPublish‚Äù  
**Then** the system responds with a validation failure (HTTP 400)  
**And** the UI shows an error summary and the backend-provided imbalance details  
**And** the version remains `DRAFT` and editable

### Scenario 5: Create a new version from an existing rule set
**Given** a posting rule set exists with a `PUBLISHED` version `N`  
**When** I choose ‚ÄúCreate New Version‚Äù from version `N` and save changes  
**Then** the system creates a new version `N+1` with `status=DRAFT`  
**And** version `N` remains unchanged and read-only

### Scenario 6: Unauthorized user cannot publish
**Given** I am authenticated but do not have permission to publish posting rule sets  
**When** I view a DRAFT posting rule set version  
**Then** I do not see an enabled ‚ÄúPublish‚Äù action  
**And** if I attempt to publish via direct URL/action, I receive a not-authorized error and no state changes occur

---

## 13. Audit & Observability

### User-visible audit data
- On version detail, display:
  - `createdAt`, `createdBy`, `updatedAt`, `updatedBy`
  - Status and status change timestamps if provided by backend

### Status history
- Show a version list with status and created timestamp.
- If backend provides audit events (recommended), provide a collapsible ‚ÄúAudit‚Äù section per version (actor, action: created/published/archived, timestamp, correlation id).

### Traceability expectations
- UI must always present `postingRuleSetId` + `version` for any view of rulesDefinition.
- Any publish/archive action should log (frontend) a structured info event containing `postingRuleSetId`, `version`, outcome, and correlation id (if returned).

---

## 14. Non-Functional UI Requirements
- **Performance:** List view should load within 2s for up to 50 rows/page (assuming normal network); support server-side pagination.
- **Accessibility:** All actions keyboard-navigable; validation messages associated to inputs; sufficient contrast for status indicators.
- **Responsiveness:** Works on tablet width; tables horizontally scroll or collapse columns.
- **i18n/timezone:** Display timestamps in user locale/timezone (from session settings).  
- **Security:** Do not expose rulesDefinition or error payloads in logs beyond what‚Äôs necessary; no secrets.

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide a standard empty state with a primary CTA (‚ÄúCreate Posting Rule Set‚Äù) because it is UI ergonomics and does not change domain logic. (Impacted: UX Summary, Error Flows)
- SD-UX-PAGINATION: Use server-side pagination with default page size 25 and user-selectable 25/50/100 because it is standard UI ergonomics. (Impacted: UX Summary, Service Contracts)
- SD-ERR-HTTP-MAP: Map HTTP 400/401/403/404/409/5xx to standard Quasar notifications + inline form errors where applicable because it‚Äôs standard error-handling behavior implied by backend contracts. (Impacted: Service Contracts, Alternate/Error Flows)
- SD-OBS-CORRELATION: Display and log correlation/request id when provided in response headers/body because it is observability boilerplate and does not alter business behavior. (Impacted: Audit & Observability, Error Flows)

---

## 16. Open Questions
1. **EventType source & contract:** What is the authoritative endpoint/service to retrieve recognized `EventType` values (and optional descriptions/schema versions)? Is the list static-config or backend-discovered?
2. **Rules editor format:** Should `rulesDefinition` be edited as:
   - raw JSON text,
   - a structured form builder UI,
   - or both (advanced JSON mode + guided form)?
   Provide the expected JSON schema for `rulesDefinition` if JSON is required.
3. **Permissions:** What are the exact permission names/scopes for:
   - viewing posting rule sets
   - creating/upversioning
   - publishing
   - archiving?
4. **Version creation semantics:** When creating a new version, does the API require `baseVersion` (explicit) or does it auto-increment latest? How are concurrent version creations handled (expected 409 behavior and message format)?
5. **Archiving policy:** Are archived versions still selectable for ‚ÄúCreate New Version‚Äù? Is archiving allowed only for PUBLISHED, and can a version be un-archived?
6. **List view contract:** Does backend provide a flattened ‚Äúlatest version summary‚Äù per rule set, or must frontend fetch versions per rule set? (Impacts performance and API calls.)
7. **Validation detail payload:** For unbalanced rule sets, what exact structure is returned (e.g., per condition: debitTotal, creditTotal, failing rule IDs)? Provide sample error response for UI rendering.

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Mapping: Configure EventType ‚Üí Posting Rule Set  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/202  
Labels: frontend, story-implementation, inventory

## Frontend Implementation for Story

**Original Story**: [STORY] Mapping: Configure EventType ‚Üí Posting Rule Set

**Domain**: inventory

### Story Description

/kiro  
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Maintain Chart of Accounts and Posting Categories

## Story
Mapping: Configure EventType ‚Üí Posting Rule Set

## Acceptance Criteria
- [ ] Posting rules are versioned and referenced on every journal entry
- [ ] Rules produce balanced debit/credit outputs for representative test fixtures
- [ ] Rules support conditional logic (taxable/non-taxable, inventory/non-inventory)
- [ ] Publishing rules that don‚Äôt balance is blocked

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #203: [FRONTEND] [STORY] Categories: Define Posting Categories and Mapping Keys  
File: ./scripts/story-work/frontend/203/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Accounting: Manage Posting Categories, Mapping Keys, and Effective-Dated GL Mappings

### Primary Persona
Financial Controller / Accountant

### Business Value
Enable consistent, deterministic classification of producer financial events into Posting Categories and effective-dated GL mappings (account + dimensions), with auditability and validation, so journal entry generation can be automated reliably.

---

## 2. Story Intent

### As a / I want / So that
**As a** Financial Controller,  
**I want** to create and maintain Posting Categories, producer-facing Mapping Keys, and effective-dated mappings from categories to GL accounts (and required dimensions),  
**so that** producer systems can deterministically resolve posting instructions for a transaction date and finance can audit configuration history.

### In-scope
- Moqui frontend screens to:
  - List/view/create/update/deactivate Posting Categories
  - List/view/create/update/deactivate Mapping Keys and link them deterministically to a Posting Category
  - Create new effective-dated GL mappings for a Posting Category (no overlapping ranges)
  - View mapping history for a category (effective ranges + audit metadata)
  - Validate and surface API errors (overlap conflicts, missing GL account, deactivated category, etc.)
- Read-only resolution test utility (optional UI) to validate a mapping key resolves for a given transaction date **if** backend provides an endpoint.

### Out-of-scope
- Defining or editing Chart of Accounts itself (assumed managed elsewhere; this story only selects from existing GL accounts)
- Defining Posting Rule Sets, journal entry generation, or posting to ledger
- Tax rules, revenue recognition, or any debit/credit mapping logic
- Automatic ‚Äúclose previous mapping end date‚Äù behavior unless explicitly confirmed (see Open Questions)

---

## 3. Actors & Stakeholders
- **Financial Controller / Accountant**: configures categories/keys/mappings, reviews history, resolves validation errors.
- **Auditor (read-only)**: reviews configuration history and audit fields.
- **Producer System Integrator (read-only)**: verifies mapping keys and resolution behavior (if UI utility exists).
- **System (Moqui backend services)**: enforces invariants (uniqueness, effective dating, non-overlap, immutability/versioning policy).

---

## 4. Preconditions & Dependencies
- User is authenticated in the Moqui application.
- Authorization exists for managing posting configuration (exact permission names unclear; see Open Questions).
- Backend provides services/endpoints for:
  - Posting Category CRUD + deactivate
  - Mapping Key CRUD + link to Posting Category
  - GL Mapping create (new version) + list/history by category
  - Chart of Accounts lookup (list GL accounts for selection and validate existence)
  - (Optional) mapping resolution by key + date for producers/test utility
- Backend enforces audit logging and immutability/versioning rules; frontend must not assume it can ‚Äúhard update‚Äù records if backend requires create-new-version semantics.

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main nav: **Accounting ‚Üí Configuration ‚Üí Posting Setup**
  - Tabs or sub-screens:
    - **Posting Categories**
    - **Mapping Keys**
    - **GL Mappings**

### Screens to create/modify
Create a screen tree under something like:
- `apps/frontend/screen/Accounting/PostingConfig.xml` (container)
  - `.../PostingCategoryList.xml`
  - `.../PostingCategoryDetail.xml`
  - `.../MappingKeyList.xml`
  - `.../MappingKeyDetail.xml`
  - `.../GlMappingList.xml` (scoped to category)
  - `.../GlMappingCreate.xml` (scoped to category)
  - (Optional) `.../ResolutionTest.xml`

> Exact filenames/paths may differ by repo conventions; implement using existing menu/screen patterns in `durion-moqui-frontend`.

### Navigation context
- From **Posting Categories list** ‚Üí open **Category detail**:
  - view category fields + status
  - see linked mapping keys
  - see GL mapping history (effective ranges)
  - actions: edit (if allowed), deactivate, create new GL mapping

- From **Mapping Keys list** ‚Üí open **Key detail**:
  - view/edit key fields
  - link/unlink to a Posting Category (deterministic 1:1)
  - status and audit metadata

### User workflows

#### Happy path: create category + mapping key + GL mapping
1. Create Posting Category (code + description) ‚Üí saved ACTIVE.
2. Create Mapping Key (unique key string) ‚Üí associate to category.
3. Add GL Mapping for category: select GL account + optional dimensions, set effective start (and optional end).
4. Verify mapping appears in history and is ACTIVE for date.

#### Alternate path: new mapping version for same category
1. On category detail, choose ‚ÄúNew Mapping Version‚Äù.
2. Enter new effective start date (and optional end).
3. Save; backend rejects if overlap. UI surfaces conflict details.

#### Alternate path: deactivate category
1. Deactivate Posting Category.
2. UI must prevent creating new GL mappings for INACTIVE category; if attempted, backend error surfaced.

---

## 6. Functional Behavior

### Triggers
- User navigates to Posting Setup screens.
- User submits create/update/deactivate forms.
- User selects a category to view mappings and history.

### UI actions
- **List screens**: filter/search, open detail, create new.
- **Detail screens**: edit allowed fields (depending on immutability policy), deactivate, view history.
- **GL mapping create**: choose category, select GL account, set effective dates, set dimensions.

### State changes (frontend perspective)
- Category status: `ACTIVE` ‚Üí `INACTIVE` (deactivate only; no delete)
- Mapping key status: (if modeled) active/inactive; otherwise existence + association changes
- GL mapping: creation of a new mapping record/version; prior mapping remains for history

### Service interactions
- On screen load: call load/list services for categories, keys, mappings, and GL accounts.
- On submit: call create/update/deactivate services; handle validation and conflicts.
- For overlap conflicts: handle `409 Conflict` with payload identifying conflicting mapping(s) (exact format TBD; see Open Questions).

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- Posting Category:
  - `categoryCode` required, unique, uppercase/underscore format preferred (format rule not specified; do **not** enforce unless confirmed).
  - `description` required (or optional‚Äîunclear; see Open Questions).
- Mapping Key:
  - Unique system-wide (required).
  - Must resolve deterministically to exactly one Posting Category.
- GL Mapping:
  - `postingCategoryId` required.
  - `glAccountId` required and must exist in CoA.
  - `effectiveStartDate` required.
  - `effectiveEndDate` optional; if provided must be >= start date.
  - No overlapping effective ranges for same Posting Category.
  - Cannot create new mappings for INACTIVE category.

### Enable/disable rules
- ‚ÄúDeactivate Category‚Äù disabled if already INACTIVE.
- ‚ÄúAdd/New GL Mapping‚Äù disabled when category INACTIVE.
- If backend enforces immutability-by-version:
  - ‚ÄúEdit‚Äù on existing GL mapping is disabled; only ‚ÄúCreate new mapping version‚Äù is available.

### Visibility rules
- Show mapping history list for a category, including effective dates, account, dimensions, status, createdBy/createdAt.
- If backend returns conflict details on overlap, display them inline under the effective date fields.

### Error messaging expectations
Frontend must map backend errors to actionable messages:
- Uniqueness violation ‚Üí ‚ÄúCode/Key already exists.‚Äù
- Overlap conflict (409) ‚Üí ‚ÄúEffective dates overlap with existing mapping <id> (<start>‚Äì<end>).‚Äù
- GL account not found (400) ‚Üí ‚ÄúSelected GL account no longer exists; refresh and try again.‚Äù
- Unauthorized (401/403) ‚Üí show access denied and hide write actions.

---

## 8. Data Requirements

> Field names below reflect story intent; actual entity/field names must match backend and Moqui entities/services.

### Entities involved (conceptual)
- `PostingCategory`
- `MappingKey` (or equivalent; backend reference conflates with category code‚Äîneeds clarification)
- `GlMapping`
- `GlAccount` (Chart of Accounts reference entity)
- `AuditLog` / audit fields on each entity

### Fields

#### PostingCategory
- `postingCategoryId` (id/UUID) ‚Äî read-only
- `categoryCode` (string) ‚Äî required, unique, editable? (unclear if immutable)
- `description` (string/text) ‚Äî required? (unclear)
- `statusId` or `status` (`ACTIVE`/`INACTIVE`) ‚Äî read-only except via deactivate action
- `createdAt`, `createdBy`, `updatedAt`, `updatedBy` ‚Äî read-only

#### MappingKey
- `mappingKeyId` ‚Äî read-only
- `mappingKey` (string) ‚Äî required, unique
- `postingCategoryId` (FK) ‚Äî required (enforces deterministic 1:1)
- `status` (if present) ‚Äî active/inactive
- audit fields ‚Äî read-only

#### GlMapping
- `glMappingId` ‚Äî read-only
- `postingCategoryId` ‚Äî required (selected/scoped)
- `glAccountId` ‚Äî required (selected from CoA)
- `dimensions` ‚Äî object/fields (unknown list; see Open Questions)
- `effectiveStartDate` (date) ‚Äî required
- `effectiveEndDate` (date nullable) ‚Äî optional
- `supersededByMappingId` (nullable) ‚Äî read-only
- audit fields ‚Äî read-only

### Read-only vs editable by state/role
- Users without manage permission: all screens read-only; cannot see create/edit/deactivate actions.
- Existing mappings: editable only if backend supports updates; otherwise read-only and new-version only (needs clarification).

### Derived/calculated fields
- ‚ÄúActive for date‚Äù indicator (computed in UI by comparing date range) for display only; not authoritative.

---

## 9. Service Contracts (Frontend Perspective)

> Service names are placeholders; implement using Moqui `service-call` to existing services defined in backend component. If not present, raise mismatch.

### Load/view calls
- `PostingCategoryFind` (list with filters: code contains, status)
- `PostingCategoryGet` (by id)
- `MappingKeyFind`
- `MappingKeyGet`
- `GlMappingFindByCategory` (history list)
- `GlAccountFind` (for selection; supports search by code/name)

### Create/update calls
- `PostingCategoryCreate`
- `PostingCategoryUpdate` **or** `PostingCategoryVersionCreate` (immutability policy unclear)
- `PostingCategoryDeactivate`
- `MappingKeyCreate`
- `MappingKeyUpdate` / `Deactivate`
- `GlMappingCreate` (new mapping record/version)

### Submit/transition calls
- Deactivation actions treated as explicit services: `...Deactivate`

### Error handling expectations
- Validation errors: `400` with field error details; bind to form fields.
- Conflict overlap: `409` with conflicting mapping identifiers and dates (payload format TBD).
- Not found: `404` when opening details for deleted/nonexistent entities.
- Unauthorized: `401/403` should route to login or show forbidden.

---

## 10. State Model & Transitions

### Allowed states
- Posting Category: `ACTIVE`, `INACTIVE`
- Mapping Key: (if modeled) `ACTIVE`, `INACTIVE`
- GL Mapping: no explicit state; effective dating defines activity. May also have superseded linkage.

### Role-based transitions
- Financial Controller with permission:
  - Category: create, update (if allowed), deactivate
  - Mapping Key: create, update (if allowed), deactivate
  - GL Mapping: create new version
- Read-only roles:
  - view only

### UI behavior per state
- INACTIVE category:
  - cannot add new GL mappings or new mapping keys associated to it (enforced in UI + backend)
  - history remains visible
- Effective date not covering ‚Äútoday‚Äù:
  - show ‚ÄúNo active mapping for today‚Äù informational banner on category detail (non-blocking)

---

## 11. Alternate / Error Flows

### Validation failures
- Missing required fields ‚Üí inline field errors, prevent submit.
- End date earlier than start date ‚Üí inline error, prevent submit (client-side) and also handle backend response.

### Concurrency conflicts
- If backend uses optimistic locking (e.g., `version` field), on save conflict show: ‚ÄúThis record was changed by another user. Reload to continue.‚Äù Provide Reload action.

### Unauthorized access
- User without permission attempting to access create/edit URL directly:
  - screen renders read-only and/or returns forbidden; must not leak privileged actions.

### Empty states
- No categories: show empty state with ‚ÄúCreate Posting Category‚Äù action if authorized.
- Category with no GL mappings: show ‚ÄúNo mappings yet‚Äù with ‚ÄúAdd Mapping‚Äù action if authorized.
- No GL accounts returned: show error ‚ÄúNo GL accounts available; check CoA setup.‚Äù

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: Create posting category
**Given** I am logged in as a Financial Controller with permission to manage posting configuration  
**When** I create a Posting Category with code `REVENUE_PARTS` and description `Revenue from Parts Sales`  
**Then** the category is saved with status `ACTIVE`  
**And** the category appears in the Posting Categories list

### Scenario 2: Prevent duplicate posting category codes
**Given** a Posting Category with code `REVENUE_PARTS` already exists  
**When** I attempt to create another Posting Category with code `REVENUE_PARTS`  
**Then** I see an error indicating the code must be unique  
**And** the duplicate category is not created

### Scenario 3: Create mapping key linked to a category
**Given** a Posting Category `REVENUE_PARTS` exists  
**When** I create a Mapping Key `pos.sale.item.parts.standard` linked to `REVENUE_PARTS`  
**Then** the mapping key is saved  
**And** the key is visible on the category detail screen

### Scenario 4: Prevent duplicate mapping keys
**Given** a Mapping Key `pos.sale.item.parts.standard` already exists  
**When** I attempt to create another Mapping Key with the same value  
**Then** I see an error indicating the mapping key must be unique  
**And** the duplicate key is not created

### Scenario 5: Create an effective-dated GL mapping
**Given** a Posting Category `REVENUE_PARTS` exists and is `ACTIVE`  
**And** a GL Account `40010` exists in the Chart of Accounts  
**When** I create a GL Mapping for `REVENUE_PARTS` to GL Account `40010` with effective start date `2026-02-01` and no end date  
**Then** the mapping is saved  
**And** it appears in the mapping history for `REVENUE_PARTS`

### Scenario 6: Reject overlapping effective dates
**Given** a GL Mapping exists for category `REVENUE_PARTS` effective `2026-02-01` through (no end date)  
**When** I attempt to create another GL Mapping for `REVENUE_PARTS` effective `2026-01-15` through `2026-03-01`  
**Then** the system rejects the save with a conflict error  
**And** I see a message identifying the conflicting mapping and overlapping date range

### Scenario 7: Block new mappings for inactive category
**Given** a Posting Category `REVENUE_PARTS` is `INACTIVE`  
**When** I view the category detail screen  
**Then** the ‚ÄúAdd/New GL Mapping‚Äù action is disabled or hidden  
**And** if I attempt to submit a new mapping anyway  
**Then** I see an error indicating mappings cannot be created for inactive categories

### Scenario 8: Handle missing GL account
**Given** I am creating a GL Mapping and select a GL account that is no longer valid  
**When** I submit the mapping  
**Then** I see an error indicating the GL account is invalid or not found  
**And** the mapping is not created

---

## 13. Audit & Observability

### User-visible audit data
- On detail screens show:
  - createdBy / createdAt
  - updatedBy / updatedAt (if applicable)
- For GL mapping history show createdAt/createdBy per mapping record.

### Status history
- For categories and mapping keys: show status changes if backend exposes audit events; otherwise show current status and audit fields.

### Traceability expectations
- Each created mapping/version must be traceable by ID and effective date range.
- If backend supports it, include links from a mapping record to audit event entries.

---

## 14. Non-Functional UI Requirements
- **Performance**: list screens should load within 2s for up to 500 records; use pagination.
- **Accessibility**: all form controls labeled; keyboard navigable; error messages announced (aria-live) via Quasar patterns.
- **Responsiveness**: usable on tablet widths; forms stack vertically.
- **i18n/timezone/currency**:
  - Dates displayed in user locale/timezone; effective dates are date-only (no time).
  - Currency not directly displayed/edited in this story.

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide standard empty state components with primary CTA when lists are empty; qualifies as safe because it changes no domain behavior; impacts UX Summary, Alternate/Empty states.
- SD-UX-PAGINATION: Paginate list screens with default page size (e.g., 25) and server-side filtering where supported; safe because it only affects presentation/perf; impacts UX Summary, Service Contracts.
- SD-ERR-STANDARD-MAPPING: Map HTTP 400/401/403/404/409 to standard inline/toast handling consistent with app conventions; safe because it follows backend signals; impacts Service Contracts, Error Flows.

---

## 16. Open Questions
1. **Mapping Key vs Category Code Modeling**: Are ‚ÄúMapping Keys‚Äù a separate entity (many keys ‚Üí one posting category), or is the producer key exactly the `categoryCode` (1:1) as suggested in backend reference note? Frontend screen design depends on this.
2. **Immutability/Versioning Rules in UI**: Are Posting Categories and Mapping Keys editable in-place, or must edits create new versioned records (append-only)? Same question for GL mappings (create-new-version only vs allow updates before superseded).
3. **Overlap Policy**: When a new mapping is created with a start date inside an existing open-ended mapping, should the system (a) reject with 409 always, or (b) automatically end-date the previous mapping? UI flow differs.
4. **Dimensions Definition**: What is the authoritative list of required/optional financial dimensions for GL mappings (e.g., departmentId, locationId, costCenterId, businessUnitId)? Are they freeform strings, references to entities, or fixed enums?
5. **Authorization**: What are the exact permissions/scopes for managing posting categories/keys/mappings, and should auditors have read-only access by default?
6. **Resolution Endpoint**: Is there a supported backend endpoint for ‚Äúresolve mapping key + transaction date ‚Üí category + GL account + dimensions‚Äù? If yes, provide request/response and error codes so a small ‚ÄúResolution Test‚Äù UI can be included.

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Categories: Define Posting Categories and Mapping Keys  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/203  
Labels: frontend, story-implementation, general

## Frontend Implementation for Story

**Original Story**: [STORY] Categories: Define Posting Categories and Mapping Keys

**Domain**: general

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Maintain Chart of Accounts and Posting Categories

## Story
Categories: Define Posting Categories and Mapping Keys

## Acceptance Criteria
- [ ] Posting categories exist for business meaning (Labor Revenue, Sales Tax Payable, COGS Tires, etc.)
- [ ] Mapping keys used by producers resolve deterministically to categories
- [ ] Category‚ÜíAccount/Dimensions mappings are effective-dated and audit-logged
- [ ] Invalid/overlapping mappings are rejected per policy


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #204: [FRONTEND] [STORY] CoA: Create and Maintain Chart of Accounts  
File: ./scripts/story-work/frontend/204/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

**Title:** [FRONTEND] [STORY] CoA: Create and Maintain Chart of Accounts (GL Accounts)

**Primary Persona:** Finance Manager / Accountant (authorized CoA maintainer)

**Business Value:** Maintain an accurate, auditable Chart of Accounts so downstream posting, reporting, and controls (effective dating, deactivation) behave predictably and compliantly.

---

## 2. Story Intent

**As a** Finance Manager / Accountant,  
**I want** a POS admin UI to create, view, edit (limited fields), and deactivate GL accounts with effective dating and audit visibility,  
**so that** the Chart of Accounts stays clean, controlled, and usable for financial classification and posting.

### In-scope
- List/search GL accounts with filters (type, status, effective dating windows)
- View GL account details including audit metadata
- Create GL account (code, name, type, description, activeFrom, optional activeThru)
- Update allowed fields only (name/description)
- Deactivate GL account by setting `activeThru` effective date/time (subject to backend policy)
- Show and handle backend validation errors (duplicate codes, invalid dates, policy violations, auth)

### Out-of-scope
- Defining/deleting chart structures (parent/child hierarchies) unless provided by API
- Editing `accountCode` or `accountType` after creation
- Any GL posting, balances display, reconciliation, or reporting screens
- Posting Categories / mappings / rule sets (explicitly out unless separately specified)

---

## 3. Actors & Stakeholders

- **Primary Actor:** Finance Manager / Accountant
- **Secondary Actors:** Auditor (read-only needs), System Administrator (may grant permissions)
- **System Dependencies:** Accounting backend service (GL account endpoints), AuthN/AuthZ provider, Audit log provider (if separate)

---

## 4. Preconditions & Dependencies

- User is authenticated.
- User has permission `CoA:Manage` for create/update/deactivate; view permission is **unclear** (see Open Questions).
- Backend provides APIs for:
  - listing GL accounts (paged)
  - retrieving GL account by id
  - creating GL account
  - patching/updating allowed fields
  - deactivating with effective date
- Backend enforces:
  - unique account codes
  - canonical account types: ASSET/LIABILITY/EQUITY/REVENUE/EXPENSE
  - effective dating constraints
  - deactivation policy constraints (not fully defined here)

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main nav: **Accounting ‚Üí Chart of Accounts**
- Direct route (proposed): `/accounting/coa` (list), `/accounting/coa/account/{accountId}` (detail)

### Screens to create/modify (Moqui)
- **New Screen:** `apps/pos/screen/accounting/Coa.xml` (container + sub-screens)
  - `CoaList.xml` (list/search)
  - `CoaCreate.xml` (create form)
  - `CoaDetail.xml` (view + edit + deactivate action)
- Add menu entry in the app‚Äôs navigation (per repo conventions)

### Navigation context
- Breadcrumbs:
  - Accounting ‚Üí Chart of Accounts ‚Üí (List | Create | Account Detail)

### User workflows
**Happy path: Create**
1. User opens CoA list.
2. Clicks ‚ÄúCreate GL Account‚Äù.
3. Fills required fields and submits.
4. On success, navigates to detail view for the new account with confirmation banner.

**Happy path: Update name/description**
1. From detail screen, user enters edit mode for allowed fields.
2. Saves changes; sees updated metadata (updatedAt/updatedBy).

**Happy path: Deactivate**
1. From detail screen, user selects ‚ÄúDeactivate‚Äù.
2. Provides effective deactivation date/time (defaults to now, editable).
3. Confirms; on success, detail shows status ‚ÄúInactive/Scheduled‚Äù based on dates.

**Alternate: View-only**
- User can list and view details without edit actions if lacking `CoA:Manage`.

---

## 6. Functional Behavior

### Triggers
- Screen load triggers data fetch (list or detail)
- Form submit triggers create/update/deactivate service calls

### UI actions
- List:
  - filter by `accountType` and ‚Äústatus‚Äù (Active / Inactive / Scheduled)
  - search by `accountCode` or `accountName` (if supported by API; otherwise client-side search is **not allowed**)
  - pagination controls
- Detail:
  - display fields read-only by default
  - ‚ÄúEdit‚Äù toggles editable fields (name, description only)
  - ‚ÄúDeactivate‚Äù opens confirmation + effective date input

### State changes (frontend)
- Local UI state only (loading, saving, error)
- No client-side derivation of ‚Äúactive‚Äù beyond displaying based on backend fields; UI may compute a badge based on `activeFrom/activeThru` for display only.

### Service interactions
- Load list via Moqui service call (see Service Contracts)
- Create via service call; handle duplicate code conflict
- Update via patch service call
- Deactivate via dedicated action call

---

## 7. Business Rules (Translated to UI Behavior)

### Validation (client-side, non-authoritative)
- Required fields on create:
  - `accountCode` (non-empty)
  - `accountName` (non-empty)
  - `accountType` (must be one of allowed enum values)
  - `activeFrom` (non-empty)
- Effective date validation:
  - if `activeThru` provided, must be strictly after `activeFrom`
- Deactivate validation:
  - `effectiveDate` required; must be >= current time? (**unclear; enforce only ‚Äúrequired‚Äù client-side**)
- Immutability:
  - After creation, UI must not allow editing `accountCode` or `accountType` (hide/disable fields).

### Enable/disable rules
- Show ‚ÄúCreate‚Äù, ‚ÄúEdit‚Äù, ‚ÄúDeactivate‚Äù only if user has `CoA:Manage` (permission check method depends on frontend auth integration).
- Deactivate action disabled if already deactivated with `activeThru` in the past; if scheduled deactivation exists (`activeThru` in future), allow ‚ÄúChange deactivation date‚Äù is **unclear** ‚Üí do not implement unless backend supports.

### Visibility rules
- Always show audit fields (createdAt/createdBy/updatedAt/updatedBy) if returned by API.
- Show status badge computed from dates:
  - **Active:** now >= activeFrom AND (activeThru is null OR now < activeThru)
  - **Scheduled:** now < activeFrom OR (activeThru not null AND now < activeThru AND deactivation action already set?) (**ambiguous**) ‚Üí display only ‚ÄúActive/Inactive‚Äù unless backend provides explicit status.

### Error messaging expectations
- Duplicate code: show inline error on `accountCode` with message from backend; also top-level banner.
- Policy violation on deactivate: show modal error with backend reason; do not change UI state.
- Auth failure: show ‚ÄúYou do not have permission‚Äù and disable actions; for 401 redirect to login.

---

## 8. Data Requirements

### Entities involved (frontend view models)
- `GLAccount` (owned by accounting domain)

### Fields
| Field | Type | Required | Editable | Default | Notes |
|---|---|---:|---:|---|---|
| accountId | UUID | yes (response) | no | n/a | route param for detail |
| accountCode | string | yes | create-only | none | unique; treat as case-insensitive for duplicate detection messaging (backend authoritative) |
| accountName | string | yes | yes | none | editable post-create |
| accountType | enum | yes | create-only | none | one of ASSET/LIABILITY/EQUITY/REVENUE/EXPENSE |
| description | string | no | yes | empty | optional |
| activeFrom | datetime (tz) | yes | create-only (assumed) | now | create-time effective start |
| activeThru | datetime (tz) | no | set via deactivate action | null | do not expose as free-edit unless specified |
| createdAt | datetime (tz) | yes | no | n/a | display |
| updatedAt | datetime (tz) | yes | no | n/a | display |
| createdBy | string/UUID | yes | no | n/a | display (formatting depends on backend) |
| updatedBy | string/UUID | yes | no | n/a | display |

### Read-only vs editable by state/role
- If user lacks `CoA:Manage`: all fields read-only, actions hidden/disabled.
- If account is inactive (activeThru <= now): edit name/description is **unclear**; default to **allowed** unless backend rejects (but this may violate policy). Because this is domain-policy adjacent, treat as **Open Question**.

### Derived/calculated fields
- `uiStatusBadge` derived for display only (non-authoritative): Active vs Inactive based on `activeFrom/activeThru`.

---

## 9. Service Contracts (Frontend Perspective)

> **Note:** Exact Moqui service names/endpoints are not provided in inputs. This story requires confirmation of backend REST paths or Moqui service facades. Until confirmed, treat these as placeholders.

### Load/view calls
- **List GL accounts**
  - `GET /v1/gl-accounts?page=<n>&pageSize=<n>&accountType=<...>&status=<...>&q=<...>`
  - Response: `{ data: GLAccount[], pageInfo: { pageIndex, pageSize, totalCount } }`
- **Get GL account**
  - `GET /v1/gl-accounts/{accountId}` ‚Üí `GLAccount`

### Create/update calls
- **Create**
  - `POST /v1/gl-accounts`
  - Body: `{ accountCode, accountName, accountType, description?, activeFrom, activeThru? }`
  - Success: `201` + `GLAccount`
  - Errors:
    - `409` duplicate code
    - `400` validation (invalid type, invalid dates)
    - `403` forbidden
- **Update mutable fields**
  - `PATCH /v1/gl-accounts/{accountId}`
  - Body: `{ accountName?, description? }`
  - Success: `200` + `GLAccount`
  - Errors: `400`, `403`, `404`, `409?` (unlikely), `409` for optimistic lock if used (**unclear**)

### Submit/transition calls
- **Deactivate**
  - `POST /v1/gl-accounts/{accountId}/deactivate`
  - Body: `{ effectiveDate }`
  - Success: `200` + `GLAccount` (or minimal response)
  - Errors:
    - `422` policy violation (non-zero balance/usage)
    - `400` invalid effectiveDate
    - `403` forbidden

### Error handling expectations (frontend)
- Map HTTP errors to UI:
  - 400: field-level errors if provided; else banner ‚ÄúFix validation errors‚Äù
  - 401: redirect to login
  - 403: show not-authorized callout; keep user on screen
  - 404: show ‚ÄúAccount not found‚Äù empty state with back-to-list
  - 409: show conflict (duplicate code) inline on `accountCode`
  - 422: show policy violation message (deactivate)

---

## 10. State Model & Transitions

### Allowed states (UI-level)
Since backend does not provide an explicit state machine, use **date-based** status for UI display:
- **Active:** within effective window
- **Inactive:** `activeThru` in past
- **Not yet active:** `activeFrom` in future (if allowed)

### Role-based transitions
- `CoA:Manage`:
  - can create
  - can update name/description
  - can request deactivation (set activeThru) subject to backend rules
- Without `CoA:Manage`:
  - view only

### UI behavior per state
- Inactive: show status badge ‚ÄúInactive‚Äù; disable ‚ÄúDeactivate‚Äù.
- Future activeFrom: show ‚ÄúScheduled‚Äù badge is optional; if implemented, must be purely derived.

---

## 11. Alternate / Error Flows

- **Duplicate account code on create**
  - User submits; backend returns 409
  - UI shows inline error on `accountCode` and keeps form values
- **Invalid account type**
  - UI prevents selection outside enum; if backend rejects anyway, show field error
- **Invalid effective dates**
  - Client-side prevents submit when `activeThru <= activeFrom`
  - If backend returns 400, show error and keep form
- **Deactivation policy violation**
  - Backend returns 422 with reason
  - UI shows blocking dialog/banner with reason; no local changes
- **Concurrency conflict**
  - If backend returns 409/412 due to version mismatch (mechanism unclear), UI reloads entity and prompts user to re-apply edits
- **Unauthorized**
  - 403: actions disabled and message shown
  - 401: login flow
- **Empty states**
  - List returns 0 results: show ‚ÄúNo accounts yet‚Äù with ‚ÄúCreate‚Äù CTA if authorized

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: View CoA list
**Given** I am an authenticated user  
**When** I navigate to Accounting ‚Üí Chart of Accounts  
**Then** I see a paginated list of GL accounts showing account code, name, type, and effective dates  
**And** I can filter the list by account type

### Scenario 2: Create a new GL account successfully
**Given** I have `CoA:Manage` permission  
**When** I create a GL account with a unique account code, a name, an account type of `ASSET`, and an activeFrom date  
**Then** the system creates the account successfully  
**And** I am navigated to the account detail screen for the new account  
**And** the account detail shows the persisted values and audit metadata (createdAt/createdBy)

### Scenario 3: Prevent duplicate account code
**Given** I have `CoA:Manage` permission  
**And** a GL account exists with account code "1010-CASH"  
**When** I attempt to create a new GL account with account code "1010-CASH"  
**Then** I see an inline validation error indicating the account code is already in use  
**And** the form remains editable with my previously entered values preserved

### Scenario 4: Update name/description only
**Given** I have `CoA:Manage` permission  
**And** I am viewing an existing GL account  
**When** I edit the account name and description and save  
**Then** the changes are persisted  
**And** the account code and account type are not editable in the UI  
**And** updatedAt/updatedBy reflect the change (when provided by backend)

### Scenario 5: Deactivate a GL account with an effective date
**Given** I have `CoA:Manage` permission  
**And** I am viewing an active GL account  
**When** I deactivate the account effective tomorrow  
**Then** the account detail displays an activeThru date equal to tomorrow  
**And** the UI reflects the account as inactive once the effective date passes (date-based display)

### Scenario 6: Deactivation blocked by policy
**Given** I have `CoA:Manage` permission  
**And** I am viewing an active GL account that violates deactivation policy  
**When** I attempt to deactivate the account  
**Then** I see an error explaining the policy violation  
**And** the account remains active in the UI with unchanged effective dates

### Scenario 7: Unauthorized user cannot manage CoA
**Given** I am authenticated  
**And** I do not have `CoA:Manage` permission  
**When** I navigate to a GL account detail screen  
**Then** I can view the account details  
**And** I do not see controls to create, edit, or deactivate accounts

---

## 13. Audit & Observability

- **User-visible audit data (read-only):**
  - createdAt, createdBy, updatedAt, updatedBy on detail screen
- **Status history:** not defined; if backend exposes audit events/history endpoint, show a tab; otherwise out-of-scope.
- **Traceability expectations:**
  - Frontend logs (console/telemetry per project convention) include `accountId` on save/deactivate failures.
  - UI should surface backend-provided error codes/messages verbatim when safe (no sensitive info).

---

## 14. Non-Functional UI Requirements

- **Performance:** list load under 2s for first page under normal conditions; show skeleton/loading state.
- **Accessibility:** all form inputs labeled; keyboard navigable dialogs; validation messages associated to fields.
- **Responsiveness:** usable on tablet; list collapses gracefully (no pixel-perfect requirements).
- **i18n/timezone:** display datetimes in user locale/timezone; input uses timezone-aware picker (do not assume UTC-only).
- **Security:** do not expose hidden actions; enforce permission-based rendering but rely on backend as source of truth.

---

## 15. Applied Safe Defaults

- SD-UX-EMPTY-STATE: Provide a standard empty-state panel on list screens with optional ‚ÄúCreate‚Äù CTA when authorized; safe because it doesn‚Äôt change domain behavior (Impacted: UX Summary, Alternate/Empty states).
- SD-UX-PAGINATION: Default to paginated list view with page size control; safe because it‚Äôs purely UI ergonomics (Impacted: UX Summary, Functional Behavior).
- SD-ERR-HTTP-MAPPING: Standard HTTP‚ÜíUI error mapping (400/401/403/404/409/422) using backend messages; safe because it follows implied REST semantics without inventing policies (Impacted: Service Contracts, Error Flows).

---

## 16. Open Questions

1. **Backend contract confirmation:** What are the exact backend endpoints (or Moqui services) for list/get/create/patch/deactivate GL accounts, and what are the exact request/response schemas and error payload formats?
2. **View permissions:** Is CoA list/detail view restricted to `CoA:Manage`, or is there a separate read-only permission (e.g., `CoA:View`)?
3. **Deactivation policy details:** Beyond ‚Äúnon-zero balance/usage,‚Äù what specific conditions block deactivation (recent activity window, mappings usage, open period constraints, etc.) and what error codes/messages are returned?
4. **Editing inactive accounts:** Are name/description edits allowed after an account becomes inactive, or must inactive accounts be fully immutable?
5. **Status filtering semantics:** If the list supports `status` filter, what are the canonical statuses and how are they computed (date-based vs explicit status field)?
6. **Optimistic locking:** Does `GLAccount` use a version field/ETag for concurrency? If so, what header/field is required and what error is returned on conflict?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] CoA: Create and Maintain Chart of Accounts  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/204  
Labels: frontend, story-implementation, general

## Frontend Implementation for Story

**Original Story**: [STORY] CoA: Create and Maintain Chart of Accounts

**Domain**: general

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Maintain Chart of Accounts and Posting Categories

## Story
CoA: Create and Maintain Chart of Accounts

## Acceptance Criteria
- [ ] Accounts support types: Asset/Liability/Equity/Revenue/Expense
- [ ] Accounts are effective-dated (activeFrom/activeThru) and audit-logged
- [ ] Duplicate account codes are blocked
- [ ] Deactivation rules are enforced per policy (e.g., balances/usage)


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #205: [FRONTEND] [STORY] Events: Validate Event Completeness and Integrity  
File: ./scripts/story-work/frontend/205/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Accounting Events: Validate Event Completeness & Integrity (UI for Ingestion Validation + Status Tracking)

### Primary Persona
Accounting Operations Analyst (and System Auditor as secondary)

### Business Value
Provide a deterministic UI to submit/test accounting events and to review validation outcomes and processing status history so upstream teams can quickly correct invalid events and Accounting can prevent corrupted/unsafe data from entering downstream mapping/posting.

---

## 2. Story Intent

### As a / I want / So that
- **As an** Accounting Operations Analyst  
- **I want** to submit or view incoming accounting events and see clear validation results with actionable error codes and processing status transitions  
- **So that** invalid or inconsistent events are rejected/suspended early, and valid events proceed with traceability and auditability.

### In-scope
- Frontend screens in Moqui (Vue/Quasar) to:
  - List/search accounting event ingestion records
  - View event details including validation errors and status history
  - Manually submit an event payload for validation (test/ops tool) **if supported by backend**
- UI behaviors for handling:
  - Schema validation failures
  - Missing reference failures
  - Financial consistency failures
  - Unknown event type handling (reject vs suspense) **as provided by backend**
- Display processing status progression (Received‚ÜíValidated‚ÜíMapped‚ÜíPosted/Rejected/Suspense)

### Out-of-scope
- Defining or implementing validation logic (backend-owned)
- Defining accounting formulas/tolerances, tax policy, GL account mappings
- Manual remediation actions like ‚Äúmove from suspense to mapped/posted‚Äù unless explicitly supported by backend contract
- Creating/maintaining canonical schemas

---

## 3. Actors & Stakeholders
- **Primary user:** Accounting Operations Analyst
- **Secondary user:** System Auditor / Compliance reviewer
- **System actor:** Accounting Event Ingestion Service (backend)
- **Upstream stakeholders:** Engineering teams producing events (need actionable error feedback)

---

## 4. Preconditions & Dependencies
- Backend provides one or more endpoints/services to:
  - List ingestion records (filterable)
  - Retrieve a single event record with payload + validation errors + status history
  - Submit an event for ingestion/validation (optional but implied by story capability)
- Backend returns structured error codes for validation failures (e.g., `SCHEMA_VALIDATION_FAILED`, `REFERENCE_NOT_FOUND`, `FINANCIAL_INCONSISTENCY`, `UNKNOWN_EVENT_TYPE`)
- Authentication/authorization exists; UI must respect permissions for viewing/submitting events.
- Moqui screens framework is available in this repo with Vue 3 + Quasar integration (per repo conventions).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main navigation: **Accounting ‚Üí Events ‚Üí Ingestion**
- Deep links:
  - `/accounting/events` (list)
  - `/accounting/events/<eventId>` (detail)

### Screens to create/modify
1. **Screen: `AccountingEventIngestionList`**
   - Purpose: searchable list of ingestion records with status and timestamps
2. **Screen: `AccountingEventIngestionDetail`**
   - Purpose: full record view including payload, validation results, status history
3. **Screen/Dialog: `AccountingEventSubmit`** (optional, if backend supports submission)
   - Purpose: paste/upload JSON payload to validate/ingest

### Navigation context
- From list ‚Üí select row ‚Üí detail screen
- From list ‚Üí ‚ÄúSubmit Event‚Äù action ‚Üí submit screen/dialog ‚Üí on success navigate to detail

### User workflows
- **Happy path (review valid event):**
  1. User opens list, filters by status `Validated`
  2. Opens event detail
  3. Sees status history `Received ‚Üí Validated`, no errors
- **Alternate path (rejected event triage):**
  1. Filter by status `Rejected`
  2. Open detail; view error codes + error details
  3. Copy eventId/error payload excerpt to share with upstream team
- **Alternate path (unknown event type):**
  1. Filter by `Suspense` or `Rejected` for `UNKNOWN_EVENT_TYPE`
  2. Review payload and policy result (as returned by backend)
- **Optional workflow (submit/test):**
  1. Open submit
  2. Paste JSON and submit
  3. UI shows created record and status `Received` (then refresh until `Validated/Rejected/Suspense`)

---

## 6. Functional Behavior

### Triggers
- Page load (list/detail) triggers backend fetch
- User submits filter changes triggers list refresh
- User opens detail triggers record fetch
- User submits event triggers ingestion call (if supported)

### UI actions
- List:
  - Filter by: status, eventType, sourceModule/sourceSystem, date range, businessUnitId (if available)
  - Pagination and sorting by `occurredAt` or `receivedAt`
- Detail:
  - Display: event envelope fields, payload (read-only JSON viewer), status history timeline/table, validation errors table
  - Actions: copy eventId, copy error code, copy payload snippet (client-side)
  - Refresh button (re-fetch)
- Submit:
  - JSON input validation on client only for ‚Äúvalid JSON‚Äù (not schema correctness)
  - Submit button calls backend; show server response and navigate to detail

### State changes (frontend-observable)
- No client-side state machine beyond view state
- Reflect backend status changes on refresh/poll:
  - `Received ‚Üí Validated ‚Üí Mapped ‚Üí Posted` (or terminal `Rejected` / `Suspense`)
- If backend supports it, UI may show ‚ÄúProcessing‚Äù indicator when status is non-terminal.

### Service interactions
- `load list` service call with filters
- `load detail` service call by eventId (or processingId)
- `submit` service call with raw event JSON

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- UI must surface backend validation outcomes as:
  - **Error code** (canonical)
  - **Human-readable message**
  - **Field/path context** where available (e.g., JSON pointer)
- UI must not attempt to re-implement schema/reference/financial checks.

### Enable/disable rules
- ‚ÄúSubmit Event‚Äù action only visible/enabled if user has permission (see Open Questions) and backend contract exists.
- Detail ‚ÄúRefresh‚Äù always enabled.

### Visibility rules
- Validation errors section visible when backend returns `validationErrors` or status is `Rejected`/`Suspense`.
- Status history always visible; empty state if none.

### Error messaging expectations
- For 400 validation responses: show banner ‚ÄúEvent rejected‚Äù plus returned error code(s).
- For 401/403: show ‚ÄúNot authorized‚Äù and hide restricted content.
- For 404: show ‚ÄúEvent not found‚Äù.
- For 409 conflict/idempotency: show ‚ÄúDuplicate event‚Äù with returned disposition (processed/no-op) if provided.

---

## 8. Data Requirements

> Note: entity names/fields below reflect domain guidance; exact backend DTO/entity field names must be confirmed (Open Questions).

### Entities involved (frontend-facing)
- **AccountingEvent / CanonicalAccountingEvent** (event envelope + payload)
- **EventProcessingRecord** (processing status + timestamps + validationErrors)
- **EventStatusHistory / Audit log entries** (status transitions)

### Fields (type, required, defaults)

**Event envelope (read-only)**
- `eventId` (string UUIDv7) ‚Äî required
- `eventType` (string) ‚Äî required
- `schemaVersion` (string SemVer) ‚Äî required
- `sourceModule` or `sourceSystem` (string) ‚Äî required
- `sourceEntityRef` (string/object) ‚Äî required (exact shape unknown)
- `occurredAt` (datetime ISO-8601) ‚Äî required
- `businessUnitId` (string) ‚Äî required
- `currencyUomId` (string) ‚Äî required

**Processing record (read-only)**
- `processingId` (string UUID) ‚Äî required
- `status` (enum) ‚Äî required; one of `Received|Validated|Mapped|Posted|Rejected|Suspense`
- `receivedAt` (datetime) ‚Äî required
- `lastUpdatedAt` (datetime) ‚Äî required
- `validationErrors` (array/object, nullable) ‚Äî optional

**Validation error item (read-only)**
- `errorCode` (string) ‚Äî required
- `message` (string) ‚Äî required
- `path` (string, optional) ‚Äî JSON pointer / field name if provided
- `details` (object, optional) ‚Äî structured metadata

**Payload (read-only JSON)**
- `payload` (object) ‚Äî required (may be large)

### Editable vs read-only
- List and detail are fully read-only.
- Submit screen allows editing only the raw JSON submission body.

### Derived/calculated (UI-only)
- Terminal status flag: status in `{Posted, Rejected, Suspense}` (unless policy says otherwise)
- Status duration display: `lastUpdatedAt - receivedAt` (presentation only)

---

## 9. Service Contracts (Frontend Perspective)

> Moqui implementation can call REST via `service-call` or `screen` transitions; exact endpoint/service names must be confirmed.

### Load/view calls
1. **List events**
   - Inputs: `status?`, `eventType?`, `sourceModule?`, `fromDate?`, `toDate?`, `businessUnitId?`, `pageIndex`, `pageSize`, `sortBy`, `sortOrder`
   - Output: array of processing records with minimal envelope fields
2. **Get event detail**
   - Input: `eventId` (or `processingId`)
   - Output: full envelope + payload + processing record + status history + validation errors

### Create/update calls
- None (read-only) except optional submit.

### Submit/transition calls (optional)
- **Submit accounting event**
  - Input: raw JSON body representing canonical event
  - Output: created/acknowledged record including `eventId` and current `status`
  - Idempotency handling: if duplicate, backend may return success/no-op or conflict; UI must display outcome.

### Error handling expectations (mapping)
- `400` ‚Üí validation error banner; render returned error codes
- `401/403` ‚Üí route to login or show unauthorized
- `404` ‚Üí not found state
- `409` ‚Üí duplicate/conflict; show duplicate disposition
- `5xx`/network ‚Üí retry affordance and preserve filters/input

---

## 10. State Model & Transitions

### Allowed states (displayed)
- `Received`
- `Validated`
- `Mapped`
- `Posted`
- `Rejected`
- `Suspense`

### Role-based transitions
- No UI-initiated transitions are in scope (view-only).
- If ‚ÄúSubmit‚Äù exists: creating a new event results in initial state `Received` (backend-owned).

### UI behavior per state
- `Received`: show ‚ÄúProcessing‚Äù indicator; refresh available
- `Validated`: show ‚ÄúValidated‚Äù badge; errors hidden unless provided
- `Mapped/Posted`: show success badges; status history visible
- `Rejected`: show error banner; validation errors section required
- `Suspense`: show warning banner; display any policy rationale and errors

---

## 11. Alternate / Error Flows

### Validation failures (submit or view)
- If submit returns `Rejected` with errors, remain on submit result view and provide link to detail.
- If viewing an event in `Rejected`, show errors with codes and details.

### Concurrency conflicts
- If event status changes between list and detail, detail fetch shows latest; UI shows ‚ÄúUpdated since last view‚Äù if `lastUpdatedAt` changed after list load (UI-only indicator).

### Unauthorized access
- List/detail endpoints return 403: show ‚ÄúYou do not have access to Accounting Events‚Äù and do not render payload.

### Empty states
- List: ‚ÄúNo events found‚Äù with active filters summary and clear-filters action.
- Detail: If missing, show not found.

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: View list of event ingestion records
**Given** I am an authorized Accounting Operations Analyst  
**When** I navigate to Accounting ‚Üí Events ‚Üí Ingestion  
**Then** I see a paginated list of event ingestion records including eventId, eventType, status, receivedAt, and lastUpdatedAt

### Scenario 2: Filter list by status
**Given** I am on the event ingestion list  
**When** I filter by status "Rejected"  
**Then** the list refreshes and only shows records with status "Rejected"

### Scenario 3: View event detail with successful validation
**Given** an event exists with status history "Received" then "Validated" and no validation errors  
**When** I open the event detail page for that event  
**Then** I see the event envelope fields and status history including both transitions  
**And** I do not see a validation error banner

### Scenario 4: View event detail for schema validation failure
**Given** an event exists with status "Rejected" due to schema validation  
**When** I open the event detail page  
**Then** I see a validation error banner  
**And** I see an error entry with code "SCHEMA_VALIDATION_FAILED" (or backend-provided equivalent) and an actionable message

### Scenario 5: View event detail for missing reference failure
**Given** an event exists with status "Rejected" due to a missing required reference  
**When** I open the event detail page  
**Then** I see an error entry with code "REFERENCE_NOT_FOUND" (or backend-provided equivalent)  
**And** the UI displays any provided reference identifier context (e.g., `customerId`) without guessing

### Scenario 6: View event detail for financial inconsistency
**Given** an event exists with status "Rejected" due to inconsistent monetary amounts  
**When** I open the event detail page  
**Then** I see an error entry with code "FINANCIAL_INCONSISTENCY" (or backend-provided equivalent)  
**And** the UI displays any provided details about the failed check

### Scenario 7: Unknown event type handled per policy
**Given** an event exists with an unknown eventType  
**When** I open the event detail page  
**Then** I see the terminal disposition as either "Rejected" or "Suspense" as returned by the backend  
**And** I see an error/policy message indicating the unknown event type handling result

### Scenario 8: Unauthorized user cannot view payload
**Given** I am logged in without permission to view accounting event details  
**When** I navigate to an event detail URL  
**Then** I receive an unauthorized message state  
**And** the event payload is not rendered

### Scenario 9 (Optional): Submit an event payload for validation
**Given** the backend supports an event ingestion endpoint and I have permission to submit events  
**When** I paste valid JSON for a known eventType and submit  
**Then** the UI shows the created/acknowledged eventId and current status  
**And** I can navigate to the event detail page for that event

---

## 13. Audit & Observability

### User-visible audit data
- Detail page must display status history entries with:
  - fromStatus, toStatus
  - timestamp
  - actor/principal (service principal) if provided by backend

### Status history
- Must render in chronological order.
- Must handle missing intermediate states (display what backend provides; do not infer).

### Traceability expectations
- All screens must display identifiers: `eventId`, and if present `processingId`, `sourceModule/sourceSystem`, `schemaVersion`.
- UI copy actions facilitate debugging without editing the payload.

---

## 14. Non-Functional UI Requirements
- **Performance:** List loads within 2s for first page under normal conditions; detail renders large JSON payload with virtualized viewer or collapsed sections to avoid freezing.
- **Accessibility:** Keyboard navigable filters; proper labels; error banners announced to screen readers.
- **Responsiveness:** Works on tablet widths; list uses responsive columns.
- **i18n/timezone/currency:** Timestamps displayed in user locale/timezone; currency shown as code only unless backend provides formatted amounts (do not format money without contract).

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide deterministic empty-state messaging and clear-filters action; qualifies as safe UI ergonomics; impacts UX Summary, Alternate/Empty states.
- SD-UX-PAGINATION: Use standard pagination (pageIndex/pageSize) and sorting; qualifies as safe UI ergonomics; impacts UX Summary, Service Contracts.
- SD-ERR-HTTP-MAP: Standard mapping of HTTP 400/401/403/404/409/5xx to UI banners and retry; qualifies as safe error-handling boilerplate; impacts Business Rules, Error Flows, Service Contracts.

---

## 16. Open Questions
1. **Backend contract (blocking):** What are the exact endpoints or Moqui services for:
   - listing event processing records
   - retrieving event detail (by `eventId` vs `processingId`)
   - submitting an event (if supported)
2. **Permissions (blocking):** What permissions control:
   - viewing event list
   - viewing event detail/payload
   - submitting events (ops/test tool)
3. **Unknown event policy (blocking):** Is unknown `eventType` always `Rejected`, always `Suspense`, or environment-configurable? How should UI message it?
4. **Canonical error codes (blocking):** What is the canonical list of error codes and the response schema for `validationErrors` (array shape, fields like `path`, `details`)?
5. **Status history shape (blocking):** Does backend provide explicit transition records? If yes, what fields (actor, reason, correlationId)?
6. **Idempotency UX (blocking):** On duplicate `eventId`, does backend return 200 with existing record, or 409, or both depending on payload match? What response fields should the UI rely on?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Events: Validate Event Completeness and Integrity  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/205  
Labels: frontend, story-implementation, general

## Frontend Implementation for Story

**Original Story**: [STORY] Events: Validate Event Completeness and Integrity

**Domain**: general

### Story Description

/kiro  
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Ingest Accounting Events (Cross-Module)

## Story
Events: Validate Event Completeness and Integrity

## Acceptance Criteria
- [ ] Invalid schema or missing required references are rejected with actionable error codes
- [ ] Unknown eventType is rejected or routed to suspense per policy
- [ ] Amount and tax consistency checks are enforced per policy
- [ ] Processing status transitions are recorded (Received‚ÜíValidated‚ÜíMapped‚ÜíPosted/Rejected/Suspense)

### Frontend Requirements
- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack
- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #206: [FRONTEND] [STORY] Events: Implement Idempotency and Deduplication  
File: ./scripts/story-work/frontend/206/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

STOP: Clarification required before finalization

---

# 1. Story Header

## Title
[FRONTEND] [STORY] Accounting Events: Idempotency, Replay, Conflict Visibility & Retry Controls

## Primary Persona
Accounting Ops / System Auditor (operational user monitoring and resolving ingestion integrity issues)

## Business Value
Prevent duplicate GL impact from event replays, surface integrity conflicts for triage, and provide safe retry controls for failed events‚Äîensuring auditability, operational recoverability, and financial data integrity.

---

# 2. Story Intent

## As a / I want / So that
- **As an** Accounting Ops user (or System Auditor)  
- **I want** a UI to search and inspect accounting event ingestion idempotency records, identify replays vs conflicts, and trigger safe retries for failed events  
- **So that** duplicate submissions do not create duplicate financial impact, conflicts are escalated and traceable, and ingestion failures can be retried without duplicating postings.

## In-scope
- New Moqui screens to:
  - Search/list idempotency records by `eventId`, status, date range, and eventType
  - View an idempotency record including stored response and GL posting reference
  - Show replay vs new processing outcomes (as recorded by backend)
  - List and view conflict records (exceptions queue) and their state (`OPEN` ‚Üí `TRIAGED` ‚Üí resolution terminals)
  - Trigger a **retry** for `FAILED` idempotency records (hash match) via backend endpoint (if provided)
- Frontend error mapping for:
  - `409 Conflict` for conflicting duplicates
  - Unauthorized access errors
  - Validation errors (invalid UUID, missing required params)
- Audit/observability in UI (show who/when, correlation where available)

## Out-of-scope
- Implementing backend idempotency, hashing, DLQ publishing, or retention/tiering jobs (backend-owned)
- Editing/overwriting original events or conflict payloads (must remain immutable)
- Automated conflict resolution (workflow is Accounting Ops; UI may support manual state transitions only if backend supports it‚Äîcurrently unclear)
- Defining GL account mappings, posting rules, or journal entry logic

---

# 3. Actors & Stakeholders
- **Accounting Ops**: triages ingestion failures and conflicts, initiates retries, documents resolution notes (if supported).
- **System Auditor**: reviews idempotency behavior and traceability for compliance.
- **SRE / Support**: uses UI to diagnose spikes in conflicts/failures; correlates to DLQ references.
- **Event Producers (systems)**: indirectly impacted; conflict detection may indicate producer bugs.

---

# 4. Preconditions & Dependencies
- Backend provides read APIs for:
  - Idempotency store records (by `eventId`, list/search)
  - Conflict store records (list/search, view by `conflictId`)
- Backend provides a command API to **retry** failed events (or documents retry is automatic only).
- Authentication/authorization is implemented and exposes permissions/scopes for accounting operations.
- Moqui frontend project has standard layout, routing, auth guard conventions (per repository README).

---

# 5. UX Summary (Moqui-Oriented)

## Entry points
- Main navigation (Accounting section) entry:
  - `Accounting ‚Üí Events ‚Üí Ingestion Monitor` (name is implementable; exact nav placement depends on existing menu model)

## Screens to create/modify (Moqui)
Create new screens under an accounting/events namespace (final paths may vary by repo conventions):
1. **Event Ingestion Monitor (Search/List)**  
   - Screen: `apps/<app>/screens/accounting/events/IngestionMonitor.xml`
2. **Idempotency Record Detail**  
   - Screen: `.../IdempotencyDetail.xml`
3. **Conflict Queue (List)**  
   - Screen: `.../ConflictQueue.xml`
4. **Conflict Detail**  
   - Screen: `.../ConflictDetail.xml`

## Navigation context
- From Ingestion Monitor list ‚Üí Idempotency detail
- From Conflict Queue ‚Üí Conflict detail
- Cross-links:
  - Idempotency detail: link to conflict detail if related conflict exists (requires backend to expose link)
  - Conflict detail: link to idempotency record by `eventId`

## User workflows
### Happy path: check event status / replay result
1. User searches by `eventId`
2. User opens record
3. UI shows status `COMPLETED` and displays cached `glPostingReference` and `responsePayload`
4. User confirms replay behavior via ‚ÄúSeen count/lastSeenAt‚Äù (if available)

### Alternate path: conflict triage
1. User opens Conflict Queue filtered to `OPEN`
2. Opens a conflict
3. Reviews hashes, DLQ reference, flaggedAt/flaggedBy
4. Marks as TRIAGED / resolves (only if backend supports transitions; otherwise read-only)

### Alternate path: retry failed
1. User filters idempotency status = `FAILED`
2. Opens record
3. Clicks ‚ÄúRetry processing‚Äù
4. UI confirms outcome and refreshes status (no duplicate posting)

---

# 6. Functional Behavior

## Triggers
- User navigates to screens (load list/detail)
- User submits search filters
- User clicks retry
- User attempts conflict state change (conditional on backend support)

## UI actions
### Ingestion Monitor (list)
- Filter inputs:
  - `eventId` (exact match)
  - `status` (`PROCESSING|COMPLETED|FAILED`)
  - `eventType` (string match; exact/contains depends on backend)
  - `firstSeenAt` date range (from/to)
- Results table columns (minimum):
  - `eventId`
  - `eventType` (if stored)
  - `status`
  - `firstSeenAt`
  - `lastSeenAt`
  - `glPostingReference` (nullable)
  - action: View

### Idempotency Detail
Display read-only fields (if present):
- `eventId`
- `status`
- `domainPayloadHash`
- `eventType` (if available)
- `firstSeenAt`, `lastSeenAt`
- `glPostingReference`
- `responsePayload` (JSON viewer; collapsible)
- `archivedAt` (if applicable)
Actions:
- `Retry` button visible only when `status == FAILED` **and** user has permission (see Open Questions)
- `View related conflict` link if backend indicates conflict exists

### Conflict Queue (list)
Filters:
- `eventId`
- `conflictState` (`OPEN|TRIAGED|RESOLVED_ACCEPT_ORIGINAL|RESOLVED_ACCEPT_NEW|RESOLVED_INVALID_PRODUCER`)
- `flaggedAt` date range
Columns:
- `conflictId`
- `eventId`
- `conflictState`
- `flaggedAt`
- `dlqMessageRef` (nullable)
- action: View

### Conflict Detail
Read-only display:
- `conflictId`, `eventId`
- `originalDomainPayloadHash`, `conflictingDomainPayloadHash`
- `conflictState`
- `flaggedAt`, `flaggedBy`
- `dlqMessageRef`
- `resolutionNotes` (nullable)
Actions (only if backend supports):
- Transition to `TRIAGED`
- Resolve to one of terminal states with required notes (policy-driven; see Open Questions)

## State changes (frontend-observable)
- Idempotency record can change `FAILED ‚Üí PROCESSING ‚Üí COMPLETED` after retry.
- Conflict record can change `OPEN ‚Üí TRIAGED ‚Üí RESOLVED_*` (if command endpoints exist).

## Service interactions
- Read: list and detail fetches
- Write/command:
  - Retry failed event
  - Update conflict state / resolution notes (if supported)

---

# 7. Business Rules (Translated to UI Behavior)

## Validation
- `eventId` search input:
  - Must be a valid UUID format (UUIDv7 acceptable as UUID)
  - If invalid: block search submit and show inline error ‚ÄúEnter a valid UUID‚Äù
- Date range:
  - `from <= to` else inline error

## Enable/disable rules
- **Retry** enabled only when:
  - record `status == FAILED`
  - user is authorized
  - record is not currently `PROCESSING` (if backend exposes)
- Conflict state transition controls enabled only when:
  - backend exposes allowed transitions for current state (preferred)
  - user authorized

## Visibility rules
- Hide response payload viewer when `responsePayload` is null; show ‚ÄúNo stored response‚Äù
- Show warning banner when:
  - status `FAILED` (actionable)
  - conflict detected (if the idempotency record links to a conflict)

## Error messaging expectations
- `409 Conflict` (conflicting duplicate): show a blocking banner:
  - ‚ÄúConflict detected for eventId <id>. This indicates the same eventId was received with different business payload. See Conflict Queue.‚Äù
- `403/401`: show ‚ÄúYou don‚Äôt have access to Accounting Event Ingestion Monitor.‚Äù
- `5xx`: show standard retryable error with ‚ÄúTry again‚Äù and preserve filters.

---

# 8. Data Requirements

## Entities involved (frontend view models)
> Exact Moqui entity names are **unknown** from provided inputs; frontend must bind to backend responses.

### Idempotency Record (hot tier)
Fields expected (from backend story):
- `eventId` (string UUID) **required**
- `domainPayloadHash` (string SHA-256 hex) **required**
- `status` (enum: `PROCESSING|COMPLETED|FAILED`) **required**
- `responsePayload` (JSON/object) optional
- `glPostingReference` (string) optional
- `firstSeenAt` (datetime) required
- `lastSeenAt` (datetime) required
- `archivedAt` (datetime) optional
Additional (not guaranteed):
- `eventType` (string) optional

Read-only vs editable
- All fields read-only in UI; user does not edit idempotency records.

### Conflict Record (exceptions queue)
Fields expected:
- `conflictId` (string/UUID) required
- `eventId` (string UUID) required
- `originalDomainPayloadHash` required
- `conflictingDomainPayloadHash` required
- `conflictState` enum required
- `flaggedAt` datetime required
- `flaggedBy` string optional/required (unclear)
- `resolutionNotes` string optional
- `dlqMessageRef` string optional

Editable by state/role
- `resolutionNotes` editable only if backend supports updates and user authorized
- `conflictState` changeable only through allowed transitions and authorization

## Derived/calculated fields (UI)
- ‚ÄúAge‚Äù = now - `firstSeenAt` (display-only)
- ‚ÄúReplay count‚Äù not available unless backend provides; do not infer.

---

# 9. Service Contracts (Frontend Perspective)

## Load/view calls
> Endpoints are not provided in inputs. Define Moqui screen transitions/services with placeholders and require backend contract confirmation.

- `GET /accounting/events/idempotency` (list/search)
  - Query params: `eventId`, `status`, `eventType`, `firstSeenFrom`, `firstSeenTo`, `pageIndex`, `pageSize`, `sort`
- `GET /accounting/events/idempotency/{eventId}` (detail)

- `GET /accounting/events/conflicts` (list/search)
  - Query params: `eventId`, `conflictState`, `flaggedFrom`, `flaggedTo`, pagination/sort
- `GET /accounting/events/conflicts/{conflictId}` (detail)

## Create/update calls
- None for idempotency records.
- Conflict updates (only if supported):
  - `POST /accounting/events/conflicts/{conflictId}/transition` with `toState` (+ `resolutionNotes` when resolving)

## Submit/transition calls
- Retry failed event:
  - `POST /accounting/events/idempotency/{eventId}/retry`
  - Response: updated idempotency record and/or command receipt

## Error handling expectations
- `400` validation: show inline errors (bad UUID, invalid date range)
- `401/403`: route to login or show access denied
- `404`: show ‚ÄúRecord not found‚Äù (eventId/conflictId)
- `409`: show conflict banner and link to Conflict Queue filtered by eventId
- `5xx`: show retryable error; keep screen state

---

# 10. State Model & Transitions

## Allowed states (from backend story)
### Idempotency record status
- `PROCESSING`
- `COMPLETED`
- `FAILED`

UI behavior per state:
- PROCESSING: show spinner/badge; disable retry
- COMPLETED: show glPostingReference/responsePayload; retry hidden
- FAILED: show error banner; allow retry if authorized

### Conflict record state
- `OPEN` ‚Üí `TRIAGED` ‚Üí terminal:
  - `RESOLVED_ACCEPT_ORIGINAL`
  - `RESOLVED_ACCEPT_NEW` (must be via compensating/reversal events; UI must not imply overwrite)
  - `RESOLVED_INVALID_PRODUCER`

Role-based transitions
- Unknown exact roles/permissions; must be clarified.
- UI must not present transitions the user cannot perform.

---

# 11. Alternate / Error Flows

## Validation failures
- Invalid `eventId` format:
  - Prevent submit; show inline validation
- Invalid date range:
  - Prevent submit; show inline validation

## Concurrency conflicts
- If user retries while backend transitions to PROCESSING:
  - Backend returns `409` or `409/423` equivalent; UI refreshes record and shows ‚ÄúAlready processing‚Äù

## Unauthorized access
- Accessing any screen without permission:
  - Show access denied screen; do not leak record existence via differing messages (prefer consistent 403 handling)

## Empty states
- No idempotency records match filters:
  - Show ‚ÄúNo events found‚Äù and keep filters
- No conflicts in OPEN state:
  - Show ‚ÄúNo open conflicts‚Äù

---

# 12. Acceptance Criteria (Gherkin)

## Scenario 1: Search idempotency records by eventId
**Given** I am an authenticated user with permission to view accounting event ingestion records  
**And** an idempotency record exists for `eventId = ABC-123`  
**When** I open the Ingestion Monitor and search for `eventId = ABC-123`  
**Then** I see exactly one result with `eventId = ABC-123`  
**And** I can navigate to the Idempotency Detail screen for that event.

## Scenario 2: View completed idempotency record shows cached GL reference
**Given** an idempotency record exists with `status = COMPLETED` and `glPostingReference` populated  
**When** I view the Idempotency Detail  
**Then** the UI displays `status = COMPLETED`  
**And** the UI displays the `glPostingReference`  
**And** if `responsePayload` exists, the UI renders it read-only.

## Scenario 3: Retry is available only for FAILED records
**Given** an idempotency record exists with `status = FAILED`  
**When** I view the Idempotency Detail  
**Then** the UI shows a ‚ÄúRetry processing‚Äù action  
**And** when I click ‚ÄúRetry processing‚Äù  
**Then** the UI calls the retry endpoint for that `eventId`  
**And** the UI refreshes and shows the updated status (PROCESSING or COMPLETED)  
**And** the UI does not create duplicate retries while a request is in-flight.

## Scenario 4: Retry is not available for COMPLETED records
**Given** an idempotency record exists with `status = COMPLETED`  
**When** I view the Idempotency Detail  
**Then** the UI does not show the ‚ÄúRetry processing‚Äù action.

## Scenario 5: Conflict queue lists OPEN conflicts and supports filtering by eventId
**Given** conflict records exist with `conflictState = OPEN`  
**When** I open Conflict Queue and filter to `conflictState = OPEN`  
**Then** I see a list of conflicts including `conflictId`, `eventId`, and `flaggedAt`  
**And** when I filter by a specific `eventId`  
**Then** only conflicts for that `eventId` are shown.

## Scenario 6: Backend returns 409 Conflict and UI surfaces conflict guidance
**Given** I attempt an operation that triggers a backend `409 Conflict` for a conflicting duplicate event  
**When** the UI receives the `409 Conflict` response  
**Then** the UI shows a clear conflict banner referencing the `eventId`  
**And** the UI provides a link to Conflict Queue filtered by that `eventId`.

## Scenario 7: Unauthorized users cannot access ingestion monitoring screens
**Given** I am authenticated but lack the required permission  
**When** I navigate to the Ingestion Monitor URL  
**Then** I receive an access denied experience (403)  
**And** no idempotency/conflict details are displayed.

---

# 13. Audit & Observability

## User-visible audit data
- Display audit timestamps:
  - Idempotency: `firstSeenAt`, `lastSeenAt`, `archivedAt`
  - Conflict: `flaggedAt`, `flaggedBy`, `resolutionNotes` (if present)
- Display immutable identifiers:
  - `eventId`, `conflictId`, hashes, `dlqMessageRef`

## Status history
- If backend provides history (not specified), show a read-only ‚ÄúStatus History‚Äù panel.
- Otherwise, show current state only; do not fabricate history.

## Traceability expectations
- Screens should include copyable identifiers for support:
  - `eventId`, `conflictId`, `glPostingReference`
- Include correlation ID from HTTP responses if available (header-based; project-dependent).

---

# 14. Non-Functional UI Requirements

## Performance
- List screens must support pagination (server-side) and avoid rendering large JSON blobs inline.
- JSON payload viewer should lazy-render/collapse by default.

## Accessibility
- All actions keyboard-accessible
- Status communicated via text (not color-only)
- JSON viewer supports screen readers (at minimum: accessible label and copy-to-clipboard)

## Responsiveness
- Tables responsive with column priority; detail screens scrollable on small viewports.

## i18n/timezone/currency
- Datetimes displayed in user‚Äôs locale/timezone (do not change stored values).
- Currency not applicable for these screens.

---

# 15. Applied Safe Defaults
- SD-UX-PAGINATION-001: Use server-side pagination defaults (pageSize=25) for list screens; qualifies as UI ergonomics and does not change domain behavior. Impacted sections: UX Summary, Functional Behavior, Non-Functional.
- SD-UX-EMPTYSTATE-001: Provide standard empty-state messaging (‚ÄúNo results found‚Äù) for lists; safe UI ergonomics. Impacted sections: UX Summary, Alternate / Error Flows.
- SD-ERR-MAP-001: Map common HTTP statuses (400/401/403/404/409/5xx) to consistent banners/inline errors; safe because it only reflects backend outcomes. Impacted sections: Business Rules, Service Contracts, Alternate / Error Flows.

---

# 16. Open Questions

1. **Backend API contracts:** What are the exact endpoints/paths, request/response schemas, and pagination/sort conventions for:
   - idempotency list/detail
   - conflict list/detail
   - retry failed event
   - (optional) conflict state transitions?
2. **Authorization model:** What permissions/roles control:
   - viewing idempotency records
   - viewing conflict records
   - retrying failed events
   - transitioning conflict state / editing resolution notes?
3. **UI scope for conflict workflow:** Is the frontend expected to support **changing** `conflictState` and adding `resolutionNotes`, or is it strictly read-only with ops handled elsewhere?
4. **Linking idempotency ‚Üî conflict:** Does backend expose a direct relationship (e.g., idempotency record contains `conflictId`), or must UI search conflicts by `eventId`?
5. **EventType availability:** Is `eventType` stored alongside idempotency records (backend data model shows it in incoming event, but idempotency store fields listed do not include it)? If not stored, should UI omit eventType filtering?
6. **Retry behavior visibility:** On retry, does backend return synchronous updated status/record, or an async job reference requiring polling? If async, what is the polling endpoint and recommended interval?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Events: Implement Idempotency and Deduplication  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/206  
Labels: frontend, story-implementation, general

## Frontend Implementation for Story

**Original Story**: [STORY] Events: Implement Idempotency and Deduplication

**Domain**: general

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Ingest Accounting Events (Cross-Module)

## Story
Events: Implement Idempotency and Deduplication

## Acceptance Criteria
- [ ] Duplicate submissions of same eventId are detected and do not create duplicate GL impact
- [ ] Conflicting duplicates (same eventId, different payload) are rejected and flagged
- [ ] Replays return the prior posting reference when already posted
- [ ] Retry workflow exists for failed events without duplicating postings


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #207: [FRONTEND] [STORY] Events: Receive Events via Queue and/or Service Endpoint  
File: ./scripts/story-work/frontend/207/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- none

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Accounting Events Ingestion: Submit Canonical Event via Sync Endpoint + View Acknowledgement

### Primary Persona
Accounting integration operator / platform engineer (service-to-service producer validation support)

### Business Value
Enable producing modules and operators to submit accounting events through a canonical ingestion endpoint and receive deterministic acknowledgements (accepted/replay/conflict), improving auditability, traceability, and operational support for downstream accounting processing.

---

## 2. Story Intent

### As a / I want / So that
- **As a** platform engineer or accounting integration operator,
- **I want** a Moqui UI to submit a canonical accounting event envelope to the ingestion sync API and view the acknowledgement/result,
- **So that** I can validate integration behavior end-to-end (validation, auth failures, idempotent replay, conflict detection) without needing external tooling.

### In-scope
- Moqui screen(s) to:
  - enter a canonical envelope (specVersion, eventId optional for sync path, eventType, sourceModule, eventTimestamp, schemaVersion, payload, correlationId optional)
  - submit to sync ingestion endpoint
  - display acknowledgement fields (`eventId`, `status`, `receivedAt`) and HTTP outcome semantics (202/200/409/400/422/503/403)
- Validation on the UI aligned to backend contract (required fields, UUIDv7 format where provided)
- Error handling and user-facing messages mapped from stable backend error codes
- Basic ‚Äúreplay‚Äù support (re-submit same eventId/payload) and ‚Äúconflict‚Äù testing (same eventId different payload)

### Out-of-scope
- Implementing broker/Kafka/SQS ingestion configuration and operations (backend/infrastructure)
- Downstream mapping/posting screens (journal entries, ledger posting, etc.)
- Defining or validating eventType-specific payload schema beyond treating `payload` as JSON blob (except basic JSON validity)

---

## 3. Actors & Stakeholders
- **Integration Operator / Platform Engineer (human user):** uses UI to submit test events and inspect responses.
- **Producing Module (service principal):** ultimate actor for real ingestion; UI is a diagnostic/support tool.
- **Accounting Ops / Finance:** benefits from predictable ingestion statuses and conflict visibility (via acknowledgement in UI).
- **Security/Admin:** ensures only authorized users can access ingestion UI and that calls are made with proper scopes.

---

## 4. Preconditions & Dependencies
- Moqui is configured to reach the Accounting Ingestion backend base URL (environment-specific).
- Sync ingestion endpoint exists and follows backend story contract:
  - New accept ‚Üí `202 Accepted`
  - Replay ‚Üí `200 OK`
  - Conflict ‚Üí `409 Conflict` with `INGESTION_DUPLICATE_CONFLICT`
  - Validation failure ‚Üí `400` `INGESTION_VALIDATION_FAILED`
  - Unsupported schema ‚Üí `422` `INGESTION_SCHEMA_UNSUPPORTED`
  - Dependency failure ‚Üí `503` `INGESTION_DEPENDENCY_FAILURE`
  - Source mismatch ‚Üí `403` `INGESTION_FORBIDDEN_SOURCE_MISMATCH`
- Authentication mechanism from Moqui to backend is available (token forwarding or service credential) and must include scope `SCOPE_accounting:events:ingest`. (If not available, see Open Questions‚Äînone required if already standardized in this repo.)

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main menu: **Accounting ‚Üí Integrations ‚Üí Event Ingestion (Sync)**
- Direct route: `/accounting/integration/event-ingestion`

### Screens to create/modify
- **New screen:** `apps/<app>/screens/accounting/integration/EventIngestion.xml` (name/location per repo conventions)
  - Subscreen(s) optional:
    - `EventIngestionSubmit.xml` (form)
    - `EventIngestionResult.xml` (result panel)

### Navigation context
- Screen is under accounting domain navigation.
- Include breadcrumb: Accounting ‚Üí Integrations ‚Üí Event Ingestion (Sync).

### User workflows
**Happy path (new event accepted):**
1. User opens Event Ingestion screen.
2. User fills envelope fields; payload provided as JSON text.
3. Clicks **Submit**.
4. UI calls ingestion endpoint and shows acknowledgement with status and receivedAt.

**Alternate path (replay):**
1. User submits same `eventId` with identical payload again.
2. UI shows replay acknowledgement (HTTP 200), clearly indicating replay vs accepted/new.

**Alternate path (conflict):**
1. User submits an event with an `eventId`.
2. User modifies payload but keeps same `eventId`, submits again.
3. UI shows conflict (HTTP 409) with error code and guidance.

**Failure paths:**
- Missing/invalid fields ‚Üí inline validation and/or server error display.
- Auth/source mismatch ‚Üí show forbidden with code.
- Dependency failure ‚Üí show retry guidance.

---

## 6. Functional Behavior

### Triggers
- User clicks **Submit** on the ingestion form.

### UI actions
- Validate required fields locally:
  - required: `specVersion`, `eventType`, `sourceModule`, `eventTimestamp`, `schemaVersion`, `payload`
  - `eventId` optional (sync exception); if provided, validate UUID format and require UUIDv7 pattern if feasible
  - `payload` must be valid JSON
- On submit:
  - Disable submit button and show in-progress state
  - POST envelope to backend ingestion endpoint
  - Render response:
    - acknowledgement panel for 200/202
    - error panel for 4xx/5xx with code/message details

### State changes (frontend)
- Maintain client-side ‚Äúlast submission‚Äù model:
  - lastRequest (sanitized), lastResponse, lastHttpStatus, lastErrorCode
- No local persistence required unless Moqui conventions already include request history; do not add new entities unless specified.

### Service interactions
- Moqui service call to an internal service that performs outbound HTTP:
  - `accounting.integration.EventIngestion.submit` (service name suggestion; implement per repo naming conventions)
- Service performs POST to backend URL and returns normalized response map to screen.

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- **Required fields** must be present before submission (client-side) and re-validated server-side.
- **eventId rules:**
  - If user provides `eventId`, UI validates it is a UUID and (where possible) UUIDv7.
  - If not provided, UI allows submission (sync path only); server may generate eventId.
- **payload** must be syntactically valid JSON. UI does not enforce eventType-specific schema.
- **correlationId** optional; if provided, must be non-empty string.

### Enable/disable rules
- Submit disabled while request in flight.
- ‚ÄúGenerate eventId‚Äù helper button (UI convenience) may generate a UUID, but **must not claim UUIDv7 unless library guarantees it**. If UUIDv7 generation isn‚Äôt available, omit this helper (safe-defaults denylist includes identifiers). (See Applied Safe Defaults: none.)

### Visibility rules
- Acknowledgement panel visible after any server response.
- Error details panel visible only on non-2xx responses.

### Error messaging expectations
- Display stable backend error code prominently when provided:
  - `INGESTION_DUPLICATE_CONFLICT`
  - `INGESTION_FORBIDDEN_SOURCE_MISMATCH`
  - `INGESTION_VALIDATION_FAILED`
  - `INGESTION_SCHEMA_UNSUPPORTED`
  - `INGESTION_DEPENDENCY_FAILURE`
- Provide user guidance:
  - 409: ‚ÄúSame eventId with different payload. Use a new eventId or revert payload to original.‚Äù
  - 403: ‚ÄúAuthenticated producer does not match sourceModule.‚Äù
  - 422: ‚ÄúschemaVersion not supported for this eventType.‚Äù
  - 503: ‚ÄúTemporary dependency failure. Retry later.‚Äù

---

## 8. Data Requirements

### Entities involved
- **No new Moqui entities required** for MVP UI submission and result viewing.
- Backend-owned immutable storage for raw events is assumed (out-of-scope for frontend).

### Fields (type, required, defaults)
Form input model (frontend/Moqui context):
- `specVersion` (string, required) ‚Äî example: `durion.accounting.ingestion.v1`
- `eventId` (string UUID, optional for sync)
- `eventType` (string, required)
- `sourceModule` (string, required)
- `eventTimestamp` (datetime string, required; ISO-8601)
- `schemaVersion` (string, required; SemVer per backend)
- `correlationId` (string, optional)
- `payload` (JSON object, required; entered as text area, parsed to object before send)

Response/ack model:
- `eventId` (string UUID)
- `status` (string; includes accepted/new vs replay statuses as returned by backend)
- `receivedAt` (datetime string)
- Optional server-provided fields (if present): `payloadHash`, `message`, etc. (display in raw JSON viewer)

### Read-only vs editable by state/role
- All request fields editable prior to submit.
- After response, fields remain editable to allow replay/conflict testing; acknowledgement is read-only.

### Derived/calculated fields
- Client parses `payload` text into JSON object for request.
- Client may compute and show a local ‚Äúpayload validity‚Äù indicator (valid/invalid JSON).

---

## 9. Service Contracts (Frontend Perspective)

### Load/view calls
- None required for initial screen load (static form).
- Optional: load default `specVersion` value from configuration (Moqui conf) rather than hardcoded.

### Create/update calls
- **POST** to backend ingestion endpoint (exact URL path must match backend deployment; use config):
  - Request body: canonical envelope:
    - `specVersion` (string)
    - `eventId` (string UUIDv7, optional)
    - `eventType` (string)
    - `sourceModule` (string)
    - `eventTimestamp` (string datetime)
    - `schemaVersion` (string)
    - `payload` (object)
    - `correlationId` (string, optional)

### Submit/transition calls
- Single submit action mapped to Moqui service:
  - Input: fields above
  - Output (normalized):
    - `httpStatus` (int)
    - `ack` (map: eventId/status/receivedAt/‚Ä¶)
    - `error` (map: code/message/details)

### Error handling expectations
- Map HTTP statuses:
  - 202/200: show acknowledgement, mark outcome = success
  - 409: show error code `INGESTION_DUPLICATE_CONFLICT` and conflict guidance
  - 400: show `INGESTION_VALIDATION_FAILED` + field hints if provided
  - 422: show `INGESTION_SCHEMA_UNSUPPORTED`
  - 403: show `INGESTION_FORBIDDEN_SOURCE_MISMATCH`
  - 503: show `INGESTION_DEPENDENCY_FAILURE` + retry guidance
- Network/timeout: show ‚ÄúUnable to reach ingestion service‚Äù with retry guidance; do not expose tokens.

---

## 10. State Model & Transitions

### Allowed states (frontend view)
This UI is stateless beyond last submission; for display purposes classify last outcome as:
- `Idle`
- `Submitting`
- `Accepted` (202)
- `Replay` (200)
- `Conflict` (409)
- `ValidationFailed` (400)
- `SchemaUnsupported` (422)
- `Forbidden` (403)
- `DependencyFailure` (503)
- `NetworkError` (no HTTP response)

### Role-based transitions
- Only authorized UI users may access screen (permission required; see Open Questions if permissions are not standardized).
- All authorized users can submit; no additional transitions.

### UI behavior per state
- Submitting: disable submit, show spinner/progress
- Accepted/Replay: show acknowledgement panel (success styling) and raw response
- Any error: show error panel and raw error response

---

## 11. Alternate / Error Flows

### Validation failures
- Client-side:
  - Missing required fields ‚Üí prevent submit, show inline messages
  - Invalid JSON payload ‚Üí prevent submit, show ‚ÄúPayload must be valid JSON‚Äù
- Server-side (400):
  - Display backend error code and message; keep user input for correction

### Concurrency conflicts
- Not applicable (single submission). If backend returns optimistic-lock style errors, display raw error and treat as unknown failure.

### Unauthorized access
- If user lacks permission to view screen: show access denied (Moqui standard) and do not render form.
- If backend returns 403: show forbidden with `INGESTION_FORBIDDEN_SOURCE_MISMATCH`.

### Empty states
- On first load: blank form with optional prefilled `specVersion`.
- If no response yet: hide acknowledgement/error panels.

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: Submit new valid event returns 202 acknowledgement
Given I am an authorized user for Accounting Event Ingestion screen  
And I enter a valid canonical envelope with required fields and valid JSON payload  
When I submit the event  
Then the system sends the envelope to the ingestion sync endpoint  
And I see an acknowledgement with eventId, status, and receivedAt  
And the HTTP outcome is displayed as Accepted (202)

### Scenario 2: Submit replay returns 200 and shows replay outcome
Given I previously submitted an event with eventId "E1" and payload "P1" successfully  
When I submit the same eventId "E1" with the same payload "P1" again  
Then the system shows a successful acknowledgement response  
And the HTTP outcome is OK (200)  
And the UI indicates the result is a replay (idempotent)

### Scenario 3: Submit conflict returns 409 and displays stable error code
Given an event with eventId "E1" and payload "P1" was previously accepted  
When I submit eventId "E1" with a different payload "P2"  
Then the system shows a failure result  
And the HTTP outcome is Conflict (409)  
And the UI displays error code "INGESTION_DUPLICATE_CONFLICT"  
And the UI guidance instructs to change eventId or revert payload

### Scenario 4: Missing required fields are blocked client-side
Given I am on the Event Ingestion screen  
When I leave specVersion empty or payload is invalid JSON  
And I click Submit  
Then the UI prevents submission  
And I see inline validation messages for the missing/invalid fields

### Scenario 5: Unsupported schema returns 422 and is shown clearly
Given I enter a valid envelope with schemaVersion not supported by the backend for the chosen eventType  
When I submit the event  
Then the UI shows a failure result  
And the HTTP outcome is Unprocessable Entity (422)  
And the UI displays error code "INGESTION_SCHEMA_UNSUPPORTED"

### Scenario 6: Backend dependency failure returns 503 with retry guidance
Given the ingestion service storage dependency is unavailable  
When I submit a valid envelope  
Then the UI shows a failure result  
And the HTTP outcome is Service Unavailable (503)  
And the UI displays error code "INGESTION_DEPENDENCY_FAILURE"  
And the UI suggests retrying later

---

## 13. Audit & Observability

### User-visible audit data
- Display `eventId`, `eventType`, `sourceModule`, `schemaVersion`, and `correlationId` (if provided) in the result summary for traceability.
- Display `receivedAt` from acknowledgement.

### Status history
- In-session only: show last outcome and timestamp of submission attempt (client time) plus server `receivedAt`.

### Traceability expectations
- Moqui logs (frontend service layer) should log structured fields:
  - `eventId` (if provided or returned)
  - `eventType`, `sourceModule`, `schemaVersion`
  - `httpStatus`, `errorCode` (if any)
- Do not log full payload by default (may be sensitive/large); if needed, log payload hash only when returned by backend.

---

## 14. Non-Functional UI Requirements

- **Performance:** submission UI should respond immediately; network request timeout should be configurable; show progress within 250ms of submit action.
- **Accessibility:** all form controls labeled; error messages associated to fields; keyboard navigable submit.
- **Responsiveness:** usable on tablet width; payload editor scrolls.
- **i18n/timezone/currency:** display timestamps in user locale but preserve raw ISO string in a ‚Äúraw response‚Äù viewer; no currency handling needed.

---

## 15. Applied Safe Defaults
- none

---

## 16. Open Questions
- none

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Events: Receive Events via Queue and/or Service Endpoint  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/207  
Labels: frontend, story-implementation, general

## Frontend Implementation for Story

**Original Story**: [STORY] Events: Receive Events via Queue and/or Service Endpoint

**Domain**: general

### Story Description

/kiro  
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Ingest Accounting Events (Cross-Module)

## Story
Events: Receive Events via Queue and/or Service Endpoint

## Acceptance Criteria
- [ ] Provide a synchronous ingestion API endpoint for producing modules
- [ ] Provide an async ingestion channel (queue/topic) where configured
- [ ] Received events are persisted immutably before mapping/posting
- [ ] System returns acknowledgement with eventId and initial status

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #208: [FRONTEND] [STORY] Events: Define Canonical Accounting Event Envelope  
File: ./scripts/story-work/frontend/208/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

STOP: Clarification required before finalization

---

# 1. Story Header

## Title
[FRONTEND] [STORY] Accounting Events: View & Validate Canonical Accounting Event Envelope (Contract UI)

## Primary Persona
- **Domain Architect / Backend Engineer (Accounting)** maintaining the canonical event envelope contract and verifying conformance.

## Business Value
Provide an implementation-ready, Moqui-native UI surface to **view and validate** the Canonical Accounting Event Envelope contract details in the system so producers/consumers can align on required fields, data types, and traceability requirements without ambiguity‚Äîreducing integration defects and audit gaps.

---

# 2. Story Intent

## As a / I want / So that
- **As a** Domain Architect (Accounting),
- **I want** a frontend screen to view the Canonical Accounting Event Envelope specification (fields, constraints, examples, schema version),
- **So that** cross-module teams can reliably implement and validate event payloads against a single, discoverable contract.

## In-scope
- Moqui screen(s) that present the canonical envelope requirements:
  - Required envelope fields and meaning
  - Expected types/format constraints
  - Line and tax array structures
  - Traceability context examples (invoiceId, workOrderId, etc.)
  - Schema version string and governance note
- Optional ‚Äúvalidate payload‚Äù utility UI that accepts a JSON payload and runs validation against the schema **if** a backend validation service exists.

## Out-of-scope
- Defining the schema itself (contract definition is a backend/repo artifact)
- Publishing schema to external Git repo or schema registry (governance process)
- Producing or ingesting events from other modules
- Any debit/credit posting mappings, GL account logic, tax policy definition

---

# 3. Actors & Stakeholders
- **Accounting Domain Architect**: owns contract semantics and required fields.
- **Producer team engineers** (Order/Billing/Workexec/Inventory): need contract clarity for producing events.
- **Accounting service engineers**: need contract clarity for consumption/validation.
- **Auditors / Compliance (read-only)**: need traceability expectations documented and discoverable.

---

# 4. Preconditions & Dependencies
- Moqui frontend module is running and can render new screens under an Accounting navigation context.
- A source of truth for the canonical envelope exists (one of):
  1) backend endpoint exposing schema/version + field definitions, or  
  2) schema file accessible to frontend build/runtime, or  
  3) stored schema record in Moqui entities.
- Authentication/authorization exists for accessing Accounting configuration/contract screens.

**Dependency (blocking):** backend contract for retrieving schema/spec and (optional) validating payloads is not defined in provided inputs.

---

# 5. UX Summary (Moqui-Oriented)

## Entry points
- Main navigation: **Accounting ‚Üí Integrations ‚Üí Event Contracts ‚Üí Canonical Accounting Event Envelope**
- Direct route: `/accounting/events/contract` (proposed; final route depends on existing screen tree)

## Screens to create/modify
- **New Screen:** `component://durion/screen/accounting/events/Contract.xml` (name illustrative)
  - Subscreens:
    - `Summary` (version, purpose, required envelope keys)
    - `EnvelopeFields` (table of fields)
    - `LineItemSchema` (lines[] structure)
    - `TaxItemSchema` (tax[] structure)
    - `TraceabilityContext` (common keys)
    - `ValidatePayload` (optional utility)
- **Modify Navigation Screen** to add menu link (where Accounting nav is defined).

## Navigation context
- Within Accounting domain screens; breadcrumb shows Accounting > Integrations > Event Contracts > Canonical Envelope.

## User workflows
### Happy path: view contract
1) User opens Canonical Envelope screen.
2) Screen loads schema metadata (schemaVersion, lastUpdated, source link).
3) User reviews required fields and nested structures.
4) User copies example JSON for producers.

### Alternate path: validate a payload (if supported)
1) User opens Validate tab.
2) Pastes JSON payload.
3) Submits.
4) UI shows validation result: pass/fail with error list (field paths + codes).

---

# 6. Functional Behavior

## Triggers
- Screen load triggers retrieval of contract/spec data.
- ‚ÄúValidate‚Äù action triggers backend validation (if provided).

## UI actions
- View schema version and required/optional fields.
- Expand/collapse sections for `lines[]`, `tax[]`, and `traceabilityContext`.
- Copy-to-clipboard for example payloads (UI ergonomics).
- Validate JSON payload (optional, gated by backend availability).

## State changes
- No domain state machine changes (read-only contract display).
- If validation utility exists, store only transient UI state (textarea content, last result). No persistence unless explicitly specified (not in scope).

## Service interactions
- `loadContractSpec` (required): fetch contract metadata + field definitions.
- `validateContractPayload` (optional): validate user-provided payload against schema.

---

# 7. Business Rules (Translated to UI Behavior)

## Validation
- When validating payload:
  - JSON must parse; otherwise show inline error ‚ÄúInvalid JSON‚Äù.
  - If backend returns schema validation errors, render them as a list with:
    - `errorCode`
    - `jsonPath` (e.g., `$.lines[0].totalAmount`)
    - human message
- Display must include the required envelope fields (from story inputs):
  - `eventId`, `eventType`, `sourceModule`, `sourceEntityRef`, `occurredAt`, `businessUnitId`, `currencyUomId`, `lines[]`, `tax[]`, `metadata`, `schemaVersion`
  - Traceability fields exist (e.g., `workOrderId`, `invoiceId`, `poId`, `receiptId`) ‚Äî shown under `traceabilityContext`.

## Enable/disable rules
- Validate button disabled until textarea contains non-empty content.
- Tabs/sections always available if spec loaded; show error state if spec load fails.

## Visibility rules
- Screen is visible only to authorized users (permission TBD ‚Üí Open Question).
- Validation utility tab visible only if backend supports validation endpoint (feature-flagged by service response or config).

## Error messaging expectations
- Load failure: show non-technical summary + correlation/requestId if provided.
- Unauthorized: show standard ‚ÄúNot authorized‚Äù screen and do not render spec content.

---

# 8. Data Requirements

## Entities involved
**Unclear** from provided inputs. Options:
- None (spec served by backend as static JSON)
- `AccountingEventSchema` entity (versioned schema records)
- `Artifact`/`Content` entity storing schema JSON and metadata

This must be confirmed (Open Questions).

## Fields (type, required, defaults)
For display purposes, the UI must support representing at least:

### Contract metadata
- `schemaVersion` (string, SemVer) ‚Äî required
- `schemaFormat` (string, e.g., `json-schema-2020-12`) ‚Äî optional
- `publishedAt` (datetime, UTC) ‚Äî optional
- `sourceUri` (string URL) ‚Äî optional but recommended

### Envelope field definitions (display model)
- `fieldName` (string) ‚Äî required
- `required` (boolean) ‚Äî required
- `type` (string) ‚Äî required
- `format` (string) ‚Äî optional
- `description` (string) ‚Äî required
- `example` (string/number/object) ‚Äî optional

### LineItem structure (minimum per input + backend ref)
- `lineType` (enum: `PARTS`, `LABOR`, `FEES`, `DISCOUNT`) ‚Äî required
- `description` (string) ‚Äî optional/required unclear
- `quantity` (decimal) ‚Äî required
- `unitPrice` (integer, smallest currency unit) ‚Äî required
- `totalAmount` (integer, smallest currency unit) ‚Äî required (discounts negative)

### TaxItem structure
- `taxType` (string) ‚Äî required
- `taxRate` (decimal) ‚Äî optional/required unclear
- `taxableAmount` (integer) ‚Äî required
- `taxAmount` (integer) ‚Äî required

### Traceability context
- Key/value object with optional keys like `workOrderId`, `invoiceId`, `poId`, `receiptId` (strings)

## Read-only vs editable by state/role
- Entire screen is read-only.
- Validation input is editable by user; not persisted.

## Derived/calculated fields
- None. (If backend returns ‚Äúrequired fields count‚Äù etc., UI may show derived counts as presentation only.)

---

# 9. Service Contracts (Frontend Perspective)

> Moqui screens will call services via standard `service-call` / REST as per project conventions (exact mechanism depends on repo patterns; not provided here).

## Load/view calls (required)
### `AccountingEventContract.getCanonicalEnvelopeSpec` (name TBD)
**Request**
- none, or optional `schemaVersion` to view a specific version

**Response (minimum)**
- `schemaVersion`
- `fields[]` with the envelope required fields listed above
- `lineItemSchema`
- `taxItemSchema`
- `traceabilityExamples`
- optional `sourceUri`

**Error handling**
- 401/403: render unauthorized
- 404: show ‚ÄúContract not found‚Äù
- 5xx: show load failure with retry

## Create/update calls
- none (out-of-scope)

## Submit/transition calls (optional)
### `AccountingEventContract.validatePayload`
**Request**
- `payloadJson` (string) OR parsed object (TBD)
- optional `schemaVersion`

**Response**
- `valid` (boolean)
- `errors[]` where each error has: `errorCode`, `jsonPath`, `message`

**Error handling**
- 400 invalid JSON or schema mismatch ‚Üí render errors inline
- 413 payload too large (if enforced) ‚Üí show ‚ÄúPayload too large‚Äù

**Blocking:** these services/endpoints are not defined in provided inputs.

---

# 10. State Model & Transitions
- No business entity state transitions in this story.
- UI states:
  - `loading`
  - `loaded`
  - `loadFailed`
  - `unauthorized`
  - (optional) `validationIdle`, `validationRunning`, `validationFailed`, `validationPassed`

---

# 11. Alternate / Error Flows

## Validation failures
- Invalid JSON in textarea ‚Üí client-side parse error; do not call backend.
- Backend validation returns errors ‚Üí list them; keep payload in textarea for correction.

## Concurrency conflicts
- Not applicable (read-only).

## Unauthorized access
- If user lacks permission, show standard unauthorized screen; no partial spec display.

## Empty states
- If `fields[]` is empty (unexpected), show ‚ÄúNo fields defined for this contract‚Äù and prompt to check backend publication.

---

# 12. Acceptance Criteria

### Scenario 1: View canonical envelope contract successfully
**Given** an authorized user navigates to Accounting ‚Üí Integrations ‚Üí Event Contracts ‚Üí Canonical Accounting Event Envelope  
**When** the screen loads  
**Then** the UI displays the contract `schemaVersion`  
**And** lists the required envelope fields: `eventId`, `eventType`, `sourceModule`, `sourceEntityRef`, `occurredAt`, `businessUnitId`, `currencyUomId`, `lines`, `tax`, `metadata`, `schemaVersion`  
**And** shows the nested structure requirements for `lines[]` and `tax[]`  
**And** shows traceability context examples including at least `workOrderId` and `invoiceId`.

### Scenario 2: Contract load failure
**Given** an authorized user navigates to the Canonical Envelope screen  
**When** the contract spec service returns a server error  
**Then** the UI shows a load failure message  
**And** provides a retry action  
**And** does not display partial or stale contract data.

### Scenario 3: Unauthorized access
**Given** a user without required permission attempts to access the Canonical Envelope screen  
**When** the screen loads  
**Then** the UI renders an unauthorized/access-denied state  
**And** does not reveal the contract field list.

### Scenario 4 (optional): Validate a conforming payload
**Given** the validation capability is enabled  
**And** the user opens the Validate tab  
**And** pastes a JSON payload containing all required envelope fields including non-empty `lines[]` and `tax[]` arrays  
**When** the user clicks Validate  
**Then** the UI shows a ‚Äúvalid‚Äù result  
**And** no validation errors are displayed.

### Scenario 5 (optional): Validate a non-conforming payload
**Given** the validation capability is enabled  
**And** the user opens the Validate tab  
**And** pastes a JSON payload missing `eventId`  
**When** the user clicks Validate  
**Then** the UI shows an ‚Äúinvalid‚Äù result  
**And** displays an error with a path indicating the missing field (e.g., `$.eventId`) and a stable `errorCode`.

### Scenario 6: Client-side invalid JSON
**Given** the user opens the Validate tab  
**When** the user enters malformed JSON and clicks Validate  
**Then** the UI shows ‚ÄúInvalid JSON‚Äù  
**And** does not call the backend validation service.

---

# 13. Audit & Observability

## User-visible audit data
- Display `schemaVersion` and (if provided) `publishedAt` and `sourceUri` for traceability.

## Status history
- Not applicable unless backend provides historical versions. If versions exist, UI should allow selecting version (Open Question).

## Traceability expectations
- All service calls should log/trace with identifiers:
  - `schemaVersion` (if part of request)
  - request/correlation id (from standard headers)
- UI should surface correlation id on error if provided in response headers/body.

---

# 14. Non-Functional UI Requirements
- **Performance:** Contract screen should load within 2s under normal conditions (excluding backend outages).
- **Accessibility:** Keyboard navigable tabs/sections; sufficient contrast; aria labels for copy buttons.
- **Responsiveness:** Works on tablet width (POS admin usage).
- **i18n/timezone/currency:** Display `occurredAt` requirement explicitly as UTC; no currency formatting assumptions beyond ‚Äúsmallest unit integer‚Äù note (do not calculate).

---

# 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide explicit empty-state messaging when the contract spec returns no fields; qualifies as safe UI ergonomics; impacts UX Summary, Error Flows.
- SD-UX-RETRY: Provide retry button on load failure; qualifies as safe error recovery; impacts Error Flows, Acceptance Criteria.
- SD-OBS-CORRELATION-ID: Display correlation/request id in error state when provided; qualifies as safe observability boilerplate; impacts Audit & Observability, Error Flows.

---

# 16. Open Questions
1) **Backend source of truth:** Where will the frontend retrieve the canonical envelope spec from (endpoint vs stored entity vs bundled schema file)? Provide the exact contract (URL/service name, request/response).  
2) **Permissions:** What permission(s)/role(s) gate access to the contract screen (e.g., `accounting.contract.view`)?  
3) **Schema versions:** Should the UI support selecting historical schema versions, or only show the latest? If versions exist, what is the list endpoint/contract?  
4) **Validation utility:** Is a backend payload validation endpoint planned/available? If yes, provide contract and error code taxonomy.  
5) **Field constraints:** Confirm required formats: is `eventId` UUIDv7 (per accounting checklist) vs UUIDv4 (backend reference text shows v4 example); and are monetary values always integers in smallest unit?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Events: Define Canonical Accounting Event Envelope  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/208  
Labels: frontend, story-implementation, order

## Frontend Implementation for Story

**Original Story**: [STORY] Events: Define Canonical Accounting Event Envelope

**Domain**: order

### Story Description

/kiro  
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Ingest Accounting Events (Cross-Module)

## Story
Events: Define Canonical Accounting Event Envelope

## Acceptance Criteria
- [ ] Event envelope includes eventId, eventType, sourceModule, sourceEntityRef, occurredAt, businessUnitId, currencyUomId, lines[], tax[], metadata, schemaVersion
- [ ] Supports multi-line totals (parts/labor/fees/discount/tax)
- [ ] Schema is versioned and published as a contract
- [ ] Traceability fields exist (workorderId, invoiceId, poId, receiptId, etc. where applicable)

### Frontend Requirements
- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack
- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---  
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #210: [FRONTEND] [STORY] Invoicing: Support Authorized Invoice Adjustments  
File: ./scripts/story-work/frontend/210/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

STOP: Clarification required before finalization

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Invoicing: Support Authorized Invoice Adjustments (Draft invoices)

### Primary Persona
Back Office Manager

### Business Value
Enable authorized corrections and goodwill adjustments on **Draft** invoices while preserving **accounting correctness, auditability, and traceability**, preventing negative invoice totals and ensuring downstream accounting events are produced.

---

## 2. Story Intent

### As a / I want / So that
- **As a** Back Office Manager  
- **I want** to adjust a **Draft** invoice (edit invoice line items and/or apply an invoice-level discount) with required reason capture  
- **So that** invoice totals/taxes are recalculated correctly, the change is fully audited, and the accounting system can emit the appropriate event (`InvoiceAdjusted` or `CreditMemoIssued`).

### In-scope
- Frontend UI to initiate and submit an adjustment for an invoice that is currently `Draft`
- Capturing **reason code** and **justification** when required by configuration
- Displaying before/after totals impact prior to submit (where supported by backend)
- Handling backend rejections: unauthorized, not-draft, negative-total-requires-credit-memo, missing reason code/justification, concurrency conflict
- Displaying adjustment audit history relevant to adjustments (at least the latest adjustment outcome; ideally the list)

### Out-of-scope
- Creating/issuing a **Credit Memo** (separate story unless backend provides a concrete endpoint and UI is requested explicitly)
- Defining tax policy, GL account mappings, revenue/tax/AR posting semantics
- Editing **Issued** invoices
- Admin management of Reason Codes and configuration flags (assumed existing)

---

## 3. Actors & Stakeholders
- **Back Office Manager**: performs authorized adjustments and provides reason/justification
- **Accounting domain services**: system of record for invoice financial state; recalculates totals; writes audit event; emits `InvoiceAdjusted` / `CreditMemoIssued`
- **Auditor/Compliance**: consumes immutable audit trail (who/when/what/why)
- **Support/Operations**: needs actionable error feedback and trace identifiers

---

## 4. Preconditions & Dependencies
- Invoice exists and is retrievable in the frontend by `invoiceId`
- Invoice is in **status = `Draft`** at time of submit (must be revalidated server-side)
- User is authenticated
- User has permission **`invoice.adjust`** (or equivalent permission enforced by backend)
- Reason codes exist for invoice adjustments, and backend can validate ‚Äúactive‚Äù status
- Backend endpoints/services exist for:
  - Loading invoice details (including status, line items, totals)
  - Submitting an adjustment command (atomic update + recalculation + audit + event emission)
  - (Optional but preferred) loading audit events/history for the invoice

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- From Invoice view screen: action ‚ÄúAdjust Invoice‚Äù visible only when invoice is `Draft` and user is authorized.

### Screens to create/modify
1. **Modify**: `apps/pos/screen/invoice/InvoiceDetail.xml` (name illustrative)
   - Add action to open adjustment flow
   - Add read-only ‚ÄúAdjusted‚Äù indicator (from `isAdjusted`)
   - Add section to view adjustment audit events (read-only list)
2. **Create**: `apps/pos/screen/invoice/InvoiceAdjust.xml`
   - Contains editable invoice content (line items + invoice-level discount)
   - Reason capture form
   - Totals preview section
   - Submit / Cancel transitions

> Note: Exact screen paths must match repo conventions; implementer should align with existing screen hierarchy in `durion-moqui-frontend`.

### Navigation context
- `InvoiceDetail` ‚Üí `InvoiceAdjust` (pass `invoiceId`)
- On success: return to `InvoiceDetail` (same `invoiceId`) and show confirmation plus updated totals/audit summary.

### User workflows
**Happy path**
1. Manager opens Draft invoice
2. Clicks ‚ÄúAdjust Invoice‚Äù
3. Edits line item(s) and/or invoice-level discount
4. Selects reason code; enters justification if required
5. Submits
6. Backend recalculates totals, persists changes, writes audit event, emits `InvoiceAdjusted`
7. UI returns to invoice detail with updated totals and audit entry visible

**Alternate paths**
- User not authorized: ‚ÄúAdjust Invoice‚Äù not shown; direct navigation shows ‚ÄúNot Authorized‚Äù
- Invoice becomes non-draft before submit: show conflict and prompt reload; disable submit until refreshed
- Backend rejects due to negative total: show explicit error ‚ÄúRequires Credit Memo‚Äù and keep user edits intact (no local commit)
- Missing reason/justification when required: inline validation + backend error mapping

---

## 6. Functional Behavior

### Triggers
- User clicks ‚ÄúAdjust Invoice‚Äù from invoice detail
- User submits adjustment form

### UI actions
- Edit invoice line items (supported fields are limited to what backend allows; see Open Questions)
- Edit invoice-level discount (if supported)
- Choose `reasonCode`
- Enter `justification` (conditionally required)
- Submit adjustment

### State changes (frontend-observable)
- Invoice `isAdjusted` becomes `true` after first successful adjustment
- Invoice totals update after recalculation
- An audit event entry appears in adjustment history

### Service interactions
- Load invoice detail on entry to both screens
- (Optional) request ‚Äúrecalculate preview‚Äù after edits (if backend provides a preview service)
- Submit adjustment command with an idempotency anchor (if required by backend contract)

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- **Draft-only**: If invoice status != `Draft`, the adjustment UI must be read-only and show message: ‚ÄúInvoice is not Draft and cannot be directly adjusted.‚Äù
- **Authorization**: If user lacks permission, block access and show unauthorized.
- **Reason required when configured**:
  - If backend indicates reason required, enforce selection of a valid reason code before enabling submit
  - If justification required, enforce non-empty free text before enabling submit
- **Negative totals are not allowed**:
  - On backend error `INVOICE_TOTAL_NEGATIVE_REQUIRES_CREDIT_MEMO`, show a blocking banner explaining a credit memo is required; do not apply changes locally

### Enable/disable rules
- Disable ‚ÄúSubmit Adjustment‚Äù while:
  - invoice not loaded
  - invoice status not `Draft`
  - required reason/justification missing
  - request in-flight
- Disable editing while submit is in-flight

### Visibility rules
- ‚ÄúAdjust Invoice‚Äù action visible only when:
  - invoice status == `Draft`
  - user authorized (`invoice.adjust`)
- Show ‚ÄúAdjusted‚Äù badge/flag if `isAdjusted == true`
- Show audit history section when available

### Error messaging expectations
- Unauthorized ‚Üí ‚ÄúYou do not have permission to adjust invoices.‚Äù
- Not Draft ‚Üí ‚ÄúInvoice is no longer Draft. Reload to see latest status.‚Äù
- Concurrency/optimistic lock conflict ‚Üí ‚ÄúInvoice changed since you opened it. Reload required.‚Äù
- Negative total requires credit memo ‚Üí explicit + actionable (no silent failure)
- Invalid/missing reason code ‚Üí inline + show backend-provided error code/message

---

## 8. Data Requirements

### Entities involved (frontend perspective)
- `Invoice`
- `InvoiceItem`
- `InvoiceAuditEvent` (or equivalent audit entity/view)
- `ReasonCode`

### Fields
**Invoice (read)**
- `invoiceId` (string/UUID) required
- `status` (enum) required; includes `Draft` at minimum
- `isAdjusted` (boolean) default false
- Totals (all currency decimals; scale per currency):
  - `subtotal`
  - `taxTotal`
  - `feeTotal` (if applicable)
  - `grandTotal`
- Currency:
  - `currencyUomId` (string) required
- (Optional for concurrency)
  - `version` / `lastUpdatedStamp` required if backend uses optimistic locking

**InvoiceItem (edit where allowed)**
- `invoiceItemId` (string/UUID) required
- `description` (string) read-only unless backend allows edits (Open Question)
- `quantity` (decimal) editable? (Open Question)
- `unitPrice` (decimal) editable? (Open Question)
- `lineDiscount` (decimal or percent) editable? (Open Question)
- `taxCode`/taxability fields are **not** assumed editable (denylist: tax policy)

**Adjustment command fields (write)**
- `invoiceId` required
- `adjustmentType` (string/enum) optional (Open Question: required?)
- `reasonCode` (string) conditionally required
- `justification` (string/text) conditionally required
- Edited line items and/or invoice-level discount payload (exact shape Open Question)
- `idempotencyKey` / `adjustmentId` (string/UUID) (Open Question: frontend responsibility?)

**AuditEvent (read)**
- `auditEventId`
- `invoiceId`
- `adjustedBy` (userId)
- `adjustedAt` (timestamp)
- `reasonCode`
- `justification` (may be sensitive; show per permissions? Open Question)
- `beforeTotals` / `afterTotals` (structured)
- `changeDetails` (summary)

### Read-only vs editable by state/role
- If invoice status != `Draft`: everything read-only; adjustment screen should not allow submit.
- Only authorized users can edit; unauthorized can view only.

### Derived/calculated fields
- Totals are backend-calculated and must be displayed as authoritative.
- UI may compute a *client-side estimate* for immediate feedback only if explicitly allowed; otherwise rely on backend preview/service response.

---

## 9. Service Contracts (Frontend Perspective)

> Moqui implementation may use service calls via screen actions (`<service-call>`) or REST calls if the frontend is SPA; align with existing repo integration patterns.

### Load/view calls
1. **Get Invoice**
   - Input: `invoiceId`
   - Output: invoice header, items, status, totals, currency, `isAdjusted`, concurrency token
2. **Get Reason Codes (Invoice Adjustment)**
   - Input: `reasonCodeType = INVOICE_ADJUSTMENT` (or similar)
   - Output: list of active reason codes (code, label, active flag)
3. **Get Invoice Audit Events (optional but recommended)**
   - Input: `invoiceId`, filter `eventType=ADJUSTMENT` (if available)
   - Output: list ordered by `adjustedAt desc`

### Create/update calls
1. **Submit Invoice Adjustment**
   - Input (minimum):
     - `invoiceId`
     - modified invoice content (items/discount)
     - `reasonCode` / `justification` if required
     - concurrency token (`version`/`lastUpdatedStamp`) if required
     - idempotency anchor if required by backend
   - Output:
     - updated invoice (status, totals, `isAdjusted`)
     - created audit event summary
     - emitted event reference (optional)

### Submit/transition calls
- None beyond ‚ÄúSubmit Adjustment‚Äù; invoice lifecycle transitions (e.g., issue) are out of scope.

### Error handling expectations (map to UI)
- `403` ‚Üí unauthorized screen/banner
- `409` conflict:
  - not-draft
  - optimistic lock conflict
- `422`/`400` validation:
  - missing reason/justification
  - `INVOICE_TOTAL_NEGATIVE_REQUIRES_CREDIT_MEMO`
- Error payload should include `errorCode` and `message`; if missing, show generic error and log correlationId

---

## 10. State Model & Transitions

### Allowed states (invoice)
- `Draft`
- Non-Draft states exist (e.g., `Issued`) but are not enumerated here; behavior is conditional: ‚Äúnot Draft‚Äù is blocked.

### Role-based transitions
- No invoice state transition is performed in this story.
- Role gating:
  - `invoice.adjust` required to submit adjustments

### UI behavior per state
- **Draft**: adjustment action available (if authorized)
- **Not Draft**: adjustment action hidden/disabled; direct nav to adjust shows read-only + guidance to use credit memo/reversal process

---

## 11. Alternate / Error Flows

### Validation failures
- Missing reason code when required:
  - show inline error on reason selector
  - keep user edits intact
- Missing justification when required:
  - show inline error on justification field

### Concurrency conflicts
- If backend indicates optimistic lock / stale version:
  - show banner ‚ÄúInvoice updated by another user; reload required‚Äù
  - provide ‚ÄúReload Invoice‚Äù action
  - do not auto-merge changes

### Unauthorized access
- If user hits adjust URL without permission:
  - show 403 page or in-screen banner
  - do not load editable controls

### Empty states
- No reason codes returned:
  - block submission
  - show ‚ÄúNo active adjustment reasons configured. Contact administrator.‚Äù
- Invoice has no line items:
  - still allow invoice-level discount adjustment only if backend supports; otherwise block submit with explanation (Open Question)

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: Authorized user adjusts a Draft invoice successfully
Given an invoice exists with status "Draft"  
And the current user has permission "invoice.adjust"  
And at least one valid active adjustment reason code exists  
When the user opens "Adjust Invoice" for that invoice  
And edits allowed invoice fields (line items and/or invoice-level discount)  
And selects a reason code  
And provides justification when required by configuration  
And submits the adjustment  
Then the system saves the adjustment and returns the updated invoice  
And the displayed totals reflect the backend recalculation (subtotal/tax/fees/grand total)  
And the invoice indicates it has been adjusted (`isAdjusted = true`)  
And an adjustment audit entry is visible with actor, timestamp, reason, and before/after totals.

### Scenario 2: Unauthorized user cannot adjust invoices
Given an invoice exists with status "Draft"  
And the current user does not have permission "invoice.adjust"  
When the user attempts to access the invoice adjustment screen or submit an adjustment  
Then the UI blocks the action  
And the backend response (if called) is handled as 403 Forbidden  
And the UI displays an authorization error message.

### Scenario 3: Invoice is no longer Draft at submit time
Given an invoice exists  
And the user opens the adjustment screen while it is "Draft"  
When the invoice status changes to a non-Draft state before submission  
And the user submits the adjustment  
Then the backend response is handled as a conflict (409 or equivalent)  
And the UI shows "Invoice is no longer Draft and cannot be directly adjusted"  
And the UI provides a reload action  
And no local success confirmation is shown.

### Scenario 4: Adjustment rejected because it would make total negative
Given an invoice exists with status "Draft"  
And the current user has permission "invoice.adjust"  
When the user submits an adjustment that would result in a grand total less than 0.00  
Then the backend response is handled as a validation/conflict error  
And the error code "INVOICE_TOTAL_NEGATIVE_REQUIRES_CREDIT_MEMO" is displayed (or mapped to a user-friendly message)  
And the invoice is not updated in the UI  
And the user‚Äôs entered changes remain visible for revision.

### Scenario 5: Reason code and justification enforcement
Given an invoice exists with status "Draft"  
And the system configuration requires a reason code  
And the system configuration requires justification text  
When the user attempts to submit without selecting a reason code or without justification  
Then the UI prevents submission and highlights the missing fields  
And if submitted anyway, backend validation errors are surfaced inline without losing edits.

### Scenario 6: Multiple adjustments do not corrupt totals (frontend verification)
Given an invoice exists with status "Draft"  
And the current user has permission "invoice.adjust"  
When the user performs an adjustment successfully  
And then performs a second adjustment successfully  
Then the invoice totals displayed match the backend totals after each adjustment  
And the audit history shows both adjustments in chronological order  
And the UI does not display duplicated or stale totals.

---

## 13. Audit & Observability

### User-visible audit data
- Display at minimum:
  - adjustedAt
  - adjustedBy
  - reasonCode
  - beforeTotals and afterTotals (subtotal/tax/fees/grand total)
  - justification (visibility may require permission clarification)

### Status history
- Not a state transition story, but must show:
  - invoice `isAdjusted` indicator
  - adjustment audit events list (immutable)

### Traceability expectations
- UI logs (frontend console/logger) should include:
  - `invoiceId`
  - `adjustmentId`/idempotency key if present
  - backend `correlationId` / `traceId` if returned
- No PII or sensitive justification text in logs unless workspace convention explicitly allows (assume ‚Äúno‚Äù)

---

## 14. Non-Functional UI Requirements

- **Performance**: invoice detail and adjustment screen load should render primary data within 2s on typical network; reason codes loaded asynchronously if needed.
- **Accessibility**: all form controls labeled; validation errors announced; keyboard navigable.
- **Responsiveness**: usable on tablet/desktop; line-item editing supports horizontal constraints.
- **i18n/timezone/currency**:
  - Display money with `currencyUomId` formatting
  - Display timestamps in user timezone
  - Do not assume currency = USD (backend story mentions $0.00 but UI must format per currency)

---

## 15. Applied Safe Defaults

- SD-UX-EMPTY-STATE: Show explicit empty-state messaging for missing reason codes and missing audit events; qualifies as safe because it does not change domain policy, only improves clarity. Impacted sections: UX Summary, Alternate / Error Flows.
- SD-ERR-MAP-HTTP: Standard mapping of HTTP 403/409/422 to UI banners/inline errors; qualifies as safe because it follows backend-implied semantics without inventing business rules. Impacted sections: Service Contracts, Alternate / Error Flows, Acceptance Criteria.
- SD-OBS-CORRELATION: Display/store backend correlationId/traceId in error details panel (non-PII) for support; qualifies as safe because it‚Äôs observability boilerplate and does not alter domain behavior. Impacted sections: Audit & Observability, Error Flows.

---

## 16. Open Questions

1. **Backend contract details (blocking):** What are the exact Moqui service names / REST endpoints and request/response schemas for:
   - load invoice (including concurrency token),
   - submit adjustment,
   - load reason codes,
   - load audit events?
2. **Editable fields (blocking):** Which invoice and invoice item fields are permitted to be changed in an ‚Äúadjustment‚Äù?
   - quantity, unitPrice, lineDiscount, description, taxCode? (tax fields likely not editable)
3. **Reason/justification configuration (blocking):** How does the frontend determine when `reasonCode` and/or `justification` is required?
   - returned flags on invoice? system parameter? reason code metadata?
4. **Idempotency anchor (blocking):** Must the frontend generate/provide an `adjustmentId`/idempotency key (`invoiceId + adjustmentVersion` mentioned), or is it entirely server-generated?
5. **Credit memo path UX (blocking):** When negative total is requested, should the UI:
   - only block with message ‚Äúrequires credit memo‚Äù (current story), or
   - offer a guided ‚Äúcreate credit memo‚Äù action/link (requires endpoint + separate permission)?
6. **Justification visibility (risk/security):** Is justification considered sensitive, and should it be visible to all who can view the invoice, or only to certain roles?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Invoicing: Support Authorized Invoice Adjustments  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/210  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Invoicing: Support Authorized Invoice Adjustments

**Domain**: user

### Story Description

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24300028/Durion_Accounting_Event_Contract_v1.pdf)

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
Back Office Manager

## Trigger
A Draft invoice requires an adjustment (goodwill discount, correction).

## Main Flow
1. Authorized user edits invoice line items or applies a discount.
2. System requires a reason code and free-text justification if configured.
3. System recalculates taxes and totals.
4. System records adjustment audit event including before/after values.
5. System flags invoice as adjusted for reporting.

## Alternate / Error Flows
- Unauthorized user attempts adjustment ‚Üí block.
- Adjustment would cause negative totals ‚Üí block or require special permission.

## Business Rules
- Adjustments require permissions and audit trail.
- Adjustments must not break traceability; they must be explainable.

## Data Requirements
- Entities: Invoice, InvoiceItem, AuditEvent, ReasonCode
- Fields: adjustmentType, reasonCode, justification, beforeTotal, afterTotal, adjustedBy, adjustedAt

## Acceptance Criteria
- [ ] Only authorized roles can adjust invoices.
- [ ] Adjustments require reason codes and are auditable.
- [ ] Totals are recalculated correctly after adjustments.
- [ ] Invoice adjustments emit a corresponding accounting event
- [ ] Revenue, tax, and AR are adjusted correctly
- [ ] Adjustments reference the original invoice
- [ ] Authorization and reason code are required
- [ ] Multiple adjustments do not corrupt invoice totals

## Integrations

### Accounting
- Emits Event: InvoiceAdjusted or CreditMemoIssued
- Event Type: Posting (reversal / amendment)
- Source Domain: workexec
- Source Entity: Invoice
- Trigger: Authorized adjustment or credit issuance
- Idempotency Key: invoiceId + adjustmentVersion


## Notes for Agents
Keep adjustments rare and transparent; otherwise you erode trust in the system.


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #212: [FRONTEND] [STORY] Invoicing: Calculate Taxes, Fees, and Totals on Invoice  
File: ./scripts/story-work/frontend/212/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Invoicing: Calculate Taxes, Fees, and Totals on Draft Invoice (Audit Snapshot + Variance Surfacing)

### Primary Persona
System (automated calculation process) with visibility for Service Advisor / Accountant reviewing results in the POS UI.

### Business Value
Ensures draft invoices display accurate, explainable totals (subtotal, tax, fees, rounding adjustment, grand total) based on authoritative rules; creates an auditable calculation snapshot and variance records so invoices are compliant and reviewable before issuance.

---

## 2. Story Intent

### As a / I want / So that
- **As the System**, I want invoice totals to be recalculated whenever a draft invoice is created or its line items change, **so that** the invoice shows correct, auditable totals and is blocked from issuance when tax basis data is incomplete.

### In-scope
- Frontend UI behavior to:
  - Trigger/submit totals calculation for a **draft invoice** (on create and on line changes).
  - Display calculated totals, per-line tax amounts, rounding adjustment, and calculation status.
  - Display variance vs estimate snapshot (amount + reason code), including ‚Äúrequires approval‚Äù indicators if returned by backend.
  - Display actionable validation errors for missing tax basis fields.
  - Display audit/trace references for calculation snapshot (IDs/timestamps) when available.
- Moqui screen/form wiring (screens, transitions, forms) for the above.

### Out-of-scope
- Defining tax rules/fee rules or performing calculations client-side.
- Issuing invoices (owned by Billing domain) except for **UI-level blocking** indicators based on calculation state.
- Approval workflow UX for variances exceeding thresholds (only surface status/need; approval action is not defined here).
- Credit memo creation/issuance.
- Editing/maintaining Chart of Accounts, Posting Rules, or Journal Entries.

---

## 3. Actors & Stakeholders
- **Actors**
  - `System`: initiates calculation when triggered by invoice/line changes.
  - `Service Advisor`: reviews totals/variance before discussing with customer.
  - `Accountant/Finance`: relies on auditability and variance traceability.
- **Stakeholders**
  - `Customer`: indirectly benefits from accurate invoice totals and transparency.
  - `Support/Operations`: needs clear error states and retriable behavior when tax service is down.

---

## 4. Preconditions & Dependencies

### Preconditions
- A draft `Invoice` exists and is viewable in the POS UI.
- Invoice has zero or more `InvoiceItem` lines.

### Dependencies
- Backend endpoint(s) exist to:
  - Load invoice + invoice items + current calculation status and totals.
  - Trigger totals calculation and return updated invoice/calculation snapshot/variance data OR return validation errors.
- Backend enforces:
  - Mandatory tax basis validation (`taxCode`, `jurisdiction`, `pointOfSaleLocation`, `productType`).
  - Rounding policy: HALF_UP, currency scale; round per-line then sum; persist rounding deltas.
  - State transitions to `TotalsCalculated` or `CalculationFailed` as applicable.

### Frontend tech dependencies
- Vue 3 + TypeScript + Quasar components.
- Moqui screen framework conventions (screen paths, transitions, forms/services).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Invoice Draft detail screen (existing or to be created) where invoice lines are added/edited/removed.
- Invoice creation flow (draft invoice created ‚Üí should immediately attempt calculation if lines exist, or when first line is added).

### Screens to create/modify
- **Modify**: `apps/pos/screen/invoice/InvoiceDetail.xml` (or equivalent invoice detail screen in this repo)
  - Add a ‚ÄúTotals & Taxes‚Äù section bound to invoice totals + calculation state.
  - Add ‚ÄúVariance vs Estimate‚Äù section when estimate snapshot exists and variance records exist.
  - Add ‚ÄúCalculation Snapshot‚Äù metadata display (snapshot id, calculatedAt) if present.
- **Optional new sub-screen**: `invoice/InvoiceTotalsPanel.xml` (embedded) to isolate totals/variance rendering.

> If actual screen paths differ in the repo, implementation should follow the project README screen organization conventions.

### Navigation context
- From invoice list ‚Üí invoice detail.
- From work/estimate context ‚Üí invoice detail (if supported).
- Calculation is not a separate page; it is an operation initiated from invoice detail.

### User workflows
**Happy path**
1. User opens Draft invoice detail.
2. User adds/edits/removes an invoice line.
3. UI triggers ‚ÄúRecalculate totals‚Äù (automatic with debounce) or user clicks ‚ÄúRecalculate‚Äù if auto is disabled.
4. UI shows in-progress state; on success, totals update and status shows `TotalsCalculated`.
5. If variance exists, UI displays variance amount and reason code.

**Alternate paths**
- Missing tax basis: UI shows `CalculationFailed` and field-level/actionable errors; totals are not updated (or show last known totals with a clear stale indicator).
- Tax service unavailable: UI shows failure with retriable ‚ÄúRetry calculation‚Äù action; remains blocked from issuance.
- Concurrency/optimistic lock: UI prompts to reload invoice and retry.

---

## 6. Functional Behavior

### Triggers
- **T1**: Draft invoice is created (and has at least one line item) ‚Üí request calculation.
- **T2**: Invoice line is added/modified/removed on a Draft invoice ‚Üí request calculation.
- **T3**: User manually clicks ‚ÄúRecalculate totals‚Äù ‚Üí request calculation.

### UI actions
- Display a calculation status indicator derived from `Invoice.status`:
  - `TotalsCalculationRequired` or ‚Äúdirty‚Äù client state ‚Üí indicates calculation needed.
  - `TotalsCalculated` ‚Üí show computed totals normally.
  - `CalculationFailed` ‚Üí show error panel with reasons and remediation guidance.
- Disable any ‚ÄúIssue invoice‚Äù entry point/button **in the invoice UI** when:
  - status is `CalculationFailed`, or
  - status is not `TotalsCalculated`, or
  - backend indicates blocking conditions (if such a flag is returned).
  - (Note: actual issuance action is out-of-scope; this is purely UI gating if the control exists.)

### State changes (frontend perspective)
- After a successful calculate call:
  - Refresh invoice header and items from response and render updated totals.
  - Render calculation snapshot reference (id/timestamp) if returned.
- After a failed calculate call:
  - Render `CalculationFailed` status and show error details.
  - Keep the invoice screen usable for fixing line tax basis fields (e.g., editing taxCode) if those fields are editable in Draft.

### Service interactions (Moqui)
- Use Moqui `transition` actions from InvoiceDetail screen:
  - `transition name="recalculateTotals"` ‚Üí calls a service that triggers calculation and returns updated invoice context.
- Ensure transitions are idempotent from the UI standpoint (multiple clicks should not create duplicate variance records beyond backend rules).

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- When calculation is triggered, if backend returns missing mandatory tax basis fields, UI must:
  - Show a summary error: ‚ÄúCannot calculate totals: missing tax basis information.‚Äù
  - List missing fields by name and identify impacted line(s) when provided (line index/id).
  - Keep invoice in a ‚Äúblocked‚Äù visual state (status `CalculationFailed`).

Mandatory fields to surface (from authoritative rules):
- `taxCode`
- `jurisdiction`
- `pointOfSaleLocation`
- `productType`

### Enable/disable rules
- Recalculate action enabled only when invoice is in Draft-related statuses (Draft, TotalsCalculationRequired, TotalsCalculated, CalculationFailed) and user has access to invoice detail.
- If invoice is `Issued`, hide/disable recalculation controls and display totals as read-only (immutability).

### Visibility rules
- Show ‚ÄúVariance vs Estimate‚Äù section only if:
  - `estimateSnapshotId` exists AND
  - variance data exists OR backend returns ‚Äúno variance‚Äù explicitly.
- Show calculation snapshot metadata only if `calculationSnapshotId`/`calculatedAt` exists.

### Error messaging expectations
- Missing tax basis: actionable, field-specific.
- Service unavailable: ‚ÄúTax service unavailable. Try again.‚Äù plus a retry action.
- Conflicts: ‚ÄúInvoice was updated elsewhere. Reload to see latest.‚Äù

---

## 8. Data Requirements

### Entities involved (read via backend; not authored client-side)
- `Invoice`
- `InvoiceItem`
- `CalculationSnapshot`
- `EstimateSnapshot` (reference for variance comparison)
- `Variance`

### Fields (frontend display/edit needs)

**Invoice**
- `invoiceId` (String/UUID) ‚Äî required, read-only
- `status` (Enum: `Draft`, `TotalsCalculationRequired`, `TotalsCalculated`, `CalculationFailed`, `Issued`) ‚Äî read-only display, drives UI gating
- `subtotal` (Decimal, currency-scale) ‚Äî read-only display
- `totalTax` (Decimal) ‚Äî read-only
- `totalFees` (Decimal) ‚Äî read-only
- `roundingAdjustment` (Decimal) ‚Äî read-only; display even if 0.00
- `grandTotal` (Decimal) ‚Äî read-only, emphasized
- `estimateSnapshotId` (String/UUID) ‚Äî read-only
- `invoiceDate` (Timestamp) ‚Äî display (existing)
- `jurisdiction` (String) ‚Äî editable only if invoice is Draft and backend allows; otherwise read-only
- `pointOfSaleLocationId` (String/UUID) ‚Äî editable only if Draft and backend allows; otherwise read-only
- `hasOverride` (Boolean) / `overrideReason` / `overriddenByUser` ‚Äî display read-only if present (no override action defined here)

**InvoiceItem**
- `invoiceItemId` ‚Äî required
- `productId` ‚Äî required
- `taxCode` (String) ‚Äî editable in Draft if backend permits; required for successful calculation
- `lineTotal` (Decimal) ‚Äî read-only if derived from qty*unitPrice; otherwise display value returned
- `taxAmount` (Decimal) ‚Äî read-only (returned after calculation)
- `isExempt` (Boolean) ‚Äî display; editing rules not defined here
- `productType` (String/Enum) ‚Äî required for tax basis; editability unclear (see Open Questions)

**CalculationSnapshot**
- `calculationSnapshotId` ‚Äî display
- `calculatedAt` ‚Äî display
- `calculationDetails` (JSON/Text) ‚Äî not rendered raw by default; provide ‚ÄúView details‚Äù only if a dedicated screen/panel exists (not required in this story).

**Variance**
- `varianceAmount` (Decimal) ‚Äî display
- `varianceReasonCode` (Enum list from backend) ‚Äî display as code + human label
- `detectedAt` ‚Äî display
- `notes` ‚Äî display if present
- `approvedBy/approvedAt` ‚Äî display if present

### Derived/calculated fields (UI only)
- ‚ÄúNeeds recalculation‚Äù boolean derived from invoice status or local dirty flag.
- Currency formatting derived from `currencyUomId` if provided; otherwise fall back is **not assumed** (see Open Questions).

---

## 9. Service Contracts (Frontend Perspective)

> Backend names/paths are not provided in inputs; below are required contracts the frontend will call via Moqui transitions. If actual service names differ, implement adapters in Moqui facade services.

### Load/view calls
- **SVC1: Load Invoice Detail**
  - Input: `invoiceId`
  - Output: `Invoice` + `InvoiceItem[]` + optional `Variance[]` + optional `CalculationSnapshot` reference
  - Errors: 404 not found; 403 unauthorized

### Create/update calls (line edits)
- **SVC2: Update Invoice Items**
  - Input: `invoiceId`, line modifications (add/update/remove)
  - Output: updated invoice/items and sets invoice status to `TotalsCalculationRequired` (or equivalent)
  - Errors: validation; 409 conflict (optimistic lock)

### Submit/transition calls
- **SVC3: Calculate Invoice Totals**
  - Input: `invoiceId`
  - Output on success:
    - Updated `Invoice` totals fields
    - Updated `Invoice.status = TotalsCalculated`
    - `CalculationSnapshot` reference (id + calculatedAt)
    - `Variance[]` if created/updated
  - Output on failure:
    - `Invoice.status = CalculationFailed`
    - Structured error with missing field list and impacted entities
  - Error handling expectations:
    - 422 for validation failures (missing tax basis)
    - 503/502 for tax service unavailable
    - 409 for state conflict (invoice Issued, or optimistic lock)
    - Errors should include machine code(s) for UI mapping (examples from backend checklist):
      - `SCHEMA_VALIDATION_FAILED`
      - `INVOICE_TOTAL_NEGATIVE_REQUIRES_CREDIT_MEMO` (UI should display but action is out-of-scope)
      - `CONFIGURATION_ERROR`

### Frontend error handling mapping
- Validation (4xx/422): show inline + summary, keep user on invoice detail.
- Service unavailable (5xx/503): show non-destructive banner + retry button.
- Conflict (409): prompt reload; do not retry automatically without reload.

---

## 10. State Model & Transitions

### Allowed states (as rendered in UI)
- `Draft`
- `TotalsCalculationRequired`
- `TotalsCalculated`
- `CalculationFailed`
- `Issued` (read-only)

### Role-based transitions (frontend gating)
- Calculation is **System-initiated**; users can trigger via UI but backend authorizes operation.
- If invoice is `Issued`: do not show recalculation; do not allow edits.

### UI behavior per state
- **Draft**: totals may be empty or stale; show ‚ÄúRecalculate‚Äù affordance when lines exist.
- **TotalsCalculationRequired**: show ‚ÄúNeeds recalculation‚Äù; allow recalc; optionally auto-trigger.
- **TotalsCalculated**: show totals normally; show variance section if present.
- **CalculationFailed**: show blocking error panel; highlight missing tax basis; allow user to correct fields and retry.
- **Issued**: everything read-only; show calculation snapshot reference; no actions.

---

## 11. Alternate / Error Flows

### Validation failures (missing tax basis)
- User triggers recalc.
- Backend returns missing fields (and ideally line identifiers).
- UI:
  - Sets/reflects status `CalculationFailed`.
  - Shows list of missing fields (grouped by invoice-level vs line-level if provided).
  - Keeps totals display but marks as ‚Äúnot calculated / stale‚Äù if backend does not return totals.

### Concurrency conflicts
- If line edits or calculate return 409:
  - UI shows ‚ÄúInvoice updated elsewhere‚Äù and provides ‚ÄúReload invoice‚Äù action.
  - After reload, user may retry recalc.

### Unauthorized access
- If 403 on load: show access denied screen.
- If 403 on calculate: keep invoice visible but disable calculate and show ‚ÄúYou don‚Äôt have permission to recalculate totals.‚Äù

### Empty states
- Draft invoice with zero lines:
  - Totals section shows zeros or ‚Äú‚Äî‚Äù per project convention; do not auto-calculate.
  - Recalculate action disabled until at least one line exists.

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: Calculate totals for a standard taxable invoice
**Given** a Draft invoice exists with one line item priced at 100.00 with quantity 2  
**And** the line item has required tax basis fields including `taxCode`, `productType`  
**And** the invoice has required tax basis fields including `jurisdiction` and `pointOfSaleLocation`  
**When** the user triggers ‚ÄúRecalculate totals‚Äù (or the system auto-triggers after line change)  
**Then** the UI requests the Calculate Invoice Totals service for that invoice  
**And** on success the UI displays `subtotal = 200.00`  
**And** the UI displays `totalTax` and `grandTotal` values returned by the backend  
**And** the invoice status displayed is `TotalsCalculated`  
**And** the UI displays `roundingAdjustment` explicitly (including 0.00).

### Scenario 2: Mixed-tax invoice displays correct aggregated totals
**Given** a Draft invoice exists with two line items: one taxable and one non-taxable  
**When** totals are recalculated successfully  
**Then** the UI displays a single invoice-level `totalTax` equal to the backend response  
**And** the UI displays per-line `taxAmount` values returned for each line  
**And** the UI displays `grandTotal` equal to `subtotal + totalTax + totalFees + roundingAdjustment` as returned (no client recomputation is authoritative).

### Scenario 3: Variance is surfaced when estimate snapshot differs
**Given** a Draft invoice is linked to an `estimateSnapshotId`  
**And** recalculation returns a `Variance` record with `varianceReasonCode = TAX_RULE_CHANGE` and a non-zero `varianceAmount`  
**When** the invoice detail is rendered after calculation  
**Then** the UI displays a ‚ÄúVariance vs Estimate‚Äù section  
**And** it shows `varianceAmount` and `varianceReasonCode`  
**And** it shows `detectedAt` timestamp.

### Scenario 4: Block calculation and issuance UI when mandatory tax basis is missing
**Given** a Draft invoice exists where at least one required tax basis field is missing (e.g., an item missing `taxCode`)  
**When** totals calculation is triggered  
**Then** the UI displays invoice status `CalculationFailed`  
**And** the UI shows an actionable error listing the missing field(s)  
**And** the UI disables/hides any ‚ÄúIssue invoice‚Äù action on this screen (if present) due to calculation failure.

### Scenario 5: Tax service unavailable shows retriable error
**Given** a Draft invoice exists with complete tax basis fields  
**When** totals calculation returns a service-unavailable error (5xx/503)  
**Then** the UI shows a non-destructive error banner indicating calculation could not be completed  
**And** the UI provides a ‚ÄúRetry calculation‚Äù action  
**And** the invoice remains not issuable in the UI until calculation succeeds.

### Scenario 6: Issued invoice is immutable in UI
**Given** an invoice is in `Issued` state  
**When** the invoice detail screen is opened  
**Then** the UI does not show invoice-line editing controls  
**And** the UI does not show ‚ÄúRecalculate totals‚Äù controls  
**And** the UI displays totals and (if present) calculation snapshot reference as read-only.

---

## 13. Audit & Observability

### User-visible audit data
- Display (when available from backend):
  - `CalculationSnapshot.calculatedAt`
  - `calculationSnapshotId`
  - Variance `detectedAt`, and approval fields if present (`approvedBy`, `approvedAt`).

### Status history
- If backend exposes invoice status history/audit events, provide a collapsible ‚ÄúHistory‚Äù panel (optional). If not exposed, do not invent.

### Traceability expectations
- All calculate actions should include identifiers in logs/telemetry:
  - `invoiceId`
  - resulting `calculationSnapshotId` (if success)
  - variance identifiers (if returned)
- Moqui screen transition should log outcome (success/failure) at INFO/WARN with sanitized error code.

---

## 14. Non-Functional UI Requirements

- **Performance**: Recalculation trigger should be debounced on rapid line edits (avoid firing on every keystroke); only trigger after the edit is committed.
- **Accessibility**: Error summary must be screen-reader accessible; focus should move to error summary on failure.
- **Responsiveness**: Totals section must render well on tablet sizes used in POS.
- **i18n/timezone/currency**:
  - Use locale-aware formatting consistent with existing app conventions.
  - Do not assume currency; format using currency from backend if provided (see Open Questions).

---

## 15. Applied Safe Defaults
- SD-UI-ERG-01 (Debounced auto-trigger): Automatically debounce recalculation after line changes to reduce API churn; qualifies as UI ergonomics and does not change business rules. Impacted sections: UX Summary, Functional Behavior, Non-Functional.
- SD-ERR-MAP-01 (Standard HTTP error mapping): Map 422/409/503 to inline validation, reload prompt, and retry banner patterns; qualifies as standard error-handling mapping. Impacted sections: Service Contracts, Alternate/Error Flows.

---

## 16. Open Questions
1. What are the **actual Moqui service names and screen paths** for:
   - loading invoice detail,
   - updating invoice items,
   - triggering totals calculation?
2. Does the backend return a **currency identifier** (e.g., `currencyUomId`) on Invoice/CalculationSnapshot for correct formatting? If not, what is the frontend‚Äôs authoritative currency source?
3. For missing tax basis validation, will the backend return **line-level pointers** (e.g., `invoiceItemId` + missing fields), or only a flat list of missing fields?
4. Are `jurisdiction`, `pointOfSaleLocationId`, and `productType` **editable in the invoice UI** while in Draft, or are they sourced from upstream entities (work order, location, product catalog) and read-only?
5. If variances exceed thresholds and require approval, does the backend return an explicit **‚ÄúrequiresApproval‚Äù flag** or approval status to render, or should the frontend infer only from presence of `approvedBy/approvedAt`?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Invoicing: Calculate Taxes, Fees, and Totals on Invoice  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/212  
Labels: frontend, story-implementation, general

## Frontend Implementation for Story

**Original Story**: [STORY] Invoicing: Calculate Taxes, Fees, and Totals on Invoice

**Domain**: general

### Story Description

/kiro  
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
System

## Trigger
Invoice draft is created or invoice lines are adjusted.

## Main Flow
1. System applies tax and fee rules to invoice lines based on snapshot/tax config.
2. System calculates subtotal, taxes, fees, rounding adjustments, and grand total.
3. System compares invoice totals to estimate snapshot totals and records variance reasons where applicable.
4. System updates invoice totals and stores calculation snapshot.
5. System prevents issuing invoice if tax basis is incomplete (policy).

## Alternate / Error Flows
- Tax configuration changed since estimate ‚Üí flag variance and require review.
- Missing tax codes ‚Üí block issuance and show actionable errors.

## Business Rules
- Tax calculation must be explainable and auditable.
- Mixed-tax scenarios must be supported.

## Data Requirements
- Entities: Invoice, InvoiceItem, TaxRule, CalculationSnapshot, EstimateSnapshot
- Fields: taxCode, taxRate, taxAmount, feeTotal, roundingAdjustment, varianceAmount, varianceReason

## Acceptance Criteria
- [ ] Invoice totals compute correctly for mixed-tax scenarios.
- [ ] System records variance vs estimate snapshot when applicable.
- [ ] Invoice cannot be issued when required tax basis is missing.

## Notes for Agents
Variance explanations reduce disputes‚Äîcapture them automatically when possible.

### Frontend Requirements
- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack
- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #69: [FRONTEND] [STORY] Accounting: Reconcile POS Status with Accounting Authoritative Status  
File: ./scripts/story-work/frontend/69/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

STOP: Clarification required before finalization

---

# 1. Story Header

## Title
[FRONTEND] [STORY] Accounting: Display & Reconcile Authoritative Accounting Status on Invoice Detail (Pending/Posted + Drilldown + Audit)

## Primary Persona
Cashier (secondary: Service Advisor, Manager/Supervisor, Accounting)

## Business Value
Reduce customer disputes and internal confusion by showing the **authoritative accounting posting status** (pending vs posted, etc.) alongside POS operational status, with traceable references and auditable reconciliation history.

---

# 2. Story Intent

## As a / I want / So that
- **As a Cashier**, I want the invoice screen to display accounting‚Äôs authoritative status (pending posting vs posted, etc.) so that I can confidently answer customer questions and resolve disputes without leaving POS.

## In-scope
- Display accounting status badge/section on an **Invoice Detail** screen.
- Show **status timestamp**, **staleness indicator**, and **manual refresh** action (permission-gated).
- Show **drilldown reference(s)** and ‚ÄúView in Accounting‚Äù deep link (permission-gated).
- Show **discrepancy banner** when POS local status conflicts with accounting status.
- Show **status sync/audit history** related to accounting reconciliation (read-only UI).
- Moqui screen actions to load/update (refresh) accounting status via service calls, and to log ‚Äúviewed‚Äù audit events.

## Out-of-scope
- Implementing the event consumer / synchronizer (backend service) that ingests `InvoiceStatusChanged` / `PostingConfirmed` events.
- Changing invoice lifecycle or posting logic; this story is **display + refresh + audit UI**.
- Defining GL accounts, journal entry lines, or accounting posting rules.
- SSO mechanics beyond opening a provided deep link URL.

---

# 3. Actors & Stakeholders

- **Cashier**: Needs quick authoritative status, minimal details, can refresh if stale (if permitted).
- **Service Advisor**: Similar needs for follow-up/collections.
- **Manager/Supervisor**: Can view drilldown details; may handle exceptions.
- **Accounting Role**: Full drilldown details; investigates discrepancies.
- **Support/Audit/Compliance**: Requires retained audit trail and traceability.

---

# 4. Preconditions & Dependencies

## Preconditions
- An invoice exists and can be opened in POS.
- The invoice has (or can derive) a POS operational/local status (e.g., PAYMENT_RECEIVED).
- Accounting status data is available either:
  - already synchronized into a local read model, and/or
  - obtainable via a refresh/poll service call.

## Dependencies (blocking for implementation detail)
- Backend endpoints/services in Moqui for:
  - loading invoice + accounting status (read model)
  - triggering refresh/poll (manual refresh)
  - retrieving audit log entries for invoice accounting status sync
  - permission checks/authorization signals available to frontend

---

# 5. UX Summary (Moqui-Oriented)

## Entry points
- Invoice search/list ‚Üí select invoice ‚Üí **Invoice Detail**.
- (Optional) From payment receipt screen ‚Üí ‚ÄúView invoice‚Äù ‚Üí Invoice Detail.

## Screens to create/modify
- **Modify**: `InvoiceDetail` screen (existing) to add an ‚ÄúAccounting Status‚Äù section.
- **Create (if missing)**: `InvoiceAccountingStatusHistory` sub-screen (embedded or dialog) to list audit events for this invoice.

> Moqui implementation expectation: update a screen under an application like `apps/pos/screen/.../InvoiceDetail.xml` (exact path TBD by repo conventions).

## Navigation context
- Within POS invoice context; must preserve invoiceId in URL parameters.
- Accounting drilldown opens a new tab/window.

## User workflows

### Happy path: view posted
1. User opens invoice detail.
2. UI loads invoice and accounting status.
3. UI shows badge: ‚ÄúPosted to Accounting‚Äù, updated timestamp, and (if permitted) drilldown link.

### Alternate: pending posting
1. Badge shows ‚ÄúPending Posting‚Äù, updated timestamp.
2. If stale threshold exceeded, show ‚ÄúMay be outdated‚Äù indicator and Refresh button (if permitted).

### Alternate: discrepancy / rejected
1. If accounting status indicates rejection/hold/reversal/etc., show warning banner with reason (if provided).
2. Show both POS status and Accounting status side-by-side (textual comparison).

### Alternate: permission-limited user
1. If no permission to view accounting status: hide entire section; optionally show restricted placeholder per policy (needs clarification).

---

# 6. Functional Behavior

## Triggers
- Screen load for Invoice Detail with `invoiceId`.
- User clicks ‚ÄúRefresh Status‚Äù (permission-gated).
- User clicks ‚ÄúView in Accounting‚Äù (permission-gated).
- User opens ‚ÄúStatus History‚Äù (embedded panel or dialog).

## UI actions
- Render accounting status badge and details:
  - `accountingStatus` enum mapped to user-friendly labels
  - last updated timestamp
  - optional reason text for exceptional statuses
- Render discrepancy banner when `discrepancyDetected=true` OR when computed mismatch conditions apply (see Open Questions).
- Render staleness indicator when `now - accountingStatusUpdatedAt > stalenessThreshold`.
- Manual refresh:
  - invoke refresh service; update UI with new status; record audit ‚ÄúMANUAL_REFRESH‚Äù source (if backend supports).
- Drilldown:
  - open `drilldownUrl` (preferred) else construct from refs (blocked:clarification‚Äîdo not guess URL patterns).
- Audit/history:
  - list audit entries with sync source, old/new status, timestamps, eventId (if permitted).

## State changes (frontend-visible)
- No direct domain state machine transitions owned by frontend.
- UI reflects updated fields after refresh:
  - `accountingStatus`, `accountingStatusUpdatedAt`, `postingReference`, `lastSyncEvent`, `discrepancyDetected`, `discrepancyReason`.

## Service interactions
- `loadInvoiceAccountingStatus` (read)
- `refreshInvoiceAccountingStatus` (command/poll)
- `listInvoiceAccountingStatusAudit` (read)
- `logInvoiceAccountingStatusViewed` (audit write) ‚Äî optional; needs clarification whether backend wants explicit ‚Äúview‚Äù logging.

---

# 7. Business Rules (Translated to UI Behavior)

## Validation
- On refresh action:
  - require `invoiceId` present.
  - require user permission `REFRESH_ACCOUNTING_STATUS`.
- For drilldown:
  - require permission `VIEW_ACCOUNTING_DETAIL`.
  - require `drilldownUrl` or required postingReference fields if URL is constructed (construction is blocked).

## Enable/disable rules
- ‚ÄúRefresh Status‚Äù button:
  - visible+enabled only if user has `REFRESH_ACCOUNTING_STATUS`.
  - disabled with spinner while refresh is in-flight.
- ‚ÄúView in Accounting‚Äù link/button:
  - visible only if user has `VIEW_ACCOUNTING_DETAIL` **and** drilldown reference exists.
- ‚ÄúAccounting Status‚Äù section:
  - visible only if user has `VIEW_ACCOUNTING_STATUS` (per backend story).
  - If user lacks permission: hide entire section (per backend story); whether to show placeholder text is an open question.

## Visibility rules (status-driven)
- If `accountingStatus` in `{REJECTED, REVERSED, VOIDED, ON_HOLD, DISPUTED}`:
  - show a prominent banner (severity depends on status) including `reason`/`discrepancyReason` if provided.
- If staleness detected:
  - show staleness indicator text ‚ÄúLast synced X ago‚Äù (relative time) and refresh CTA if permitted.
- If out-of-order/duplicate handling occurs, UI does not need to expose internals; audit history may reflect latest status only.

## Error messaging expectations
- Refresh failures must show actionable, non-technical messages:
  - ‚ÄúAccounting status unavailable. Try again later.‚Äù
- Authorization failures:
  - ‚ÄúYou don‚Äôt have permission to refresh accounting status.‚Äù
- Missing status:
  - ‚ÄúAccounting status not available yet‚Äù (only if backend indicates no status exists; do not infer).

---

# 8. Data Requirements

## Entities involved (frontend-facing read models)
- Invoice (existing POS invoice entity/read model; includes `posLocalStatus`)
- InvoiceAccountingStatus (read model described in backend story)
- AccountingStatusSyncAuditLog (audit list per invoice)

## Fields (type, required, defaults)

### InvoiceAccountingStatus (read)
- `invoiceId` (UUID, required)
- `posLocalStatus` (enum/string, required for comparison display)
- `accountingStatus` (enum, optional if not yet received)
- `accountingStatusUpdatedAt` (timestamp, optional)
- `postingReference.glEntryId` (UUID, optional; sensitive)
- `postingReference.batchId` (string, optional; sensitive)
- `postingReference.postingDate` (date, optional)
- `postingReference.drilldownUrl` (string/url, optional; sensitive)
- `lastSyncEvent` (UUID, optional)
- `discrepancyDetected` (boolean, default false if absent)
- `discrepancyReason` (string, optional)

### AccountingStatusSyncAuditLog (read list)
- `auditId` (UUID)
- `invoiceId` (UUID)
- `eventId` (UUID, optional)
- `oldStatus` (string/enum)
- `newStatus` (string/enum)
- `syncedAt` (timestamp)
- `discrepancyDetected` (boolean)
- `viewedByUserId` (UUID, optional)
- `metadata.syncSource` (enum EVENT|POLLING|MANUAL_REFRESH)
- `metadata.latencyMs` (integer, optional)

## Read-only vs editable
- All fields are **read-only** in UI.
- Only action is ‚ÄúRefresh‚Äù (command) which may update backend state; UI never edits accountingStatus fields directly.

## Derived/calculated fields (UI-only)
- `isStale = accountingStatusUpdatedAt && (now - accountingStatusUpdatedAt > threshold)`
- `relativeUpdatedAt` string for display
- `statusLabel` mapping per enum
- `statusSeverity` mapping per enum (info/warn/error)

---

# 9. Service Contracts (Frontend Perspective)

> Names are placeholders until confirmed by Moqui service naming conventions in this repo.

## Load/view calls
1. **Load invoice + accounting status**
   - Service: `pos.invoice.getInvoiceAccountingStatus`
   - Inputs: `invoiceId`
   - Outputs: Invoice + InvoiceAccountingStatus composite (or two calls)
   - Errors:
     - 404 if invoice not found
     - 403 if no VIEW permission (behavior needs clarification: hide vs error)

2. **List audit history**
   - Service: `accounting.invoice.listAccountingStatusSyncAudit`
   - Inputs: `invoiceId`, pagination params
   - Outputs: list of audit log entries
   - Errors: 403 if restricted

## Create/update calls (commands)
3. **Manual refresh**
   - Service: `accounting.invoice.refreshAccountingStatus`
   - Inputs: `invoiceId`
   - Outputs: updated InvoiceAccountingStatus
   - Errors:
     - 403 unauthorized
     - 409 conflict (if invoice in invalid state?) (only if backend defines)
     - 503/504 upstream accounting unavailable (map to user-friendly message)

4. **Log ‚Äúviewed‚Äù audit event (optional)**
   - Service: `accounting.invoice.logAccountingStatusViewed`
   - Inputs: `invoiceId`, maybe `viewContext`
   - Outputs: success
   - Errors: non-blocking for UX; should not prevent screen render.

## Error handling expectations
- Standard Moqui error responses should be surfaced:
  - field errors inline if any (unlikely)
  - toast/banner for service failures
- Correlation ID (if provided in response headers/body) should be logged client-side per repo conventions (needs confirmation).

---

# 10. State Model & Transitions

## Allowed states (Accounting status enum, v1)
- `PENDING_POSTING`
- `POSTED`
- `RECONCILED`
- `REJECTED`
- `REVERSED`
- `VOIDED`
- `ON_HOLD`
- `DISPUTED`

## Role-based transitions (UI)
- UI does not initiate status transitions; it only:
  - refreshes (polls) current status if permitted
  - views detail if permitted

## UI behavior per state
- `PENDING_POSTING`: yellow/neutral badge; show staleness if applicable.
- `POSTED`: green badge; show posting refs if permitted.
- `RECONCILED`: green badge; show posting refs if permitted.
- `REJECTED`: error badge/banner; show reason if present; encourage escalation.
- `REVERSED`: warning/error banner; show that prior posting was reversed.
- `VOIDED`: terminal indicator; banner; drilldown if permitted.
- `ON_HOLD`: warning banner; show reason if present.
- `DISPUTED`: warning banner.

Backward progression detection:
- If backend exposes ‚Äúout-of-order ignored‚Äù audit entries, UI may show in history only; otherwise no special UI.

---

# 11. Alternate / Error Flows

## Validation failures
- Refresh clicked without permission ‚Üí show permission error; do not call service.
- Drilldown clicked without URL/ref ‚Üí show ‚ÄúDetails not available‚Äù and do nothing.

## Concurrency conflicts
- If refresh returns conflict due to concurrent update:
  - UI reloads status (re-fetch) and shows ‚ÄúStatus updated elsewhere; showing latest.‚Äù

## Unauthorized access
- No `VIEW_ACCOUNTING_STATUS`:
  - Hide accounting section (per backend story).
  - Log attempt only if backend supports; UI should not leak existence of restricted fields.

## Empty states
- No accounting status yet:
  - Display ‚ÄúNot yet received from accounting‚Äù (only if backend returns explicit null/empty), and show refresh button if permitted.
- No audit logs:
  - Display ‚ÄúNo synchronization history available.‚Äù

## Upstream unavailable
- Refresh fails due to accounting API outage:
  - keep current status; show error banner and allow retry.

---

# 12. Acceptance Criteria

## Scenario 1: Display authoritative status badge (posted)
**Given** an invoice exists with POS local status `PAYMENT_RECEIVED`  
**And** the invoice has `accountingStatus = POSTED` and `accountingStatusUpdatedAt` populated  
**When** a user with `VIEW_ACCOUNTING_STATUS` opens the Invoice Detail screen  
**Then** the UI displays an Accounting Status badge labeled ‚ÄúPosted‚Äù (or ‚ÄúPosted to Accounting‚Äù)  
**And** the UI displays the last updated timestamp for the accounting status  
**And** the POS local status remains visible but is visually secondary to the accounting status.

## Scenario 2: Pending vs posted are clearly distinguishable
**Given** an invoice has `accountingStatus = PENDING_POSTING`  
**When** a Cashier opens Invoice Detail  
**Then** the badge indicates ‚ÄúPending Posting‚Äù with a non-success severity  
**And** the ‚Äúlast updated‚Äù timestamp is displayed.  

**Given** the same invoice later has `accountingStatus = POSTED`  
**When** the Cashier refreshes the screen or triggers refresh (if permitted)  
**Then** the badge updates to ‚ÄúPosted‚Äù with success severity.

## Scenario 3: Permission-gated drilldown visibility
**Given** an invoice has `postingReference.drilldownUrl` present  
**And** the user has `VIEW_ACCOUNTING_DETAIL`  
**When** the user views the invoice  
**Then** the UI shows a ‚ÄúView in Accounting‚Äù action  
**And** activating it opens the drilldown URL in a new tab/window.

**Given** the user lacks `VIEW_ACCOUNTING_DETAIL`  
**When** the user views the invoice  
**Then** the UI does not display GL identifiers (`glEntryId`, `batchId`) nor the drilldown action  
**And** the accounting badge and timestamp remain visible (if `VIEW_ACCOUNTING_STATUS` is granted).

## Scenario 4: Discrepancy banner when accounting is exceptional
**Given** an invoice has `accountingStatus = REJECTED`  
**And** `discrepancyReason` is ‚ÄúInvoice total mismatch‚Äù  
**When** a user with `VIEW_ACCOUNTING_STATUS` opens Invoice Detail  
**Then** the UI shows a warning/error banner indicating accounting rejected the invoice  
**And** the banner includes the reason text ‚ÄúInvoice total mismatch‚Äù  
**And** both POS local status and accounting status are shown for comparison.

## Scenario 5: Staleness indicator and refresh action
**Given** an invoice has `accountingStatusUpdatedAt` older than the configured staleness threshold  
**When** a user with `VIEW_ACCOUNTING_STATUS` views the invoice  
**Then** the UI displays ‚ÄúAccounting status may be outdated‚Äù and the relative last sync time.  

**Given** the user has `REFRESH_ACCOUNTING_STATUS`  
**When** the user clicks ‚ÄúRefresh Status‚Äù  
**Then** the UI calls the refresh service with `invoiceId`  
**And** on success the UI updates the badge/status fields without requiring a full page reload  
**And** the refresh action is recorded in audit history as `MANUAL_REFRESH` (if backend provides).

## Scenario 6: Restricted users do not see accounting section
**Given** a user lacks `VIEW_ACCOUNTING_STATUS`  
**When** the user opens Invoice Detail  
**Then** the Accounting Status section is not displayed  
**And** the UI does not display posting references or audit history links.

## Scenario 7: Refresh failure handling
**Given** a user has `REFRESH_ACCOUNTING_STATUS`  
**When** the user clicks ‚ÄúRefresh Status‚Äù and the service returns an upstream unavailable error  
**Then** the UI keeps the current displayed status unchanged  
**And** shows an error message ‚ÄúAccounting status unavailable. Try again later.‚Äù  
**And** the user can attempt refresh again.

---

# 13. Audit & Observability

## User-visible audit data
- A ‚ÄúStatus History‚Äù view shows rows with:
  - syncedAt, oldStatus, newStatus, syncSource, (optional) eventId
  - discrepancyDetected indicator
- Visibility of this history should follow `VIEW_ACCOUNTING_STATUS` at minimum; finer control is an open question.

## Status history
- Must be ordered descending by `syncedAt`.
- Must support pagination for long retention.

## Traceability expectations
- UI should display `lastSyncEvent` (eventId) **only** to users with `VIEW_ACCOUNTING_DETAIL` (or separate permission, open question).
- When a user triggers refresh or clicks drilldown, emit frontend logs (console/logger) with `invoiceId` and action outcome per repo conventions (no PII).

---

# 14. Non-Functional UI Requirements

- **Performance**: Invoice detail load should not be meaningfully degraded; accounting status load should be within typical POS SLA (target p95 < 1s for cached read; refresh is user-initiated).
- **Accessibility**: Status indicators must not rely on color alone; include text labels and ARIA-friendly semantics.
- **Responsiveness**: Works on tablet/desktop POS layouts; accounting section collapsible if space constrained.
- **i18n/timezone/currency**:
  - Timestamps displayed in store/user timezone (needs repo convention confirmation).
  - Status labels translatable via existing i18n mechanism.

---

# 15. Applied Safe Defaults

- SD-UX-EMPTY-STATE-01: Show explicit empty states (‚ÄúNot yet received‚Äù, ‚ÄúNo history available‚Äù) for missing status/history; safe because it‚Äôs UX-only and does not alter domain policy. Impacted sections: UX Summary, Error Flows, Acceptance Criteria.
- SD-UX-PAGINATION-01: Paginate audit history list with a conservative default page size (e.g., 25) and next/prev controls; safe because it‚Äôs a presentation concern. Impacted sections: Data Requirements, Audit & Observability.
- SD-ERR-MAP-01: Map 401/403 to permission messaging, 404 to ‚Äúnot found‚Äù, 5xx to ‚Äútemporarily unavailable‚Äù; safe because it‚Äôs standard error surfacing without changing business rules. Impacted sections: Service Contracts, Error Flows.

---

# 16. Open Questions

1. **Moqui screen locations & existing invoice detail screen ID**: What is the exact Moqui screen path/name to extend for Invoice Detail in `durion-moqui-frontend`?
2. **Service names and endpoints**: What are the actual Moqui services (or REST endpoints) for:
   - loading invoice accounting status,
   - triggering manual refresh/poll,
   - listing audit history,
   - logging ‚Äúviewed‚Äù events (if required)?
3. **Deep link construction**: Will backend provide `postingReference.drilldownUrl` fully formed, or must frontend construct it? If constructed, what is the canonical base URL/pattern and required identifiers?
4. **Permission source**: How does frontend obtain permission flags in this project (session user groups, Moqui artifacts authz, explicit permission service, etc.)? Are the three permissions (`VIEW_ACCOUNTING_STATUS`, `REFRESH_ACCOUNTING_STATUS`, `VIEW_ACCOUNTING_DETAIL`) already modeled?
5. **Staleness threshold**: Is the 1-hour staleness threshold configurable and provided to frontend (config/entity/service), or should frontend use a constant? (Cannot assume for denylist policy/threshold.)
6. **Discrepancy logic**: Should discrepancy display rely only on backend-provided `discrepancyDetected/discrepancyReason`, or should frontend compute mismatch between POS local status and accounting status? If computed, what is the exact rule mapping?
7. **Audit history access control**: Should viewing the audit history require only `VIEW_ACCOUNTING_STATUS`, or a separate permission?
8. **Restricted users UX**: When user lacks `VIEW_ACCOUNTING_STATUS`, should UI (a) hide silently, or (b) show a restricted placeholder text? Backend story suggests hide; confirm desired behavior.

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Accounting: Reconcile POS Status with Accounting Authoritative Status  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/69  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Accounting: Reconcile POS Status with Accounting Authoritative Status

**Domain**: user

### Story Description

/kiro  
# User Story

## Narrative  
As a **Cashier**, I want POS to reflect accounting‚Äôs authoritative status so that disputes are minimized.

## Details  
- Show ‚Äúpending posting‚Äù vs ‚Äúposted.‚Äù  
- Provide drilldown refs.

## Acceptance Criteria  
- Accounting status overrides local state.  
- Pending/posted states clear.  
- Audit of reconciliation.

## Integrations  
- Accounting emits InvoiceStatusChanged/PostingConfirmed events.

## Data / Entities  
- PostingConfirmation, InvoiceStatusChangedEvent, AuditLog

## Classification (confirm labels)  
- Type: Story  
- Layer: Experience  
- domain :  Point of Sale

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript  
- Use Quasar framework for UI components  
- Integrate with Moqui Framework backend  
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API  
- TypeScript 5.x  
- Quasar v2.x  
- Moqui Framework integration

---  
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #70: [FRONTEND] [STORY] Accounting: Update Invoice Payment Status from Payment Outcomes ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/70  
File: ./scripts/story-work/frontend/70/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

STOP: Clarification required before finalization

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Accounting: Display Invoice Payment Status & Posting Outcome from Payment/Posting Events

### Primary Persona
POS cashier / manager (invoice viewer), and reconciliation staff (finance ops) using the POS UI to understand invoice payment state.

### Business Value
Ensure invoice status shown in the POS is accurate and traceable after payment outcomes, reducing customer balance disputes and enabling quick reconciliation when postings fail.

---

## 2. Story Intent

### As a / I want / So that
- **As a** POS user viewing an invoice,
- **I want** to see the current payment status and latest payment/posting outcome details (transaction references and posting errors),
- **So that** I can confirm whether an invoice is paid/partially paid/unpaid/failed and know if accounting posting succeeded or needs follow-up.

### In-scope
- Moqui screens to **view** invoice payment status and related payment/posting references.
- UI refresh behavior to reflect latest status (manual refresh + on-navigation reload).
- Display of idempotency/transaction references as read-only audit context.
- Error/empty states when events are missing or backend indicates processing/posting failure.

### Out-of-scope
- Applying payments from the UI (payment capture/void/refund).
- Editing invoice totals, issuing invoices, or triggering accounting postings.
- Defining GL account mappings or posting rules (backend/config).

---

## 3. Actors & Stakeholders
- **Cashier / POS user:** needs simple ‚ÄúPaid vs Not Paid‚Äù clarity and references.
- **Store manager:** needs visibility into failed payments/posting errors.
- **Finance / reconciliation:** needs transaction IDs, correlation IDs, and failure markers.
- **Accounting backend service:** system of record for invoice financial/payment status and posting outcomes.
- **Payment service/gateway:** source of payment outcomes (not directly operated from this UI story).

---

## 4. Preconditions & Dependencies
- An invoice exists in backend with an identifier (`invoiceId` or `invoiceNumber`) and payment-related fields.
- Backend exposes an API/view entity that the frontend can call to retrieve:
  - `invoiceStatus` (Paid/PartiallyPaid/Unpaid/Failed/Chargeback if applicable)
  - amounts (total/paid/outstanding) in minor units
  - latest payment transaction reference(s)
  - posting status/error indicator(s) (e.g., `postingError`, posting intent status)
- User is authenticated and authorized to view invoices and payment status.

**Dependency (blocking):** exact Moqui service names, screen locations, and entity/view names are not provided in inputs (see Open Questions).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- From an existing **Invoice detail** screen in POS, add a ‚ÄúPayment & Posting‚Äù section/tab.
- If no invoice detail exists, create an invoice view screen accessible via a menu entry under Accounting/Invoices (blocking decision).

### Screens to create/modify
- **Modify**: `InvoiceDetail` screen (or equivalent) to include payment/posting status panel.
- **Create (if needed)**: a sub-screen `InvoicePaymentStatus` embedded in invoice detail for modularity.

### Navigation context
- Route expects `invoiceId` (preferred) as path/parameter.
- Provide a ‚ÄúBack to invoices‚Äù navigation consistent with existing POS patterns.

### User workflows
**Happy path**
1. User opens invoice detail.
2. UI loads invoice header + payment status block.
3. UI displays:
   - Payment Status (Paid/PartiallyPaid/Unpaid/Failed)
   - Paid amount and outstanding amount
   - Last transaction reference
   - Posting outcome (Posted/Pending/Failed) if provided
4. User optionally clicks ‚ÄúRefresh‚Äù to re-load latest status.

**Alternate paths**
- Invoice exists but has no payments yet ‚Üí show Unpaid + ‚ÄúNo payments recorded‚Äù.
- Payment recorded but posting pending ‚Üí show status + ‚ÄúPosting pending‚Äù.
- Posting failed ‚Üí show prominent warning + reconciliation hint + correlation/intent IDs (if available).
- Unauthorized ‚Üí show access denied.

---

## 6. Functional Behavior

### Triggers
- Screen load / parameter change (navigating to a different invoice).
- User clicks ‚ÄúRefresh‚Äù.

### UI actions
- Read-only display of payment/posting fields.
- Copy-to-clipboard for transaction ID / correlation ID (optional; if not supported by conventions, omit).

### State changes (frontend)
- Local loading states: `loading`, `loaded`, `error`.
- No domain state mutation from frontend in this story.

### Service interactions
- Call a backend read service to fetch an **InvoiceStatusView** (or equivalent view) by `invoiceId`.
- If backend separates posting outcomes, call a second service to fetch latest posting intent/outcome by invoiceId (blocking until confirmed).

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- `invoiceId` parameter is required; if missing/blank ‚Üí show validation error and block calls.
- If backend returns invoice not found ‚Üí show ‚ÄúInvoice not found‚Äù.

### Enable/disable rules
- ‚ÄúRefresh‚Äù enabled when `invoiceId` present; disabled while `loading=true`.

### Visibility rules
- Show **Posting Failure** banner only when backend indicates `postingError=true` or latest posting status = Failed.
- Show transaction reference section only when at least one reference exists.

### Error messaging expectations
- Map backend error codes (if provided) into user-safe messages:
  - 401/403 ‚Üí ‚ÄúYou don‚Äôt have access to view payment status for this invoice.‚Äù
  - 404 ‚Üí ‚ÄúInvoice not found.‚Äù
  - 409 (conflict/concurrency) ‚Üí ‚ÄúInvoice status is being updated. Refresh in a moment.‚Äù
  - 5xx/timeouts ‚Üí ‚ÄúUnable to load payment status. Try again.‚Äù

---

## 8. Data Requirements

### Entities involved (frontend perspective)
- `Invoice` (read-only in this story)
- `InvoiceStatusView` (view entity / DTO; read-only)
- Optional: `PostingIntent` / `PostingOutcomeView` (read-only)

### Fields (type, required, defaults)
**Required to display core status**
- `invoiceId` (string/UUID) ‚Äî required
- `invoiceStatus` (enum string: `Paid|PartiallyPaid|Unpaid|Failed` (+ `Chargeback` if present)) ‚Äî required
- `currencyUomId` (string, e.g., USD) ‚Äî required
- `totalAmountMinor` (integer) ‚Äî required
- `paidAmountMinor` (integer) ‚Äî required
- `outstandingAmountMinor` (integer) ‚Äî required

**Optional audit/trace fields**
- `lastPaymentTransactionId` (string) ‚Äî optional
- `lastPaymentOccurredAt` (datetime) ‚Äî optional
- `postingError` (boolean) ‚Äî optional
- `postingIntentId` (string/UUID) ‚Äî optional
- `postingStatus` (enum `Pending|Posted|Failed`) ‚Äî optional
- `postingLastAttemptAt` (datetime) ‚Äî optional
- `correlationId` (string) ‚Äî optional

### Read-only vs editable by state/role
- All fields read-only in this story for all roles.

### Derived/calculated fields (UI-only)
- Display money amounts formatted from minor units using `currencyUomId`.
- Display a status badge derived from `invoiceStatus`.
- Display a posting badge derived from `postingStatus` / `postingError`.

---

## 9. Service Contracts (Frontend Perspective)

### Load/view calls
1. `InvoiceStatusView.get` (name TBD)
   - Input: `invoiceId`
   - Output: fields listed above
   - Errors: 401/403/404/409/5xx

2. (Optional) `PostingOutcome.getLatestByInvoice` (name TBD)
   - Input: `invoiceId`
   - Output: posting intent/outcome fields
   - Errors: same mapping; 404 treated as ‚Äúno posting record yet‚Äù

### Create/update calls
- None.

### Submit/transition calls
- None.

### Error handling expectations
- Frontend must not retry mutations (none). For loads, allow user-initiated retry via Refresh.
- Preserve correlation identifiers from backend response headers/body if available and display only where intended (see Open Questions).

---

## 10. State Model & Transitions

### Allowed states (display-only)
- Invoice payment status:
  - `Unpaid`
  - `PartiallyPaid`
  - `Paid`
  - `Failed`
  - `Chargeback` (only if backend uses it)

- Posting outcome status (if exposed):
  - `Pending`
  - `Posted`
  - `Failed`

### Role-based transitions
- None in UI (no transitions triggered).

### UI behavior per state
- **Paid:** show ‚ÄúPaid‚Äù status; outstanding = 0 (display what backend returns).
- **PartiallyPaid:** show partial; show paid/outstanding.
- **Unpaid:** show unpaid; hide transaction refs if none.
- **Failed:** show failed; show last transaction ref if present; show guidance ‚Äúpayment failed‚Äù.
- **Chargeback:** show chargeback warning; show original transaction ref if present.
- **Posting Failed:** show posting failure banner + reconciliation fields if present.

---

## 11. Alternate / Error Flows

### Validation failures
- Missing invoiceId ‚Üí inline error and no call.

### Concurrency conflicts
- Backend returns 409 indicating invoice is mid-update ‚Üí show non-blocking message and keep last loaded data if available; allow Refresh.

### Unauthorized access
- 401 ‚Üí redirect to login (if app pattern exists) or show session expired.
- 403 ‚Üí show access denied.

### Empty states
- No payments recorded: show ‚ÄúNo payments recorded yet.‚Äù
- No posting record yet: show ‚ÄúPosting not started/pending‚Äù (only if backend distinguishes; otherwise hide section).

---

## 12. Acceptance Criteria

### Scenario: View a fully paid invoice
**Given** I am an authenticated user with permission to view invoices  
**And** an invoice exists with `invoiceStatus=Paid`, `paidAmountMinor=totalAmountMinor`, `outstandingAmountMinor=0`  
**When** I open the invoice detail screen for that invoice  
**Then** the UI displays Payment Status = ‚ÄúPaid‚Äù  
**And** displays paid/outstanding amounts formatted in the invoice currency  
**And** displays the last payment transaction reference if provided by backend.

### Scenario: View a partially paid invoice
**Given** an invoice exists with `invoiceStatus=PartiallyPaid` and `outstandingAmountMinor > 0`  
**When** I view the invoice  
**Then** the UI displays Payment Status = ‚ÄúPartially Paid‚Äù  
**And** shows both paid and outstanding amounts.

### Scenario: View an unpaid invoice with no payments
**Given** an invoice exists with `invoiceStatus=Unpaid`  
**And** no transaction reference is available  
**When** I view the invoice  
**Then** the UI shows ‚ÄúUnpaid‚Äù  
**And** shows ‚ÄúNo payments recorded yet‚Äù  
**And** does not show a blank transaction reference row.

### Scenario: Payment failed
**Given** an invoice exists with `invoiceStatus=Failed`  
**When** I view the invoice  
**Then** the UI shows Payment Status = ‚ÄúFailed‚Äù  
**And** displays any available transaction reference and failure indicator fields returned by backend.

### Scenario: Posting failed indicator shown
**Given** an invoice status response includes `postingError=true` (or `postingStatus=Failed`)  
**When** I view the invoice  
**Then** the UI displays a ‚ÄúPosting failed‚Äù banner/alert  
**And** displays posting identifiers (postingIntentId/correlationId) if provided  
**And** the UI does not allow editing these values.

### Scenario: Manual refresh updates display
**Given** I am viewing an invoice detail page  
**When** I click ‚ÄúRefresh‚Äù  
**Then** the frontend re-calls the load service(s)  
**And** updates the displayed payment/posting status to the latest returned values.

### Scenario: Invoice not found
**Given** I navigate to an invoiceId that does not exist  
**When** the backend returns 404  
**Then** the UI shows ‚ÄúInvoice not found‚Äù  
**And** does not display stale invoice payment data.

### Scenario: Unauthorized access
**Given** I lack permission to view invoices  
**When** I navigate to an invoice detail page  
**Then** the UI shows ‚ÄúAccess denied‚Äù (403) or login flow (401) per application conventions  
**And** no invoice data is displayed.

---

## 13. Audit & Observability

### User-visible audit data
- Show read-only identifiers useful for audit/reconciliation if returned:
  - last payment `transactionId`
  - posting intent ID
  - correlation ID
  - timestamps for last payment and last posting attempt

### Status history
- If backend provides status history, display a minimal ‚ÄúRecent status changes‚Äù list; otherwise omit (blocking).

### Traceability expectations
- Every displayed transaction/posting identifier should be copyable and clearly labeled.

---

## 14. Non-Functional UI Requirements
- **Performance:** initial load should not block rendering of the rest of invoice detail; payment block may show skeleton/loading state.
- **Accessibility:** status indicators must be conveyed via text, not color alone; keyboard navigation for Refresh.
- **Responsiveness:** payment/posting section must fit mobile POS layouts.
- **i18n/timezone/currency:** format money by currency; format datetimes in user locale/timezone (only if the app already does so; otherwise blocking).

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Show explicit ‚ÄúNo payments recorded yet‚Äù when no payment references are returned; qualifies as UI ergonomics and does not change domain behavior; impacts UX Summary, Error Flows.
- SD-UX-LOADING-SKELETON: Use a loading/skeleton state while fetching; qualifies as UI ergonomics; impacts UX Summary, Functional Behavior.
- SD-ERR-HTTP-MAP: Standard HTTP error-to-message mapping (401/403/404/409/5xx) for read calls; qualifies as standard error-handling mapping; impacts Business Rules, Error Flows, Acceptance Criteria.

---

## 16. Open Questions
1. **Which Moqui screen(s) should be modified/extended?** Provide the canonical invoice detail screen path/name in `durion-moqui-frontend` (e.g., `apps/pos/screen/...`) and navigation pattern.
2. **What are the exact backend service names and response fields?** We need the Moqui service endpoints (or REST paths) for:
   - invoice payment/status view by `invoiceId`
   - latest posting outcome by `invoiceId` (if separate)
3. **What is the authoritative enum set for invoice payment status in this system?** Inputs mention Paid/PartiallyPaid/Unpaid/Failed; backend reference includes Chargeback. Confirm allowed values and display labels.
4. **Authorization/permissions:** what permission(s) gate viewing invoice payment and posting outcome? (We must not infer security boundaries.)
5. **Posting outcome model exposure:** should UI show `postingIntentId`, `correlationId`, retry counts/attempt timestamps, or only a boolean `postingError`? Confirm what is safe for POS users vs finance-only roles.
6. **Do we need status history in UI?** If yes, what entity/service provides it and how many entries to show?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Accounting: Update Invoice Payment Status from Payment Outcomes ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/70  
Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] Accounting: Update Invoice Payment Status from Payment Outcomes

**Domain**: payment

### Story Description

/kiro
# User Story

## Narrative
As the **POS system**, I want to update invoice payment status so that customer balances are accurate.

## Details
- Map payment outcomes to invoice statuses: Paid/PartiallyPaid/Unpaid/Failed.
- Include transaction refs.
- Idempotent updates.

## Acceptance Criteria
- Status updates emitted for accounting.
- Retries and idempotency supported.
- UI reflects latest status.

## Integrations
- POS emits PaymentApplied events; accounting responds with posting confirmation events.

## Data / Entities
- PaymentAppliedEvent, InvoiceStatusView, IdempotencyKey

## Classification (confirm labels)
- Type: Story
- Layer: Experience
- domain :  Point of Sale

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
DOMAIN: security
Total Stories: 6
Generated: dim. 18 janv. 2026 12:03:02 EST
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #106: [FRONTEND] [STORY] Security: Define Roles and Permission Matrix for Product/Pricing ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/106
File: ./scripts/story-work/frontend/106/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:security
- status:draft

### Recommended
- agent:security-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** security-strict

---

## 1. Story Header

### Title
[FRONTEND] [STORY] Security: Admin UI to Manage Roles & Permissions for Product/Pricing Access Control (RBAC)

### Primary Persona
System Administrator (Admin)

### Business Value
Provide a secure, auditable, least-privilege way to configure who can perform financially sensitive product/cost/pricing actions, enabling controlled operations and reducing risk of unauthorized changes.

---

## 2. Story Intent

### As a / I want / So that
- **As an** Admin  
- **I want** a frontend interface to view and manage Roles, Permissions, and Role‚ÜíPermission grants used for product/pricing controls  
- **So that** only authorized staff can change sensitive financial data, and changes are auditable.

### In-scope
- Moqui-based admin screens to:
  - List/view **Permissions** (filterable by domain such as `product`, `pricing`)
  - List/create/edit **Roles**
  - Grant/revoke **Permissions** to/from a **Role** (RolePermission management)
  - View **audit history** related to role/permission changes (read-only)
- Frontend enforcement of authorization **to access these admin screens/actions** (deny-by-default UX behavior when backend returns 401/403).
- Consistent error handling and validation messaging for RBAC mutations.

### Out-of-scope
- Defining the authoritative permission matrix content for product/pricing (exact permission keys and which roles get which permissions) **unless provided**.
- Assigning roles to users/principals (PrincipalRole/UserRole management) unless explicitly confirmed.
- Enforcing permissions in Product/Pricing domain screens themselves (those are separate domain stories).
- Authentication mechanism and IdP integration details (assumed external; handled elsewhere).

---

## 3. Actors & Stakeholders
- **Admin (Primary):** Configures roles and role-permission grants.
- **Security Service (System):** System of record for Role/Permission/RolePermission and audit emission.
- **Product/Pricing domain owners (Stakeholders):** Provide permission manifests and intended mapping guidance.
- **Compliance/Audit stakeholders:** Require visibility into who changed access configuration and when.

---

## 4. Preconditions & Dependencies
- Backend security RBAC APIs exist (from backend story reference #42) and are reachable by Moqui frontend:
  - `GET /permissions` and `GET /permissions?domain=...`
  - Role CRUD endpoints (exact paths TBD)
  - RolePermission grant/revoke endpoints (exact paths TBD)
  - Audit log query endpoint (exact path/filtering TBD)
- Admin authentication is already established (principal available to backend; frontend receives 401/403 appropriately).
- Permission naming convention is enforced server-side: `domain:resource:action`.

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Admin navigation item: **Security ‚Üí Roles & Permissions** (exact menu placement/path TBD).

### Screens to create/modify (Moqui)
Create new screens under an admin/security area, for example:
- `apps/pos/screens/admin/security/Roles.xml`
- `apps/pos/screens/admin/security/RoleDetail.xml`
- `apps/pos/screens/admin/security/Permissions.xml`
- `apps/pos/screens/admin/security/Audit.xml` (scoped to RBAC events)

> If repository conventions differ, align names/paths to `durion-moqui-frontend` README conventions (needs confirmation).

### Navigation context
- Breadcrumb: Admin ‚Üí Security ‚Üí (Roles | Permissions | Audit)
- Cross-links:
  - From Role detail ‚Üí ‚ÄúView granted permissions‚Äù
  - From Permissions list ‚Üí ‚ÄúView roles with this permission‚Äù (optional; only if backend supports query)

### User workflows
**Happy path: Create role + grant permissions**
1. Admin opens Roles list ‚Üí selects ‚ÄúCreate Role‚Äù
2. Enters role name/description ‚Üí saves
3. On Role detail, selects permissions to grant (filtered by domain `product`/`pricing`)
4. Saves grants; sees confirmation and updated list of grants
5. Audit view shows corresponding events

**Alternate paths**
- Admin edits role description only
- Admin revokes a permission from a role
- Admin filters permissions by domain and searches by key substring

---

## 6. Functional Behavior

### Triggers
- Screen load triggers list-fetch services (roles, permissions, audit).
- Form submit triggers create/update/grant/revoke calls.

### UI actions
- Roles list:
  - Search by role name
  - Open Role detail
  - Create new role
- Role detail:
  - Edit role description (role name immutability needs confirmation)
  - Grant permission(s) (single and/or bulk grant; bulk behavior needs confirmation)
  - Revoke permission(s)
- Permissions list:
  - Filter by domain (e.g., `product`, `pricing`)
  - Search by permission key
- Audit view:
  - Filter by event types related to RBAC (exact event types from security guide)
  - Filter by date range
  - Filter by actorId/roleName (if supported)

### State changes
- Role created/updated in backend
- RolePermission created/deleted in backend
- No frontend-local state machine beyond optimistic UI state; backend is authoritative.

### Service interactions
- All mutations call backend services and must handle:
  - `400` validation errors
  - `401` unauthenticated
  - `403` unauthorized (deny-by-default)
  - `404` missing role/permission
  - `409` conflicts (e.g., duplicate role name, duplicate grant, concurrency)

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- Role name:
  - Required
  - Uniqueness handled by backend; frontend shows `409` as ‚ÄúRole name already exists.‚Äù
  - Format/length constraints are unknown ‚Üí must be returned/validated server-side; frontend displays field-level error if provided.
- Permission key:
  - Not editable in UI (permissions are registered code-first); UI is read-only list.
- Grant/revoke:
  - Must reference existing role and permission key; show `404` clearly if backend indicates missing.

### Enable/disable rules
- Disable all mutation controls (create/update/grant/revoke) while request in-flight.
- Disable grant button if no permission selected.
- If backend returns `403`, hide or disable mutation controls for the remainder of the session on that screen (but do not invent permissions; simply reflect denial).

### Visibility rules
- Screens themselves should be protected: if user lacks authorization, route to an ‚ÄúAccess Denied‚Äù screen or show inline denied state (implementation pattern TBD).
- Audit tab visible only if audit endpoint is authorized; otherwise show ‚ÄúNot authorized to view audit history.‚Äù

### Error messaging expectations
- Show top-level error banner for non-field errors.
- Show field-level messages when backend provides structured validation errors (shape TBD ‚Üí open question).

---

## 8. Data Requirements

### Entities involved (conceptual)
- `Role`
- `Permission`
- `RolePermission`
- `AuditLog` (or equivalent audit event read model)

### Fields (type, required, defaults)
**Role**
- `roleId` (string/UUID; read-only)
- `roleName` (string; required; likely immutable after create‚Äîneeds confirmation)
- `description` (string; optional)

**Permission**
- `permissionKey` (string; read-only)
- `domain` (string; read-only; derived from key or stored)
- `description` (string; read-only; optional)
- `deprecated` (boolean; read-only; optional)

**RolePermission**
- `roleId` / `roleName` (reference; read-only on display)
- `permissionKey` (reference; read-only on display)
- `grantedAt` (datetime; read-only; if available)

**AuditLog**
- `timestamp`
- `actorId` (admin principal)
- `eventType` (e.g., `role.permission.grant`)
- `details` (structured; display-friendly summary needs confirmation)
- `outcome` (success/failure/deny)
- `correlationId`

### Read-only vs editable by state/role
- Only authorized admins can edit roles and grants; everyone else gets denied/hidden based on backend authorization.
- Permissions are always read-only.

### Derived/calculated fields
- Permission domain can be derived from `permissionKey` prefix before first `:` for display/filtering when backend doesn‚Äôt provide `domain`.

---

## 9. Service Contracts (Frontend Perspective)

> Exact endpoint paths and payload shapes are **not defined in provided inputs**; below is a frontend contract **template** that must be mapped to actual Moqui services/endpoints once confirmed.

### Load/view calls
- List roles
  - `GET /roles?search=...&page=...`
- Get role detail (including granted permissions)
  - `GET /roles/{roleId}`
  - `GET /roles/{roleId}/permissions`
- List permissions
  - `GET /permissions?domain=pricing`
- Query audit logs (RBAC-related)
  - `GET /audit?eventType=role.permission.grant&from=...&to=...`

### Create/update calls
- Create role
  - `POST /roles` with `{ roleName, description }`
- Update role
  - `PUT /roles/{roleId}` with `{ description }` (and roleName if editable‚ÄîTBD)

### Submit/transition calls (grant/revoke)
- Grant permission to role
  - `POST /roles/{roleId}/permissions` with `{ permissionKey }` (or bulk `{ permissionKeys: [] }`‚ÄîTBD)
- Revoke permission from role
  - `DELETE /roles/{roleId}/permissions/{permissionKey}`

### Error handling expectations
- `400`: show validation messages; map field errors to inputs if provided
- `401`: redirect to login (mechanism TBD) or show session expired
- `403`: show access denied; disable/hide mutation actions
- `404`: show ‚ÄúNot found‚Äù with safe details (role/permission missing)
- `409`: show conflict (duplicate role, duplicate grant, concurrent update)

---

## 10. State Model & Transitions

### Allowed states
- Not a domain state machine; UI has view/edit modes:
  - `viewing`
  - `editing` (role description)
  - `granting` (in-flight mutation)
  - `revoking` (in-flight mutation)

### Role-based transitions
- Transition into screens/actions depends on backend authorization:
  - If backend denies, UI must not provide a path to mutate data (still may allow read-only lists if permitted).

### UI behavior per state
- `viewing`: show data and available actions
- `editing`: enable role fields and save/cancel
- `granting/revoking`: disable controls, show spinner/progress, then refresh role permissions list on success

---

## 11. Alternate / Error Flows

### Validation failures
- Creating role with missing name ‚Üí show required error
- Backend rejects roleName format/length ‚Üí show backend message
- Grant with invalid permission key (should not happen if selected from list) ‚Üí show error and refresh permissions list

### Concurrency conflicts
- If two admins edit same role:
  - On `409`/ETag mismatch (if implemented), show ‚ÄúRole changed; reload required‚Äù and provide reload action (ETag support TBD).

### Unauthorized access
- Direct navigation to Security admin screens:
  - If backend returns `403` on initial load, show Access Denied screen/state.
- Partial authorization:
  - If roles list loads but audit query returns `403`, show audit as unavailable.

### Empty states
- No roles exist ‚Üí show empty state with ‚ÄúCreate Role‚Äù if authorized.
- No permissions for selected domain ‚Üí show ‚ÄúNo permissions registered for domain‚Äù and link to guidance (no guessing of registration steps).

---

## 12. Acceptance Criteria

### Scenario 1: View permissions filtered by domain
**Given** I am an authenticated Admin authorized to view permissions  
**When** I open the Permissions screen and select domain filter `pricing`  
**Then** I see a list of permissions whose keys begin with `pricing:` (or whose domain is `pricing`)  
**And** each permission is read-only (cannot edit key).

### Scenario 2: Create a new role
**Given** I am authorized to create roles  
**When** I submit a new role with a unique role name and optional description  
**Then** the role is created successfully  
**And** I am routed to the Role Detail screen for the new role.

### Scenario 3: Prevent duplicate role names
**Given** a role named `PricingAnalyst` already exists  
**And** I am authorized to create roles  
**When** I try to create another role named `PricingAnalyst`  
**Then** I receive a conflict error  
**And** the UI shows ‚ÄúRole name already exists‚Äù without creating a duplicate.

### Scenario 4: Grant a permission to a role
**Given** I am authorized to modify role permissions  
**And** a role exists  
**And** the permission `pricing:price_book:edit` exists in the permissions registry  
**When** I grant `pricing:price_book:edit` to the role  
**Then** the granted permissions list for that role includes `pricing:price_book:edit` after refresh  
**And** the UI shows a success confirmation.

### Scenario 5: Revoke a permission from a role
**Given** a role has permission `pricing:price_book:edit` granted  
**And** I am authorized to modify role permissions  
**When** I revoke `pricing:price_book:edit` from the role  
**Then** the role no longer shows that permission in its granted list  
**And** the UI shows a success confirmation.

### Scenario 6: Access denied for unauthorized user
**Given** I am authenticated but not authorized to manage roles/permissions  
**When** I open the Roles & Permissions area  
**Then** the UI shows an Access Denied state  
**And** no role/permission mutation controls are available.

### Scenario 7: Audit visibility for RBAC changes
**Given** I am authorized to view audit logs  
**When** I open the Audit view filtered to RBAC events  
**Then** I see entries for role/permission changes including timestamp, actorId, eventType, and outcome.

---

## 13. Audit & Observability

### User-visible audit data
- Provide an Audit tab/view showing RBAC change events (read-only) with:
  - timestamp
  - actor/principal identifier
  - event type (e.g., `role.permission.grant`, `role.permission.revoke`, `role.created`, `role.updated`, `permission.registered`, `principal.role.assign` if present)
  - target identifiers (roleName/roleId, permissionKey where applicable)
  - correlationId (display optional; useful for support)

### Status history
- Not applicable beyond audit entries for changes.

### Traceability expectations
- Frontend should pass/propagate `correlationId` if the platform has a standard header (TBD); otherwise rely on backend-generated correlation IDs and display them when returned.

---

## 14. Non-Functional UI Requirements
- **Performance:** Lists should support pagination for large permission registries (page size configurable).
- **Accessibility:** All form controls keyboard-navigable; proper labels; error messages associated to fields.
- **Responsiveness:** Usable on tablet widths; admin pages may be desktop-first but must not break on smaller screens.
- **i18n/timezone:** Display timestamps in user‚Äôs locale/timezone (source timezone from backend; formatting handled in UI).

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide explicit empty states for no roles/permissions results; safe because it does not change domain behavior and only affects presentation. (Impacted: UX Summary, Alternate/Empty states)
- SD-UX-PAGINATION: Add pagination controls to roles/permissions lists; safe because it‚Äôs a UI ergonomics concern and backend already implies list querying. (Impacted: UX Summary, Service Contracts)
- SD-ERR-HTTP-MAP: Standard mapping of HTTP 400/401/403/404/409 to user-facing messages; safe because it follows backend contract patterns without inventing policies. (Impacted: Service Contracts, Error Flows)

---

## 16. Open Questions
1. **Backend endpoints & schemas:** What are the exact REST paths, request/response schemas, and error shapes for Role CRUD, RolePermission grant/revoke, and AuditLog query in `pos-security-service`?
2. **Authorization scope:** Which permission(s) gate access to:
   - viewing roles
   - creating/updating roles
   - granting/revoking permissions
   - viewing audit logs  
   (Per security agent contract, we cannot invent permission names.)
3. **Role name mutability:** Is `roleName` editable after creation, or immutable with only `description` editable?
4. **Role assignment UI:** Is PrincipalRole/UserRole assignment **in scope** for this frontend story (assign roles to users/groups), or explicitly deferred?
5. **Location overrides:** The synopsis mentions ‚Äúpermissions mapped to actions including location overrides.‚Äù Is there any UI requirement now for location-scoped grants/overrides (ABAC-like), or is this strictly global RBAC for this story?
6. **Audit API & retention:** What audit event types are available via the query API, and does the backend return structured `details` suitable for display, or only unstructured text?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Security: Define Roles and Permission Matrix for Product/Pricing ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/106

====================================================================================================

FRONTEND STORY (FULL CONTEXT)

====================================================================================================

Title: [FRONTEND] [STORY] Security: Define Roles and Permission Matrix for Product/Pricing
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/106
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Security: Define Roles and Permission Matrix for Product/Pricing

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As an **Admin**, I want roles/permissions for product/cost/pricing actions so that only authorized staff can change financially sensitive data.

## Details
- Roles: ProductAdmin, PricingAnalyst, StoreManager, ServiceAdvisor, IntegrationOperator.
- Permissions mapped to actions including location overrides.

## Acceptance Criteria
- Permissions enforced.
- Role changes audited.
- Least-privilege defaults.

## Integrations
- Integrates with durion-hr/security identity & role assignment.

## Data / Entities
- Role, Permission, RolePermission, UserRole, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Product / Parts Management


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

====================================================================================================

END BACKEND REFERENCES

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #126: [FRONTEND] [STORY] Security: Define Shop Roles and Permission Matrix  
File: ./scripts/story-work/frontend/126/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:security
- status:draft

### Recommended
- agent:security-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** security-strict

STOP: Clarification required before finalization

---

# 1. Story Header

## Title
[FRONTEND] [STORY] Security: Define Shop Roles and Permission Matrix (RBAC Admin UI)

## Primary Persona
System Administrator / Admin (authorized to manage RBAC)

## Business Value
Enable administrators to manage roles and assign permissions so sensitive shop operations (e.g., schedule overrides, time approval) are enforced consistently and changes are auditable.

---

# 2. Story Intent

## As a / I want / So that
**As an** Admin,  
**I want** to create/edit roles and assign predefined permissions (and optionally assign roles to users),  
**So that** only authorized staff can perform protected shop actions, and RBAC configuration changes are traceable.

## In-scope
- Moqui frontend screens to:
  - List roles
  - Create role
  - Edit role (name/description)
  - Assign/unassign permissions to a role
  - View role details including assigned permissions
- UI enforcement of access to RBAC admin screens (deny-by-default behavior when unauthorized).
- Display of audit information for RBAC changes **if backend exposes it** (see Open Questions).

## Out-of-scope
- Creating new Permission keys from the UI (permissions are predefined/registered elsewhere).
- Defining authentication/IdP flows.
- Implementing backend RBAC services/entities (assumed available via Moqui services or REST).
- Downstream feature-level enforcement across the whole POS UI (this story provides the admin configuration UI; individual feature screens enforcing specific permissions is separate unless already wired).

---

# 3. Actors & Stakeholders
- **Admin (primary)**: manages roles and permission assignments.
- **Shop Staff (indirect)**: experience allow/deny outcomes on protected actions.
- **Security/Audit stakeholders**: need traceability of changes.
- **Developers/Testers**: need deterministic UI + service interaction behavior.

---

# 4. Preconditions & Dependencies
- Moqui app is running with authentication already in place (principal available in session).
- Backend capabilities exist for:
  - Role CRUD
  - Permission list retrieval
  - Role‚ÜîPermission assignment mutation
  - (Optional) User‚ÜîRole assignment mutation (mentioned in inputs but not explicitly required for frontend scope‚Äîsee Open Questions)
- Authorization checks exist to protect RBAC admin operations (backend returns 401/403 as appropriate).
- A canonical list of permissions exists (predefined; not created by admin in UI).

---

# 5. UX Summary (Moqui-Oriented)

## Entry points
- Admin navigation: **Security ‚Üí Roles & Permissions** (final menu placement depends on existing Moqui menu structure).

## Screens to create/modify (Moqui)
1. **`apps/pos/security/RoleList.xml`**
   - Lists roles, supports search/filter, and navigation to create/edit/detail.
2. **`apps/pos/security/RoleCreate.xml`**
   - Form to create a role (name, description).
3. **`apps/pos/security/RoleDetail.xml`**
   - View role metadata and permissions; entry to edit.
4. **`apps/pos/security/RoleEdit.xml`**
   - Edit role fields + permission assignment UI (multi-select or dual-list).
5. (Optional, if in-scope after clarification) **`apps/pos/security/UserRoleAssignments.xml`**
   - Assign roles to users.

## Navigation context
- Standard breadcrumb: Security ‚Üí Roles ‚Üí (Role Name)
- Role detail and edit accessible from list.

## User workflows
### Happy path: create role and assign permissions
1. Admin opens Role List.
2. Admin clicks ‚ÄúCreate Role‚Äù.
3. Enters role name + description; saves.
4. Navigates to Role Edit/Detail.
5. Adds permissions (predefined list); saves assignments.

### Alternate path: remove permission
1. Admin opens Role Edit.
2. Removes a permission; saves.
3. UI confirms success; updated permission list displayed.

### Unauthorized path
- Non-admin attempts to access any RBAC screens ‚Üí show access denied screen/message; no data leakage.

---

# 6. Functional Behavior

## Triggers
- Route entry to RBAC screens
- Form submit actions (create/update)
- Permission assignment save action

## UI actions (explicit)
- **Role List**
  - Search by role name (contains/starts-with; see safe defaults)
  - Click role row ‚Üí Role Detail
  - Create button ‚Üí Role Create
- **Role Create**
  - Inputs: roleName (required), description (optional)
  - Save ‚Üí creates role, then transitions to Role Detail (or Edit)
  - Cancel ‚Üí back to Role List
- **Role Edit**
  - Update role metadata (name/description) and save
  - Permission assignment widget:
    - Load all permissions
    - Load current role‚Äôs permissions
    - Add/remove permissions in UI
    - Save assignment changes (batch save preferred)
- **Role Detail**
  - Read-only display of role and assigned permissions
  - Edit button ‚Üí Role Edit

## State changes
- Role created/updated/deleted (if delete is included; not explicitly requested for frontend‚Äîsee Open Questions)
- RolePermission assignments created/removed

## Service interactions (Moqui)
- Use Moqui `service-call` (or REST via screen transitions) to:
  - Fetch roles list
  - Create/update role
  - Fetch permissions list
  - Fetch role permissions
  - Update role permissions (grant/revoke or replace)

---

# 7. Business Rules (Translated to UI Behavior)

## Validation
- **Role name required** (client-side required + server-side enforcement)
- **Role name uniqueness**: if backend returns conflict (likely 409) for duplicate role names (case-insensitive), UI must:
  - Keep user on form
  - Highlight role name field
  - Show error: ‚ÄúRole name already exists.‚Äù
- **Permission assignment validity**:
  - UI must only allow selecting from permissions returned by backend (no free-text permission keys).
  - If backend rejects assignment due to invalid permission key / missing role, display returned message and reload current state.

## Enable/disable rules
- Save buttons disabled while request in-flight (prevent double-submit).
- Permission assignment save disabled if no changes compared to loaded state (diff-based) OR allow idempotent save (see safe defaults).

## Visibility rules
- RBAC admin menu and screens should be hidden or blocked for unauthorized users.
  - If permission/role gating mechanism exists in frontend, use it for hiding.
  - Regardless, backend 403 must be handled correctly (cannot rely on hiding alone).

## Error messaging expectations
- 401: ‚ÄúYour session has expired. Please sign in again.‚Äù
- 403: ‚ÄúYou do not have access to manage roles and permissions.‚Äù
- 404: ‚ÄúRole not found.‚Äù (when navigating to unknown roleId)
- 409: ‚ÄúConflict: role name already exists.‚Äù or backend-provided message
- Generic 5xx/network: ‚ÄúSomething went wrong. Try again.‚Äù

---

# 8. Data Requirements

## Entities involved (conceptual; backend-owned)
- `Role`
- `Permission`
- `RolePermission`
- `UserRole` (only if role assignment UI included)

## Fields
### Role
- `roleId` (string/UUID, read-only)
- `roleName` (string, required, unique case-insensitive)
- `description` (string, optional)
- `createdAt` / `updatedAt` (read-only; display optional)

### Permission
- `permissionKey` (string; stable identifier)
- `description` (string; display label)

### RolePermission (derived for UI)
- `roleId` (read-only)
- `permissionKey` (selected from list)

## Read-only vs editable
- Editable: roleName, description, role‚Äôs permission assignments
- Read-only: IDs, timestamps, permission keys (select-only, not editable)

## Derived/calculated fields
- Effective permission count per role (derived; show in list if available)
- ‚ÄúChanged‚Äù state for permissions assignment (diff between loaded and selected)

---

# 9. Service Contracts (Frontend Perspective)

> Concrete service names/endpoints are not provided in inputs; Moqui implementation must bind to whatever the backend exposes. This section defines **required capabilities** and expected request/response semantics; exact service names are an Open Question.

## Load/view calls
- **List Roles**
  - Input: paging (pageIndex/pageSize), optional roleName filter
  - Output: array of roles with roleId, roleName, description
- **Get Role**
  - Input: roleId
  - Output: role object
- **List Permissions**
  - Input: optional domain filter (if supported)
  - Output: list of permissions (permissionKey, description)
- **Get Role Permissions**
  - Input: roleId
  - Output: list of permissionKeys (or permission objects)

## Create/update calls
- **Create Role**
  - Input: roleName, description
  - Output: created role (including roleId)
  - Errors: 400 validation, 409 duplicate
- **Update Role**
  - Input: roleId, roleName, description
  - Output: updated role
  - Errors: 400/404/409

## Submit/transition calls
- **Update Role Permissions**
  - Preferred: replace set (idempotent)
    - Input: roleId, permissionKeys[]
  - Alternate: incremental grant/revoke
    - Input: roleId, permissionKey, action=(grant|revoke)
  - Output: success + updated permissions
  - Errors: 400 invalid key, 404 role not found

## Error handling expectations
- Moqui screens must map backend errors into:
  - Field errors (roleName duplicates/invalid)
  - Top-level banner for authorization/network
- After failed permission save, UI must reload role permissions from server to avoid drift if partial updates occurred.

---

# 10. State Model & Transitions

## Allowed states
- No explicit lifecycle states provided for Role/Permission in inputs.
- Treat role as active if it exists.

## Role-based transitions
- Transition into any RBAC screen requires an admin authorization check (server-enforced).
- Mutation actions require authorization.

## UI behavior per state
- **Unauthorized**: show access denied; do not render data tables/forms.
- **Loading**: show spinner/skeleton; disable actions.
- **Saving**: disable save; show progress indicator.
- **Error**: show error banner; preserve user input when safe.

---

# 11. Alternate / Error Flows

## Validation failures
- Missing roleName ‚Üí inline validation; prevent submit.
- Backend 400 ‚Üí display field-level or form-level message from response.

## Concurrency conflicts
- Two admins edit same role:
  - If backend supports optimistic locking (not specified), handle 409 with message: ‚ÄúRole was updated by someone else. Reload and try again.‚Äù
  - If not supported, last write wins; UI should reload after save to show canonical state. (Needs clarification.)

## Unauthorized access
- Direct URL navigation to RBAC screens without permission:
  - Backend returns 403
  - UI shows access denied and does not leak role/permission lists.

## Empty states
- No roles exist:
  - Show empty table message and a ‚ÄúCreate Role‚Äù CTA (if authorized).
- No permissions returned:
  - Permission assignment section shows ‚ÄúNo permissions available‚Äù and disables save.

---

# 12. Acceptance Criteria (Gherkin)

## Scenario 1: Authorized admin can view roles list
**Given** I am authenticated as a user authorized to manage roles and permissions  
**When** I navigate to Security ‚Üí Roles & Permissions  
**Then** I see a list of roles loaded from the backend  
**And** each role shows at least its name  
**And** I can open a role‚Äôs detail screen

## Scenario 2: Unauthorized user is blocked from RBAC screens
**Given** I am authenticated as a user not authorized to manage roles and permissions  
**When** I navigate directly to the Roles & Permissions URL  
**Then** the system shows an ‚ÄúAccess denied‚Äù message  
**And** no role or permission data is displayed

## Scenario 3: Admin can create a role
**Given** I am authorized to manage roles and permissions  
**When** I create a role with role name ‚ÄúShopManager‚Äù and a description  
**Then** the role is created successfully  
**And** I am taken to the role detail (or edit) view for the new role  
**And** the role appears in the roles list

## Scenario 4: Duplicate role name is rejected
**Given** I am authorized to manage roles and permissions  
**And** a role named ‚ÄúShopManager‚Äù already exists (case-insensitive)  
**When** I attempt to create a role named ‚Äúshopmanager‚Äù  
**Then** the system prevents creation  
**And** I see an error indicating the role name already exists  
**And** my entered form values remain visible for correction

## Scenario 5: Admin can assign permissions to a role
**Given** I am authorized to manage roles and permissions  
**And** a role ‚ÄúShopManager‚Äù exists  
**And** the permissions list includes ‚ÄúSCHEDULE_OVERRIDE‚Äù and ‚ÄúTIME_APPROVAL‚Äù  
**When** I open the role edit screen for ‚ÄúShopManager‚Äù  
**And** I select ‚ÄúSCHEDULE_OVERRIDE‚Äù and ‚ÄúTIME_APPROVAL‚Äù  
**And** I save permission assignments  
**Then** the role detail shows exactly those permissions assigned  
**And** reloading the page still shows those permissions assigned

## Scenario 6: Admin can remove a permission from a role
**Given** I am authorized to manage roles and permissions  
**And** a role ‚ÄúShopManager‚Äù has permission ‚ÄúTIME_APPROVAL‚Äù assigned  
**When** I remove ‚ÄúTIME_APPROVAL‚Äù from the role and save  
**Then** the role no longer shows ‚ÄúTIME_APPROVAL‚Äù assigned after reload

## Scenario 7: Backend rejects invalid permission assignment
**Given** I am authorized to manage roles and permissions  
**And** the backend returns an error when saving role permissions  
**When** I attempt to save permission assignments  
**Then** I see an error message returned by the backend (or a generic error)  
**And** the UI reloads the role‚Äôs assigned permissions from the backend to reflect the canonical state

---

# 13. Audit & Observability

## User-visible audit data
- If backend provides audit events for RBAC changes:
  - Role detail screen should include an ‚ÄúAudit‚Äù section showing recent changes (event type, actor, timestamp, summary).
- If not available:
  - UI does not fabricate audit history; this remains backend-only.

## Status history
- Not applicable unless backend provides change history.

## Traceability expectations
- All mutation requests should include/propagate a correlation/request ID if the frontend framework supports it (Moqui requestId).
- UI should log (client console only in dev) minimal debug info; do not log sensitive identity tokens.

---

# 14. Non-Functional UI Requirements
- **Performance**: Role list loads within 2 seconds for up to 200 roles (paged).
- **Accessibility**: Forms have labels, validation messages are announced (aria-live), keyboard navigation supported for permission selection.
- **Responsiveness**: Works on tablet widths; tables wrap or stack columns gracefully.
- **i18n**: All user-facing strings routed through existing i18n mechanism (if present in repo).
- **Security**: Do not expose internal IDs in URLs beyond roleId already required; never log tokens/PII.

---

# 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide explicit empty states for ‚Äúno roles‚Äù and ‚Äúno permissions‚Äù to avoid ambiguous blank screens; qualifies as safe UI ergonomics. (UX Summary, Error Flows)
- SD-UX-PAGINATION: Paginate Role List with default page size (e.g., 25) and basic name filter; safe and reversible UI ergonomics. (UX Summary, Service Contracts)
- SD-ERR-MAP-HTTP: Standard mapping of HTTP 400/401/403/404/409/5xx into inline vs banner errors; safe because it does not change domain policy, only presentation. (Business Rules, Error Flows)

---

# 16. Open Questions
1. **Backend service contract for Moqui:** What are the exact Moqui service names (or REST endpoints) for:
   - listRoles, getRole, createRole, updateRole
   - listPermissions
   - getRolePermissions, updateRolePermissions (replace vs grant/revoke)?
2. **Authorization gating:** What permission(s) control access to RBAC admin screens and mutation actions? (Story must not invent permission keys or role hierarchy.)
3. **Role deletion:** Is deleting roles in-scope for the frontend? If yes, what are constraints (cannot delete if assigned to users? soft delete vs hard delete)?
4. **User‚ÜîRole assignment UI:** The input mentions `UserRole`. Is role assignment to users required in this frontend story, or handled elsewhere?
5. **Audit visibility:** Does the backend expose an audit query API for RBAC events (ROLE_CREATED/UPDATED/etc.)? If yes, what is the endpoint and schema?
6. **Multi-tenant/location scoping:** Are roles/permissions global to tenant, or scoped per location/shop? How is tenant/location derived in UI requests?
7. **Optimistic locking/concurrency:** Does Role update use versioning/ETag for conflict detection? If so, what field/header should the UI send and how should 409 be handled?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Security: Define Shop Roles and Permission Matrix  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/126  
Labels: frontend, story-implementation, user  

## Frontend Implementation for Story

**Original Story**: [STORY] Security: Define Shop Roles and Permission Matrix

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As an **Admin**, I want to define shop roles and permissions so that only authorized staff can override schedules or approve time.

## Details
- Roles: Dispatcher, ServiceAdvisor, ShopManager, MobileLead, Mechanic.
- Permissions stored and enforced.

## Acceptance Criteria
- Configurable roles/permissions.
- Access checks enforced.
- Changes audited.

## Integrations
- Integrates with durion-hr / security identities and role assignments.

## Data / Entities
- Role, Permission, RolePermission, UserRole

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Shop Management


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #155: [FRONTEND] [STORY] Users: Provision User and Link to Person  
File: ./scripts/story-work/frontend/155/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:security
- status:draft

### Recommended
- agent:security-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** security-strict

STOP: Clarification required before finalization

---

## 1. Story Header

### Title
[FRONTEND] Users: Provision User and Link to Person

### Primary Persona
Admin (authorized to provision users)

### Business Value
Enable an employee to authenticate and be correctly attributed across downstream systems (workexec/timekeeping/shopmgr) by provisioning a platform `User` and initiating linkage to an existing `Person`.

---

## 2. Story Intent

### As a / I want / So that
- **As an** Admin  
- **I want** to provision a new system `User` (credentials identity + initial roles) and initiate linking it to an existing `Person`  
- **So that** the employee can log in and is correctly attributed across downstream services.

### In-scope
- A Moqui/Quasar frontend flow to:
  - Search/select an existing `Person` (by email at minimum) to link
  - Capture user identity fields (username/email) and status
  - Select initial role assignments
  - Submit provisioning request to security orchestration endpoint
  - Show immediate success (async linking happens after)
  - Show ‚Äúlink pending/unconfirmed‚Äù messaging when appropriate
  - Display errors from provisioning endpoint with actionable messaging

### Out-of-scope
- Creating/editing `Person` records (people domain)
- Implementing/defining RBAC permission keys, role hierarchies, or authorization mechanisms
- Implementing the event consumer/linking in `pos-people` (backend responsibility)
- Downstream integrations beyond reflecting linkage status in UI (if available)

---

## 3. Actors & Stakeholders
- **Admin user**: initiates provisioning
- **Security service (pos-security-service)**: system of record for `User`, hosts provisioning endpoint
- **People service (pos-people)**: system of record for `Person` and `UserPersonLink`, consumes provisioning event
- **Downstream services**: workexec/timekeeping/shopmgr rely on link for attribution and staff visibility

---

## 4. Preconditions & Dependencies
- Admin is authenticated in the frontend and has authorization to access user provisioning UI and submit provisioning.
- A `Person` already exists in `pos-people` with a stable `personId`.
- Backend endpoints exist and are reachable from Moqui frontend:
  - Security: provision user (idempotent) and assign initial roles (as part of provisioning)
  - People: search person by email (or list/search people) to choose the target `personId`
- Correlation/request ID propagation is supported (header or field) from frontend to backend (exact mechanism TBD).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Admin navigation: **Users ‚Üí Provision User** (exact menu location TBD in app nav)

### Screens to create/modify
- Create new Moqui screen (suggested path/name, adjust to repo conventions):
  - `component://frontend/screen/admin/users/ProvisionUser.xml` (or equivalent)
- Optionally modify Users admin index screen to add a link/button to provisioning flow.

### Navigation context
- Standard admin layout and breadcrumb trail:
  - Admin Home ‚Üí Users ‚Üí Provision User

### User workflows

#### Happy path
1. Admin opens ‚ÄúProvision User‚Äù.
2. Admin searches for an existing Person by email (and/or name if supported) and selects exactly one person.
3. Admin enters/confirm user identity fields (username/email) and selects status.
4. Admin selects one or more initial roles.
5. Admin submits.
6. UI shows success: user provisioned; linking will complete asynchronously.
7. UI shows returned identifiers (at least `userId`, `personId`) and a ‚ÄúLink status: Pending‚Äù (unless backend can confirm linked immediately).

#### Alternate paths
- Person not found: show empty state and guidance (cannot proceed until a Person exists).
- User already exists (idempotent resolve): UI still shows success and returned `userId`; messaging indicates ‚ÄúExisting user resolved‚Äù.
- Backend returns validation errors: UI highlights relevant fields.
- Backend returns unauthorized: UI shows ‚ÄúAccess denied‚Äù and does not reveal sensitive details.

---

## 6. Functional Behavior

### Triggers
- Screen load: initialize form state; optionally prefill email if passed as query param (only if existing patterns support it).
- Person search action (type-to-search or explicit Search button).
- Submit action: ‚ÄúProvision User‚Äù.

### UI actions
- Person search input and results list; selecting a Person populates a read-only `personId` and displays Person summary.
- Provisioning form fields enabled only when a Person is selected.
- Role selection control (multi-select) populated from roles source (endpoint TBD).
- Submit button disabled until required fields are valid.

### State changes (frontend)
- Maintain view-state:
  - `idle` ‚Üí `searchingPerson` ‚Üí `personSelected`
  - `submitting` ‚Üí `success` | `error`
- After success:
  - Store and display returned `userId`
  - Display link status as `pending` unless backend provides a definitive linked indicator

### Service interactions
- People lookup:
  - Search Persons by email (primary) to get `personId` and display fields
- Security provisioning:
  - Submit provisioning request with selected `personId`, identity fields, status, and initial roles
- Optional status check (only if endpoint exists):
  - Query for linkage status `UserPersonLink` by `userId` or `personId`

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- Required:
  - `personId` (must be selected from search results; not free text)
  - `email` (format-valid; see Open Questions for whether it must match Person email)
  - `username` (required unless backend derives from email; TBD)
  - `status` (must be one of allowed statuses; enumeration TBD)
  - `initialRoles` (required? TBD‚Äîstory says ‚Äúinitial role assignments‚Äù but not whether empty is allowed)
- Client-side validation mirrors backend constraints where known; backend remains authoritative.

### Enable/disable rules
- Disable provisioning form until Person selected.
- Disable Submit while submitting, or if required fields invalid/missing.

### Visibility rules
- Show selected Person summary once selected (at minimum: name + email + personId).
- Show success panel with returned IDs and audit/correlation info if provided.

### Error messaging expectations
- Map HTTP errors:
  - `400`: show field-level validation messages where possible, else a form-level message.
  - `401`: prompt re-authentication (standard app behavior).
  - `403`: show access denied and hide admin-only details.
  - `404`: if person lookup returns none, show ‚ÄúNo matching person found‚Äù.
  - `409`: show conflict message (e.g., duplicate username/email) with next steps.
  - `5xx`: show generic error and allow retry (idempotent safe).

---

## 8. Data Requirements

### Entities involved (frontend perspective)
- Security domain:
  - `User` (security system of record; returned identifiers/status)
  - `Role` (for selection)
- People domain:
  - `Person` (search/select)
  - `UserPersonLink` (status/confirmation display if queryable)

### Fields

#### Person (read/search)
- `personId` (string/UUID; required; read-only)
- `email` (string; required for search/display)
- `firstName`/`lastName` (string; optional display)
- Other fields: out of scope

#### Provision request (write)
- `personId` (string/UUID; required)
- `username` (string; required? TBD)
- `email` (string; required)
- `status` (enum/string; required; values TBD)
- `initialRoleIds` or `initialRoleNames` (array; required? TBD; identifier type TBD)
- `correlationId` (string; optional; if frontend provides)

#### Provision response (read)
- `userId` (string/UUID; required)
- `personId` (string/UUID; required)
- `resolvedExisting` (boolean; optional)
- `eventEnqueued` (boolean; optional)
- `correlationId` (string; optional)
- `occurredAt` (datetime; optional)

### Read-only vs editable by state/role
- All fields editable only for authorized Admins; otherwise screen should deny access (403 handling).
- After success, form becomes read-only unless admin clicks ‚ÄúProvision another user‚Äù to reset.

### Derived/calculated fields
- `linkStatus` (derived):
  - Default to `PENDING` after success unless backend confirms linked
  - If a link-status endpoint exists, derive from returned link record

---

## 9. Service Contracts (Frontend Perspective)

> Note: Concrete Moqui service names/endpoints are not defined in provided inputs; these are placeholders that require confirmation.

### Load/view calls
1. **Search Person**
   - Request: `GET /people?email=<query>` or `GET /people/search?email=...`
   - Response: list of persons with `personId`, `email`, names
2. **Load Roles for selection**
   - Request: `GET /roles` (security) or equivalent
   - Response: list of roles (id + displayName)

### Create/update calls
- None (people/person creation is out of scope)

### Submit/transition calls
1. **Provision user**
   - Request: `POST /users/provision`
   - Body: `{ personId, username, email, status, initialRoles[] }`
   - Response: `{ userId, personId, correlationId?, resolvedExisting? }`
   - Behavior: returns success without waiting for linking completion

### Error handling expectations
- Backend returns standard HTTP statuses per security checklist; frontend maps as in Business Rules.
- Idempotency: repeated submit due to network retry should not create duplicates; UI should allow retry on safe failure and display resolvedExisting when available.

---

## 10. State Model & Transitions

### Allowed states (frontend workflow state)
- `DRAFT` (editing; not submitted)
- `SUBMITTING`
- `PROVISIONED_PENDING_LINK` (success; async link pending)
- `PROVISIONED_LINKED` (if link confirmation available)
- `ERROR` (submission failed)

### Role-based transitions
- Only authorized Admin can transition `DRAFT ‚Üí SUBMITTING`.
- Unauthorized users attempting to access screen or submit are blocked (`403`).

### UI behavior per state
- `DRAFT`: editable form, submit enabled when valid.
- `SUBMITTING`: disable inputs and submit; show progress indicator.
- `PROVISIONED_PENDING_LINK`: show success details; optional ‚ÄúCheck link status‚Äù if supported.
- `PROVISIONED_LINKED`: show confirmed link info.
- `ERROR`: show error summary; keep form values for correction; allow retry.

---

## 11. Alternate / Error Flows

### Validation failures
- If backend returns field errors (400):
  - Highlight corresponding fields
  - Keep Person selection intact
  - Do not clear role selection

### Concurrency conflicts
- If two admins provision same identity simultaneously and backend returns `409`:
  - Show conflict message and suggest ‚ÄúSearch existing user‚Äù (link TBD) or retry
  - Do not attempt automatic resolution client-side unless backend provides resolution semantics

### Unauthorized access
- If `401`: route to login flow (existing app behavior)
- If `403`: show access denied page/state; do not show provisioning form

### Empty states
- Person search returns no results:
  - Show ‚ÄúNo person found for that email‚Äù
  - Provide guidance: ‚ÄúCreate the person record first‚Äù (link to People screen if exists; otherwise plain text)

---

## 12. Acceptance Criteria

### Scenario 1: Successful provisioning with pending link
**Given** I am authenticated as an Admin authorized to provision users  
**And** a Person exists with a known email and `personId`  
**When** I search for the person by email and select the result  
**And** I enter required user fields and select initial roles  
**And** I submit the Provision User form  
**Then** the frontend sends a provisioning request containing `personId` and the entered user fields  
**And** I see a success confirmation including the returned `userId` and `personId`  
**And** I see messaging that linking completes asynchronously (pending)

### Scenario 2: Idempotent retry resolves existing user
**Given** I am authenticated as an authorized Admin  
**And** a previous provisioning attempt for the same identity already created the user  
**When** I submit the provisioning form again with the same identity inputs  
**Then** the frontend displays success (not duplicate-created)  
**And** the response indicates the user was resolved as existing (if backend provides such a flag)  
**And** the displayed `userId` matches the existing user

### Scenario 3: Person not found blocks provisioning
**Given** I am authenticated as an authorized Admin  
**When** I search for a Person by an email that does not exist  
**Then** I see an empty-state message indicating no matching person was found  
**And** the Provision User submit action remains disabled until a Person is selected

### Scenario 4: Backend validation error is shown
**Given** I am authenticated as an authorized Admin  
**And** I have selected a Person  
**When** I submit the form with an invalid email format (or other invalid field)  
**Then** the backend returns a 400 validation error  
**And** the frontend displays the validation message and indicates which field must be corrected  
**And** my entered values remain so I can fix and resubmit

### Scenario 5: Unauthorized access is denied
**Given** I am authenticated as a user without provisioning authorization  
**When** I navigate to Users ‚Üí Provision User  
**Then** I receive an access denied experience (403 handling)  
**And** I cannot submit provisioning requests

---

## 13. Audit & Observability

### User-visible audit data
- After successful provisioning, display (if returned):
  - `correlationId`
  - `occurredAt`
  - ‚ÄúProvisioned by: <current admin>‚Äù (only if available from session; do not fabricate backend audit)

### Status history
- UI should not attempt to build a full audit trail unless an audit endpoint exists.
- If link status endpoint exists, show last-checked time and current status.

### Traceability expectations
- Frontend should pass/propagate a correlation/request ID (mechanism TBD) and log client-side (console/dev logging per project conventions) without exposing sensitive tokens/PII.

---

## 14. Non-Functional UI Requirements
- Performance: Person search should debounce input (e.g., 300ms) to avoid excessive calls (safe UI default).
- Accessibility: All form controls have labels; errors are announced and associated with fields.
- Responsiveness: Screen usable on tablet/desktop; form layout adapts without losing required information.
- i18n/timezone/currency: Not applicable beyond standard localization of dates if `occurredAt` displayed.

---

## 15. Applied Safe Defaults
- SD-UX-01 Debounced search input: Assume a 300ms debounce on person email search to reduce API load; qualifies as safe UI ergonomics. Impacted sections: UX Summary, Functional Behavior, Non-Functional.
- SD-ERR-01 Standard HTTP-to-UI mapping: Use conventional handling for 400/401/403/404/409/5xx without inventing domain policy; safe because it mirrors backend status semantics. Impacted sections: Business Rules, Error Flows, Acceptance Criteria.

---

## 16. Open Questions

1. **Permissions/Access Control (blocking):** What permission(s) (keys) gate:
   - Viewing the Provision User screen
   - Submitting `POST /users/provision`
   (Security contract forbids inventing permission names.)

2. **Endpoint contracts (blocking):** What are the exact Moqui-accessible endpoints/services for:
   - Person search/select (people service) including response fields
   - Role list for selection (security service) including identifier type (roleId vs roleName)
   - Provision user request/response schema and error shape

3. **Identity rules (blocking):**
   - Is `username` required, or is it derived from email by backend?
   - Must provisioned user email **match** the selected Person‚Äôs email exactly, or can it differ?

4. **User status enumeration (blocking):** What are allowed `status` values and default?

5. **Initial role assignment rule (blocking):** Are zero roles allowed at provision time, or is at least one role required?

6. **Link status visibility (non-blocking if not required):** Is there an API to query whether the `UserPersonLink` has been created (linked vs pending), and should the frontend poll or provide a manual ‚ÄúCheck status‚Äù action?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Users: Provision User and Link to Person  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/155  
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Users: Provision User and Link to Person

**Domain**: user

### Story Description

/kiro
# User Story

## Narrative
As an **Admin**, I want **to create a user in pos-security-service and link them to a person in pos-people** so that **the employee can log in and be correctly attributed across workexec and timekeeping**.

## Details
- Create user with username/email, status, and initial role assignments.
- Link userId ‚Üî personId using email as primary match.
- Idempotent behavior on retries.

## Acceptance Criteria
- User created (or resolved) in pos-security-service.
- Link created between user and person.
- Initial role assignment applied.
- Audit record captured with actor and timestamp.

## Integration Points (workexec/shopmgr)
- workexec resolves technician attribution using personId/userId link.
- shopmgr receives new staff visibility if assigned to a location.

## Data / Entities
- User (pos-security-service)
- Person (pos-people)
- UserPersonLink (pos-people)

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: People Management


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #268: [FRONTEND] Approval: Handle Approval Expiration  
File: ./scripts/story-work/frontend/268/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:security
- status:draft

### Recommended
- agent:story-authoring
- agent:security-domain-agent

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** security-strict

---

## 1. Story Header

### Title
[FRONTEND] Approval: Handle Approval Expiration

### Primary Persona
Approver (manager/supervisor) who reviews and approves requests in the POS.

### Business Value
Prevents invalid/late approvals by making ‚Äúexpired‚Äù approvals un-actionable, clearly communicating why, and guiding users to the correct next step‚Äîreducing operational errors and support overhead.

---

## 2. Story Intent

### As a / I want / So that
**As an** Approver,  
**I want** approvals to automatically become ‚ÄúExpired‚Äù after their expiration time and be blocked from being approved/denied,  
**so that** I cannot take action on stale approvals and the system remains secure and auditable.

### In-scope
- Frontend detection and handling of an approval that is expired (on load and on submit).
- UI behavior: disabling actions, showing status/alerts, and rendering expiration metadata.
- Error handling for backend responses indicating expiration.
- Moqui screen/form/transitions implementing the above.

### Out-of-scope
- Defining the backend expiration policy (duration, calculation, grace periods).
- Creating/renewing/reissuing approvals (unless explicitly provided by backend).
- Notification mechanisms (email/SMS/push) for impending expiration.

---

## 3. Actors & Stakeholders

- **Approver (Primary Actor):** Attempts to approve/deny a pending approval.
- **Requester (Stakeholder):** Needs timely decisions; impacted if approval expires.
- **System (Actor):** Enforces expiration, returns errors, provides current status.
- **Audit/Compliance (Stakeholder):** Requires traceability of expiration vs actions taken.
- **Security (Stakeholder):** Ensures expired approvals cannot be used to authorize actions.

---

## 4. Preconditions & Dependencies

### Preconditions
- User is authenticated in the frontend.
- User has access to view the approval item (authorization enforced by backend / security).

### Dependencies
- A backend API/service exists to:
  - Load approval details including current status and expiration timestamp (or equivalent).
  - Attempt approve/deny actions and return deterministic errors for expired approvals.
- Time handling convention must be defined (server time vs client time; timezone).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- From an ‚ÄúApprovals Inbox/List‚Äù screen: selecting an approval navigates to an approval detail screen.
- Deep link: direct navigation to an approval detail screen by `approvalId` in the URL.

### Screens to create/modify
1. **Modify**: `approvals/ApprovalList` (or equivalent)
   - Display status badge and optionally ‚ÄúExpired‚Äù state indicator.
2. **Modify/Create**: `approvals/ApprovalDetail`
   - Shows approval metadata, status, expiration info.
   - Provides actions: Approve / Deny (or equivalent).
3. **(Optional) Create**: reusable dialog/snackbar component wiring for error display consistent with project patterns.

> Exact screen names/paths are project-convention dependent; implementer must align with existing Moqui screen tree in `durion-moqui-frontend`.

### Navigation context
- Breadcrumb: Approvals ‚Üí Approval Detail
- Back navigation returns to list with preserved filters (safe default).

### User workflows
#### Happy path (not expired)
1. User opens approval detail.
2. UI shows status = `PENDING` (or equivalent) and expiration timestamp.
3. User clicks Approve or Deny.
4. UI submits action; shows success; status updates to `APPROVED`/`DENIED`; actions become disabled.

#### Expired on view
1. User opens approval detail.
2. UI shows status = `EXPIRED`.
3. Approve/Deny actions are disabled/hidden; message explains expiration.
4. User can return to list.

#### Expires between view and submit
1. User opens approval detail while still actionable.
2. User waits; clicks Approve.
3. Backend rejects with ‚Äúexpired‚Äù error.
4. UI updates status to `EXPIRED`, displays error, disables actions.

---

## 6. Functional Behavior

### Triggers
- Screen load of Approval Detail (by `approvalId`).
- User clicks ‚ÄúApprove‚Äù or ‚ÄúDeny‚Äù.

### UI actions
- On load: fetch approval; compute whether expired **only if** backend provides an authoritative field; otherwise treat backend as source of truth and only reflect what backend says.
- Render:
  - Status chip (Pending/Approved/Denied/Expired)
  - Expiration timestamp (if provided)
  - If expired: show inline alert ‚ÄúThis approval expired at <time> and can no longer be acted on.‚Äù

### State changes (frontend view state)
- `viewStatus`: `loading | loaded | error`
- `approval.status`: reflects backend status
- `actionsEnabled`: derived: enabled only when status is actionable and user is authorized.

### Service interactions (Moqui)
- `transition` on screen entry calls a service to load approval details.
- `transition` for approve/deny calls submit service; handles response; then reloads approval detail for consistency.

---

## 7. Business Rules (Translated to UI Behavior)

> Because the actual approval domain rules are not provided in inputs, only UI-safe translations are specified and key items are open questions.

### Validation
- Approve/Deny submit must include required identifiers (e.g., `approvalId`) and any required concurrency token/version if backend requires it.
- Do not allow submission if approval is expired (based on backend status/flag).

### Enable/disable rules
- If `approval.status == EXPIRED`: disable/hide approve/deny buttons.
- If `approval.status in (APPROVED, DENIED)`: disable/hide approve/deny buttons.
- If user lacks permission (backend returns 403): show ‚ÄúNot authorized‚Äù message and do not show actions.

### Visibility rules
- Expiration info is visible when provided by backend; if not provided, show status only.

### Error messaging expectations
- If backend indicates expiration on submit: show a non-dismissive error message:
  - Title: ‚ÄúApproval expired‚Äù
  - Body: ‚ÄúThis approval expired and can‚Äôt be approved/denied. Refreshing status‚Ä¶‚Äù
  - After reload, status displays as `EXPIRED`.

---

## 8. Data Requirements

### Entities involved (frontend perspective)
- **Approval** (read model / DTO)
  - Source of record: backend approval service.

### Fields
Because the backend contract is not included, these are **required-to-implement UI** but must be confirmed:

| Field | Type | Required | Default | Notes |
|---|---|---:|---|---|
| `approvalId` | string/UUID | yes | n/a | Route param and submit identifier |
| `status` | enum|string | yes | n/a | Must include an `EXPIRED` representation |
| `expiresAt` | timestamp (ISO-8601) | no* | null | Needed to display expiry time; optional if backend doesn‚Äôt provide |
| `requestedAt` | timestamp | no | null | Informational |
| `requestedBy` | string | no | null | Informational |
| `subjectType` / `subjectId` | string | no | null | What this approval is for |
| `version` / `etag` | string/int | no* | null | Needed if backend requires optimistic concurrency |

\* ‚ÄúRequired‚Äù depends on backend; if missing, UI still must function by relying on backend status and submit errors.

### Read-only vs editable
- All fields read-only in UI; only actions are approve/deny.

### Derived/calculated fields
- `isActionable = (status == PENDING)` (exact actionable status set is an open question).
- `isExpired = (status == EXPIRED)`; do **not** derive from client time unless backend explicitly authorizes that behavior.

---

## 9. Service Contracts (Frontend Perspective)

> Moqui names are placeholders; implementer must map to actual service names or REST endpoints used in this frontend repo.

### Load/view calls
- **Service:** `approval.ApprovalServices.get#ApprovalDetail` (placeholder)
- **Input:** `{ approvalId }`
- **Output:** `{ approval: { ...fields above... } }`
- **Errors:**
  - `404` not found ‚Üí show ‚ÄúApproval not found‚Äù
  - `403` forbidden ‚Üí show ‚ÄúNot authorized‚Äù
  - `5xx` ‚Üí generic retryable error

### Submit/transition calls
1. **Approve**
   - **Service:** `approval.ApprovalServices.post#Approve` (placeholder)
   - **Input:** `{ approvalId, version? }`
2. **Deny**
   - **Service:** `approval.ApprovalServices.post#Deny` (placeholder)
   - **Input:** `{ approvalId, version?, reason? }` (reason is unknown; open question)

### Error handling expectations
- Expired:
  - Backend returns `409 Conflict` or `422 Unprocessable Entity` (TBD) with machine code like `APPROVAL_EXPIRED` (TBD).
  - UI maps to ‚ÄúApproval expired‚Äù and reloads detail.
- Concurrency:
  - If backend returns stale version error: UI shows ‚ÄúThis approval was updated by someone else. Reloading‚Ä¶‚Äù and reloads.

---

## 10. State Model & Transitions

### Allowed states (must be confirmed)
- `PENDING` (actionable)
- `APPROVED` (terminal)
- `DENIED` (terminal)
- `EXPIRED` (terminal)

### Role-based transitions
- Only authorized approvers may transition `PENDING ‚Üí APPROVED` or `PENDING ‚Üí DENIED`.
- System may transition `PENDING ‚Üí EXPIRED` (time-based).

### UI behavior per state
- `PENDING`: show Approve/Deny enabled.
- `APPROVED`/`DENIED`: show status, disable actions.
- `EXPIRED`: show expired banner, disable actions, show `expiresAt` if available.

---

## 11. Alternate / Error Flows

### Validation failures
- Missing `approvalId` route param ‚Üí show error state and link back to list.
- Missing required fields on submit (backend 400) ‚Üí show backend message; keep user on page.

### Concurrency conflicts
- Backend indicates already approved/denied/expired while user is viewing:
  - UI shows conflict message and reloads to reflect latest status.

### Unauthorized access
- 403 on load: show unauthorized page/section; do not render actions.
- 403 on submit: show ‚ÄúYou are not authorized to take this action.‚Äù

### Empty states
- Approval detail returns minimal info: still render status and identifiers; hide unknown sections.

---

## 12. Acceptance Criteria

### Scenario 1: View an expired approval
**Given** an approval exists with status `EXPIRED`  
**When** the user opens the Approval Detail screen for that approval  
**Then** the screen shows status `EXPIRED`  
**And** the Approve and Deny actions are not actionable (disabled or hidden)  
**And** the user sees a message indicating the approval is expired  
**And** no approve/deny request is sent from the UI.

### Scenario 2: Expiration handled on submit
**Given** an approval is displayed as actionable (`PENDING`)  
**And** the approval expires before the user submits  
**When** the user clicks Approve (or Deny)  
**And** the backend responds with an ‚Äúexpired approval‚Äù error  
**Then** the UI shows an ‚ÄúApproval expired‚Äù error message  
**And** the UI reloads the approval detail  
**And** the status is shown as `EXPIRED`  
**And** actions are no longer actionable.

### Scenario 3: Non-expired approval can be approved
**Given** an approval exists with status `PENDING`  
**When** the user clicks Approve  
**And** the backend returns success  
**Then** the UI shows a success confirmation  
**And** the approval status updates to `APPROVED` (after reload or response binding)  
**And** the Approve/Deny actions are no longer actionable.

### Scenario 4: Unauthorized user cannot act
**Given** a user without permission to act on approvals  
**When** they open an approval detail  
**Then** the UI indicates they are not authorized  
**And** no action controls are available  
**And** if they attempt a direct submit (e.g., via crafted request), the UI displays a forbidden error on response.

### Scenario 5: Not found approval
**Given** no approval exists for `approvalId = X`  
**When** the user navigates to Approval Detail for `X`  
**Then** the UI displays ‚ÄúApproval not found‚Äù  
**And** provides navigation back to Approval List.

---

## 13. Audit & Observability

### User-visible audit data
- Show status and timestamps if provided (requestedAt, expiresAt, decidedAt).
- Show ‚ÄúLast updated‚Äù timestamp if backend provides.

### Status history
- If backend exposes history, render a read-only timeline; otherwise out of scope.

### Traceability expectations
- Frontend should include correlation/request ID in error logs if available from existing frontend logging patterns.
- On submit failures due to expiration, log event with `approvalId` and error code (no PII).

---

## 14. Non-Functional UI Requirements

- **Performance:** Approval detail load under 2s on typical broadband; show skeleton/loading state immediately.
- **Accessibility:** WCAG 2.1 AA; expired banner announced to screen readers; buttons reflect disabled state correctly.
- **Responsiveness:** Works on tablet and desktop; approval actions remain reachable without horizontal scrolling.
- **i18n/timezone:** Display `expiresAt` in the location/user timezone per app standard; if undefined, display in UTC with explicit ‚ÄúUTC‚Äù label (needs confirmation).

---

## 15. Applied Safe Defaults

- SD-UI-EMPTY-STATE-01: Provide a standard ‚ÄúNot found / Unauthorized / Error‚Äù empty state component behavior; safe because it doesn‚Äôt change domain logic, only presentation. (Impacted: UX Summary, Error Flows)
- SD-UI-LOADING-STATE-01: Use consistent loading indicator/skeleton while fetching approval detail; safe as it only improves ergonomics. (Impacted: UX Summary)
- SD-ERR-MAP-01: Map HTTP 401/403/404/409/422/500 to standard UI notifications with retry where applicable; safe because it doesn‚Äôt assume business policy, only transport-level handling. (Impacted: Service Contracts, Error Flows)

---

## 16. Open Questions

1. **Domain ownership / label:** Is ‚ÄúApproval‚Äù governed by `domain:security` (authorization/approval control) or another domain (e.g., workexec/accounting)? Confirm the correct domain label and agent.
2. **Backend contract:** What are the actual API endpoints/services used by the frontend to:
   - list approvals,
   - load approval detail,
   - approve,
   - deny?
   Include request/response schemas and error format (including a machine-readable error code for expiration).
3. **State model:** What are the authoritative approval statuses and which are actionable? (Is it only `PENDING`? Are there intermediate states like `REQUESTED`, `IN_REVIEW`?)
4. **Expiration definition:** Does backend expose:
   - `expiresAt` timestamp,
   - `isExpired` boolean,
   - or only `status=EXPIRED`?
   Also confirm whether client should ever compute expiration from `expiresAt` or must rely solely on backend status.
5. **Timezones:** Which timezone governs display of `expiresAt` (user profile timezone, site/location timezone, or always UTC)?
6. **Deny requirements:** Does denying require a reason/comment? If yes, what validation rules (min/max length, required/optional)?
7. **Post-expiration user path:** Should UI offer an explicit ‚ÄúRequest new approval‚Äù action/link when expired? If yes, what screen/route/service handles it?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] Approval: Handle Approval Expiration  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/268  
Labels: frontend, story-implementation, type:story, layer:functional, kiro

## ü§ñ Implementation Issue - Created by Durion Workspace Agent

### Original Story
**Story**: #23 - Approval: Handle Approval Expiration  
**URL**: https://github.com/louisburroughs/durion/issues/23  
**Domain**: general

### Implementation Requirements
This issue was automatically created by the Missing Issues Audit System to address a gap in the automated story processing workflow.

The original story processing may have failed due to:
- Rate limiting during automated processing
- Network connectivity issues
- Temporary GitHub API unavailability
- Processing system interruption

### Implementation Notes
- Review the original story requirements at the URL above
- Ensure implementation aligns with the story acceptance criteria
- Follow established patterns for frontend development
- Coordinate with corresponding backend implementation if needed

### Technical Requirements
**Frontend Implementation Requirements:**
- Use Vue.js 3 with Composition API
- Follow TypeScript best practices
- Implement using Quasar UI framework components
- Ensure responsive design and accessibility (WCAG 2.1)
- Handle loading states and error conditions gracefully
- Implement proper form validation where applicable
- Follow established routing and state management patterns

### Notes for Agents
- This issue was created automatically by the Missing Issues Audit System
- Original story processing may have failed due to rate limits or network issues
- Ensure this implementation aligns with the original story requirements
- Frontend agents: Focus on Vue.js 3 components, TypeScript, Quasar UI framework. Coordinate with backend implementation for API contracts.

### Labels Applied
- `type:story` - Indicates this is a story implementation
- `layer:functional` - Functional layer implementation
- `kiro` - Created by Kiro automation
- `domain:general` - Business domain classification
- `story-implementation` - Implementation of a story issue
- `frontend` - Implementation type

---
*Generated by Missing Issues Audit System - 2025-12-26T17:37:43.83278977*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #65: Security: Audit Trail for Price Overrides, Refunds, and Cancellations (Frontend, Moqui Screens)
File: ./scripts/story-work/frontend/65/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:security
- status:draft

### Recommended
- agent:security-domain
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** security-strict

---

## 1. Story Header

**Title**: Security: Audit Trail for Price Overrides, Refunds, and Cancellations (Frontend, Moqui Screens)

**Primary Persona**: Auditor (secondary: Store Manager, Cashier; Compliance/Security Reviewer)

**Business Value**: Financial exceptions (price overrides, refunds, cancellations) are explainable, traceable, and reviewable with immutable audit evidence for investigations, internal controls, and dispute resolution.

---

## 2. Story Intent

### As a / I want / So that
- **As an Auditor**, I want a centralized, append-only audit trail for price overrides, refunds, and cancellations, so that I can explain financial exceptions with who/when/why and supporting references.

### In-scope
- Moqui **screens + navigation** to:
  - Search/filter audit entries
  - Drill down from an **order and/or invoice** to related audit entries
  - View audit entry details including actor, timestamp, reason, and payment/accounting references
  - Export audit entries report (format TBD)
- UI enforcement of **append-only** behavior (no edit/delete actions exposed)
- Basic error handling and empty states

### Out-of-scope
- Defining backend persistence, entity schema, or write-side generation of audit entries (no backend matches found)
- Authoring/refactoring the business logic that determines *when* an audit entry is created (assumed backend responsibility)
- Permission model details beyond what‚Äôs required to gate UI routes (requires clarification)

---

## 3. Actors & Stakeholders
- **Auditor**: Primary consumer; searches, filters, exports, reviews drilldowns.
- **Store Manager**: Investigates exceptions for a store/day/cashier; may export.
- **Cashier**: Typically not allowed to access global audit; may see limited ‚Äúwhy required‚Äù prompts elsewhere (write-side not in scope).
- **Security/Compliance Admin**: Defines access policies/roles, retention, export restrictions (clarification required).
- **Accounting**: Needs references to invoices, journals, or accounting documents (integration references).

---

## 4. Preconditions & Dependencies
- Moqui frontend app is running with authenticated user context.
- Backend provides:
  - A read API/service to query audit entries (paging/sorting/filtering)
  - A read API/service to fetch audit entry detail
  - A linkable identifier for **order**, **invoice**, and **payment references**
  - An export endpoint or a query that can be exported server-side (clarification)
- Authorization/permissions available in session (e.g., user has roles/permissions)
- Entities mentioned (AuditLog, ExceptionReport, ReferenceIndex) exist or equivalents exist (clarification required due to ‚ÄúNo backend matches found‚Äù).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main navigation: **Security ‚Üí Audit Trail**
- Contextual drilldowns:
  - From **Order Detail** screen: ‚ÄúView Audit Trail‚Äù
  - From **Invoice Detail** screen: ‚ÄúView Audit Trail‚Äù
  - (Optional) From **Payment Detail** screen: ‚ÄúView Audit Trail‚Äù (clarification)

### Screens to create/modify
1. **New Screen**: `apps/pos/screen/security/AuditTrail.xml`
   - Search/list view with filters + results table + export action
2. **New Screen**: `apps/pos/screen/security/AuditTrailDetail.xml`
   - Detail view for a single audit entry (read-only)
3. **Modify Screen** (if exists): `OrderDetail` screen to add transition/link to audit trail filtered by orderId
4. **Modify Screen** (if exists): `InvoiceDetail` screen to add transition/link to audit trail filtered by invoiceId

> Exact screen paths depend on repo conventions (clarification if structure differs).

### Navigation context
- Audit Trail list supports deep links with query params:
  - `orderId`, `invoiceId`, `paymentId/ref`, `eventType`, `dateFrom/dateTo`, `userId`
- Detail screen accessible by `auditLogId` (or equivalent PK)

### User workflows
**Happy path (Auditor search ‚Üí drilldown ‚Üí export)**
1. Auditor opens Security ‚Üí Audit Trail.
2. Applies filters (date range, event type, store/location, user).
3. Opens a result row to view detail.
4. From detail, navigates to referenced order/invoice/payment.
5. Exports results matching current filters.

**Alternate paths**
- Deep link from Order Detail ‚Üí Audit Trail pre-filtered to that order
- Empty results: show ‚ÄúNo audit entries match filters‚Äù
- Unauthorized user: show ‚ÄúNot authorized‚Äù and block access

---

## 6. Functional Behavior

### Triggers
- Screen load of Audit Trail list (initial query)
- Filter change + ‚ÄúSearch‚Äù action (re-query)
- Row click ‚ÄúView details‚Äù (load detail)
- ‚ÄúExport‚Äù action (export current result set based on filters)

### UI actions
- Filters (exact set depends on backend fields; see Data Requirements)
- Results table:
  - Sort by timestamp desc by default
  - Pagination controls
  - Columns: event type, timestamp, actor, reason summary, order/invoice/payment refs
- Detail view:
  - Immutable fields displayed
  - Reference links to related records

### State changes (frontend)
- No mutation of audit entries
- Local UI state only: selected filters, paging, loading/error states

### Service interactions
- `findAuditEntries` (list query)
- `getAuditEntry` (detail)
- `exportAuditEntries` (export)
- `getOrder`/`getInvoice` (for reference linking, if needed)

(Exact service names/paths require clarification due to missing backend contract.)

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- Date range:
  - `dateFrom <= dateTo`
  - If only one boundary provided, treat the other as open-ended (allowed)
- At least one filter is **not required** (unless performance policy requires it; clarification)
- `eventType` must be within supported set (from backend or fixed enum)

### Enable/disable rules
- Export button disabled when:
  - No results loaded OR export is in progress
- ‚ÄúView details‚Äù disabled when row lacks a resolvable audit entry id (should not happen; treat as error)

### Visibility rules
- Screens visible only to authorized roles/permissions (policy TBD)
- Payment reference fields shown only if present (do not fabricate)

### Error messaging expectations
- Query failure: show non-technical message + correlation id if available
- Unauthorized: show ‚ÄúYou do not have access to Audit Trail.‚Äù
- Export failure: show error and keep current filters intact

---

## 8. Data Requirements

### Entities involved (conceptual; backend mapping required)
- **AuditLog**: append-only audit events
- **ExceptionReport**: exportable reporting view (may be derived)
- **ReferenceIndex**: mapping between audit events and domain records (order/invoice/payment)

### Fields (type, required, defaults)
**Audit Entry (list + detail)**
- `auditLogId` (string/UUID, required) ‚Äî primary key for drilldown
- `eventType` (enum/string, required) ‚Äî one of:
  - `PRICE_OVERRIDE`, `REFUND`, `CANCELLATION` (names TBD)
- `eventTs` (datetime w/ timezone, required) ‚Äî display in user timezone
- `actorUserId` (string, required)
- `actorUserDisplayName` (string, optional but preferred)
- `reasonCode` (string, optional; depends on policy)
- `reasonText` (string, required for exceptions? policy unclear)
- `orderId` (string, optional)
- `orderExternalRef` (string, optional)
- `invoiceId` (string, optional)
- `invoiceExternalRef` (string, optional)
- `paymentId` (string, optional)
- `paymentRef` (string, optional; e.g., processor reference)
- `amount` (decimal, optional; currency handling unclear)
- `currencyUomId` (string, optional)
- `locationId` / `storeId` (string, optional but likely important)
- `terminalId` (string, optional)
- `notes` (string, optional)
- `payloadJson` (string/json, optional) ‚Äî only if allowed for auditors (security concern; clarification)

**Defaults**
- Default sort: `eventTs desc`
- Default date range: none (unless performance policy requires; clarification)

### Read-only vs editable
- All audit entry fields are **read-only** in UI.
- No create/update/delete actions exposed in these screens.

### Derived/calculated fields
- ‚ÄúReason summary‚Äù derived from `reasonCode` + truncated `reasonText`
- ‚ÄúReference display‚Äù derived from available order/invoice/payment refs

---

## 9. Service Contracts (Frontend Perspective)

> No backend matches found; these are **required contracts** that must be implemented or mapped.

### Load/view calls
1. **List query**
   - Service: `security.AuditTrail.find` (placeholder)
   - Inputs:
     - `eventType?`, `dateFrom?`, `dateTo?`, `actorUserId?`, `orderId?`, `invoiceId?`, `paymentRef?`, `locationId?`
     - `pageIndex` (int), `pageSize` (int)
     - `orderBy` (string; default `-eventTs`)
   - Output:
     - `items[]` (Audit Entry summary)
     - `totalCount` (int)

2. **Detail fetch**
   - Service: `security.AuditTrail.get` (placeholder)
   - Inputs: `auditLogId` (required)
   - Output: full Audit Entry

### Create/update calls
- None (append-only; UI provides no mutations)

### Submit/transition calls
- Export:
  - Service: `security.AuditTrail.export` (placeholder)
  - Inputs: same filters as list query (+ desired format)
  - Output: file download stream or URL to download

### Error handling expectations
- Map backend validation errors to field-level messages when possible (date range, invalid enum)
- For 401/403: redirect to login or show unauthorized screen per app convention
- For 5xx: show generic failure, allow retry

---

## 10. State Model & Transitions

### Allowed states
- Audit entries themselves have no UI-managed state (immutable records).

### Role-based transitions
- **Route access control**:
  - `AuditTrail` and `AuditTrailDetail` require audit permission/role (TBD)
- Drilldown transitions:
  - From audit entry ‚Üí Order Detail / Invoice Detail / Payment Detail only if user has access to those screens

### UI behavior per state
- Loading: show progress indicator, disable export/search until initial load completes
- Loaded: show results + paging
- Error: show error panel with retry
- Empty: show empty state with ‚ÄúClear filters‚Äù action

---

## 11. Alternate / Error Flows

1. **Validation failure (date range invalid)**
   - Prevent search; show inline error on date inputs.

2. **Concurrency conflicts**
   - Not applicable (read-only), except:
     - Audit entry referenced order/invoice missing/deleted: show ‚ÄúReferenced record not found‚Äù when navigating.

3. **Unauthorized access**
   - If user lacks permission:
     - Block route and show unauthorized message
     - Do not leak existence of audit entries (no partial results)

4. **Empty states**
   - No entries found: show empty message and retain filters.

5. **Export too large / restricted**
   - If backend returns ‚Äútoo many rows‚Äù or ‚Äúexport restricted‚Äù:
     - Show actionable error (‚ÄúNarrow date range and try again‚Äù / ‚ÄúYou do not have export permission‚Äù)

---

## 12. Acceptance Criteria

### Scenario 1: Auditor views audit trail list
**Given** I am authenticated as a user with audit trail access  
**When** I navigate to Security ‚Üí Audit Trail  
**Then** I see a paginated list of audit entries sorted by most recent first  
**And** each entry shows event type, timestamp, actor, and any available order/invoice/payment references

### Scenario 2: Filter by order drilldown
**Given** I am viewing an Order Detail page for order `O-123`  
**When** I click ‚ÄúView Audit Trail‚Äù  
**Then** I am taken to the Audit Trail screen with results filtered to `orderId=O-123`  
**And** all matching audit entries are displayed (or an empty state if none)

### Scenario 3: View audit entry detail
**Given** I am on the Audit Trail list and there is an entry with id `A-1`  
**When** I open the audit entry detail for `A-1`  
**Then** I see read-only fields including who/when/why  
**And** I see any available payment reference(s)  
**And** I can navigate to referenced order/invoice/payment screens when identifiers exist

### Scenario 4: Append-only enforcement in UI
**Given** I am on the Audit Trail list or detail screen  
**Then** there are no UI actions to edit or delete an audit entry  
**And** direct URL attempts to any edit route for audit entries are not available (route does not exist or is denied)

### Scenario 5: Export report
**Given** I have loaded audit trail results with filters applied  
**When** I click Export  
**Then** an export is generated matching the current filters  
**And** I receive a downloadable file (or download link)  
**And** if export fails, I see an error message and can retry without losing filters

### Scenario 6: Unauthorized user blocked
**Given** I am authenticated without audit trail permission  
**When** I navigate to Security ‚Üí Audit Trail  
**Then** I am shown an unauthorized message  
**And** no audit data is displayed

---

## 13. Audit & Observability

### User-visible audit data
- Display `actor`, `timestamp`, `reason`, and references on detail view
- Display ‚ÄúCreated at‚Äù as the audit timestamp (no updates shown)

### Status history
- Not applicable unless backend provides multi-step exception workflows (not in scope)

### Traceability expectations
- Export should include the same identifiers shown in UI (auditLogId, orderId, invoiceId, paymentRef)
- UI should log client-side route/view events per workspace convention (screen viewed, export attempted), without including sensitive payloads

---

## 14. Non-Functional UI Requirements
- **Performance**: List queries must be paginated; avoid loading entire dataset in the browser.
- **Accessibility**: All controls keyboard accessible; table and filter controls have labels; export action reachable without mouse.
- **Responsiveness**: Works on tablet widths typical for POS back office; table columns may collapse into stacked rows.
- **i18n/timezone/currency**:
  - Timestamps displayed in user‚Äôs timezone (source timezone must be clear from backend).
  - Amounts formatted with currency if provided; do not infer currency.

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide a standard empty-state message and ‚ÄúClear filters‚Äù action; qualifies as UI ergonomics only; impacts UX Summary, Alternate/Error Flows.
- SD-UX-PAGINATION: Use paginated list with default page size per app convention; safe as it‚Äôs non-domain UX; impacts Functional Behavior, Service Contracts.
- SD-ERR-STANDARD-MAPPING: Map 401/403/5xx to standard unauthorized/generic error UI; safe as generic error handling; impacts Business Rules, Error Flows, Acceptance Criteria.

---

## 16. Open Questions
1. **Backend contract**: What are the exact Moqui services (names, parameters, outputs) for listing audit entries, fetching detail, and exporting?
2. **Entity schema**: Are `AuditLog`, `ExceptionReport`, and `ReferenceIndex` real Moqui entities in this project? If yes, what are their primary keys and key fields?
3. **Event types**: What is the canonical set of auditable exception event types (exact codes) and required fields per type (e.g., is ‚Äúreason‚Äù mandatory)?
4. **Authorization**: Which roles/permissions can (a) view audit trail, (b) export, and (c) drill into linked order/invoice/payment detail?
5. **Export format & delivery**: CSV vs XLSX vs PDF? Should export be synchronous download, async job with notification, or ‚Äúdownload link‚Äù?
6. **Reference linking**: What identifiers should be treated as authoritative for drilldowns (orderId vs orderExternalRef, invoiceId vs invoice number, paymentId vs paymentRef)?
7. **Sensitive payload visibility**: Should auditors see raw payload JSON/metadata, or only curated fields? Any redaction requirements?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Security: Audit Trail for Price Overrides, Refunds, and Cancellations  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/65  
Labels: frontend, story-implementation, payment  

## Frontend Implementation for Story

**Original Story**: [STORY] Security: Audit Trail for Price Overrides, Refunds, and Cancellations

**Domain**: payment

### Story Description

/kiro  
# User Story

## Narrative  
As an **Auditor**, I want an audit trail so that financial exceptions are explainable.

## Details  
- Record who/when/why for overrides/refunds/cancels.  
- Exportable report.

## Acceptance Criteria  
- Audit entries append-only.  
- Drilldown by order/invoice.  
- Payment refs included.

## Integrations  
- Accounting and payment references included.

## Data / Entities  
- AuditLog, ExceptionReport, ReferenceIndex

## Classification (confirm labels)  
- Type: Story  
- Layer: Experience  
- domain :  Point of Sale

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript  
- Use Quasar framework for UI components  
- Integrate with Moqui Framework backend  
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API  
- TypeScript 5.x  
- Quasar v2.x  
- Moqui Framework integration

---  
*This issue was automatically created by the Durion Workspace Agent*

No backend matches found.

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #66: [FRONTEND] [STORY] Security: Define POS Roles and Permission Matrix ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/66
File: ./scripts/story-work/frontend/66/after.md
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:security
- status:draft

### Recommended
- agent:security-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** security-strict

---

## 1. Story Header

### Title
[FRONTEND] Security: Roles & Permission Matrix Admin UI (Roles, Grants, Assignments, Audit)

### Primary Persona
Admin (authorized security administrator)

### Business Value
Provide an admin-facing UI to manage RBAC (roles, permissions, role grants, user role assignments) with audit visibility so sensitive POS actions can be controlled with least privilege and changes are traceable.

---

## 2. Story Intent

### As a / I want / So that
- **As an Admin**, I want to create/edit roles, grant permissions to roles, and assign roles to users  
- **So that** sensitive operations (refunds, overrides, voids, adjustments, cancellations) are protected by explicit permission checks and all changes are auditable.

### In-scope
- Moqui frontend screens to:
  - List/view/create roles
  - View permissions registry and grant/revoke permissions on roles
  - Assign/revoke roles for users (principal)
  - View audit log entries related to RBAC changes (read-only)
- Frontend enforcement behaviors:
  - Show/hide/disable protected admin actions based on authorization responses (deny-by-default)
  - Display clear error states for 401/403/validation/conflicts
- Basic filtering/search/pagination for lists (safe UI defaults)

### Out-of-scope
- Defining the canonical permission list itself (owned by security backend/manifest)
- Authentication mechanism (IdP/JWT) implementation details
- Location/tenant scoping policy (unless explicitly provided)
- Role inheritance / hierarchy rules (not specified)
- ‚ÄúProtected operations‚Äù enforcement across the entire POS UI (this story focuses on admin RBAC management UI; wiring other features belongs to their stories)

---

## 3. Actors & Stakeholders
- **Admin**: performs RBAC configuration
- **Security Officer / Auditor**: reviews audit trail (read-only)
- **POS Operator**: indirectly impacted by permissions (not a UI actor here)
- **Security backend service (`pos-security-service`)**: system of record for RBAC entities and audit emission
- **People domain / Identity**: provides user/principal lookup and person linkage (integration detail; not owned here)

---

## 4. Preconditions & Dependencies
- Moqui app can call backend services for:
  - Role CRUD
  - Permission registry read
  - Grant/revoke permissions to roles
  - Assign/revoke roles to principals/users
  - Audit log query
- Backend enforces deny-by-default authorization and returns standard HTTP status codes (401/403/400/404/409).
- The permission registry exists (reference mentions `permissions_v1.yml` in backend repo), and an API exists to list permissions (exact endpoint TBD).
- A way to search/select a user/principal exists (endpoint + shape TBD).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- Main nav: **Administration ‚Üí Security ‚Üí Roles & Permissions**
- Deep links:
  - `/admin/security/roles`
  - `/admin/security/roles/{roleId}`
  - `/admin/security/users` (or `/admin/security/principals`) (TBD)

### Screens to create/modify (Moqui)
Create new screens under a security admin root:
- `component://pos-security/screen/admin/security/SecurityAdmin.xml` (root/menu)
- `.../RoleList.xml`
- `.../RoleDetail.xml`
- `.../UserRoleAssignments.xml`
- `.../AuditLog.xml` (filtered to RBAC-related events)

Each screen uses Moqui screen forms + transitions that call services (or REST via Moqui service facade, depending on project conventions).

### Navigation context
- From Role List ‚Üí Role Detail
- From Role Detail tabs/sections:
  - Role info
  - Permissions granted to role
  - Users assigned to role (optional; depends on API)
  - Audit events for this role

### User workflows
**Happy path: create role + grant permissions**
1. Admin opens Role List ‚Üí ‚ÄúCreate Role‚Äù
2. Enters role name + description ‚Üí Save
3. On Role Detail, opens ‚ÄúPermissions‚Äù section ‚Üí selects permissions ‚Üí Grant
4. System confirms; audit events visible in Audit Log screen

**Alternate path: assign role to user**
1. Admin opens User Role Assignments screen
2. Searches user/principal
3. Assigns one or more roles
4. Role takes effect immediately (frontend reflects success; no caching assumptions)

**Alternate path: revoke**
- Revoke permission from role / revoke role from user with confirmation and resulting UI refresh

---

## 6. Functional Behavior

### Triggers
- Admin navigates to security admin screens
- Admin submits create/update/grant/revoke/assign actions
- Admin filters/searches lists

### UI actions
- Role list: search by name, open detail
- Create role: submit form
- Edit role: update description/name (if allowed; TBD)
- Grant permission(s): multi-select grant action
- Revoke permission: per-row revoke action
- Assign role(s) to user: add assignment
- Revoke role from user: remove assignment
- Audit log: filter by event type/date/actor/role (as supported)

### State changes (frontend)
- Local UI state: loading/error/success banners
- No domain state machine is defined; treat entities as active records unless backend indicates statuses.

### Service interactions
- All mutations call backend; on success, refresh the affected lists/details from backend.
- On 401 ‚Üí route to login/session-expired flow (project convention TBD).
- On 403 ‚Üí show ‚ÄúNot authorized‚Äù and disable mutation controls.
- On 409 ‚Üí show conflict message (e.g., duplicate role name).

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- Role name required; enforce basic client-side validation (non-empty, trim). Server remains source of truth.
- Permission grant/revoke requires selected permission(s).
- User selection required before assigning roles.

### Enable/disable rules
- If user lacks authorization to manage RBAC:
  - Entire Security Admin menu hidden OR screen shows 403 state (implementation depends on how authz is exposed to UI; TBD).
- Mutation buttons disabled while request in-flight to avoid double-submit.
- Deny-by-default: if permission check endpoint is unavailable, UI must default to hiding/disabling protected actions and show an error.

### Visibility rules
- Permissions list display includes permission key and description (if provided).
- Audit screen shows only RBAC-relevant event types by default (filter), with ability to broaden if API supports.

### Error messaging expectations
- Validation errors: show field-level messages where possible.
- Authorization errors: ‚ÄúInsufficient permissions to perform this action.‚Äù
- Conflicts: ‚ÄúRole name already exists‚Äù (if 409 indicates unique constraint).
- Not found: ‚ÄúRole not found or you no longer have access.‚Äù

---

## 8. Data Requirements

### Entities involved (frontend perspective)
Security domain (SoR backend):
- Role
- Permission
- RolePermission (grant mapping)
- PrincipalRole / UserRole (assignment mapping)
- AuditLog (RBAC events)

### Fields (type, required, defaults)
**Role**
- `roleId` (string/uuid, read-only)
- `roleName` (string, required, unique; casing rules TBD)
- `description` (string, optional)
- `createdAt` (datetime, read-only)
- `createdBy` (string, read-only)

**Permission**
- `permissionKey` (string, read-only; format `domain:resource:action`)
- `description` (string, read-only, optional)
- `domain` (string, read-only, optional if derived)
- `resource` / `action` (string, read-only, optional if derived)

**RolePermission**
- `roleId` (read-only)
- `permissionKey` (read-only)
- `assignedAt` (datetime, read-only)
- `assignedBy` (string, read-only)

**PrincipalRole/UserRole**
- `principalId` or `userId` (string, read-only once selected)
- `roleId` (string)
- `assignedAt`, `assignedBy` (read-only)
- `revokedAt`, `revokedBy` (read-only; if soft revoke exists; TBD)

**AuditLog**
- `auditId` (string)
- `eventType` (string)
- `actorId` (string)
- `subjectType` + `subjectId` (strings, if provided)
- `occurredAt` (datetime)
- `correlationId` (string, optional)
- `details` (json/string, read-only)

### Read-only vs editable by state/role
- Editable: roleName/description (if backend allows), grant/revoke mappings, assignments
- Read-only: permission registry, audit logs, generated IDs/timestamps

### Derived/calculated fields
- Display-only counts:
  - number of permissions in role
  - number of users assigned to role (only if API provides)

---

## 9. Service Contracts (Frontend Perspective)

> Endpoints are **TBD** unless confirmed by repo conventions; frontend must be implemented behind a service abstraction so URLs can be swapped without UI rewrites.

### Load/view calls
- `GET roles` ‚Üí list roles (pagination)
- `GET roles/{roleId}` ‚Üí role detail
- `GET permissions` ‚Üí permission registry list (filter by domain optional)
- `GET roles/{roleId}/permissions` ‚Üí current grants (or included in role detail)
- `GET principals/search?q=` ‚Üí search users/principals (TBD)
- `GET principals/{principalId}/roles` ‚Üí assignments (TBD)
- `GET audit?eventType in (...)&subjectId=...` ‚Üí audit query (TBD)

### Create/update calls
- `POST roles` ‚Üí create role
- `PUT/PATCH roles/{roleId}` ‚Üí update role (TBD)

### Submit/transition calls (mutations)
- `POST roles/{roleId}/permissions:grant` with `{ permissionKeys: [] }` (TBD)
- `POST roles/{roleId}/permissions:revoke` with `{ permissionKeys: [] }` (TBD)
- `POST principals/{principalId}/roles:assign` with `{ roleIds: [] }` (TBD)
- `POST principals/{principalId}/roles:revoke` with `{ roleIds: [] }` (TBD)

### Error handling expectations
- `400` validation ‚Üí surface messages; map to field errors when keys provided
- `401` unauthenticated ‚Üí route to login/session recovery
- `403` unauthorized ‚Üí show not-authorized state; disable controls
- `404` missing resource ‚Üí show not-found
- `409` conflict (duplicate name / concurrent changes) ‚Üí show conflict banner with refresh option
- Network/timeouts ‚Üí retry affordance; do not assume mutation succeeded

---

## 10. State Model & Transitions

### Allowed states
- No explicit state machine defined for Role/Permission. Treat as active records.
- Assignments may be active/revoked if backend models revocation vs delete (TBD).

### Role-based transitions
- Admin-only transitions:
  - Create role
  - Update role
  - Grant/revoke permissions
  - Assign/revoke roles
- Auditor-only (or read-only admin) transitions:
  - View roles/permissions/audit

### UI behavior per state
- If assignment supports ‚Äúrevoked‚Äù history:
  - Show active roles by default; allow ‚Äúinclude revoked‚Äù toggle.

---

## 11. Alternate / Error Flows

### Validation failures
- Empty role name ‚Üí inline error; do not submit
- Invalid role name rejected by backend ‚Üí show backend message; keep user input

### Concurrency conflicts
- If role was modified elsewhere and backend returns 409:
  - UI shows conflict message and provides ‚ÄúReload role‚Äù action.
  - Do not auto-merge.

### Unauthorized access
- Direct navigation to admin screens without permission:
  - Screen returns 403 state with link back to home.
  - No mutation controls rendered.

### Empty states
- No roles exist ‚Üí show empty state with ‚ÄúCreate Role‚Äù if authorized
- No permissions granted to role ‚Üí show empty state with ‚ÄúGrant Permissions‚Äù
- No audit events found ‚Üí ‚ÄúNo matching events‚Äù

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: Admin can create a role with least privilege defaults
**Given** the user is authenticated as an Admin authorized to manage roles  
**When** the user creates a role with a unique role name and optional description  
**Then** the role is created successfully  
**And** the role shows zero permissions granted by default  
**And** the UI refreshes the role detail from the backend

### Scenario 2: Duplicate role name is rejected
**Given** a role named "Cashier" already exists  
**When** the Admin attempts to create another role named "Cashier"  
**Then** the backend returns a conflict error (e.g., 409)  
**And** the UI shows an error indicating the role name already exists  
**And** no duplicate role appears in the list

### Scenario 3: Admin grants permissions to a role
**Given** an Admin is viewing an existing role detail  
**And** the permission registry is available  
**When** the Admin grants one or more permissions to the role  
**Then** the role‚Äôs granted permissions list updates to include the new permissions  
**And** the UI shows a success confirmation  
**And** the UI can navigate to audit log view and see an RBAC change event for the grant (if audit query API supports it)

### Scenario 4: Admin revokes a permission from a role
**Given** a role currently has a permission granted  
**When** the Admin revokes that permission  
**Then** the permission no longer appears in the role‚Äôs granted permissions list after refresh  
**And** any backend error is surfaced to the user with no silent failure

### Scenario 5: Admin assigns a role to a user/principal
**Given** an Admin can search and select a user/principal  
**When** the Admin assigns a role to that principal  
**Then** the assignment appears in the principal‚Äôs role list after refresh  
**And** a success confirmation is shown  
**And** the UI displays any audit reference/correlation id returned (if provided)

### Scenario 6: Unauthorized user cannot access RBAC admin mutations
**Given** the user is authenticated but lacks authorization to manage RBAC  
**When** the user navigates to the Roles & Permissions screens  
**Then** the UI shows a not-authorized state (403) or hides the module entrypoint per convention  
**And** no create/edit/grant/assign actions are available

---

## 13. Audit & Observability

### User-visible audit data
- Provide an Audit Log screen (read-only) showing RBAC-related events:
  - role created/updated
  - permission granted/revoked
  - role assigned/revoked for principal
  - (optionally) access denied events if exposed

### Status history
- Role detail includes ‚ÄúRecent changes‚Äù section sourced from audit query filtered by subject roleId (if supported).

### Traceability expectations
- All mutation requests include a `correlationId` header if the frontend has one (or uses backend-generated id returned in response; TBD).
- UI surfaces correlationId on success/error banners when available for support.

---

## 14. Non-Functional UI Requirements

- **Performance:** lists must support pagination; initial load < 2s on typical datasets (exact SLA TBD).
- **Accessibility:** keyboard navigable forms; proper labels; error messages associated with inputs.
- **Responsiveness:** usable on tablet widths; admin screens may be desktop-first but must not break on smaller screens.
- **i18n/timezone:** display timestamps in user‚Äôs locale/timezone per project convention; do not hardcode formats.

---

## 15. Applied Safe Defaults
- SD-UX-EMPTY-STATES: Provide explicit empty states with authorized primary actions; safe because it‚Äôs purely presentational and reversible. (Impacted: UX Summary, Alternate/Empty states)
- SD-UX-PAGINATION: Paginate role/permission/audit lists with standard page size; safe because it doesn‚Äôt change domain meaning. (Impacted: UX Summary, Service Contracts)
- SD-ERR-HTTP-MAP: Standard mapping of 400/401/403/404/409/network to banners/field errors; safe because it follows implied backend semantics and is UI-only. (Impacted: Service Contracts, Error Flows)

---

## 16. Open Questions

1. **Permission/role management API contract (blocking):** What are the exact backend endpoints, request/response schemas, and identifiers for:
   - Role CRUD
   - Permission registry list (does it come from `permissions_v1.yml` via an endpoint?)
   - Grant/revoke permissions to role
   - Assign/revoke roles to principal/user
   - Audit log query and filter fields

2. **Authorization model for admin UI (blocking):** Which permissions (keys) govern:
   - Viewing RBAC screens
   - Creating/updating roles
   - Granting/revoking permissions
   - Assigning/revoking user roles  
   (Per security agent contract: do not invent permission names.)

3. **Principal identity & scoping (blocking):**
   - Is assignment performed against `userId`, `principalId`, or something else?
   - Is RBAC scoped by `tenantId` and/or `locationId`? If yes, how is scope selected in UI and enforced?

4. **Role uniqueness & casing rules (blocking):**
   - Is role name uniqueness case-insensitive?
   - Are updates to role name allowed after creation?

5. **Audit visibility (blocking):**
   - Is audit log queryable by the frontend? If yes, what fields are safe to display and what retention applies?
   - Should access denied events be visible in UI or only in logs?

---

## Original Story (Unmodified ‚Äì For Traceability)

Title: [FRONTEND] [STORY] Security: Define POS Roles and Permission Matrix ‚Äî URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/66

Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Security: Define POS Roles and Permission Matrix

**Domain**: user

### Story Description

/kiro
# User Story

## Narrative
As an **Admin**, I want roles and permissions so that sensitive actions (refunds, overrides) are controlled.

## Details
- Roles mapped to permissions.
- Least privilege defaults.

## Acceptance Criteria
- Protected operations enforce permissions.
- Role changes audited.

## Integrations
- Integrates with HR/security identity/roles.

## Data / Entities
- Role, Permission, RolePermission, UserRole, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Experience
- domain :  Point of Sale

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*


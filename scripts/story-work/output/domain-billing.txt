â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
DOMAIN: billing
Total Stories: 10
Generated: dim. 18 janv. 2026 12:03:02 EST
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ISSUE #164: [FRONTEND] [STORY] Billing: Define Account Billing Rules â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/164
File: ./scripts/story-work/frontend/164/after.md
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## ğŸ·ï¸ Labels (Proposed)

### Required
- type:story
- domain:billing
- status:draft

### Recommended
- agent:billing-domain-agent
- agent:story-authoring

### Blocking / Risk
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

# 1. Story Header

**Title:** [FRONTEND] [STORY] Billing: Define Account Billing Rules (Commercial Accounts)

**Primary Persona:** Billing Clerk

**Business Value:** Ensures invoicing behavior (PO enforcement, terms, delivery, grouping) is consistent per commercial account, auditable, and permission-controlled so downstream Work Execution and Billing automation behave predictably.

---

# 2. Story Intent

### As a / I want / So that
- **As a** Billing Clerk  
- **I want** to create and update billing rules for a commercial account  
- **So that** invoicing defaults and enforcement rules are correct, consistent, and traceable across the POS workflow.

### In-scope
- Frontend screens/flows to **view** and **edit/upsert** Billing Rules for a given `accountId`.
- Fetching current Billing Rules for display.
- Fetching enumerated options for selectable fields (e.g., payment terms, delivery method, grouping strategy) if exposed by backend.
- Permission-gated UI actions and user-facing error handling for 403/404/409/422-like failures.
- Display of audit metadata (at minimum: last updated timestamp + updated by), and a link/section placeholder for change history if backend supports it.

### Out-of-scope
- Implementing backend persistence, validation, event emission, or provisioning (handled by Billing backend).
- Work Execution estimate approval enforcement UI (owned by Work Execution domain).
- Invoice creation/issuance/payment processing flows.
- Defining the system-wide default rules template (admin/backoffice configuration).

---

# 3. Actors & Stakeholders
- **Billing Clerk (Primary):** Configures rules per commercial account.
- **Billing Manager / Auditor:** Needs confidence changes are permissioned and auditable.
- **Work Execution users (Indirect):** Rely on rules snapshot/enforcement downstream; not editing here.
- **System (Moqui UI + Billing APIs):** UI calls Billing services/APIs and renders results.

---

# 4. Preconditions & Dependencies
- User is authenticated in the Moqui-based frontend.
- A commercial account exists and the UI can obtain a stable `accountId` (from CRM/account lookup or route param).
- Backend provides Billing Rules APIs (reference backend story #100):
  - `GET /billing-rules/{accountId}`
  - `PUT /billing-rules/{accountId}` (idempotent upsert)
- Backend provides (or embeds) option sets for:
  - `paymentTermsId` valid values
  - `invoiceDeliveryMethod` enum values
  - `invoiceGroupingStrategy` enum values  
  If not available as endpoints, UI must rely on values returned from backend or a shared configuration (needs clarification).

---

# 5. UX Summary (Moqui-Oriented)

### Entry points
- From **Commercial Account** context (e.g., Account Details screen): action â€œBilling Rulesâ€.
- Direct deep link route: `/accounts/<accountId>/billing-rules`.

### Screens to create/modify
- **New/Modified Screen:** `apps/pos/account/BillingRules.xml` (or equivalent per repo conventions)
  - View current rules (read-only summary)
  - Edit form (upsert)
  - Audit metadata display (last updated)
- **Modify existing Account screen** to add navigation link to Billing Rules (where account screens exist).

### Navigation context
- Breadcrumb/toolbar should reflect: Account â†’ Billing Rules.
- The screen must retain `accountId` in parameters across transitions.

### User workflows
**Happy path**
1. Billing Clerk opens Billing Rules for an account.
2. UI loads current rules (or shows â€œnot configuredâ€ state if 404).
3. Clerk edits fields (PO required toggle, payment terms, delivery method, grouping strategy).
4. Clerk saves; UI performs upsert.
5. UI reloads and shows updated values and updated metadata.

**Alternate paths**
- Rules not found (404): show empty state + allow â€œCreate rulesâ€ (same form with defaults from backend if returned).
- Permission denied (403): show read-only view if allowed; otherwise show access denied.
- Concurrent modification (409): prompt user to reload and re-apply changes.
- Validation errors (400/422): highlight fields and show actionable messages.

---

# 6. Functional Behavior

### Triggers
- Screen load with `accountId`.
- User clicks Save/Update.

### UI actions
- **On load**
  - Call service to load account summary (optional, if already in context) and Billing Rules.
  - Populate form model with returned values or initialize with backend-provided defaults if available.
- **On change**
  - Track dirty state; enable Save only when changes exist and form is valid.
- **On Save**
  - Submit upsert request with full Billing Rules payload (not patch) to ensure deterministic state.
  - Disable Save while request is in flight; prevent double-submit.
- **On success**
  - Show success confirmation.
  - Refresh displayed data from GET to reflect canonical persisted state (including version/updatedAt).
- **On failure**
  - Map backend error to user-facing message and field errors where applicable.

### State changes (frontend)
- `loading` â†’ `loaded`
- `editMode` toggles (optional; may be always editable if permitted)
- `saving` â†’ `saved` or `error`
- Maintain `serverVersion`/`etag` (if provided) for optimistic concurrency.

### Service interactions (Moqui)
- Use Moqui screen actions to invoke REST calls (or Moqui services that proxy to backend).
- Use transitions for Save action with redirect back to view state on success.

---

# 7. Business Rules (Translated to UI Behavior)

### Validation
UI must enforce basic client-side validation (non-authoritative) aligned to backend invariants:
- `paymentTermsId` is **required**.
- `invoiceDeliveryMethod` is **required**.
- `invoiceGroupingStrategy` is **required**.
- `isPoRequired` is **required** boolean (default false when creating new).

If backend defines PO format/uniqueness policies, they are enforced server-side; UI must display server error text.

### Enable/disable rules
- Save button enabled only when:
  - user has modify permission, AND
  - form is dirty, AND
  - required fields are present.
- If user lacks modify permission:
  - fields rendered read-only/disabled
  - Save hidden/disabled

### Visibility rules
- Show â€œNot configuredâ€ empty state when GET returns 404.
- Show audit metadata section when `updatedAt`/`updatedBy` present.
- Show â€œChange historyâ€ section only if backend provides an audit history endpoint (otherwise show placeholder text â€œNot availableâ€).

### Error messaging expectations
- 403: â€œYou do not have permission to manage billing rules for this account.â€
- 404 on load: â€œNo billing rules exist for this account yet.â€
- 409: â€œThese billing rules were updated by another user. Reload to continue.â€
- 400/422: â€œFix the highlighted fields and try again.â€
- 503/network: â€œBilling service unavailable. Try again later.â€

---

# 8. Data Requirements

### Entities involved (frontend perspective)
- **BillingRules** (Billing-owned; UI reads/writes via APIs)
- **PaymentTerm** (enumeration/list; read-only options)
- **Commercial Account** (CRM-owned; UI uses `accountId` and display name)

### Fields
BillingRules form model (types are UI-level):
- `accountId` (string/uuid, required, read-only; from route/context)
- `isPoRequired` (boolean, required, default false)
- `paymentTermsId` (string, required)
- `invoiceDeliveryMethod` (enum string, required; e.g., `EMAIL|PORTAL|MAIL`)
- `invoiceGroupingStrategy` (enum string, required; e.g., `PER_WORK_ORDER|PER_VEHICLE|SINGLE_INVOICE`)
- `version` (number/int, optional, read-only; used for optimistic concurrency if present)
- `updatedAt` (datetime, read-only)
- `updatedBy` (string/userRef, read-only)

### Read-only vs editable by state/role
- Editable only for users with permission `billingRules:manage` (or backend equivalent).
- Always read-only: `accountId`, `version`, `updatedAt`, `updatedBy`.

### Derived/calculated fields
- Display label text derived from IDs/enums (e.g., PaymentTerm name from list).
- â€œLast updatedâ€ string derived from `updatedAt`.

---

# 9. Service Contracts (Frontend Perspective)

> Note: Exact Moqui service names/endpoints must match the integration layer in this repo. Below is the required contract behavior; implement via REST calls or Moqui faÃ§ade services.

### Load/view calls
1. **Get Billing Rules**
   - Method: `GET /billing-rules/{accountId}`
   - Success: `200` returns BillingRules JSON
   - Not found: `404` (render empty state)
   - Forbidden: `403` (render access denied or read-only)
2. **Get option lists** (one of the following must exist; otherwise Open Question)
   - `GET /payment-terms` â†’ list `{id, name, ...}`
   - enums may be returned as part of BillingRules payload (e.g., `allowedDeliveryMethods`, `allowedGroupingStrategies`)

### Create/update calls
1. **Upsert Billing Rules**
   - Method: `PUT /billing-rules/{accountId}`
   - Request body includes:
     - `isPoRequired`
     - `paymentTermsId`
     - `invoiceDeliveryMethod`
     - `invoiceGroupingStrategy`
     - include `version` or `If-Match` header if backend supports optimistic concurrency
   - Responses:
     - `200 OK` (updated) or `201 Created` (created)
     - `400/422` validation errors with field-level details if provided
     - `403` forbidden
     - `409` conflict if stale version/etag

### Error handling expectations
- Map HTTP status to UX messages (see section 7).
- If backend returns structured errors:
  - Prefer field mapping for inline validation (e.g., `{fieldErrors:{paymentTermsId:"..."}}`)
- Never log PII; sanitize any account contact info if present.

---

# 10. State Model & Transitions

### Allowed states (UI-level)
- `UNCONFIGURED` (GET 404)
- `CONFIGURED` (GET 200)

### Role-based transitions
- `UNCONFIGURED` â†’ `CONFIGURED` via Save (PUT) if authorized.
- `CONFIGURED` â†’ `CONFIGURED` via Save (PUT) if authorized.

### UI behavior per state
- **UNCONFIGURED**
  - Show empty state
  - If authorized: show editable form with required fields; defaults prefilled if available
  - If not authorized: show message and no form submission
- **CONFIGURED**
  - Show current values and audit metadata
  - If authorized: allow edits + Save
  - If not authorized: read-only display

---

# 11. Alternate / Error Flows

### Validation failures (server)
- Backend returns 400/422 with message(s)
- UI:
  - keeps user inputs
  - highlights fields if field mapping available
  - displays summary banner

### Concurrency conflicts
- Backend returns 409
- UI:
  - shows conflict message
  - provides action â€œReloadâ€ that re-fetches GET and resets form
  - does not auto-merge

### Unauthorized access
- Backend returns 403 on GET:
  - UI shows access denied page/state
- Backend returns 403 on PUT:
  - UI shows â€œnot permittedâ€ banner and keeps form read-only thereafter

### Empty states
- GET 404:
  - show â€œNo rules configuredâ€
  - provide Create flow if authorized

### Downstream unavailable
- 503 / network timeout:
  - show retry affordance
  - do not lose unsaved edits on PUT failure

---

# 12. Acceptance Criteria

### Scenario 1: View existing billing rules
**Given** I am an authenticated Billing Clerk with permission to view billing rules  
**And** billing rules exist for `accountId`  
**When** I open the Billing Rules screen for that account  
**Then** the system loads and displays `isPoRequired`, `paymentTermsId`, `invoiceDeliveryMethod`, and `invoiceGroupingStrategy`  
**And** the screen displays `updatedAt` and `updatedBy` when provided by the API.

### Scenario 2: Create billing rules when none exist
**Given** I am authorized to manage billing rules  
**And** no billing rules exist for `accountId` (API returns 404)  
**When** I enter valid values for required fields and click Save  
**Then** the UI sends `PUT /billing-rules/{accountId}` with the entered values  
**And** I see a success confirmation  
**And** a subsequent reload shows the saved rules as the canonical values.

### Scenario 3: Update billing rules
**Given** I am authorized to manage billing rules  
**And** billing rules exist for `accountId`  
**When** I change `paymentTermsId` and click Save  
**Then** the UI sends `PUT /billing-rules/{accountId}` with the updated payload  
**And** the UI refreshes from `GET /billing-rules/{accountId}`  
**And** the displayed value reflects the update.

### Scenario 4: Prevent save when required fields missing (client-side)
**Given** I am authorized to manage billing rules  
**When** `paymentTermsId` is empty  
**Then** the Save action is disabled (or blocked with inline validation)  
**And** no PUT request is sent.

### Scenario 5: Handle server-side validation error
**Given** I am authorized to manage billing rules  
**When** I click Save and the backend returns a validation error (400/422)  
**Then** the UI shows an error message  
**And** keeps my entered values  
**And** highlights the fields indicated by the server response (if provided).

### Scenario 6: Handle concurrent modification
**Given** I am authorized to manage billing rules  
**And** I have loaded billing rules for `accountId`  
**When** I click Save and the backend responds with `409 Conflict`  
**Then** I see a conflict message prompting reload  
**And** I can reload to fetch the latest rules before re-applying changes.

### Scenario 7: Permission enforcement
**Given** I do not have permission to manage billing rules  
**When** I open the Billing Rules screen  
**Then** I cannot edit or save billing rules  
**And** if I attempt a save (e.g., via direct action), the UI handles `403 Forbidden` by showing an authorization error.

---

# 13. Audit & Observability

### User-visible audit data
- Display:
  - `updatedAt`
  - `updatedBy`
- If an audit-history endpoint exists, display a read-only list of changes with:
  - timestamp, actor, fields changed (before/after where provided)

### Status history
- Not a state machine beyond configured/unconfigured for UI; show last updated metadata.

### Traceability expectations
- Include `accountId` in:
  - UI logs (sanitized)
  - correlation/trace headers if the frontend integration layer supports it

---

# 14. Non-Functional UI Requirements
- **Performance:** Initial load should complete with a single round-trip for rules + (optional) one round-trip for option lists; avoid chatty calls.
- **Accessibility:** Form controls must have labels, keyboard navigation, and error text associated to fields.
- **Responsiveness:** Must work on tablet width used at POS; avoid layouts that require horizontal scrolling.
- **i18n/timezone/currency:** Display `updatedAt` in the userâ€™s locale/timezone per app defaults (no currency handling required here).

---

# 15. Applied Safe Defaults
- **SD-UI-EMPTY-STATE-01**: Provide a standard empty state when `GET /billing-rules/{accountId}` returns 404; qualifies as safe because it affects only UX presentation, not domain policy. (Impacted sections: UX Summary, Alternate / Error Flows)
- **SD-ERR-MAP-HTTP-01**: Map common HTTP statuses (403/404/409/422/503) to consistent banners and inline messages; qualifies as safe because it does not change backend behavior and only standardizes error display. (Impacted sections: Business Rules, Service Contracts, Alternate / Error Flows, Acceptance Criteria)

---

# 16. Open Questions
1. **Option list sources:** What are the exact endpoints/contracts to load **Payment Terms** and allowed enum values for **Delivery Method** and **Grouping Strategy** in the frontend (or are these embedded in `GET /billing-rules/{accountId}` responses)?
2. **Permissions contract:** What permissions/roles should the frontend check (exact permission strings) to determine view vs manage access for billing rules?
3. **Optimistic concurrency:** Does the backend require `version` in payload or `If-Match`/ETag for updates, and what is the expected UI behavior when version is omitted?
4. **Audit history UI:** Is there an endpoint to retrieve Billing Rules change history (e.g., `GET /billing-rules/{accountId}/audit`)? If yes, what fields and pagination does it support?

---

## Original Story (Unmodified â€“ For Traceability)

Title: [FRONTEND] [STORY] Billing: Define Account Billing Rules â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/164


====================================================================================================

FRONTEND STORY (FULL CONTEXT)

====================================================================================================

Title: [FRONTEND] [STORY] Billing: Define Account Billing Rules
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/164
Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] Billing: Define Account Billing Rules

**Domain**: payment

### Story Description

/kiro
# User Story

## Narrative
As a **Billing Clerk**, I want **to set billing rules for a commercial account** so that **invoicing is correct and consistent**.

## Details
- Rules: PO required, payment terms, invoice delivery (email/portal), invoice grouping (per vehicle/per workorder).
- Rule changes audited and permissioned.

## Acceptance Criteria
- Create/update rules.
- Rules returned on account lookup.
- Rule changes audited and access-controlled.

## Integration Points (Workorder Execution)
- Estimate approval enforces PO rules.
- Invoicing uses delivery + grouping defaults.

## Data / Entities
- BillingRule
- PaymentTerm
- DeliveryPreference

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: CRM


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

====================================================================================================

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ISSUE #192: [FRONTEND] [STORY] AP: Execute Payment and Post to GL â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/192
File: ./scripts/story-work/frontend/192/after.md
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## ğŸ·ï¸ Labels (Proposed)

### Required
- type:story
- domain:billing
- status:draft

### Recommended
- agent:billing-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

STOP: Clarification required before finalization

---

# 1. Story Header

## Title
[FRONTEND] [STORY] AP: Execute Vendor Payment (Allocate Across Bills) and Track GL Posting Status

## Primary Persona
AP Clerk (or AP Manager) using POS Back Office (Billing/AP area)

## Business Value
Enable AP users to execute a vendor payment, allocate it across one or more open bills with idempotency safety, and see the GL posting status/acknowledgement for auditability and reconciliation.

---

# 2. Story Intent

## As a / I want / So that
**As an** AP Clerk,  
**I want** to initiate a vendor payment and allocate the payment across one or more payable bills,  
**So that** vendor bills are settled correctly and the system can track downstream GL posting completion.

## In-scope
- A Moqui screen flow to:
  - Select a vendor and one or more open bills
  - Enter payment details (amount, currency, paymentRef/idempotency key)
  - Optionally specify explicit allocations by bill
  - Submit payment execution
  - View payment result (gateway transaction id, allocations, unapplied remainder)
  - View GL posting status (pending/posted/failed) and acknowledgement reference when available
- UI enforcement of allocation validation rules from backend story (non-negative, sum â‰¤ payment amount, bills payable/open)
- Idempotent UX behavior when re-submitting with same `paymentRef`
- Read-only detail view of a payment record including allocations and status history

## Out-of-scope
- Defining accounting posting rules / COA mapping UI (owned by Accounting)
- Implementing payment gateway adapter behavior (backend)
- Retry/backoff controls for GL posting (backend)
- Refunds/chargebacks and payment reversal flows (not specified here)
- Vendor/bill creation flows (assumed existing)

---

# 3. Actors & Stakeholders
- **Primary user:** AP Clerk / AP Manager
- **System:** Billing/AP services (Moqui backend integration)
- **Downstream system:** Accounting (asynchronous GL posting, acknowledgement event)
- **Audit/Compliance:** Auditors requiring traceability from payment â†’ allocations â†’ journal entry reference

---

# 4. Preconditions & Dependencies
- User is authenticated and authorized for payment execution actions.
- Vendor exists and has one or more payable/open bills.
- Backend endpoints/services exist (or will exist) consistent with backend story #128:
  - Execute payment (idempotent by `paymentRef`)
  - Retrieve payment by id / paymentRef
  - Retrieve vendor open bills eligible for payment
  - Retrieve bill details needed for allocation (open balance, due date, invoice date)
- Optional: backend exposes GL posting acknowledgement reference and payment workflow status.
- UI must not require knowledge of settlement timing (explicitly prohibited by billing agent contract).

---

# 5. UX Summary (Moqui-Oriented)

## Entry points
- Back Office navigation: **Billing/AP â†’ Vendor Bills â†’ â€œMake Paymentâ€**
- Alternate entry: **Billing/AP â†’ Payments â†’ New Payment**
- Deep link: `/ap/payments/new` and `/ap/payments/view?billingPaymentId=...`

## Screens to create/modify (Moqui)
1. **`ap/payments/NewPayment.xml`** (new)
   - Vendor selection + eligible bills list
   - Allocation editor (auto or explicit)
   - Submit action: execute payment
2. **`ap/payments/PaymentDetail.xml`** (new)
   - Read-only payment summary, allocations, status timeline, GL posting acknowledgement if present
   - â€œRe-fetch statusâ€ action (reload)
3. **`ap/vendors/VendorBills.xml`** (modify or confirm existing)
   - Add â€œMake Paymentâ€ action pre-filtered to selected vendor and selected bills

## Navigation context
- Breadcrumbs: Billing/AP > Payments > New / Payment Detail
- After successful execution: route to Payment Detail screen with `billingPaymentId`

## User workflows
### Happy path
1. User opens New Payment
2. Select vendor
3. System loads open bills for vendor and displays balances
4. User selects bills and enters payment amount and `paymentRef`
5. User chooses allocation mode:
   - Automatic allocation (deterministic backend policy), or
   - Explicit allocation amounts per selected bill
6. User submits
7. UI shows success result and navigates to Payment Detail; GL status initially shows pending until acknowledgement arrives

### Alternate paths
- Submit with same `paymentRef` again â†’ UI displays existing payment result without duplicating gateway call
- Payment amount exceeds open balances â†’ UI shows unapplied remainder field in result (read-only)
- Gateway fails â†’ UI shows failure state; no allocations applied

---

# 6. Functional Behavior

## Triggers
- User clicks **Execute Payment** on New Payment screen.
- User navigates to Payment Detail for existing payment.

## UI actions
### New Payment
- Vendor lookup/select
- Load eligible bills for vendor
- Select one or more bills
- Enter:
  - `grossAmount`
  - `currency` (if not implied by tenant/location)
  - `paymentRef` (idempotency key; user-entered or generatedâ€”see Open Questions)
  - Optional `feeAmount` (only if backend expects it from UIâ€”see Open Questions)
- Allocation mode toggle:
  - **Auto allocate** (no explicit lines sent), or
  - **Explicit allocate** (grid: billId, appliedAmount)

### Payment Detail
- Display:
  - payment identifiers, status, amounts (gross/fee/net if present)
  - allocations list
  - status timeline (state transitions)
  - GL posting acknowledgement reference if available (`journalEntryId` or postingRef)
- Manual refresh: reload payment record

## State changes (frontend-visible)
- On submit: show in-progress state; disable submit to prevent duplicate click
- On response:
  - If success: show `GATEWAY_SUCCEEDED` and likely `GL_POST_PENDING`
  - If failure: show `GATEWAY_FAILED`
- Payment record may later transition to `GL_POSTED` or `GL_POST_FAILED` upon acknowledgement processing (reflected on reload)

## Service interactions (Moqui)
- `transition` from New Payment form calls a Moqui service faÃ§ade that hits backend payment execution endpoint (or Moqui service if monolithic).
- Payment Detail uses `screen` actions to load payment and allocations.

---

# 7. Business Rules (Translated to UI Behavior)

## Validation
- Vendor must be selected (required)
- At least one bill must be selected (required)
- `grossAmount` must be > 0
- `paymentRef` required and must be unique for idempotency (uniqueness enforced server-side; UI should treat duplicate as â€œalready processedâ€ not error)
- If explicit allocations provided:
  - Each `appliedAmount` must be â‰¥ 0
  - Sum of `appliedAmount` across lines must be â‰¤ `grossAmount`
  - Only bills in â€œpayable/openâ€ status may be allocated (validated server-side; UI should prevent selection of non-eligible bills)
- If no explicit allocations provided:
  - UI sends no allocation lines; backend performs deterministic allocation (oldest due date first, nulls last, then invoice date, then bill ID)

## Enable/disable rules
- Disable Execute Payment button until required fields satisfied (vendor, bills, amount, paymentRef)
- When submit is in flight: disable all inputs and show progress indicator
- Allocation grid editable only when allocation mode = explicit

## Visibility rules
- Show â€œUnapplied remainderâ€ only when backend returns remainder > 0
- Show fee/net fields only if backend returns them (do not assume fee known at capture time)

## Error messaging expectations
- Validation errors (422): map field-level errors to corresponding inputs; show summary at top
- Conflict/idempotency (409 or â€œalready processedâ€ semantic): show message â€œPayment already processed for this paymentRefâ€ and link to Payment Detail
- Downstream unavailable (503): show retryable error, keep form state intact

---

# 8. Data Requirements

## Entities involved (frontend perspective)
- `BillingPayment` (payment record, workflow status)
- `BillingPaymentAllocation` (payment â†’ bill applied amounts)
- `Bill` (AP bill header with open balance and eligibility)
- Optional: `StatusHistory` / `AuditLog` projection for payment transitions
- Optional: `AccountingAcknowledgement` projection containing `journalEntryId`

## Fields
### New Payment input model
- `vendorId` (UUID, required)
- `currencyUomId` (string, required) **(source unclear; see Open Questions)**
- `grossAmount` (decimal/money, required, > 0)
- `paymentRef` (string, required; idempotency key)
- `allocations[]` (optional)
  - `billId` (UUID, required when allocations present)
  - `appliedAmount` (decimal/money, required when allocations present, â‰¥ 0)

### Payment detail view model (read-only)
- `billingPaymentId` (UUID)
- `paymentRef`
- `vendorId`
- `gatewayTransactionId` (string, nullable on failure)
- `status` (enum)
- `grossAmount`, `feeAmount?`, `netAmount?`, `currencyUomId`
- `unappliedAmount?` (derived by backend; UI displays if present)
- `allocations[]`: `billId`, `appliedAmount`
- `glPosting`:
  - `journalEntryId?` or `postingRef?`
  - `postedAt?`
  - `glStatus` (if separate from payment status)

## Read-only vs editable by state/role
- New Payment fields editable until submit.
- Payment Detail: all fields read-only.
- Access controlled by permissions (see Open Questions for exact permission IDs).

## Derived/calculated fields
- Allocation sum (UI-calculated for validation/display)
- Remaining-to-allocate = `grossAmount - sum(allocations)`
- Unapplied remainder is backend-authoritative and displayed from response (do not compute as financial truth in UI)

---

# 9. Service Contracts (Frontend Perspective)

> Note: backend API paths are not defined in provided frontend issue; contracts below specify required semantics and payloads. If actual endpoints differ, map them via Moqui service layer.

## Load/view calls
1. **List vendor payable bills**
   - Input: `vendorId`
   - Output: list of bills with `billId`, `billNumber`, `dueDate?`, `invoiceDate?`, `openBalance`, `currency`, `status`
   - Errors: 401/403 unauthorized; 404 vendor not found

2. **Get payment detail**
   - Input: `billingPaymentId` (or `paymentRef`)
   - Output: payment + allocations + status history + gl ack reference (if available)
   - Errors: 404 not found; 403 unauthorized

## Create/submit calls
1. **Execute payment (idempotent)**
   - Input:
     - `paymentRef` (idempotency key)
     - `vendorId`
     - `grossAmount`, `currency`
     - `allocations[]` optional (explicit allocation)
   - Output:
     - `billingPaymentId`
     - `status` (e.g., `GATEWAY_SUCCEEDED` and/or `GL_POST_PENDING`)
     - `gatewayTransactionId` when succeeded
     - `allocationsApplied[]`
     - `unappliedAmount` if any
   - Errors:
     - 422 validation (invalid amounts, invalid bills, missing required fields)
     - 409 conflict/state (e.g., duplicate with different payload, or bills not payable/open)
     - 503 gateway unavailable/downstream error
   - Idempotency behavior:
     - Same `paymentRef` returns same `billingPaymentId` and outcome without re-executing gateway

## Error handling expectations (frontend)
- 422: show inline errors; keep user inputs
- 409 with idempotency: navigate to existing Payment Detail (if `billingPaymentId` provided) or show link to search by `paymentRef`
- 503: show retry; do not clear form

---

# 10. State Model & Transitions

## Allowed states (from backend reference)
- `INITIATED`
- `GATEWAY_PENDING`
- `GATEWAY_FAILED`
- `GATEWAY_SUCCEEDED`
- `GL_POST_PENDING`
- `GL_POSTED`
- `GL_POST_FAILED`

## Role-based transitions
- AP Clerk can initiate payment (INITIATED â†’ GATEWAY_PENDING)
- Only system/back-end processes transition gateway and GL statuses after submission
- UI should not present manual state transition controls (no â€œmark postedâ€)

## UI behavior per state
- `GATEWAY_PENDING`: show â€œProcessing paymentâ€; disable edits; allow leaving screen, but show status on detail
- `GATEWAY_FAILED`: show failure reason if provided; allow starting a new payment (new paymentRef)
- `GL_POST_PENDING`: show â€œPayment succeeded; GL posting pendingâ€
- `GL_POSTED`: show posted reference and timestamp
- `GL_POST_FAILED`: show â€œGL posting failed; requires back office remediationâ€ (no retry button unless backend provides explicit actionâ€”out of scope)

---

# 11. Alternate / Error Flows

## Validation failures
- Missing vendor/bills/amount/paymentRef â†’ block submit with client-side validation
- Allocation sum > grossAmount â†’ block submit and highlight allocation section
- Negative applied amounts â†’ block submit

## Concurrency conflicts
- Bill open balance changed between load and submit â†’ backend returns 409/422; UI shows message â€œBill balances changed, reload billsâ€ and provides Reload action

## Unauthorized access
- 401: redirect to login
- 403: show â€œNot authorized to execute paymentsâ€ and hide submit actions

## Empty states
- No open bills for vendor: show empty state and disable submit (unless policy allows unapplied/vendor credit paymentsâ€”see Open Questions)

---

# 12. Acceptance Criteria (Gherkin)

## Scenario 1: Execute payment with explicit allocations (success)
Given I am an authorized AP Clerk  
And vendor "V" has payable bills "B1" and "B2" with open balances  
When I create a new payment for vendor "V" with gross amount 100.00 and paymentRef "PR-001"  
And I enter explicit allocations of 60.00 to "B1" and 40.00 to "B2"  
And I submit Execute Payment  
Then the system creates or returns a BillingPayment with a billingPaymentId  
And the payment status is "GATEWAY_SUCCEEDED" or later  
And the allocations displayed match 60.00 for "B1" and 40.00 for "B2"  
And the UI navigates to the Payment Detail screen for that billingPaymentId

## Scenario 2: Execute payment without allocations (auto allocation)
Given I am an authorized AP Clerk  
And vendor "V" has three payable bills with distinct due dates  
When I create a new payment for vendor "V" with gross amount 200.00 and paymentRef "PR-002"  
And I do not provide explicit allocations  
And I submit Execute Payment  
Then the payment executes successfully  
And the Payment Detail shows allocations created by the system  
And the UI does not require the user to manually allocate before submission

## Scenario 3: Partial payment allocation allowed
Given I am an authorized AP Clerk  
And vendor "V" has a payable bill "B1" with open balance 500.00  
When I submit a payment of 100.00 with an explicit allocation of 100.00 to "B1"  
Then the payment is accepted  
And the allocation of 100.00 is shown on Payment Detail  
And the bill is not treated as fully settled by the UI (no â€œPaid in fullâ€ assertion unless returned by backend)

## Scenario 4: Payment amount exceeds allocatable balance results in unapplied remainder
Given I am an authorized AP Clerk  
And vendor "V" has payable bills totaling an open balance of 50.00  
When I submit a payment of 100.00 with paymentRef "PR-003"  
Then the payment is accepted  
And the Payment Detail shows allocations totaling 50.00  
And the Payment Detail shows an unapplied remainder of 50.00

## Scenario 5: Idempotency prevents duplicate execution
Given I am an authorized AP Clerk  
And I have already submitted a payment with paymentRef "PR-004"  
When I submit another payment request with the same paymentRef "PR-004"  
Then the system does not execute the gateway payment again  
And the UI receives the same billingPaymentId and outcome as the original  
And the UI shows the existing Payment Detail instead of creating a duplicate

## Scenario 6: Allocation validation blocks submit (sum exceeds gross)
Given I am an authorized AP Clerk  
And vendor "V" has payable bills "B1" and "B2"  
When I enter gross amount 100.00  
And I enter allocations 80.00 to "B1" and 30.00 to "B2"  
Then the UI blocks submission  
And I see an error indicating allocations exceed the payment amount

## Scenario 7: Gateway failure shows failure and no allocations assumed
Given I am an authorized AP Clerk  
When I submit Execute Payment and the gateway returns a failure  
Then the UI shows a payment status of "GATEWAY_FAILED" on the Payment Detail  
And the UI does not show allocations as applied unless returned by backend  
And the UI provides a way to start a new payment with a new paymentRef

## Scenario 8: GL posting pending then posted is visible on refresh
Given a payment has status "GL_POST_PENDING"  
When I open Payment Detail and refresh after the accounting acknowledgement is processed  
Then I see the payment status "GL_POSTED"  
And I see a journal entry reference (journalEntryId/postingRef) and posted timestamp if provided

---

# 13. Audit & Observability

## User-visible audit data
- Payment Detail displays:
  - `paymentRef`, `billingPaymentId`, `gatewayTransactionId`
  - Status timeline: initiated, gateway result, GL posting result (with timestamps and actor/system)
- Display â€œCreated byâ€ (user) and created timestamp if available from backend

## Status history
- UI should render status transition list if backend provides it; otherwise show current status only.

## Traceability expectations
- Payment Detail must show linked vendor and linked bills (via allocations) for audit navigation.

---

# 14. Non-Functional UI Requirements
- **Performance:** Vendor bills list loads within 2s for up to 200 bills; show loading state and allow filtering.
- **Accessibility:** All form controls labeled; errors announced; keyboard navigable allocation grid.
- **Responsiveness:** Works on tablet width; allocation grid supports horizontal scroll.
- **i18n/timezone/currency:** Currency formatting uses tenant locale; timestamps shown in user timezone; do not assume single currency if backend returns `currencyUomId`.

---

# 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Show explicit empty state when vendor has no payable bills; qualifies as safe UX ergonomics. Impacted: UX Summary, Error Flows.
- SD-UX-INFLIGHT-SUBMIT-GUARD: Disable submit during in-flight request to prevent double-click duplicates; safe because backend is idempotent but UX reduces accidental retries. Impacted: Functional Behavior, Error Flows.
- SD-ERR-STANDARD-MAPPING: Map 422/409/503 to inline validation vs conflict vs retryable toast; safe because itâ€™s standard HTTP semantics handling without changing domain policy. Impacted: Service Contracts, Error Flows.

---

# 16. Open Questions
1. **Payment method/instrument capture:** What payment instrument fields are required from the UI for AP vendor payments (e.g., bank account, ACH, check, card), and how are they represented? (Blocking: cannot build input form/service payload.)
2. **Currency source-of-truth:** Is currency always implied by tenant/location/vendor, or must user select `currencyUomId`? If selectable, what are allowed currencies per vendor?
3. **paymentRef generation:** Should the UI generate a UUID by default, or must users enter an external reference (e.g., bank transfer reference)? What uniqueness scope applies (tenant-wide vs vendor-wide)?
4. **Permissions:** What exact permission IDs/roles gate: execute payment, view payment detail, view vendor bills, view GL posting references?
5. **API endpoints/contracts:** What are the concrete Moqui service names or REST endpoints for:
   - listing vendor payable bills
   - executing payment (idempotent)
   - fetching payment detail by id/paymentRef
   - fetching status history / GL acknowledgement
6. **Fee capture:** Should `feeAmount`/`netAmount` ever be entered in UI, or are they always returned by gateway/backend? If returned asynchronously, how is it updated on detail screen?
7. **Unapplied remainder handling UX:** When payment exceeds allocatable open balance, should UI allow submitting anyway without any bill selected (creating pure vendor credit/unapplied cash), or must at least one bill be selected?

---

## Original Story (Unmodified â€“ For Traceability)

Title: [FRONTEND] [STORY] AP: Execute Payment and Post to GL â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/192

====================================================================================================

FRONTEND STORY (FULL CONTEXT)

====================================================================================================

Title: [FRONTEND] [STORY] AP: Execute Payment and Post to GL
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/192
Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] AP: Execute Payment and Post to GL

**Domain**: payment

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Accounts Payable (Bill â†’ Payment)

## Story
AP: Execute Payment and Post to GL

## Acceptance Criteria
- [ ] Payment allocates across one or more bills (full/partial)
- [ ] GL postings: Dr AP, Cr Cash/Bank (per rules)
- [ ] Fees/unallocated amounts handled per policy
- [ ] Idempotent by paymentRef/eventId


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ISSUE #209: [FRONTEND] [STORY] Invoicing: Finalize and Issue Invoice â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/209
File: ./scripts/story-work/frontend/209/after.md
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## ğŸ·ï¸ Labels (Proposed)

STOP: Clarification required before finalization

### Required
- type:story
- domain:billing
- status:draft

### Recommended
- agent:billing-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

# 1. Story Header

## Title
[FRONTEND] [STORY] Invoicing: Finalize and Issue Invoice

## Primary Persona
Back Office / Accounts Receivable Clerk

## Business Value
Convert a reviewed Draft invoice into an official, immutable Issued invoice with auditability and downstream accounting/event emission readiness, reducing billing errors and preventing duplicate issuance.

---

# 2. Story Intent

## As a / I want / So that
- **As an** Accounts Receivable Clerk  
- **I want to** issue a Draft invoice after review  
- **So that** it becomes an official Issued invoice (locked/immutable), auditable, and ready for delivery and downstream accounting processing.

## In Scope
- Frontend â€œIssue Invoiceâ€ action from an invoice view screen.
- Frontend display of invoice totals and traceability links (read-only review context).
- Frontend orchestration of issuance request to Moqui backend (service + transition).
- Handling validation errors, conflict errors (already issued), and authorization failures.
- Post-issuance UI behavior: lock editing actions, show issued metadata, and show delivery preparation status (as returned by backend).

## Out of Scope
- Credit/rebill, credit memo creation, refunds/chargebacks.
- Editing invoice lines/totals (except as already existing elsewhere).
- Payment capture/collection flows.
- Accounting postings / AR creation UI (Accounting consumes events asynchronously).
- Designing invoice numbering scheme policy.
- Implementing event bus/outbox mechanics (backend responsibility).

---

# 3. Actors & Stakeholders
- **Accounts Receivable Clerk (primary user):** reviews and issues invoices.
- **Customer (indirect):** receives invoice via email/print.
- **Billing domain / service (SoR):** owns invoice lifecycle state and issuance validations.
- **Accounting domain (downstream consumer):** creates AR and posts based on `InvoiceIssued` event; not directly controlled by frontend.
- **Auditor/Compliance:** requires non-repudiation and issuance audit trail.

---

# 4. Preconditions & Dependencies

## Preconditions
- User is authenticated.
- User has permission to issue invoices (permission name referenced in backend: `invoice:issue`).
- Invoice exists and is accessible within tenant/businessUnit boundaries.
- Invoice is in **Draft** state at time user initiates issuance.

## Dependencies (must exist or be implemented in Moqui backend)
- A screen endpoint to view invoice details including:
  - header, customer, totals, tax breakdown, traceability links, delivery preference.
- A backend operation to issue the invoice (single atomic transaction) that:
  - validates issuance requirements,
  - transitions state Draft â†’ Issued,
  - sets `invoiceNumber`, `issuedAt`, `issuedBy`,
  - locks invoice from edits,
  - records an audit event,
  - queues delivery preparation (email/print) according to preference,
  - triggers/queues `InvoiceIssued` event emission idempotently.
- Backend must return actionable validation errors (field + message + code), and 409 on invalid state.

---

# 5. UX Summary (Moqui-Oriented)

## Entry Points
- From invoice search/list screen: open invoice detail.
- From work order context (if present): navigate to associated invoice detail.

## Screens to Create/Modify
1. **Modify**: `InvoiceDetail` screen (existing or to be created if missing)
   - Add â€œIssue Invoiceâ€ primary action when invoice is Draft and user is authorized.
   - Add issued-state summary panel (issued metadata + delivery prep status).
   - Add audit/history section (issuance audit entry visible).

2. **(Optional) Create/Modify**: `InvoiceIssueConfirm` modal/dialog screenlet
   - Confirmation step showing immutability warning and delivery method recap.

## Navigation Context
- Path example (Moqui screen path to be aligned to repo conventions):  
  `/apps/pos/invoice/detail?invoiceId=...`
- After issuance, remain on Invoice Detail with refreshed state (Issued).

## User Workflows
### Happy Path
1. User opens Draft invoice detail.
2. Reviews totals and traceability.
3. Clicks **Issue Invoice**.
4. Confirms (if confirmation UI used).
5. UI calls issuance transition/service.
6. UI refreshes invoice; shows state **Issued**, shows `invoiceNumber`, `issuedAt`, `issuedBy`, and delivery prep status.
7. Edit actions are disabled/hidden.

### Alternate Paths
- Validation fails: UI stays on Draft invoice detail; shows a structured list of errors with direct links/anchors to affected sections (customer info, delivery, taxes/totals, traceability).
- Already issued (409): UI refreshes and displays banner â€œInvoice already issuedâ€ and shows current Issued metadata.
- Unauthorized: show â€œYou donâ€™t have permission to issue invoicesâ€ and do not attempt transition again.

---

# 6. Functional Behavior

## Triggers
- User clicks â€œIssue Invoiceâ€ on Draft invoice detail screen.

## UI Actions
- Show confirmation (required if any irreversible action; see Open Questions).
- Disable the Issue button while request is in-flight (prevent double submit).
- Submit issuance via Moqui transition calling a backend service.
- On success:
  - refresh invoice detail dataset from backend,
  - show success notification with invoice number,
  - disable/hide edit actions and â€œIssue Invoiceâ€ action.
- On failure:
  - map backend error codes to UI messages,
  - keep user on same screen and preserve scroll position,
  - show inline validation errors and/or banner error.

## State Changes (UI-observed)
- Invoice `status`: Draft â†’ Issued
- Invoice becomes immutable: UI must treat all invoice fields as read-only when status != Draft.

## Service Interactions
- Load invoice view service on screen entry and after issuance.
- Issue invoice service on action.
- Optional: load audit history service after issuance to show the issuance audit entry.

---

# 7. Business Rules (Translated to UI Behavior)

## Validation (frontend responsibilities)
Frontend must **not** implement financial validation logic; it must:
- Present backend validation failures clearly and actionably.
- Perform minimal client-side validation only for UX (e.g., confirm dialog acknowledgement), not for policy.

Backend validation errors that must be supported in UI (examples; exact codes are backend-defined and currently unclear):
- Missing customer billing address.
- Delivery method Email but missing/invalid email address.
- Totals inconsistent or tax calculation not finalized.
- Missing traceability links (workOrderId, billableScopeSnapshotId, customerAccountId).
- Invoice has no line items.
- Line item has invalid quantity or unit price.

## Enable/Disable Rules
- **Issue Invoice** button:
  - Enabled only when:
    - invoice.status == `Draft`
    - user has `invoice:issue`
    - invoice is not currently â€œissuingâ€ (in-flight)
  - Hidden or disabled (with tooltip) otherwise.
- Edit actions (edit header/lines):
  - Enabled only when invoice.status == `Draft` and user has edit permission (existing behavior).
  - Disabled/hidden for Issued/Paid/Void.

## Visibility Rules
- Show issuance metadata block when status in (`Issued`, `Paid`, `Void`) if fields exist:
  - invoiceNumber, issuedAt, issuedBy.
- Show delivery preference summary always (read-only), but show delivery prep status only after issuance if backend provides it.

## Error Messaging Expectations
- Validation failures: show a summary banner â€œCannot issue invoiceâ€ plus a list of errors.
- Conflict (already issued): â€œInvoice is already issued; page refreshed.â€
- Unauthorized: â€œNot authorized to issue invoices.â€
- Transient/server: â€œIssue failed due to server error. Try again.â€ with correlation/reference id if provided.

---

# 8. Data Requirements

## Entities Involved (frontend-view perspective)
- `Invoice` (SoR: Billing domain)
- `Customer` / `CustomerAccount` (SoR: CRM domain, but consumed here read-only)
- `DeliveryPreference` (likely Billing or CRM; unclear)
- `AuditEvent` / `InvoiceAuditEvent` (domain ownership unclear in frontend repo; must be readable)

## Fields (type, required, defaults)
> Types are UI-level; backend canonical types may differ.

### Invoice (read-only except where existing edit screens apply)
- `invoiceId` (string/UUID) â€” required
- `status` (enum: Draft, Issued, Paid, Void) â€” required
- `invoiceNumber` (string) â€” required after issuance; may be null in Draft
- `invoiceVersion` (number/int) â€” required for idempotency semantics (needed for display/debug; backend uses for event idempotency)
- `issuedAt` (datetime) â€” required after issuance
- `issuedBy` (string/UUID) â€” required after issuance
- `currencyUomId` (string) â€” required
- Totals (all read-only):
  - `subTotal` (decimal, currency scale)
  - `taxTotal` (decimal)
  - `feeTotal` (decimal) (if applicable)
  - `discountTotal` (decimal) (if applicable)
  - `grandTotal` (decimal) â€” required
- Tax breakdown:
  - list of tax lines: `taxAuthority/jurisdiction`, `taxRate` (decimal), `taxAmount` (decimal)

### Invoice Line Items (read-only here)
- `invoiceItemId` (string/UUID)
- `description` (string)
- `quantity` (decimal)
- `unitPrice` (decimal)
- `lineSubTotal` (decimal)
- `lineTaxTotal` (decimal)
- `lineTotal` (decimal)

### Customer / Billing Info (read-only display)
- `customerAccountId` (string/UUID) â€” required
- `billingAddress` (structured) â€” required to issue
- `emailAddress` (string) â€” conditionally required if deliveryMethod == Email

### Delivery Preference (read-only)
- `deliveryMethod` (enum: Email, Print, Both? TBD) â€” required to prepare delivery
- `deliveryStatus` (enum/string; e.g., Queued, Sent, Failed) â€” optional, likely after issuance

### Traceability Links (read-only; required to issue)
- `workOrderId` (string/UUID)
- `billableScopeSnapshotId` (string/UUID)

## Read-only vs Editable by State/Role
- In **Draft**:
  - Issuance action available with `invoice:issue`.
  - Any existing edit features remain as-is (not defined here).
- In **Issued/Paid/Void**:
  - All invoice header/lines/totals are read-only.
  - Issuance action not available.

## Derived/Calculated Fields
- Display-only:
  - `isIssueAllowed` derived from status + permission + backend hints (if provided).
  - Human-readable formatted totals/dates.

---

# 9. Service Contracts (Frontend Perspective)

> Exact service names/endpoints are not provided; Moqui implementation must map these to actual services/transitions.

## Load/View Calls
1. `Invoice.get#Detail`
   - **Input**: `invoiceId`
   - **Output**: invoice header, lines, totals, customer billing info, delivery preference, traceability, audit summary.

2. `Invoice.get#AuditHistory` (optional if included in detail payload)
   - **Input**: `invoiceId`
   - **Output**: list of audit events including issuance event.

## Create/Update Calls
- None in this story (issuance is a transition/command).

## Submit/Transition Calls
1. `Invoice.issue` (command)
   - **Input**: `invoiceId`
   - **Output (success)**:
     - updated invoice snapshot (preferred) OR minimal fields + require reload
     - `status=Issued`, `invoiceNumber`, `issuedAt`, `issuedBy`
     - delivery preparation info if available (`deliveryMethod`, `deliveryStatus`)
   - **Output (failure)**:
     - validation errors with codes and field references
     - conflict error when invoice not Draft

## Error Handling Expectations
- **422 Unprocessable Entity**: validation errors; show list; do not change local invoice state.
- **409 Conflict**: invalid state (already issued/paid/void); refresh invoice and show banner.
- **403 Forbidden**: user lacks permission; show unauthorized error.
- **404 Not Found**: invoiceId invalid or inaccessible; route to not-found screen.
- **503 Service Unavailable / timeout**: transient; show retry guidance.

---

# 10. State Model & Transitions

## Allowed States (minimum per billing guide)
- `Draft`
- `Issued`
- `Paid`
- `Void`

## Role-Based Transitions
- Accounts Receivable Clerk with `invoice:issue`:
  - `Draft` â†’ `Issued` only.
- No other transitions in scope.

## UI Behavior per State
- **Draft**
  - Show Issue Invoice action (if authorized).
  - Show warning that issuance locks the invoice.
- **Issued**
  - Hide/disable Issue action.
  - Lock all edit actions.
  - Show issued metadata + delivery prep status.
- **Paid/Void**
  - Same as Issued for locking in this UI, plus any existing paid/void banners (not defined here).

---

# 11. Alternate / Error Flows

## Validation Failures
- Backend returns field-level errors (e.g., missing billing address).
- UI shows:
  - Summary banner
  - Error list with â€œFixâ€ guidance where possible (link to customer screen if thatâ€™s where billing address is edited; see Open Questions).

## Concurrency Conflicts
- Two clerks attempt issuance:
  - First succeeds.
  - Second receives 409.
  - UI refreshes and shows â€œAlready issuedâ€ with issued metadata.

## Unauthorized Access
- User without `invoice:issue`:
  - Issue button not shown OR disabled.
  - Direct navigation to issuance action URL/transition returns 403; UI shows not authorized.

## Empty States
- Invoice has no lines:
  - Issuance attempt returns validation error; UI displays it.
- Missing traceability links:
  - validation error; UI displays.

---

# 12. Acceptance Criteria (Gherkin)

## Scenario 1: Issue a valid Draft invoice successfully
**Given** I am an authenticated Accounts Receivable Clerk with permission `invoice:issue`  
**And** an invoice exists with `status = Draft` and all required customer billing info, taxes/totals, and traceability links present  
**When** I click â€œIssue Invoiceâ€ and confirm the action  
**Then** the system issues the invoice successfully  
**And** the invoice detail view refreshes showing `status = Issued`  
**And** `invoiceNumber`, `issuedAt`, and `issuedBy` are displayed  
**And** invoice edit actions are disabled/hidden  
**And** â€œIssue Invoiceâ€ action is no longer available.

## Scenario 2: Missing billing address blocks issuance
**Given** I have permission `invoice:issue`  
**And** an invoice exists with `status = Draft`  
**And** the customer billing address is missing  
**When** I attempt to issue the invoice  
**Then** issuance is blocked  
**And** the invoice remains `status = Draft` in the UI after refresh  
**And** the UI displays an actionable error indicating billing address is required.

## Scenario 3: Email delivery requires email address
**Given** I have permission `invoice:issue`  
**And** an invoice exists with `status = Draft`  
**And** the invoice delivery method is â€œEmailâ€  
**And** the email address is missing or invalid  
**When** I attempt to issue the invoice  
**Then** issuance is blocked  
**And** the UI displays an actionable error indicating a valid email address is required for email delivery.

## Scenario 4: Prevent duplicate issuance (already issued)
**Given** I have permission `invoice:issue`  
**And** an invoice exists with `status = Issued`  
**When** I attempt to issue the invoice (via UI action or direct URL)  
**Then** the system responds with a conflict error  
**And** the UI refreshes and continues to show the invoice in `status = Issued`  
**And** the UI indicates the invoice was already issued  
**And** no second issuance is performed.

## Scenario 5: Unauthorized user cannot issue invoice
**Given** I am authenticated but do not have permission `invoice:issue`  
**And** an invoice exists with `status = Draft`  
**When** I view the invoice detail  
**Then** I do not see an enabled â€œIssue Invoiceâ€ action  
**When** I attempt to issue the invoice via the issuance endpoint/transition  
**Then** I receive a forbidden/unauthorized error  
**And** the UI shows an authorization error message.

## Scenario 6: Transient backend failure during issuance
**Given** I have permission `invoice:issue`  
**And** an invoice exists with `status = Draft`  
**When** I attempt to issue the invoice and the backend returns a 503 or times out  
**Then** the UI shows a non-destructive error message with retry guidance  
**And** the UI re-enables the â€œIssue Invoiceâ€ action after the failure  
**And** the invoice remains `status = Draft` (no optimistic state change).

---

# 13. Audit & Observability

## User-visible audit data
- Invoice detail screen must display issuance audit metadata at minimum:
  - `issuedAt`, `issuedBy`, and optionally an â€œIssuedâ€ audit event row with timestamp and actor.
- If audit history list exists, include the issuance event entry after successful issuance (refresh).

## Status history
- UI should show current status and (if available) a status history timeline/list including transition Draft â†’ Issued with timestamp and actor.

## Traceability expectations
- Invoice detail must show traceability links used for audit:
  - `workOrderId`, `billableScopeSnapshotId`, `customerAccountId`
- After issuance, these remain visible and uneditable.

---

# 14. Non-Functional UI Requirements

## Performance
- Invoice detail load: target < 2s on typical network for typical invoice size.
- Issuance action: show loading state immediately; if > 5s, show â€œStill workingâ€¦â€ hint without duplicating request.

## Accessibility
- Buttons and error banners must be keyboard accessible.
- Error summary must be announced to screen readers (aria-live) and focus should move to error summary on validation failure.

## Responsiveness
- Invoice detail and issuance action usable on tablet widths; action buttons must remain reachable without horizontal scrolling.

## i18n / timezone / currency
- Display currency using `currencyUomId` and locale formatting.
- Display `issuedAt` in userâ€™s timezone (or configured tenant timezone) consistently.

---

# 15. Applied Safe Defaults
- **SD-UX-EMPTY-STATE-01**: Show explicit empty-state messaging for missing audit history / missing delivery status rather than leaving blank UI; qualifies as safe because it does not change domain behavior, only presentation. (Impacted: UX Summary, Alternate / Error Flows)
- **SD-UX-DOUBLE-SUBMIT-02**: Disable primary action while request is in-flight to prevent duplicate submissions; safe because it is purely client-side ergonomics and reduces accidental retries. (Impacted: Functional Behavior, Alternate / Error Flows)
- **SD-ERR-MAP-HTTP-03**: Standard HTTP error mapping (422 validation, 409 conflict, 403 unauthorized, 404 not found, 503 transient) to consistent UI banners; safe because it follows conventional transport semantics without inventing domain policy. (Impacted: Service Contracts, Alternate / Error Flows, Acceptance Criteria)

---

# 16. Open Questions

1. **Rewrite Variant conflict:** Domain is `domain:billing`, but the required mapping table forces `accounting-strict` for billing. Confirm whether billing stories should use `accounting-strict` or whether this table should map `domain:billing` â†’ a billing variant. (Blocks finalization due to process constraint.)
2. **Moqui routes/service names:** What are the canonical Moqui screen paths and service names for invoice detail and issuance in this frontend repo (e.g., `apps/pos/invoice/InvoiceDetail` and `InvoiceServices.issueInvoice`), so the story can specify exact transitions?
3. **Confirmation requirement:** Is an issuance confirmation modal required by product policy (because issuance is irreversible), or should it be a single-click action with server-side confirmation only?
4. **Delivery preference model:** Where is `DeliveryPreference` sourced (Billing vs CRM), and what are the allowed values (Email/Print/Both)? Does backend return a `deliveryStatus` after issuance?
5. **Validation error contract:** What is the backend error response shape (fields: `errorCode`, `message`, `field`, `details[]`, `correlationId`), so the UI can implement deterministic error rendering?
6. **Traceability navigation:** Should `workOrderId` and `customerAccountId` be clickable links to other screens? If yes, what are the target screen routes and required permissions?

---

## Original Story (Unmodified â€“ For Traceability)

Title: [FRONTEND] [STORY] Invoicing: Finalize and Issue Invoice â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/209


====================================================================================================

FRONTEND STORY (FULL CONTEXT)

====================================================================================================

Title: [FRONTEND] [STORY] Invoicing: Finalize and Issue Invoice
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/209
Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] Invoicing: Finalize and Issue Invoice

**Domain**: payment

### Story Description

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24300023/Durion_Accounting_Event_Contract_v1.pdf)

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
Back Office / Accounts Receivable Clerk

## Trigger
Draft invoice is reviewed and ready to be issued.

## Main Flow
1. User reviews invoice totals and traceability links.
2. User selects 'Issue Invoice'.
3. System validates invoice completeness (customer details, taxes, totals, traceability).
4. System transitions invoice to Issued/Posted state per workflow.
5. System locks invoice lines and records issuance audit event; prepares delivery (email/print) per preference.

## Alternate / Error Flows
- Validation fails (missing billing info) â†’ block issuance and show actionable errors.
- Invoice already issued â†’ prevent duplicate issuance.

## Business Rules
- Issuance is a state transition with validations and locking.
- Issued invoice should be immutable except via credit/rebill (out of scope).

 ## Data Requirements
  - Entities: Invoice, Customer, AuditEvent, DeliveryPreference
  - Fields: status, issuedAt, issuedBy, deliveryMethod, emailAddress, billingAddress

## Acceptance Criteria
- [ ] Invoice can be issued only when validations pass.
- [ ] Issued invoice is locked against edits.
- [ ] Issuance is auditable and invoice is prepared for delivery.
- [ ] InvoiceIssued event is emitted exactly once per invoice version
- [ ] Event includes full line-item, tax, and total breakdown
- [ ] Accounts Receivable is created correctly
- [ ] Revenue and tax liabilities post accurately
- [ ] Duplicate or replayed events do not double-post

## Integrations

### Accounting
- Emits Event: InvoiceIssued
- Event Type: Posting
- Source Domain: workexec
- Source Entity: Invoice
- Trigger: Invoice finalized and issued
- Idempotency Key: invoiceId + invoiceVersion


## Notes for Agents
Issuance ends quote-to-cash; protect the integrity and lock the record.


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

====================================================================================================

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ISSUE #211: [FRONTEND] [STORY] Invoicing: Preserve Traceability Links (Estimate/Approval/Workorder) â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/211
File: ./scripts/story-work/frontend/211/after.md
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## ğŸ·ï¸ Labels (Proposed)

### Required
- type:story
- domain:billing
- status:draft

### Recommended
- agent:billing-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

STOP: Clarification required before finalization

---

## 1. Story Header

### Title
[FRONTEND] Invoicing: Display & Enforce Invoice Traceability Links (Work Order / Estimate / Approvals)

### Primary Persona
Billing Specialist (authorized POS user) / Billing Administrator

### Business Value
Ensure every invoice is defensible and auditable by (a) surfacing immutable source links to executed/approved work and (b) preventing issuance when traceability is incomplete per billing policy, reducing disputes and compliance risk.

---

## 2. Story Intent

### As a / I want / So that
- **As a** Billing Specialist  
- **I want** the invoice UI to show traceability links (work order, estimate version, approval artifacts) captured on the invoice and enforce issuance gating when required links are missing  
- **So that** I can verify the invoice is tied to approved scope and executed work before issuing/collecting payment.

### In-scope
- Add **Traceability** section to invoice view/edit (Draft) screens showing immutable source references captured by Billing.
- Enforce **Draft â†’ Issued** transition gating in UI when traceability policy requirements are not satisfied (based on backend validation + UI precheck).
- Authorized access to view/download approval artifacts from invoice context (via backend-provided links/IDs).
- Error/empty-state handling when traceability is missing or artifacts cannot be fetched.

### Out-of-scope
- Generating the traceability snapshot (backend responsibility).
- Customer-facing invoice document formatting / â€œinclude identifiers on invoice PDF/emailâ€ configuration and rendering (explicitly separate story).
- Creating/editing estimates, approvals, or work orders.
- Any reconciliation/accounting posting behavior.

---

## 3. Actors & Stakeholders
- **Billing Specialist (primary user):** Reviews invoice traceability and issues invoice.
- **Billing Administrator (privileged user):** Can access more details/artifacts; resolves traceability exceptions.
- **Auditor (stakeholder):** Requires immutable lineage and history.
- **System (Moqui UI + Billing services):** Loads invoice, checks validations, performs transitions.
- **Upstream Work Execution system (stakeholder dependency):** Source of work order/estimate/approval identifiers (already snapshotted onto invoice).

---

## 4. Preconditions & Dependencies
- User is authenticated and authorized to access invoice screens.
- Backend Billing provides invoice detail payload including immutable traceability fields (see **Data Requirements**).
- Backend provides a service endpoint to attempt invoice issuance (Draft â†’ Issued) that:
  - rejects issuance if policy-required traceability is missing
  - returns structured errors (422/409) with reason codes/messages
- Backend provides a service endpoint to fetch approval artifacts (or artifact metadata + secure download URLs) subject to permissions.
- Invoice exists in `DRAFT` or `ISSUED` state; traceability fields are immutable once persisted.

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- From invoice list: select an invoice â†’ Invoice Detail screen.
- From work order context (if present in app): open linked invoice â†’ Invoice Detail.

### Screens to create/modify
- **Modify**: `InvoiceDetail` screen (draft + issued views) to add **Traceability** panel.
- **Modify**: `InvoiceIssueConfirm` (or existing issue action area/modal) to enforce gating and show blocking reasons.
- **Optional (if pattern exists)**: `ArtifactViewer` screen/dialog for viewing artifact metadata + download/open actions.

> Exact screen names/paths must match repo conventions (Open Question if unknown).

### Navigation context
- Invoice Detail includes:
  - existing invoice summary
  - new Traceability panel with identifiers and links
  - issuance action area (only when in Draft and authorized)

### User workflows

**Happy path: view traceability + issue**
1. User opens a Draft invoice.
2. User reviews Traceability panel:
   - Work order link
   - Estimate version link (if present)
   - Approval record(s) / artifact(s) list (if present)
3. User clicks â€œIssue Invoiceâ€.
4. UI calls backend issue service; on success navigates/refreshes to `ISSUED` state and shows immutable traceability still visible.

**Alternate: missing optional traceability**
- Estimate/approval data is absent but not required by policy â†’ Traceability panel shows â€œNot providedâ€ with reason text; issuance allowed.

**Alternate: missing required traceability**
- Required approval/estimate is missing (policy) â†’ UI disables â€œIssue Invoiceâ€ and shows blocking reason; if user attempts via direct action, backend returns validation error and UI displays it.

**Alternate: artifact retrieval failure**
- Artifact list fails to load due to permission/404/timeout â†’ show partial traceability data; issuance behavior depends on policy + backend response.

---

## 6. Functional Behavior

### Triggers
- Invoice Detail screen loads.
- User expands Traceability section.
- User clicks an artifact to view/download.
- User clicks â€œIssue Invoiceâ€.

### UI actions
- Load invoice details (including traceability snapshot).
- Render traceability identifiers with copy-to-clipboard.
- Provide navigation links (internal route) to related objects **only if** the app has those screens and user is authorized.
- Retrieve artifact metadata and allow open/download if authorized.
- Issue invoice via transition call; handle success/failure.

### State changes
- Invoice status changes from `DRAFT` â†’ `ISSUED` only on successful backend transition.
- No UI-side mutation of traceability fields (read-only always).

### Service interactions
- `InvoiceDetail` load service.
- `InvoiceArtifactList` / `ArtifactGet` service(s) (if separate).
- `InvoiceIssue` transition/service.

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- Traceability fields are **display-only**; UI must not present inputs to edit:
  - `sourceWorkorderId`
  - `sourceEstimateId` / `sourceEstimateVersionId`
  - `sourceApprovalIds`
  - `sourceSchemaVersion`
- Issuance gating:
  - UI must treat backend as authoritative.
  - UI should pre-check and disable Issue action when invoice detail includes backend-provided â€œissuance blockersâ€ (if available) **or** when mandatory traceability fields are absent and policy says theyâ€™re required (policy source unclear â†’ Open Question).
  - On issuing attempt, must handle backend `422` (validation), `409` (state conflict), `403` (not authorized).

### Enable/disable rules
- â€œIssue Invoiceâ€ button visible only when:
  - invoice status == `DRAFT`
  - user has permission `invoice:issue` (or equivalent)
- â€œView/Download Artifactâ€ actions visible only when:
  - artifact exists and user has permission `approvalArtifact:view` (name TBD)
  - backend indicates artifact is accessible (e.g., signed URL returned)

### Visibility rules
- Traceability panel visible to authorized roles; if user lacks permission, panel either hidden or shows â€œInsufficient permissionsâ€ (needs product decision â†’ Open Question).

### Error messaging expectations
- If issuance blocked due to missing traceability: show a deterministic message including which link(s) are missing (e.g., â€œApproval record required but missingâ€).
- If artifacts missing due to corruption: show blocking banner â€œTraceability incompleteâ€”contact adminâ€ and prevent issuance (policy-driven; backend should enforce).

---

## 8. Data Requirements

### Entities involved (frontend perspective)
- `Invoice` (Billing SoR)
- References (read-only identifiers only):
  - Work Order (WorkExec SoR)
  - Estimate / Estimate Version (WorkExec/CRM depending on architecture; treated as reference only)
  - Approval Record / Document Artifact (approval system; treated as reference only)

### Fields (type, required, defaults)

**Invoice (loaded for display)**
- `invoiceId` (string/UUID, required)
- `status` (`DRAFT|ISSUED|PAID|VOID`, required)
- `sourceWorkorderId` (string/UUID, required, read-only)
- `sourceEstimateId` (string/UUID, optional, read-only)
- `sourceEstimateVersionId` (string/UUID, optional, read-only) *(choose one naming; backend shows both patterns â†’ Open Question)*
- `sourceApprovalIds` (array<string/UUID>, optional, read-only)
- `sourceSchemaVersion` (string, required, read-only)
- `traceabilitySummary` (string, optional, read-only) *(if backend provides)*
- `issuanceBlockers` (array of `{code, message, field?}`, optional) *(if backend provides; recommended to avoid UI guessing)*

**Artifact metadata (if supported)**
- `artifactId` (string/UUID)
- `artifactType` (string)
- `title` (string)
- `createdAt` (datetime)
- `createdBy` (string/userRef)
- `downloadUrl` (string, time-limited) OR `contentRef` (string) with separate download call

### Read-only vs editable by state/role
- All traceability fields: read-only always.
- Artifact access: read-only, permission-gated.

### Derived/calculated fields (frontend)
- `traceabilityStatus` (derived display state):
  - `COMPLETE` when required items present
  - `INCOMPLETE` when required items missing
  - `UNKNOWN` when policy info not provided
> This is display-only; must not be used as sole enforcement.

---

## 9. Service Contracts (Frontend Perspective)

> Moqui service names are placeholders; implementer must map to actual services/endpoints used by this repo.

### Load/view calls
1. **Load Invoice Detail**
   - Input: `invoiceId`
   - Output: Invoice fields + traceability snapshot fields listed above
   - Errors:
     - `404` invoice not found â†’ show not found state
     - `403` unauthorized â†’ show access denied

2. **Load Artifact List for Invoice**
   - Input: `invoiceId` (or `sourceApprovalIds[]`)
   - Output: list of artifact metadata; optionally includes secure `downloadUrl`
   - Errors:
     - `403` unauthorized â†’ hide artifact actions; show â€œNot authorizedâ€
     - `404` artifact missing â†’ mark as missing; if policy requires it, issuance will fail downstream
     - `503` unavailable â†’ show retry option; do not assume artifacts absent

### Submit/transition calls
3. **Issue Invoice**
   - Input: `invoiceId`, optional idempotency token (if frontend participates)
   - Success: updated invoice status `ISSUED` (or redirect to refreshed invoice)
   - Errors:
     - `422` validation (missing required traceability, missing customer billing data, etc.) â†’ render error list; keep in Draft
     - `409` conflict (already issued/voided/changed) â†’ force refresh; show conflict message
     - `503` downstream failure â†’ show non-destructive error and allow retry

### Error handling expectations
- Errors must be displayed in a banner + field-level cues where applicable.
- All service calls should log correlation/trace id if available in response headers (or Moqui context).

---

## 10. State Model & Transitions

### Allowed states (relevant to this story)
- `DRAFT` (editable invoice fields maybe; traceability read-only)
- `ISSUED` (invoice immutable; traceability read-only)
- `PAID`, `VOID` (read-only for this story)

### Role-based transitions
- `DRAFT` â†’ `ISSUED`: requires permission `invoice:issue` and traceability completeness per policy.
- No other transitions in scope.

### UI behavior per state
- **DRAFT**
  - Show Traceability panel
  - Show â€œIssue Invoiceâ€ if permitted and not blocked
- **ISSUED/PAID/VOID**
  - Show Traceability panel
  - Hide issuance action
  - Artifacts remain viewable only if permitted

---

## 11. Alternate / Error Flows

### Validation failures (issuance)
- Missing approval/estimate required by policy:
  - Backend returns `422` with reason code(s)
  - UI displays blocking banner and keeps invoice in Draft

### Concurrency conflicts
- Invoice status changed by another user/session:
  - Backend returns `409`
  - UI prompts â€œInvoice updated elsewhere. Refreshingâ€¦â€ and reloads detail

### Unauthorized access
- User without permission:
  - Invoice load returns `403` OR panel-level permission denies
  - UI shows access denied (screen) or hides panel/actions (needs decision)

### Empty states
- No estimate/approval IDs present:
  - Show â€œNo estimate linkedâ€ / â€œNo approvals linkedâ€ with neutral styling
- Artifact list empty but approval IDs exist:
  - Show â€œArtifacts unavailableâ€ and encourage retry/contact admin

---

## 12. Acceptance Criteria

### Scenario 1: Traceability panel shows immutable links on Draft invoice
**Given** I am an authorized billing user  
**And** an invoice exists in `DRAFT` with `sourceWorkorderId` populated  
**When** I open the Invoice Detail screen  
**Then** I see a Traceability section showing `sourceWorkorderId` and `sourceSchemaVersion` as read-only values  
**And** I see estimate and approval identifiers if present  
**And** there are no editable inputs for traceability fields.

### Scenario 2: Issue action is blocked when backend policy rejects missing traceability
**Given** I am authorized to issue invoices  
**And** an invoice is in `DRAFT`  
**And** required traceability identifiers are missing per billing policy  
**When** I click â€œIssue Invoiceâ€  
**Then** the UI calls the Issue Invoice service  
**And** the service responds with a validation error (e.g., HTTP 422) indicating missing traceability  
**And** the invoice remains in `DRAFT`  
**And** the UI displays an error banner listing the missing traceability requirement(s).

### Scenario 3: Successful issuance preserves visible traceability
**Given** I am authorized to issue invoices  
**And** an invoice is in `DRAFT` with all policy-required traceability present  
**When** I issue the invoice  
**Then** the invoice transitions to `ISSUED`  
**And** the Traceability section still shows the same immutable identifiers  
**And** the â€œIssue Invoiceâ€ action is no longer available.

### Scenario 4: Artifact access is permission-gated
**Given** an invoice shows one or more approval/artifact references  
**When** I do not have permission to view artifacts  
**Then** artifact download/view actions are not shown (or are disabled)  
**And** I see an â€œInsufficient permissionsâ€ message for artifact access.

### Scenario 5: Artifact retrieval failure does not misrepresent completeness
**Given** an invoice includes approval IDs  
**When** artifact list retrieval fails with a transient error (e.g., 503)  
**Then** the UI shows a retryable error state for artifacts  
**And** it does not claim â€œno artifacts existâ€  
**And** issuance behavior remains determined by the backend issue attempt response.

### Scenario 6: Concurrency conflict on issuance
**Given** I have Invoice Detail open for an invoice in `DRAFT`  
**And** another user issues the invoice  
**When** I attempt to issue the invoice  
**Then** I receive a conflict response (409)  
**And** the UI refreshes invoice data  
**And** I see the invoice in `ISSUED` state with issuance action removed.

---

## 13. Audit & Observability

### User-visible audit data
- Invoice detail should show (if already available in app):
  - `issuedAt`, `issuedBy` (read-only) once issued
  - traceability identifiers as immutable references

### Status history
- If the app has a status history component, ensure issuance adds/refreshes the timeline entry (no new backend assumptions).

### Traceability expectations
- UI must display `sourceSchemaVersion` (workexec contract version) for audit defensibility.
- When issuance is blocked, UI should display backend-provided reason code(s) to support support/audit workflows.

---

## 14. Non-Functional UI Requirements
- **Performance:** Invoice detail load should render skeleton/loading state; artifact list loads asynchronously to avoid blocking main invoice render.
- **Accessibility:** Traceability section must be keyboard navigable; links/buttons have accessible names; error banners announced (ARIA live region).
- **Responsiveness:** Traceability panel readable on tablet-sized POS devices; identifiers should wrap and provide copy action.
- **i18n/timezone/currency:** Not applicable beyond standard timestamp formatting already used by app; do not introduce new currency behavior.

---

## 15. Applied Safe Defaults
- Default ID: UI-EMPTY-STATE-01  
  - Assumed: Standard empty states for missing optional estimate/approval identifiers (â€œNot providedâ€).  
  - Why safe: Purely presentational; does not change business policy or state.  
  - Impacted sections: UX Summary, Alternate / Error Flows.
- Default ID: UI-ERROR-HANDLING-01  
  - Assumed: Map HTTP 422/409/403/404/503 to banner messaging + retry where applicable.  
  - Why safe: Standard error mapping; enforcement remains backend-authoritative.  
  - Impacted sections: Service Contracts, Alternate / Error Flows, Acceptance Criteria.
- Default ID: UI-ASYNC-LOAD-01  
  - Assumed: Load artifact list separately after invoice detail to improve perceived performance.  
  - Why safe: Does not alter data or policy; only sequencing of reads.  
  - Impacted sections: Non-Functional UI Requirements, UX Summary.

---

## 16. Open Questions

1. **Backend contract (required):** What are the exact field names returned for estimate reference: `sourceEstimateId` vs `sourceEstimateVersionId` vs both? Provide the canonical response schema used by the frontend.  
2. **Issuance gating UX:** Does the invoice detail payload include an explicit `issuanceBlockers` (or similar) array we should render/interpret, or must the frontend only learn blockers from the issuance attempt (422 response)?  
3. **Permissions:** What are the exact permission IDs/roles for:
   - viewing traceability panel
   - issuing invoice
   - viewing/downloading approval artifacts
4. **Artifact retrieval API:** What service/endpoint returns approval artifacts from invoice context?
   - Input: invoiceId vs approvalIds
   - Output: signed URL vs separate download endpoint
5. **Policy specificity:** Which traceability identifiers are *policy-required* to issue (approval always? estimate version always? configurable per customer/account)? Frontend must not guess.
6. **Navigation links:** Do screens/routes exist for Work Order, Estimate, Approval record in this frontend? If not, should identifiers be copy-only (no links) until those screens exist?

---

## Original Story (Unmodified â€“ For Traceability)

Title: [FRONTEND] [STORY] Invoicing: Preserve Traceability Links (Estimate/Approval/Workorder) â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/211


====================================================================================================

FRONTEND STORY (FULL CONTEXT)

====================================================================================================

Title: [FRONTEND] [STORY] Invoicing: Preserve Traceability Links (Estimate/Approval/Workorder)
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/211
Labels: frontend, story-implementation, user

## Frontend Implementation for Story

**Original Story**: [STORY] Invoicing: Preserve Traceability Links (Estimate/Approval/Workorder)

**Domain**: user

### Story Description

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
System

## Trigger
Invoice draft is generated.

## Main Flow
1. System stores references from invoice to workorder.
2. System stores references from invoice to originating estimate version.
3. System stores references from invoice to approval artifacts/records.
4. System exposes traceability in UI for authorized roles.
5. System includes reference identifiers in customer-facing invoice where configured.

## Alternate / Error Flows
- Origin artifacts missing due to data corruption â†’ block issuance and alert admin.

## Business Rules
- Invoices must be traceable to the approved scope and executed work.

## Data Requirements
- Entities: Invoice, Workorder, Estimate, ApprovalRecord, DocumentArtifact
- Fields: workorderId, estimateId, estimateVersion, approvalId, artifactRef, traceabilitySummary

## Acceptance Criteria
- [ ] Invoice contains links to workorder and estimate/approval trail.
- [ ] Authorized users can retrieve approval artifacts from invoice context.
- [ ] Issuance is blocked if traceability is incomplete (policy).

## Notes for Agents
Traceability is your defense in disputes; enforce it.


### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

====================================================================================================

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ISSUE #213: [FRONTEND] [STORY] Invoicing: Generate Invoice Draft from Completed Workorder â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/213
File: ./scripts/story-work/frontend/213/after.md
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## ğŸ·ï¸ Labels (Proposed)

### Required
- type:story
- domain:billing
- status:draft

### Recommended
- agent:billing-domain-agent
- agent:story-authoring

### Blocking / Risk
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

# 1. Story Header

## Title
[FRONTEND] Invoicing: Generate Draft Invoice from Invoice-Ready Completed Work Order

## Primary Persona
Accounts Receivable (AR) Clerk (Back Office)

## Business Value
Create an auditable, deterministic Draft Invoice from an invoice-ready Work Order without manual re-entry, ensuring all billable items and traceability links are captured consistently for downstream issuance and payment.

---

# 2. Story Intent

## As a / I want / So that
- **As an** AR Clerk  
- **I want** to generate a **Draft** invoice from a single completed, invoice-ready work order  
- **So that** I can review and proceed with billing using system-calculated totals and required traceability links.

## In-scope
- UI action â€œCreate Invoiceâ€ from a Work Order context (completed + invoiceReady)
- Frontend calls to create an invoice draft (idempotent behavior)
- Display of resulting Draft invoice details (header, line items, totals, traceability)
- UI handling of validation and error responses (409/422/503) per backend contract reference
- Audit/observability surfacing (where visible) such as created-by/created-at and correlation id handling

## Out-of-scope
- Issuing/finalizing invoices (Draft â†’ Issued/Posted)
- Taking payments, refunds, chargebacks
- Editing invoice line items (snapshot is immutable)
- Regenerating invoices from Voided invoices (privileged endpoint; not part of this story)
- Configuration of billing rules, tax rules, payment terms

---

# 3. Actors & Stakeholders
- **Primary Actor:** AR Clerk
- **Secondary Actors:** Service Advisor (indirect stakeholder), Accounting (downstream consumer), Work Execution system (source of Work Order readiness & snapshot)
- **System Actors:** Billing service (invoice creation), Work Execution service (invoiceReady & BillableScopeSnapshot provider)

---

# 4. Preconditions & Dependencies

## Preconditions
- User is authenticated in the POS/backoffice UI.
- User has permission to create invoices (exact permission string TBD by security model; see Open Questions).
- A Work Order exists and is viewable by the user.
- Work Order is **Completed** and **invoiceReady=true** (authoritative from Work Execution).
- Customer Account linked to the Work Order exists and has required billing details; otherwise backend returns 422.

## Dependencies
- Backend endpoint exists to create invoice draft from a workOrderId and returns invoiceId (idempotent behavior):
  - If Draft exists: return existing invoiceId (success)
  - If Posted/Paid exists: 409
  - If not invoice-ready: 409
  - If missing billing data: 422 with missing fields list
  - If Work Execution fetch fails: 503
- Backend endpoint exists to load invoice details for display once created (contract specifics TBD; see Open Questions).
- Work Order details screen already exists and can host an action button (or must be created/extended).

---

# 5. UX Summary (Moqui-Oriented)

## Entry points
- Work Order detail screen (Back Office) for a **Completed** Work Order.

## Screens to create/modify
1. **Modify:** `apps/pos/screen/workorder/WorkOrderDetail.xml` (name illustrative; align to repo conventions)
   - Add a **Create Invoice** action visible when invoice creation is allowed (see rules below).
2. **Create or Modify:** `apps/pos/screen/billing/InvoiceDetail.xml`
   - Display invoice header, line items, totals, and traceability links for a Draft invoice.
   - If already exists (idempotent), navigation should still land here.

## Navigation context
- From Work Order Detail â†’ Create Invoice â†’ redirect to Invoice Detail for returned `invoiceId`.
- Provide a â€œBack to Work Orderâ€ link using stored `workOrderId` on invoice.

## User workflows

### Happy path
1. AR Clerk opens a Completed Work Order.
2. Clicks **Create Invoice**.
3. UI shows progress state (blocking action, spinner).
4. On success, UI routes to Invoice Detail and displays the created Draft invoice.

### Alternate path: idempotent existing Draft
1. AR Clerk clicks **Create Invoice** again.
2. Backend returns same `invoiceId`.
3. UI routes to Invoice Detail (no duplicate created) and shows non-blocking message â€œDraft invoice already exists; opened existing draft.â€

### Error path: not invoice-ready (409)
- UI displays error banner with backend message and keeps user on Work Order screen.

### Error path: missing customer billing data (422)
- UI displays a â€œCannot create invoiceâ€ panel listing missing fields, with navigation link to Customer Account (if route exists; otherwise show read-only message and field names).

### Error path: downstream failure (503)
- UI shows retry affordance and does not navigate away.

---

# 6. Functional Behavior

## Triggers
- User clicks â€œCreate Invoiceâ€ action/button from Work Order Detail.

## UI actions
- Disable the Create Invoice button while request is in-flight to prevent double submits.
- On success:
  - Route to Invoice Detail with `invoiceId`
- On handled failure:
  - Show inline banner/toast and preserve current screen state.

## State changes (frontend-visible)
- Work Order screen: â€œCreate Invoiceâ€ action state changes:
  - enabled â†’ disabled (in-flight)
  - optionally disabled permanently if invoice already Posted/Paid (based on Work Order + invoice summary if available; otherwise rely on backend response)

## Service interactions
- Call Billing service to create invoice draft (see Service Contracts).
- After creation, load invoice details for display (or use create response if it returns full invoice; see Open Questions).

---

# 7. Business Rules (Translated to UI Behavior)

## Validation (frontend)
- UI must require a `workOrderId` in context to initiate creation.
- UI must not attempt to edit line items in Draft created from snapshot (display only).

## Enable/disable rules
- **Create Invoice** action is:
  - **Visible** only when Work Order is in a terminal/completed view AND user has invoice-create permission.
  - **Enabled** only when UI has `invoiceReady=true` for the Work Order.
  - If UI cannot determine invoiceReady (missing field), action remains visible but disabled with tooltip â€œInvoice readiness unavailableâ€ and relies on backend error mapping when invoked (see Open Questions: should it be hidden vs disabled?).

## Visibility rules
- Invoice Detail must show immutable traceability links:
  - workOrderId, billableScopeSnapshotId, customerAccountId
  - estimateId / approval trail references if provided by backend

## Error messaging expectations
- 409: show message: Work Order not invoice-ready OR invoice already exists and cannot be regenerated.
- 422: show â€œMissing required customer billing dataâ€ plus list of fields.
- 503: show â€œService unavailable; try again.â€

(Use backend-provided message as primary, with a generic fallback.)

---

# 8. Data Requirements

## Entities involved (frontend perspective)
- **Invoice** (Billing-owned)
- **InvoiceItem** (Billing-owned)
- **WorkOrder** (Work Execution-owned)
- **BillableScopeSnapshot** (Work Execution-owned; referenced, not edited)
- **ApprovalRecord** (upstream traceability; displayed if provided)

## Fields (type, required, defaults)

### Create request (minimum)
- `workOrderId` (UUID, required)

### Invoice (display)
- `invoiceId` (UUID, required, read-only)
- `status` (Enum/String: Draft/Issued(or Posted)/Paid/Void; required, read-only)
- `workOrderId` (UUID, required, read-only)
- `customerAccountId` (UUID, required, read-only)
- `billableScopeSnapshotId` (UUID, required, read-only)
- `snapshotVersion` (String, optional display)
- `estimateId` (UUID/String, optional display)
- `approvalId` or approval references (String/UUID, optional display)
- `poNumber` (String, optional display)
- `paymentTermsId` (UUID/String, optional display)
- `subtotal` (Decimal, required, read-only)
- `taxAmount` (Decimal, required, read-only)
- `totalAmount` (Decimal, required, read-only)
- `issueDate` (Date, optional in Draft)
- `dueDate` (Date, optional in Draft)
- Audit fields for display if available: `createdByUserId`, `createdDate`

### InvoiceItem (display)
- `invoiceItemId` (UUID, required)
- `sourceSnapshotItemId` (UUID/String, required)
- `itemType` (Enum: LABOR/PART/FEE, if provided)
- `description` (String, required)
- `quantity` (Decimal, required)
- `unitPrice` (Decimal, required)
- `lineTotal` (Decimal, required)
- `taxCategoryCode` (String, optional but expected)
- `taxable` (Boolean, required)
- `lineTaxAmount` (Decimal, optional if backend provides)

## Read-only vs editable by state/role
- For this story, all displayed invoice fields are **read-only** in Draft because they derive from immutable snapshot + billing calculations.
- No frontend editing of PO number/terms in this story (even if present); treat as display-only.

## Derived/calculated fields
- Totals (subtotal/tax/total) are computed by backend and displayed by UI; UI must not recompute for authority (can format only).

---

# 9. Service Contracts (Frontend Perspective)

> Note: Endpoint paths are not confirmed in provided frontend inputs; backend reference indicates likely `/billing/v1/invoices` create. Treat paths as Open Questions unless already standardized in the repo.

## Load/view calls
- **Get Work Order detail** (existing): must include `workOrderId`, completion status, and `invoiceReady` boolean.
- **Get Invoice detail**: by `invoiceId` to display header + items + traceability.

## Create/update calls
- **Create Draft Invoice from Work Order**
  - Request: `{ workOrderId }` (and optionally idempotency key header if required by backend; see Open Questions)
  - Response success: `{ invoiceId, status }` at minimum
  - Behavior:
    - 200/201 success for newly created
    - 200 success for idempotent existing Draft return

## Submit/transition calls
- None (no Draftâ†’Issued in this story)

## Error handling expectations
- Map HTTP status to UI:
  - **409 Conflict**: show non-field error banner; do not navigate
  - **422 Unprocessable Entity**: show validation panel; display `missingFields[]` if provided
  - **503 Service Unavailable**: show retry message; keep action available
  - **401/403**: show â€œNot authorizedâ€ and hide/disable action on subsequent renders

---

# 10. State Model & Transitions

## Allowed states (Invoice)
- Draft
- Issued/Posted (backend reference uses Posted; billing guide uses Issued; UI must display whatever backend returns)
- Paid
- Void

## Role-based transitions
- Only â€œCreate Draftâ€ is implemented here:
  - From Work Order invoiceReady=true â†’ Invoice Draft creation action available to authorized AR Clerk.

## UI behavior per state
- If invoice status is:
  - **Draft**: show banner â€œDraftâ€ and read-only details
  - **Posted/Issued/Paid/Void**: still viewable; creation action should be prevented at source (via backend 409 if attempted)

---

# 11. Alternate / Error Flows

## Validation failures (422)
- Missing customer billing data:
  - UI displays missing fields list exactly as returned (e.g., `billingAddress`, `billingContactMethod`)
  - UI provides guidance text: â€œUpdate customer billing profile before creating invoice.â€
  - No invoice detail navigation occurs.

## Concurrency conflicts / idempotency
- Double click / two users:
  - If backend returns existing Draft: navigate to that Draft invoice.
  - If backend returns 409 due to already Posted/Paid: show message; do not navigate.

## Unauthorized access (401/403)
- If user lacks permission:
  - UI should not render Create Invoice action (preferred) when permission known.
  - If called anyway and backend returns 403: show â€œYou do not have permission to create invoices.â€

## Empty states
- If Invoice detail loads but has zero items (unexpected):
  - Show â€œNo invoice items foundâ€ and include invoiceId/workOrderId for support; treat as error state but render page.

---

# 12. Acceptance Criteria

## Scenario 1: Successful Draft Invoice Creation
**Given** I am an authenticated AR Clerk with permission to create invoices  
**And** I am viewing a Work Order in a completed state with `invoiceReady=true`  
**And** the customer account has billing address and billing contact method on file  
**When** I click â€œCreate Invoiceâ€  
**Then** the UI calls the billing create-invoice endpoint with the Work Order ID  
**And** the UI navigates to the Invoice Detail screen for the returned `invoiceId`  
**And** the Invoice Detail shows `status=Draft`, the Work Order reference, and at least one invoice item  
**And** the Invoice Detail shows populated totals including `subtotal`, `taxAmount`, and `totalAmount`.

## Scenario 2: Idempotent Return When Draft Already Exists
**Given** I am viewing a completed Work Order with `invoiceReady=true`  
**And** an invoice already exists for that Work Order in `Draft` status  
**When** I click â€œCreate Invoiceâ€  
**Then** the UI receives success with the existing `invoiceId`  
**And** the UI navigates to Invoice Detail for that `invoiceId`  
**And** the UI indicates non-blocking feedback that an existing draft was opened (message text may vary).

## Scenario 3: Block When Work Order Not Invoice-Ready (409)
**Given** I am viewing a Work Order with `invoiceReady=false`  
**When** I attempt to create an invoice (via button if enabled erroneously or via direct action invocation)  
**Then** the UI receives a `409 Conflict` response  
**And** the UI remains on the Work Order screen  
**And** the UI displays an error stating the Work Order is not in a state that allows invoicing.

## Scenario 4: Block When Posted/Paid Invoice Already Exists (409)
**Given** a Work Order already has a linked invoice in `Posted` or `Paid` status  
**When** I click â€œCreate Invoiceâ€  
**Then** the UI receives a `409 Conflict` response  
**And** the UI displays an error indicating an invoice already exists and regeneration is not allowed (corrections require credit notes)  
**And** no new invoice is created and the UI does not navigate to a new invoice.

## Scenario 5: Missing Customer Billing Data (422)
**Given** I am viewing a completed Work Order with `invoiceReady=true`  
**And** the customer account is missing required billing data (e.g., billing address)  
**When** I click â€œCreate Invoiceâ€  
**Then** the UI receives a `422 Unprocessable Entity` response  
**And** the UI displays a â€œCannot create invoiceâ€ message  
**And** the UI lists the missing fields returned by the API.

## Scenario 6: Downstream Failure (503)
**Given** I am viewing a completed Work Order with `invoiceReady=true`  
**When** I click â€œCreate Invoiceâ€ and the backend cannot fetch required data due to downstream unavailability  
**Then** the UI receives a `503 Service Unavailable` response  
**And** the UI displays an error with a retry option  
**And** the UI does not navigate away from the Work Order screen.

---

# 13. Audit & Observability

## User-visible audit data
- Invoice Detail should display (if provided by backend):
  - created date/time
  - created by user (or userId)
  - correlation/request id (optional, but include in dev console logs)

## Status history
- Not implemented in this story; if Invoice API returns status history, display read-only â€œHistoryâ€ section; otherwise omit.

## Traceability expectations
- Invoice Detail must show immutable references:
  - workOrderId
  - billableScopeSnapshotId
  - customerAccountId
  - estimate/approval references if present

Frontend must not allow editing of these fields.

---

# 14. Non-Functional UI Requirements

- **Performance:** Create action should provide immediate feedback; Invoice Detail load should render skeleton/loader until data arrives.
- **Accessibility:** Create Invoice control must be keyboard accessible; error banners must be announced (ARIA live region).
- **Responsiveness:** Work Order and Invoice Detail screens must remain usable on tablet widths (Quasar responsive layout).
- **i18n/timezone/currency:** Display money fields using configured currency/locale formatting; dates rendered in userâ€™s timezone (no business-rule assumptions about due dates).

---

# 15. Applied Safe Defaults

- SD-UI-EMPTY-STATE: Show a standard empty-state panel when invoice items array is empty; qualifies as safe because it affects only UI ergonomics and not business policy. Impacted sections: UX Summary, Alternate/Error Flows.
- SD-UI-INFLIGHT-GUARD: Disable primary action button while request is in-flight to prevent accidental duplicate submits; safe because backend remains authoritative and this only reduces user error. Impacted sections: Functional Behavior, Acceptance Criteria.
- SD-ERR-MAP-HTTP: Map 409/422/503/403 to standard UI banners/toasts with backend message fallback; safe because it does not change domain logic, only presents errors consistently. Impacted sections: Service Contracts, Alternate/Error Flows.

---

# 16. Open Questions

1. What are the exact Moqui screen paths/names for the existing **Work Order Detail** screen in this frontend repo (to correctly place the â€œCreate Invoiceâ€ action)?
2. What are the exact backend endpoints and payloads for:
   - Create Draft Invoice from Work Order (path, method, request/response schema)
   - Fetch Invoice Detail (path, includes items? includes traceability fields?)
3. What permission identifiers should the frontend check to show/enable â€œCreate Invoiceâ€ (e.g., `invoice:create`), and where are permissions exposed in the current Moqui session/user context?
4. Should the UI **hide** the Create Invoice action when `invoiceReady=false`, or show it disabled with an explanation? (Current story proposes disabled when known.)
5. Does the create endpoint require an **Idempotency-Key** header from the client? If yes, what key format/source should frontend use?

---

## Original Story (Unmodified â€“ For Traceability)

Title: [FRONTEND] [STORY] Invoicing: Generate Invoice Draft from Completed Workorder â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/213

Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] Invoicing: Generate Invoice Draft from Completed Workorder

**Domain**: payment

### Story Description

/kiro  
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
Back Office / Accounts Receivable Clerk

## Trigger
A workorder is Completed and invoice-ready.

## Main Flow
1. User selects 'Create Invoice' on the completed workorder.
2. System creates a Draft invoice using the billable scope snapshot.
3. System carries over customer billing details and references (PO number, terms).
4. System populates invoice line items and initial totals.
5. System links invoice to workorder, estimate version, and approval trail.

## Alternate / Error Flows
- Workorder not invoice-ready â†’ block and show missing prerequisites.

## Business Rules
- Invoices are created from the billable scope snapshot.
- Traceability links are required.

## Data Requirements
- Entities: Invoice, InvoiceItem, BillableScopeSnapshot, Workorder, ApprovalRecord
- Fields: invoiceId, status, snapshotVersion, workorderId, estimateId, approvalId, termsId, poNumber

## Acceptance Criteria
- [ ] System creates a Draft invoice with all billable items present.
- [ ] Invoice references workorder and upstream approval trail.
- [ ] Invoice totals are populated.

## Notes for Agents
Keep invoice generation deterministic; the snapshot is the single source of truth.

### Frontend Requirements
- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack
- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ISSUE #67: [FRONTEND] [STORY] Customer: Enforce PO Requirement and Billing Rules During Checkout â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/67
File: ./scripts/story-work/frontend/67/after.md
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STOP: Clarification required before finalization

## ğŸ·ï¸ Labels (Proposed)

### Required
- type:story
- domain:billing
- status:draft

### Recommended
- agent:billing-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

# 1. Story Header

## Title
[FRONTEND] Enforce PO Requirement & Billing Rules During Checkout (PO capture, override approval, credit limit blocks)

## Primary Persona
POS Clerk / Service Advisor

## Business Value
Prevent non-compliant commercial checkouts by enforcing customer billing rules at the point of sale; ensure PO capture/override is auditable and credit terms are applied correctly to reduce AR risk and downstream reconciliation effort.

---

# 2. Story Intent

## As a / I want / So that
- **As a** POS Clerk  
- **I want** the checkout flow to enforce customer billing rules (PO requirement, uniqueness, and credit/terms rules)  
- **So that** commercial accounts comply with contractual terms and finance can audit who captured/overrode requirements and why.

## In-scope
- Gate **order finalization** on billing-rule enforcement results.
- Display billing rule evaluation results in checkout: PO required, PO format, PO uniqueness policy, charge account eligibility, credit limit outcomes.
- Capture PO number (and lock it once saved).
- Support override workflow with permission enforcement and 1- or 2-approver capture.
- Surface clear, actionable error messages for blocked checkout.
- Persist and show (read-only) captured rule version + override audit metadata on the order.
- Moqui screen/form/service wiring for the above.

## Out-of-scope
- Defining or changing billing rules (admin/config UI).
- Accounting GL posting and reconciliation workflows.
- Payment gateway capture/void/refund behavior (not part of this checkout-rule enforcement story).
- Designing the backend policy engine; frontend consumes backend decisions/contracts.

---

# 3. Actors & Stakeholders
- **POS Clerk / Service Advisor (primary)**: finalizes orders; enters PO; requests override when needed.
- **Manager / Finance Manager (approver)**: performs override approval (may be 2nd approver).
- **Finance / AR**: audits overrides and policy adherence; cares about traceability.
- **Billing domain services (SoR for billing rules, credit/terms decisions)**: provides active rule version and enforcement results.
- **CRM snapshot (read-only consumer, optional for UX)**: may provide cached flags but is not authoritative for enforcement.

---

# 4. Preconditions & Dependencies
- User is authenticated in POS and has an identity available to the frontend (`actorUserId`).
- An **Order/Work Order checkout context** exists (a unique `orderId` or `workOrderId` used in checkout).
- Backend endpoints exist (or will exist) to:
  - evaluate billing rules for the checkout context,
  - save PO reference and/or override,
  - attempt finalization and return blocking validation errors.
- Authorization model exists for permission `OVERRIDE_PO_REQUIREMENT`.
- Backend provides the authoritative `billingRuleVersion` and any `policyVersion` used for override.

**Dependency note:** The provided backend reference includes concrete behaviors; the frontend story must not invent missing API shapes. See Open Questions.

---

# 5. UX Summary (Moqui-Oriented)

## Entry points
- From existing checkout screen for an order/work order: user clicks **Finalize** (or equivalent).

## Screens to create/modify
- **Modify existing Checkout screen** (likely under a POS/Order/WorkOrder screen tree):
  - Add a **Billing Requirements** section/panel in the checkout page.
  - Add modal/dialog for **PO entry** when required.
  - Add modal/dialog for **Override PO requirement** with approver capture.
- Add/extend a read-only **Order Summary / Order Details** area to display:
  - `billingRuleVersion` used,
  - PO number + captured metadata,
  - override flag + approvers + reason + policyVersion.

## Navigation context
- User remains on checkout screen; blocking conditions show inline errors and/or modal prompts; successful save returns to checkout and allows finalization.

## User workflows

### Happy path A: PO required â†’ capture PO â†’ finalize
1. Clerk clicks Finalize.
2. UI calls â€œevaluate billing rulesâ€ and gets `poRequired=true`.
3. UI prompts for PO entry; validates basic format client-side (only if contract confirmed).
4. UI submits PO to backend; backend returns success + stored metadata.
5. Clerk clicks Finalize again (or auto-retry finalization after save if supported); finalization succeeds.

### Happy path B: PO not required â†’ finalize
1. Clerk clicks Finalize.
2. UI evaluates rules; `poRequired=false`; no prompt.
3. Finalization proceeds.

### Alternate path C: override required â†’ single approver
1. PO required, missing â†’ clerk selects Override.
2. UI verifies permission (by backend response or user permission set).
3. UI collects override reason; submits override; backend returns stored audit data.
4. Finalization proceeds.

### Alternate path D: override required â†’ two-person approval
1. PO required, missing â†’ clerk selects Override.
2. Backend indicates 2nd approver required; UI prompts for second approver authentication (mechanism TBD).
3. UI submits override with both approvers and reason; finalization proceeds.

### Alternate path E: charge account credit limit block
1. Checkout evaluates rules includes charge account eligibility/terms and credit limit evaluation.
2. If backend returns credit limit exceeded, UI blocks finalization and shows message; user must choose different billing method (if such choice exists) or stop.

---

# 6. Functional Behavior

## Triggers
- User action: click **Finalize checkout**.
- User action: submit **PO number**.
- User action: submit **Override** (single or two-person).

## UI actions (required)
- On entering checkout or on Finalize click (see Open Question), call backend to fetch:
  - active billing rule version,
  - enforcement flags (po required, uniqueness policy),
  - override policy evaluation result (single vs two-person),
  - charge account eligibility and credit-limit evaluation outcome (if applicable).
- If `poRequired=true` and no PO is already attached:
  - disable/stop Finalize and present PO capture prompt OR present error with action button â€œEnter POâ€.
- Provide â€œOverride PO requirementâ€ action only when:
  - PO is required and missing, and
  - backend indicates override is allowed for this user OR user has permission (source TBD).
- If PO was captured successfully:
  - display PO as read-only and prevent edits (immutable).
- If override succeeded:
  - display â€œPO Overriddenâ€ flag and read-only audit metadata.

## State changes (frontend-visible)
- Order gains `poNumber` + captured metadata OR `poOverridden=true` + override metadata.
- Order retains `billingRuleVersion` used at time of checkout (read-only after capture/finalize).

## Service interactions (frontend)
- `evaluateBillingRules(orderId)` (read)
- `savePoReference(orderId, poNumber)` (write)
- `overridePoRequirement(orderId, reasonCode, approver(s))` (write)
- `finalizeCheckout(orderId)` (transition/submit) which may return blocking validation errors.

(Exact names/paths are Open Questions; Moqui service mappings are defined below as screen actions.)

---

# 7. Business Rules (Translated to UI Behavior)

## Validation
- PO number validation must be enforced server-side; UI may provide pre-validation **only** for format to reduce round-trips.
- PO format (from reference): 3â€“30 chars; letters/numbers plus `-` and `_`; case-insensitive.
- If uniqueness violation occurs, UI must show backend-provided message including conflicting order reference (if provided).

## Enable/disable rules
- Finalize button must be disabled or must fail fast with a blocking message when:
  - PO required and missing AND no override is applied.
  - Billing rules are missing/invalid for B2B and backend instructs to block.
  - Credit limit exceeded for charge account billing method (if backend returns this condition).
- Override action must be disabled/hidden when user lacks permission; unauthorized attempts must show â€œContact a managerâ€ message.

## Visibility rules
- Billing Requirements panel always visible for commercial accounts (how â€œcommercial/B2Bâ€ is detected is Open Question; must follow backend signal).
- Override modal appears only after backend indicates override is permitted and whether 2-person approval is required.

## Error messaging expectations
- Use specific, non-technical messages:
  - Missing PO: â€œPO number required for this customer. Enter PO or request override.â€
  - Invalid PO format: â€œPO must be 3â€“30 characters: letters, numbers, dashes, underscores.â€
  - Uniqueness: â€œPO number is already in use for another order. Use a unique PO.â€
  - Missing billing config: â€œBilling rules not configured for this customer. Contact an administrator.â€
  - Unauthorized override: â€œInsufficient permissions to override PO requirement. Contact a manager.â€
  - Credit limit exceeded: â€œOrder total exceeds available credit limit. Select a different payment method or contact finance.â€
- Error messages should include a stable `errorCode` (if backend provides) for test assertions (Open Question).

---

# 8. Data Requirements

## Entities involved (frontend perspective)
- **Order/Checkout context** (existing): `orderId` (or `workOrderId`).
- **Billing rule evaluation result** (read model returned by billing service).
- **PO Reference** attached to order.
- **Override Audit** attached to order.

## Fields (type, required, defaults)

### BillingRuleEvaluation (read-only DTO)
- `customerAccountId` (string/UUID, required)
- `isB2B` (boolean, required) **or** `customerType` (enum) (Open Question)
- `billingRuleId` (string/UUID, required when configured)
- `billingRuleVersion` (string/int, required when configured; required for audit)
- `poRequired` (boolean, required)
- `poUniquenessPolicy` (enum: `PER_ORDER|PER_ACCOUNT_OPEN_ORDERS|PER_ACCOUNT_ALL_TIME`, required if poRequired true)
- `poFormatPrefix` (string, optional; if present, UI should display as guidance only unless backend requires client validation)
- `chargeAccountEligible` (boolean, optional)
- `paymentTerms` (string, optional)
- `creditLimit` (decimal, optional)
- `currentOutstandingBalance` (decimal, optional)
- `creditLimitExceeded` (boolean, optional)
- `overrideAllowed` (boolean, required)
- `overrideRequiresSecondApprover` (boolean, required when overrideAllowed true)
- `overridePolicyVersion` (string/int, optional unless override happens)
- `messages[]` (array, optional): `code`, `severity`, `text`

### PoReference (write once, then read-only)
- `poNumber` (string, required if capturing PO)
- `poCapturedAt` (datetime, server-set)
- `poCapturedBy` (userId, server-set)
- `billingRuleVersion` (string/int, server-set linkage)

### PoOverride (write once, then read-only)
- `poOverridden` (boolean, server-set)
- `overrideReasonCode` (string, required)
- `overrideApproverIds` (string[] length 1 or 2, required)
- `overrideAt` (datetime, server-set)
- `overridePolicyVersion` (string/int, server-set)
- `billingRuleVersion` (string/int, server-set linkage)

## Read-only vs editable by state/role
- PO Number: editable only until successfully saved; thereafter read-only always.
- Override fields: editable only within override modal prior to submission; after submission read-only.
- Display of approver IDs: visible to authorized staff (permission model Open Question; default to showing to POS roles only).

## Derived/calculated fields
- `overrideRequiresSecondApprover` derived from backend policy evaluation using order total/risk tier; UI must not calculate.

---

# 9. Service Contracts (Frontend Perspective)

> Moqui implementation note: define screen actions calling services; services may proxy to backend microservices if applicable. Exact service names below are placeholders; must match actual component/service naming conventions in repo.

## Load/view calls
1. `BillingServices.getCheckoutBillingContext`
   - Input: `orderId`
   - Output: `BillingRuleEvaluation` DTO + existing `PoReference/PoOverride` if any.

## Create/update calls
2. `BillingServices.capturePoReference`
   - Input: `orderId`, `poNumber`
   - Output: saved PO reference + updated order billing metadata
   - Errors:
     - `422` invalid format
     - `409` uniqueness violation (include conflicting order ref if available)
     - `403` unauthorized

3. `BillingServices.overridePoRequirement`
   - Input: `orderId`, `overrideReasonCode`, `approver1UserId`, `approver2UserId?` (+ authentication proof for 2nd approver; Open Question)
   - Output: saved override audit + updated order billing metadata
   - Errors:
     - `403` unauthorized override
     - `422` missing reason / missing 2nd approver when required
     - `409` state conflict if PO already captured or order already finalized

## Submit/transition calls
4. `OrderServices.finalizeCheckout`
   - Input: `orderId`
   - Output: success with final order status, or failure with blocking errors (po required, credit limit exceeded, missing billing config, etc.)
   - Errors:
     - `409` conflict (order state changed, already finalized)
     - `422` rule violations / unmet requirements
     - `503` billing service unavailable

## Error handling expectations
- Map backend errors to:
  - field-level errors for PO input when possible,
  - banner/toast for general blocking errors,
  - include `correlationId` from response headers/body in an expandable â€œDetailsâ€ section (if available).
- Do not display internal stack traces.

---

# 10. State Model & Transitions

## Allowed states (order lifecycle â€” only those relevant to UI gating)
- `CHECKOUT_IN_PROGRESS` (or equivalent existing state)
- `FINALIZED` (or equivalent)

(Exact order states are Open Questions; UI must rely on backendâ€™s â€œfinalizableâ€ flag or returned state.)

## Role-based transitions
- POS Clerk: may capture PO and finalize if requirements met.
- User with `OVERRIDE_PO_REQUIREMENT`: may override; may require second approver.

## UI behavior per state
- In checkout state:
  - show billing requirements; allow PO capture or override.
- In finalized state:
  - show PO/override info read-only; no edits; no override actions.

---

# 11. Alternate / Error Flows

## Validation failures
- PO invalid â†’ keep modal open; highlight field; show message from server (plus local format hint if enabled).
- Missing override reason â†’ show inline required error; do not submit.

## Concurrency conflicts
- If PO captured by another user while modal open:
  - submission returns `409`; UI reloads billing context and shows â€œPO already captured; no changes made.â€
- If order finalized elsewhere:
  - disable capture/override actions; show read-only state.

## Unauthorized access
- Override attempt without permission:
  - backend `403`; UI shows â€œContact a managerâ€ message and logs client-side event.

## Empty states
- If billing context cannot load (503):
  - show blocking message and disable finalization (â€œBilling rules service unavailable; try againâ€).
  - provide Retry action.

---

# 12. Acceptance Criteria

## Scenario 1: PO required blocks finalization until captured
**Given** a checkout order for a B2B customer where backend evaluation returns `poRequired=true` and no PO is attached  
**When** the POS Clerk clicks â€œFinalizeâ€  
**Then** the UI blocks finalization and prompts for PO entry  
**And** displays a message indicating a PO is required  
**And** does not submit finalize successfully until PO is saved or override is completed.

## Scenario 2: Valid PO is accepted and becomes immutable
**Given** `poRequired=true` and the clerk enters `PO-12345`  
**When** the clerk submits the PO capture  
**Then** the UI calls the PO capture service with `orderId` and `poNumber`  
**And** on success displays the PO as read-only with captured timestamp/user (if provided)  
**And** finalization is allowed on the next finalize attempt (assuming no other blockers).

## Scenario 3: Invalid PO format is rejected
**Given** `poRequired=true`  
**When** the clerk submits a PO that fails server validation  
**Then** the UI shows the server-provided format error message  
**And** the PO is not saved  
**And** finalization remains blocked.

## Scenario 4: PO uniqueness violation is shown with conflict reference (if provided)
**Given** backend indicates `poUniquenessPolicy=PER_ACCOUNT_OPEN_ORDERS`  
**When** the clerk submits a PO that is already used by another open order  
**Then** the UI shows a uniqueness violation message  
**And** includes the conflicting order reference if returned  
**And** finalization remains blocked.

## Scenario 5: Override denied without permission
**Given** `poRequired=true` and no PO is attached  
**And** the current user lacks `OVERRIDE_PO_REQUIREMENT`  
**When** the user attempts to override  
**Then** the UI blocks the override and shows an â€œinsufficient permissionsâ€ message  
**And** does not mark the order as overridden.

## Scenario 6: Override succeeds with single approver when allowed
**Given** `poRequired=true` and backend indicates `overrideAllowed=true` and `overrideRequiresSecondApprover=false`  
**When** an authorized user submits override with a reason  
**Then** the UI calls the override service  
**And** on success shows â€œPO Overriddenâ€ and displays reason + approver + policyVersion (if provided) read-only  
**And** finalization is allowed (assuming no other blockers).

## Scenario 7: Two-person approval required and enforced
**Given** backend indicates `overrideRequiresSecondApprover=true`  
**When** the user submits override without a second approver  
**Then** the UI shows an error indicating a second approver is required  
**And** does not submit successfully  
**When** the user provides a second approver per the configured authentication method  
**Then** override submission succeeds and records both approvers.

## Scenario 8: Missing/invalid billing configuration blocks checkout (fail-safe)
**Given** backend indicates B2B billing rules are missing/invalid (via explicit flag/error)  
**When** the POS Clerk attempts to finalize  
**Then** the UI blocks checkout and shows â€œBilling rules not configuredâ€¦â€  
**And** provides no path forward except Retry or authorized override (if backend allows).

## Scenario 9: Credit limit exceeded blocks CHARGE_ACCOUNT finalization
**Given** backend returns `creditLimitExceeded=true` for the order when `billingMethod=CHARGE_ACCOUNT`  
**When** the clerk attempts to finalize  
**Then** the UI blocks finalization and shows the credit-limit exceeded message  
**And** records no PO/override changes as a side effect.

---

# 13. Audit & Observability

## User-visible audit data
- On checkout and order summary views, display (read-only):
  - `billingRuleVersion` used
  - PO captured by/at OR override by/at with reason and approvers
  - policy version for overrides (if returned)

## Status history
- UI must show a simple â€œBilling Compliance Statusâ€ derived from backend:
  - `COMPLIANT` (PO present or not required)
  - `OVERRIDDEN`
  - `BLOCKED` (missing PO / credit limit / misconfig)

## Traceability expectations
- Include `orderId`, `customerAccountId`, and any backend-provided `correlationId` in client logs for:
  - evaluation load,
  - PO capture,
  - override submit,
  - finalize attempt.

---

# 14. Non-Functional UI Requirements
- **Performance:** billing context load on checkout should complete within 1s p95 under normal conditions (frontend timeout configurable; exact SLA Open Question).
- **Accessibility:** dialogs and errors must be keyboard navigable; focus management on modal open/close; errors announced via ARIA live region where applicable.
- **Responsiveness:** usable on standard POS tablet widths; dialogs must not overflow viewport.
- **i18n/timezone/currency:** display timestamps in store/user timezone per existing app conventions (Open Question); currency formatting for credit limit messages should follow existing formatting utilities.

---

# 15. Applied Safe Defaults
- SD-UX-EMPTY-STATE: Provide a retryable â€œUnable to load billing requirementsâ€ blocking state when billing context fetch fails; qualifies as UI ergonomics and does not define business policy. (Impacted: UX Summary, Alternate/Error Flows)
- SD-UX-PREVALIDATE-FORMAT: Add optional client-side PO format hinting matching server rules to reduce round-trips; server remains authoritative. (Impacted: Business Rules, Error Flows)
- SD-OBS-CORRELATION-ID: Surface correlationId in an expandable error details area if provided by backend headers/body; observability boilerplate only. (Impacted: Service Contracts, Audit & Observability)

---

# 16. Open Questions
1. **Backend contract (blocking):** What are the exact Moqui-facing service names/endpoints and request/response schemas for:
   - billing rules evaluation for checkout,
   - PO capture,
   - override submit (including second approver auth proof),
   - finalize checkout?
2. **Checkout identifier (blocking):** Does the frontend checkout operate on `orderId`, `workOrderId`, or both? Which is the required identifier for billing enforcement?
3. **Second approver authentication (blocking):** How is the second approver captured in POS?
   - Re-authenticate via password/PIN?
   - Badge scan?
   - Existing â€œswitch userâ€ flow?
   The UI must match the established POS auth pattern.
4. **Commercial/B2B detection (blocking):** Does backend explicitly return `isB2B`/customer type and the â€œmissing billing configurationâ€ condition, or must UI infer from CRM/customer data? (UI must not infer policy.)
5. **Finalize gating behavior (blocking):** Should billing evaluation occur:
   - on screen load,
   - on every finalize click,
   - or both (with caching + invalidation)?
6. **Order billing method selection (blocking for AC9):** Where/how is `billingMethod = CHARGE_ACCOUNT | IMMEDIATE_PAYMENT` chosen in the POS UI today? Is it in-scope to add/modify that selection, or only to block based on current value?
7. **Permission discovery (blocking):** How does frontend determine user permissions?
   - Provided in session payload?
   - Must call an authz service?
   Without this, override button visibility/behavior is ambiguous.
8. **Error code contract (non-blocking but recommended):** Will backend return stable `errorCode` values (e.g., `PO_REQUIRED`, `PO_INVALID_FORMAT`, `PO_NOT_UNIQUE`, `CREDIT_LIMIT_EXCEEDED`) to support deterministic UI handling and tests?

---

## Original Story (Unmodified â€“ For Traceability)

Title: [FRONTEND] [STORY] Customer: Enforce PO Requirement and Billing Rules During Checkout â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/67

Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] Customer: Enforce PO Requirement and Billing Rules During Checkout

**Domain**: payment

### Story Description

/kiro
# User Story

## Narrative
As a **POS Clerk**, I want billing rules enforced so that compliance is maintained for commercial accounts.

## Details
- If PO required, block finalization until captured.
- Apply terms/charge account flow optional.
- Override requires permission.

## Acceptance Criteria
- Rule enforced consistently.
- Override requires permission.
- Audit includes who/why.

## Integrations
- CRM billing rules; accounting terms may apply.

## Data / Entities
- BillingRuleCheck, PoReference, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Experience
- domain :  Point of Sale

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ISSUE #71: [FRONTEND] [STORY] Payment: Print/Email Receipt and Store Reference â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/71
File: ./scripts/story-work/frontend/71/after.md
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STOP: Clarification required before finalization

## ğŸ·ï¸ Labels (Proposed)

### Required
- type:story
- domain:billing
- status:draft

### Recommended
- agent:billing-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

**Title:** [FRONTEND] Payment: Print/Email Receipt and Store Reference (Post-Capture + Reprint)

**Primary Persona:** Cashier (secondary: Supervisor/Manager, Customer Service)

**Business Value:** Provide customers immediate proof of payment (printed or emailed), ensure auditable linkage between payment/invoice/receipt, and support controlled reprints without financial or privacy risk.

---

## 2. Story Intent

### As a / I want / So that
- **As a** Cashier  
- **I want** the POS to generate a receipt after a successful payment capture and allow printing and optional emailing  
- **So that** customers receive proof of payment and the business retains a traceable receipt reference for audit and reprint.

### In-scope
- Showing receipt actions immediately after successful capture:
  - auto-generate receipt (or fetch generated receipt)
  - print receipt
  - optionally email receipt
  - allow â€œNo receiptâ€ (store reference without delivery)
- Storing/displaying the **receipt reference** on the payment/invoice UI
- Reprint flow with:
  - permission gating
  - identity verification prompts when required (policy-driven)
  - watermarking indicator (â€œREPRINT/DUPLICATEâ€) in rendered output (as provided by backend, or clearly marked if frontend overlays)
- Display receipt delivery status/history (print/email/declined) and reprint count
- Standard error handling and recovery UI (printer unavailable, email invalid, unauthorized)

### Out-of-scope
- Implementing backend receipt generation, storage, retention, retry policies, or template rendering
- Defining/altering financial settlement, reconciliation, or accounting posting
- Creating/updating CRM contact data (manual email entry must not be persisted to CRM)
- Designing printer drivers; only invoking existing POS print mechanism

---

## 3. Actors & Stakeholders

- **Cashier:** prints/email receipts; performs same-day reprints
- **Supervisor/Manager:** overrides reprint limits / performs reprints anytime (subject to permissions)
- **Customer Service:** may reprint with permission and reason code
- **Customer:** receives printed/email receipt
- **Billing (Moqui backend services):** receipt retrieval, email send request, reprint logging
- **CRM (external):** provides suggested email contact when customer account exists
- **POS Printer subsystem:** prints receipt payload

---

## 4. Preconditions & Dependencies

### Preconditions
- A **payment capture** succeeded for an **invoice** (invoice exists and is identifiable via invoiceId/invoiceNumber)
- User is authenticated in POS and has required permissions for actions they attempt

### Dependencies (must exist/confirmed)
- Backend exposes services/endpoints to:
  - retrieve receipt by invoice/payment/receiptReference
  - request email delivery (idempotent)
  - record print attempt result and reprint events (or backend does this implicitly)
- Frontend has access to:
  - current terminal/printer configuration identifier (terminalId, printerId if applicable)
  - current user identity (userId, displayName) and permission checks
- Printer integration available in frontend runtime (Quasar app) to send a print job

> Note: The backend story is detailed, but frontend cannot assume specific REST paths; Moqui service names/parameters must be confirmed (see Open Questions).

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
1. **Post-payment success screen/panel** (immediately after capture confirmation)
2. **Invoice detail screen** (paid invoice -> receipt section)
3. **Receipt search/reprint screen** (via invoice number / receipt reference)

### Screens to create/modify (Moqui)
1. **Modify existing**: `PaymentComplete` / `InvoicePayment` success view (where capture success is shown)
   - Add â€œReceiptâ€ action group: **Print**, **Email**, **No Receipt**, **View Details**, **Reprint** (if allowed)
2. **Create/Modify**: `ReceiptDetail` screen
   - Shows receipt reference, invoice/payment linkage, delivery history, reprint count, and actions
3. **Create** (optional if not existing): `ReceiptLookup` screen
   - Search by invoice number or receipt reference (minimum)
   - Displays matching receipt(s) and allows navigation to `ReceiptDetail`

### Navigation context
- From payment success â†’ receipt preview/detail modal or dedicated screen
- From invoice detail â†’ receipt detail
- From receipt lookup â†’ receipt detail â†’ actions

### User workflows
**Happy path (print):**
- Payment captured â†’ system loads/creates receipt â†’ cashier clicks Print â†’ print job succeeds â†’ UI shows â€œPrintedâ€ with timestamp and updates delivery status.

**Happy path (email):**
- Payment captured â†’ cashier clicks Email â†’ UI suggests CRM email (if available) or allows entry â†’ confirm â†’ backend accepts request â†’ UI shows â€œEmail queued/sentâ€ status.

**Alternate paths:**
- Printer error â†’ show error + offer email fallback
- Customer declines receipt â†’ record â€œdeclinedâ€ status without printing/emailing
- Reprint after 7 days â†’ require verification inputs or supervisor override (per backend policy)

---

## 6. Functional Behavior

### Triggers
- **On payment capture success UI render**: load receipt data (or create draft receipt record) for the invoice/payment.
- **On Print click**: request printable content (if not already loaded) and send to printer.
- **On Email click**: request email delivery through backend with selected email.
- **On Reprint click**: enforce authorization/verification + request reprint content and print.

### UI actions (explicit)
- Buttons:
  - `Print Receipt`
  - `Email Receipt`
  - `No Receipt`
  - `Reprint Receipt`
  - `View Receipt Details`
- Email entry modal:
  - Prefill from CRM if provided
  - Validate email format before submit
  - Explicit consent text: â€œEmail will be used only to send this receipt and not saved to your profile.â€ (copy must be confirmed if required)

### State changes (frontend-visible)
- Receipt delivery attempt creates/updates a delivery record:
  - method PRINT/EMAIL/DECLINED
  - status SUCCESS/FAILED/PENDING/CUSTOMER_DECLINED
- Reprint increments reprintCount and adds reprintHistory entry (as returned by backend)

### Service interactions (frontend perspective)
- Load receipt for invoice/payment (idempotent)
- Submit email delivery request (idempotent by backend key)
- Submit reprint request / fetch reprint-renderable artifact
- Optional: notify backend of print success/failure if backend doesnâ€™t infer it

---

## 7. Business Rules (Translated to UI Behavior)

### Validation
- Email address:
  - Required only when emailing
  - Must pass basic format validation client-side
  - Must be revalidated server-side; show server message on failure
- Reprint verification:
  - If backend indicates verification is required (e.g., >7 days), prompt for required factors (invoice + last4 + transaction date) OR supervisor override flow

### Enable/disable rules
- Disable â€œEmail Receiptâ€ if:
  - backend indicates emailing not available OR no permission
- Disable â€œReprintâ€ if:
  - user lacks permission OR backend indicates max reprints reached without override
- Disable actions while a request is in-flight (prevent double-submits)

### Visibility rules
- Show receipt reference once available (post-load)
- Show delivery history table only when receipt exists
- Show â€œDUPLICATE/REPRINTâ€ indicator on reprints (either within returned artifact or as a UI banner when printing a reprint)

### Error messaging expectations
- Printer offline: â€œPrinter unavailable. Load paper or select email option.â€
- Unauthorized: â€œYou do not have permission to reprint receipts. Contact supervisor.â€
- Missing data from backend: â€œCannot generate receipt: Missing <field>â€
- Email failure: show reason without exposing sensitive data; never log/display full gateway secrets

---

## 8. Data Requirements

### Entities involved (frontend view models; backend SoR = Billing)
- `Receipt`
- `ReceiptDelivery` (nested)
- `ContactRef` (from CRM, optional)

### Fields (type, required, defaults)
**Receipt (read-only in UI except delivery requests):**
- receiptId (string/UUID, read-only)
- receiptReference (string, required once generated, read-only)
- invoiceId (string/UUID, required, read-only)
- invoiceNumber (string, required, read-only)
- paymentId (string/UUID, required, read-only)
- generatedAt (datetime, required, read-only)
- generatedBy (string, required, read-only)
- terminalId (string, required, read-only)
- templateId (string, required, read-only)
- templateVersion (string, required, read-only)
- deliveryMethods[] (array, read-only)
- reprintCount (int, read-only)
- reprintHistory[] (array, read-only)

**Email request payload (editable input):**
- emailAddress (string, required for email)
- source (enum: CRM_SUGGESTED | MANUAL_ENTRY)
- consentAcknowledged (boolean) â€” **needs confirmation if required**

**Reprint request payload (editable input when required):**
- receiptReference (string, required)
- reprintReasonCode (string, optional/required depending on policy)
- verification:
  - last4 (string, optional/required depending on policy)
  - transactionDate (date, optional/required depending on policy)
  - supervisorOverride (boolean/credential token?) **TBD**

### Read-only vs editable by state/role
- Cashier can initiate print/email; can reprint same day (if permitted)
- Supervisor can override reprint limit and verification requirements (exact mechanism TBD)

### Derived/calculated fields (display only)
- â€œAge of receiptâ€ = now - generatedAt (used to determine when verification is required, but **policy must come from backend**; UI should not hardcode day thresholds unless confirmed)
- Delivery status summary (latest per method)

---

## 9. Service Contracts (Frontend Perspective)

> Moqui service names, screen transitions, and response shapes must be confirmed. Below is the required contract behavior.

### Load/view calls
1. **Get receipt for payment/invoice**
   - Input: invoiceId and/or paymentId (preferred), fallback invoiceNumber
   - Output: Receipt model including receiptReference, template/version, deliveryMethods, reprintCount
   - Behavior: idempotent; if receipt exists return it; if not and payment captured, create/generate or return a â€œgeneratingâ€ status (TBD)

2. **Get suggested email from CRM**
   - Input: customerAccountId (from invoice context)
   - Output: ContactRef (emailAddress masked in UI as needed, plus emailVerified/emailPreference)

### Create/update calls
3. **Request email receipt delivery**
   - Input: receiptReference, invoiceId, emailAddress, idempotencyKey (backend-defined; frontend passes stable key if required)
   - Output: updated deliveryMethods entry with status PENDING/SUCCESS/FAILED and timestamp; failureReason if failed

4. **Record print attempt (if required)**
   - Input: receiptReference, printerId/terminalId, outcome SUCCESS/FAILED, failureReason (if any)
   - Output: updated deliveryMethods

### Submit/transition calls
5. **Request reprint**
   - Input: receiptReference, reasonCode (if required), verification inputs (if required)
   - Output: printable payload (text/PDF) plus updated reprintCount/history

### Error handling expectations
- 401/403: show permission error; do not retry automatically
- 409: show state conflict (e.g., reprint limit reached, receipt immutable conflict)
- 422: show validation errors (missing email, invalid email, missing required verification)
- 503: show â€œService unavailable, try againâ€ with retry button

---

## 10. State Model & Transitions

### Receipt lifecycle (as displayed)
- GENERATED (implicit once receipt exists)
- Delivery method states per method:
  - PRINT: SUCCESS/FAILED/PENDING (if backend uses pending)
  - EMAIL: PENDING/SUCCESS/FAILED
  - DECLINED: CUSTOMER_DECLINED

### Allowed transitions (UI-driven)
- On payment captured:
  - None â†’ GENERATED (backend)
- Delivery:
  - GENERATED â†’ add PRINT SUCCESS/FAILED
  - GENERATED â†’ add EMAIL PENDING then SUCCESS/FAILED
  - GENERATED â†’ add DECLINED CUSTOMER_DECLINED
- Reprint:
  - GENERATED â†’ increment reprintCount + append reprintHistory + print artifact

### Role-based transitions (UI gating)
- Cashier:
  - print/email
  - reprint same-day (if permitted)
- Supervisor/Manager:
  - reprint anytime
  - override beyond max reprints (requires reason code)
- Customer service:
  - reprint anytime with permission

> UI must rely on backend-provided â€œallowedActionsâ€ or permission + policy result; do not hardcode 7-day/5-reprint rules unless backend contract explicitly returns them.

---

## 11. Alternate / Error Flows

1. **Printer offline/out of paper**
- When print fails, show actionable error and offer:
  - retry print
  - email receipt
  - view receipt reference for later
- If backend requires recording failure, call record-print-failure service.

2. **Email invalid**
- Client-side validation blocks submit
- Server-side 422 shows field-level error; allow correction and resubmit
- Do not persist manual email anywhere except the delivery request

3. **Email delivery failure**
- Backend returns FAILED with reason; UI shows failure and allows retry (subject to idempotency rules)
- If backend marks hard bounce, UI must not auto-retry; allow entering a new email and resubmitting.

4. **Receipt generation missing data**
- If backend cannot generate, display blocking error, show receipt reference if already assigned; provide â€œContact supervisorâ€ guidance.

5. **Unauthorized reprint attempt**
- 403 â†’ show message and log correlation id in UI (if available)

6. **Concurrency/idempotency**
- Double click on email/print: UI must disable while pending; if backend returns â€œalready requested,â€ treat as success and refresh receipt.

7. **Empty states**
- Invoice has no receipt yet (but payment captured): show â€œReceipt is generatingâ€ and poll/refresh button (polling behavior TBD)

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: Receipt details available after successful capture
Given a cashier completes a payment capture successfully for an invoice with an associated paymentId  
When the payment success screen loads  
Then the UI requests the receipt details for that invoice/payment  
And the UI displays the receiptReference once returned  
And the UI displays receipt identifiers (invoiceNumber, paymentId, timestamp) and delivery history if present.

### Scenario 2: Print receipt successfully
Given a receipt exists for the captured payment  
And the user has permission to print receipts  
When the cashier clicks "Print Receipt"  
Then the POS sends the printable receipt payload to the configured printer  
And the UI shows a success confirmation with the print timestamp  
And the receipt delivery history reflects PRINT status SUCCESS after refresh.

### Scenario 3: Printer error offers email fallback
Given a receipt exists for the captured payment  
When the cashier clicks "Print Receipt" and the printer returns an error  
Then the UI displays "Printer unavailable. Load paper or select email option."  
And the UI offers actions to Retry Print or Email Receipt  
And no duplicate print requests are issued while the prior attempt is unresolved.

### Scenario 4: Email receipt using CRM-suggested email
Given a receipt exists for the captured payment  
And the invoice is linked to a customer account with an email address in CRM  
When the cashier clicks "Email Receipt"  
Then the UI displays the CRM-suggested email address for confirmation  
When the cashier confirms  
Then the UI submits an email delivery request for that receiptReference and email  
And the UI shows delivery status as PENDING or SUCCESS based on response  
And the receipt delivery history includes an EMAIL entry.

### Scenario 5: Email receipt with manual email entry (not stored in CRM)
Given a receipt exists for the captured payment  
And no CRM email is available  
When the cashier clicks "Email Receipt"  
Then the UI prompts for an email address  
And blocks submission until the email is syntactically valid  
When the cashier submits a valid email  
Then the UI requests email delivery  
And the UI does not create or update any CRM contact record.

### Scenario 6: Customer declines receipt
Given a payment capture succeeded and a receipt can be generated/stored  
When the cashier selects "No Receipt"  
Then the UI records the receipt as declined (via backend)  
And no print or email delivery is initiated  
And the receipt remains retrievable for later reprint.

### Scenario 7: Reprint allowed (same day)
Given a receipt exists and was generated today  
And the cashier has reprint permission for same-day reprints  
When the cashier clicks "Reprint Receipt"  
Then the UI requests a reprint artifact from the backend (or the original with reprint watermark)  
And prints it  
And the UI shows that the receipt is a reprint/duplicate  
And the reprint count increases after refresh.

### Scenario 8: Reprint requires verification after policy threshold
Given a receipt exists and backend indicates verification is required to reprint  
When the cashier clicks "Reprint Receipt"  
Then the UI prompts for the required verification inputs or supervisor override  
And if the cashier does not provide required inputs  
Then the UI blocks reprint and displays a clear requirement message.

### Scenario 9: Reprint denied due to permissions
Given a receipt exists  
And the user lacks reprint permission  
When the user attempts to reprint  
Then the UI displays an authorization error  
And the receipt is not printed.

---

## 13. Audit & Observability

### User-visible audit data
- Receipt reference
- Delivery history entries (method, status, timestamp; failure reason when failed)
- Reprint count and last reprint timestamp

### Status history
- Show chronological list of delivery attempts and reprints (read-only)

### Traceability expectations
- All frontend service calls include correlation id (if available in Moqui request context)
- Do not log full email addresses; display them to user only where needed

---

## 14. Non-Functional UI Requirements

- **Performance:** Receipt load should not block rendering; show loading state; target <2s perceived load for receipt actions (network permitting)
- **Accessibility:** All actions keyboard-navigable; dialogs have focus trapping; status messages announced via ARIA live region
- **Responsiveness:** Works on standard POS tablet/desktop resolutions; receipt actions usable in narrow layouts
- **i18n/timezone/currency:** Display timestamps in store/local timezone; currency displayed using ISO currency from receipt/payment data (no hardcoded $)

---

## 15. Applied Safe Defaults

- **SD-UX-EMPTY-STATE:** Provide explicit empty/loading states for receipt not yet available; qualifies as UI ergonomics. Impacted sections: UX Summary, Alternate/Error Flows.
- **SD-UX-INFLIGHT-GUARD:** Disable action buttons during in-flight requests to prevent double-submit; qualifies as UI ergonomics. Impacted sections: Functional Behavior, Alternate/Error Flows.
- **SD-ERR-STD-MAPPING:** Map 401/403/409/422/503 to standard user messages and retry affordances; qualifies as standard error-handling mapping. Impacted sections: Service Contracts, Alternate/Error Flows.
- **SD-OBS-CORRELATION:** Include correlation/request id in client error reports and logs when available, without PII; qualifies as observability boilerplate. Impacted sections: Audit & Observability.

---

## 16. Open Questions

1. **Moqui contract:** What are the exact Moqui screen paths and services to (a) fetch/create receipt for invoice/payment, (b) request email delivery, (c) request reprint artifact, and (d) record print outcome (if needed)? Provide service names + parameters + response fields.
2. **Partial payments:** Can an invoice be partially paid in this POS flow, and if so should the receipt UI explicitly show â€œPARTIAL PAYMENTâ€ and remaining balance (as backend rules describe), or is this story limited to â€œpaid in fullâ€ captures only?
3. **Failure handling:** When email delivery fails, should the UI allow immediate retry from the POS (new request) or only allow changing email and resubmitting? What statuses does backend return (PENDING/SENT/FAILED/BOUNCED)?
4. **Reprint policy source:** Will backend return policy evaluation such as `allowedActions`, `verificationRequired`, `maxReprintsReached`, and `requiresReasonCode`? If not, where should frontend get the 7-day / 5-reprint thresholds without hardcoding?
5. **Permissions:** What are the exact permission identifiers used in this Moqui app for print/email/reprint and supervisor override?
6. **Printing payload type:** Will printable content be plain text, HTML, or PDF for thermal printing? Does frontend need to format to 40â€“48 char width, or will backend provide printer-ready text?
7. **â€œNo Receiptâ€ behavior:** Is â€œNo Receiptâ€ a backend state transition on receipt delivery (DECLINED), or does it only suppress printing/emailing while still generating the receipt automatically?

---

## Original Story (Unmodified â€“ For Traceability)

Title: [FRONTEND] [STORY] Payment: Print/Email Receipt and Store Reference â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/71

Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] Payment: Print/Email Receipt and Store Reference

**Domain**: payment

### Story Description

/kiro
# User Story

## Narrative
As a **Cashier**, I want receipts so that customers have proof of payment.

## Details
- Receipt includes invoice ref, auth code, timestamp, transaction refs.
- Email receipt optional.

## Acceptance Criteria
- Receipt produced on successful capture.
- Receipt ref stored.
- Reprint supported.

## Integrations
- Payment service returns receipt data; CRM provides email contact (optional).

## Data / Entities
- Receipt, ReceiptDelivery, ContactRef

## Classification (confirm labels)
- Type: Story
- Layer: Experience
- domain :  Point of Sale

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ISSUE #72: [FRONTEND] [STORY] Payment: Void Authorization or Refund Captured Payment â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/72
File: ./scripts/story-work/frontend/72/after.md
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## ğŸ·ï¸ Labels (Proposed)

### Required
- type:story
- domain:billing
- status:draft

### Recommended
- agent:billing-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

# 1. Story Header

## Title
[FRONTEND] Payment Reversal: Void Authorization or Refund Captured Payment (with approvals, reasons, and async refund status)

## Primary Persona
Store Manager

## Business Value
Enable safe, permissioned correction of payment mistakes (void auths / refund captured payments), with complete auditability and accurate invoice/payment status updates to prevent financial discrepancies and support reconciliation.

---

# 2. Story Intent

## As a / I want / So that
As a **Store Manager**, I want to **void authorized payments** or **refund captured/settled payments** (including partial refunds where allowed), so that payment corrections are handled safely with proper approvals, reasons, and traceable outcomes.

## In-scope
- UI to initiate **Void** on eligible payments in **AUTHORIZED** state.
- UI to initiate **Refund** on eligible payments in **CAPTURED/SETTLED** state (full and partial per policy).
- Capture **reason code** (+ notes for OTHER and for certain tiers), and show required **approvals** if the amount requires it.
- Display and update **payment reversal status** and **invoice status** (including refund pending lifecycle).
- Display reversal history (void/refund records) with audit metadata (actor, approver, timestamps, reason, notes).
- Handle common error cases and provide actionable messages.

## Out-of-scope
- Implementing payment gateway logic, webhooks, or backend reconciliation.
- Defining or changing tax/accounting posting behavior (frontend only reflects backend status).
- Creating new business policy beyond what backend already decided (e.g., settlement timing rules beyond exposed eligibility).
- Receipt generation/reprint UX unless explicitly returned by backend contract.

---

# 3. Actors & Stakeholders
- **Store Manager (primary)**: initiates void/refund, provides reason/notes, may need additional approvals.
- **District Manager / Finance Approver (secondary)**: provides approval for high-value reversals (if workflow requires separate approval step).
- **Cashier (secondary)**: may execute cash refund operational steps (display-only unless backend requires).
- **Billing/Payment services (system)**: evaluate eligibility, enforce policy, execute reversal, emit events.
- **Accounting (downstream)**: receives reversal events; frontend may show â€œsynced/pendingâ€ if exposed.

---

# 4. Preconditions & Dependencies

## Preconditions
- User is authenticated.
- User can access the invoice/payment context (tenant/account boundary enforced).
- A payment exists and is linked to an invoice.

## Dependencies (must exist server-side)
- Backend endpoints/services to:
  - Load invoice + payments + reversal history.
  - Determine eligibility and required action (void vs refund) and any approval requirement.
  - Create void/refund request with idempotency and return a status.
  - Expose async refund lifecycle (REQUESTED/PENDING/COMPLETED/FAILED).
- Permission model exposed to frontend (at least via 401/403; ideally via explicit permission flags in response).

---

# 5. UX Summary (Moqui-Oriented)

## Entry points
- From **Invoice Detail** screen: â€œPaymentsâ€ section listing payments with actions.
- Optional: From a **Payment Detail** view (reachable by clicking a payment row).

## Screens to create/modify (Moqui)
1. **Modify** existing Invoice screen (assumed): `InvoiceDetail`
   - Add Payments panel with actions: **Void Authorization**, **Refund Payment**
   - Add Reversal History subpanel (void/refund records)
2. **Create** modal/dialog screen(s) or embedded forms:
   - `VoidPaymentDialog` (form + confirm)
   - `RefundPaymentDialog` (form + confirm + amount input if partial)
3. **Optional**: `RefundRequestDetail` or `PaymentReversalDetail` screen to view a specific reversal record and status history.

## Navigation context
- Route pattern should keep invoice context: `/invoices/:invoiceId` (exact route TBD by repo conventions).
- Dialogs should return to Invoice Detail and refresh data on completion.

## User workflows

### Happy path: Void an authorized payment
1. Manager opens Invoice Detail â†’ Payments.
2. Selects an **AUTHORIZED** payment â†’ clicks â€œVoid Authorizationâ€.
3. Dialog shows amount, tender type, time window/eligibility message (if provided), reason dropdown + notes when required.
4. Submit â†’ success message; payment/reversal status updates; invoice status updates accordingly.

### Happy path: Refund a captured/settled payment (full)
1. Manager selects **CAPTURED/SETTLED** payment â†’ â€œRefund Paymentâ€.
2. Dialog shows refundable amount; chooses reason + notes if required.
3. Submit â†’ refund created; status becomes PENDING if async; UI shows pending and allows refresh.

### Alternate path: Partial refund
- Manager toggles â€œPartial refundâ€ (or amount input enabled by default) and enters amount within allowed bounds; submit.

### Alternate path: Requires higher approval
- UI indicates approval required and either:
  - Blocks submission and instructs to request approval (if separate approval flow exists), or
  - Allows submission but backend returns â€œapproval requiredâ€ with next-step instructions/status.

(Exact approval UX depends on backend contract; see Open Questions.)

---

# 6. Functional Behavior

## Triggers
- User clicks â€œVoid Authorizationâ€ or â€œRefund Paymentâ€ on a payment row.

## UI actions
### Payments list
- Each payment row shows:
  - payment state (AUTHORIZED / CAPTURED / SETTLED / etc. as provided)
  - amount, refundable remaining (if provided), tender type, created date
  - action buttons based on eligibility:
    - **Void** visible/enabled only if backend says eligible for void (or state=AUTHORIZED and permitted)
    - **Refund** visible/enabled only if eligible for refund (or state in CAPTURED/SETTLED and permitted)

### Void dialog
- Inputs:
  - `voidReason` (enum)
  - `notes` required when reason=OTHER
- Submit calls backend void service.
- On success: close dialog; refresh invoice/payments; show reversal record entry.

### Refund dialog
- Inputs:
  - `refundReason` (enum)
  - `notes` required when reason=OTHER
  - `refundAmount` required; supports partial if allowed
- Client-side validations enforce numeric format; backend is authoritative for policy (windows, caps, min, max count).
- Submit calls backend refund service.
- On success: show status:
  - If immediate completed: â€œRefund completedâ€
  - If async: show â€œRefund pendingâ€ and display pending status in payment/reversal history

## State changes (frontend-visible)
- Payment shows reversal status (voided/refunded/pending/failed) as provided.
- Invoice status updated (backend-driven). Must display `REFUND_PENDING` if returned.

## Service interactions
- Initial load: fetch invoice + payment list + reversal records.
- Action submit: call void/refund endpoint; handle synchronous success and async pending.
- Refresh: after submit, re-fetch invoice details; optionally poll pending refunds.

---

# 7. Business Rules (Translated to UI Behavior)

## Validation
- **Reason is required** for both void and refund.
- **Notes required** when reason=OTHER.
- For refund:
  - `refundAmount` must be > 0.
  - Must not exceed backend-provided refundableRemaining (if provided); otherwise allow entry and rely on backend validation.
- If backend returns â€œapproval requiredâ€:
  - UI must present a blocking message with next-step guidance (e.g., â€œRequires District Manager approvalâ€) and store/display the request status if created.

## Enable/disable rules
- Void action disabled if:
  - Payment not in eligible state
  - User lacks permission (403)
  - Backend indicates outside time window without override permission
- Refund action disabled if:
  - No refundable remaining
  - Payment not eligible
  - User lacks permission
  - Backend indicates max partial refund count reached (action disabled if returned as ineligible; otherwise backend error)

## Visibility rules
- Show â€œVoidâ€ only for AUTHORIZED payments (or `eligibleActions` includes VOID).
- Show â€œRefundâ€ only for CAPTURED/SETTLED payments (or eligibleActions includes REFUND).
- Show approval tier hints (â‰¤$100, etc.) only if backend returns tier metadata; do not hardcode thresholds in UI.

## Error messaging expectations
- 401/403: â€œYou donâ€™t have permission to void/refund payments.â€
- 409: â€œPayment state changed; refresh and try again.â€
- 422: Show field-level errors (amount/reason/notes) using backend error details.
- 503: â€œPayment service unavailable; try again later.â€

---

# 8. Data Requirements

## Entities involved (frontend view models)
- Invoice (includes status, totals, amountPaid, amountDue)
- PaymentRecord / PaymentTransaction (id, invoiceId, amount, state, tenderType, gatewayRef, timestamps)
- VoidRecord (id, paymentId, reason, notes, actorUserId, approverUserId?, createdAt, status)
- RefundRecord (id, paymentId, amount, reason, notes, status, actorUserId, approverUserId?, createdAt, completedAt?, failureReason?)
- AuditLog entries (or embedded audit fields on records)

## Fields (type, required, defaults)
### Void request
- `paymentId` (string/uuid, required)
- `reason` (enum VOID_REASON, required)
- `notes` (string, required iff reason=OTHER)
- `idempotencyKey` (string, required if backend requires; otherwise optional)

### Refund request
- `paymentId` (string/uuid, required)
- `amount` (decimal string, required)
- `reason` (enum REFUND_REASON, required)
- `notes` (string, required iff reason=OTHER)
- `idempotencyKey` (string, required if backend requires; otherwise optional)

## Read-only vs editable
- Invoice/payment fields are read-only.
- Only dialog fields (reason, notes, amount) are editable.

## Derived/calculated fields (frontend)
- `refundableRemaining` display: prefer backend-provided value.
- Formatting: currency formatting based on invoice currency (do not infer if not provided).

---

# 9. Service Contracts (Frontend Perspective)

> Backend endpoints are referenced conceptually; exact names/paths must match the Moqui services/screens in this repo.

## Load/view calls
- `GET InvoiceDetail(invoiceId)` returns:
  - invoice summary + status
  - payments list with states and eligibility (preferred: `eligibleActions`, `refundableRemaining`, `requiresApproval`, `approvalTier`)
  - reversal history (refund/void records) OR separate endpoints

## Create/update calls
- `POST VoidPaymentAuthorization`
  - request: paymentId, reason, notes, idempotencyKey?
  - response: voidRecord + updated payment/invoice status (or ids to refresh)

- `POST CreateRefund`
  - request: paymentId, amount, reason, notes, idempotencyKey?
  - response: refundRecord with status (REQUESTED/PENDING/COMPLETED/FAILED) + updated invoice/payment status

## Submit/transition calls
- None beyond void/refund commands.

## Error handling expectations
- Map backend error codes:
  - 422 validation error â†’ show field errors
  - 409 state conflict â†’ refresh prompt
  - 403 forbidden â†’ permission toast + disable action
  - 503 downstream unavailable â†’ retry suggestion
- Do not log sensitive payment data; show masked tender info only if provided.

---

# 10. State Model & Transitions

## Allowed states (as surfaced to UI)
### Payment
- AUTHORIZED â†’ (void) VOIDED
- CAPTURED/SETTLED â†’ (refund) REFUND_REQUESTED / REFUND_PENDING â†’ REFUNDED or REFUND_FAILED
(Exact state strings must match backend; UI should be tolerant and display unknown states generically.)

### Invoice
- Existing states per billing domain plus:
  - `REFUND_PENDING` (display and treat as non-final)
- Invoice status changes are backend-driven; UI simply reflects.

## Role-based transitions
- Store Manager: can initiate void/refund if has `VOID_PAYMENT` / `REFUND_PAYMENT`.
- Higher tiers: District Manager / Finance approval may be required for large refunds (workflow TBD).

## UI behavior per state
- If refund status is PENDING: show banner â€œRefund pendingâ€ and show last updated time; allow manual refresh.
- If FAILED: show failure reason (if provided) and guidance (contact finance/support).

---

# 11. Alternate / Error Flows

## Validation failures
- Missing reason/notes/amount â†’ inline errors; prevent submit.
- Amount exceeds refundable remaining â†’ show backend message and keep dialog open.

## Concurrency conflicts
- Payment moved from AUTHORIZED to CAPTURED while dialog open â†’ backend returns 409; UI shows â€œPayment state changed; refresh.â€

## Unauthorized access
- 403 on action: show message; action buttons become disabled for that session context.

## Empty states
- No payments: show â€œNo payments found for this invoice.â€
- No reversal history: show â€œNo voids/refunds recorded.â€

## Async refund pending too long
- If backend provides age/ETA: display â€œPending since â€¦â€.
- Provide manual refresh; do not invent automated retry/recovery beyond optional polling (see Open Questions).

---

# 12. Acceptance Criteria (Gherkin)

## Scenario 1: Void an authorized payment successfully
Given I am a Store Manager with permission to void payments  
And an invoice has a payment in AUTHORIZED state eligible for void  
When I open the Void Authorization dialog and select a void reason  
And I submit the void request  
Then the system shows a success confirmation  
And the payment is shown as VOIDED (or equivalent backend status)  
And the invoice status and payment totals are refreshed from the backend  
And the void record appears in reversal history with my user identity and reason

## Scenario 2: Void requires notes when reason is OTHER
Given I am initiating a void for an eligible AUTHORIZED payment  
When I select void reason OTHER  
And I do not enter notes  
Then the UI prevents submission and displays a required-field error for notes

## Scenario 3: Refund a captured payment and receive pending status
Given I am a Store Manager with permission to refund payments  
And an invoice has a payment in CAPTURED/SETTLED state eligible for refund  
When I submit a refund for the full refundable amount with a valid refund reason  
Then the UI displays the refund record status returned by the backend  
And if the status is PENDING, the invoice displays REFUND_PENDING (if provided)  
And reversal history shows the refund with status PENDING  
And I can refresh and see the updated status when it changes

## Scenario 4: Partial refund amount validation
Given a payment has refundable remaining amount of $50.00  
When I enter a refund amount of $60.00 and submit  
Then the UI displays an actionable validation error from the backend  
And no refund is recorded as completed  
And the dialog remains open for correction

## Scenario 5: Permission denied
Given I lack REFUND_PAYMENT permission  
When I attempt to open or submit a refund for a payment  
Then the UI shows an authorization error  
And the refund action is disabled or blocked

## Scenario 6: Payment state changed (conflict)
Given I opened a refund/void dialog for a payment  
And the payment state changes before I submit  
When I submit the request  
Then the UI shows a conflict error instructing me to refresh  
And the UI reloads the latest invoice/payment state on user action

---

# 13. Audit & Observability

## User-visible audit data
- Reversal history list shows:
  - reversal type (VOID/REFUND)
  - amount (for refunds)
  - reason + notes (notes visible to authorized roles)
  - initiated by (actor) and approved by (if applicable)
  - timestamps
  - status + failure reason (if failed)

## Status history
- If backend provides status transitions for refund lifecycle, display a simple timeline (Requested â†’ Pending â†’ Completed/Failed).

## Traceability expectations
- All void/refund submissions include a client-generated correlation/idempotency key if required by backend.
- UI includes invoiceId/paymentId in logs/telemetry events (no PAN/CVV).

---

# 14. Non-Functional UI Requirements

- **Performance:** Invoice detail (including payments) should render with standard pagination if lists are large (do not block main thread).
- **Accessibility:** Dialogs keyboard-navigable; form fields have labels; errors announced; focus management on open/close.
- **Responsiveness:** Dialog usable on tablet; tables adapt to narrow widths.
- **i18n/timezone/currency:** Dates shown in user locale/timezone; currency formatting uses invoice currency if provided; do not assume USD if absent.

---

# 15. Applied Safe Defaults

- SD-UX-EMPTY-STATE: Provide clear empty-state copy for no payments / no reversal history; qualifies as UI ergonomics only; impacts UX Summary, Error Flows.
- SD-UX-PAGINATION: Paginate payments/reversal history lists when count is large; qualifies as UI ergonomics only; impacts UX Summary, Data Requirements.
- SD-OBS-CORRELATION-ID: Include correlation id in frontend logs/requests when supported; qualifies as observability boilerplate; impacts Service Contracts, Audit & Observability.

---

# 16. Open Questions

1. What are the **exact Moqui screen names/routes** for Invoice Detail and Payment Detail in this repo (to correctly place transitions and screen paths)?
2. What are the **exact backend service names/endpoints** and request/response schemas for:
   - invoice detail load including payments + eligibility
   - void authorization
   - refund (full/partial)
   - refund status query/history
3. Does the backend require an **idempotency key** from the client for void/refund requests? If yes, what header/field name?
4. How is the **tiered approval workflow** represented for the frontend?
   - Is it a single call that may return â€œapproval requiredâ€, or a separate Requestâ†’Approveâ†’Execute flow with additional screens?
5. Should the frontend **poll** PENDING refunds automatically (and at what interval), or only provide manual refresh? (Do not invent retry/recovery policy.)
6. For **mixed tender / multi-payment** invoices: does the UI allow selecting which payment(s) to refund, and can one refund request target multiple payments?

---

## Original Story (Unmodified â€“ For Traceability)

Title: [FRONTEND] [STORY] Payment: Void Authorization or Refund Captured Payment â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/72

Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] Payment: Void Authorization or Refund Captured Payment

**Domain**: payment

### Story Description

/kiro
# User Story

## Narrative
As a **Store Manager**, I want to void/refund payments so that corrections are handled safely.

## Details
- Voids before settlement; refunds after settlement.
- Requires permission and reason.
- Partial refunds supported (basic).

## Acceptance Criteria
- Void/refund returns success or actionable error.
- Invoice status updated.
- Audit includes reason/approver.

## Integrations
- Payment service API; accounting status updated accordingly.

## Data / Entities
- RefundRecord, VoidRecord, PaymentTransactionRef, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Experience
- domain :  Point of Sale

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

---
*This issue was automatically created by the Durion Workspace Agent*

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ISSUE #73: [FRONTEND] [STORY] Payment: Initiate Card Authorization and Capture â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/73
File: ./scripts/story-work/frontend/73/after.md
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

## ğŸ·ï¸ Labels (Proposed)

### Required
- type:story
- domain:billing
- status:draft

### Recommended
- agent:billing-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

STOP: Clarification required before finalization

---

# 1. Story Header

## Title
[FRONTEND] Payment: Initiate Card Authorization and Capture (Checkout)

## Primary Persona
Cashier

## Business Value
Enable cashiers to take compliant card payments against an invoice at checkout (sale/capture and authâ†’capture), generate a receipt, and ensure billing/audit traceability for accounting reconciliation.

---

# 2. Story Intent

## As a / I want / So that
- **As a** Cashier  
- **I want** to initiate a card payment for an invoice (sale/capture or auth then capture)  
- **So that** the invoice can be paid at checkout, a receipt is produced, and the transaction is auditable without storing card data.

## In-scope
- From an invoice checkout context, start a card payment
- Support **SALE_CAPTURE** default and **AUTH_ONLY â†’ CAPTURE** flow (per backend decisions)
- Display payment status/progress and final outcome
- Persist and show only **token/transaction references** (no PAN/CVV)
- Trigger receipt generation and allow immediate receipt viewing/printing entrypoint
- Record/show audit-friendly metadata visible to user (who/when/terminal) where exposed by backend
- Handle error responses and â€œunknown outcomeâ€ states safely (frontend UX + polling/inquiry hooks)

## Out-of-scope
- Multi-gateway selection/failover UI
- Refunds/chargebacks UI
- Back-office â€œmanual capture laterâ€ workflows (unless explicitly needed for POS checkout screen)
- Invoice regeneration/voiding flows
- Receipt reprint authorization flow details (separate story)

---

# 3. Actors & Stakeholders
- **Cashier**: initiates and completes payment at POS
- **Customer**: presents card and may request receipt email/print
- **Manager** (optional): approval if amount exceeds cashier limit or for flow selection (permission-based)
- **Billing/Payment services (backend)**: create payment intent, authorize, capture, update invoice, emit events
- **Receipt service (backend)**: generates receipt after capture
- **Accounting (downstream)**: receives payment success event (not directly handled by frontend)

---

# 4. Preconditions & Dependencies
- User is authenticated in POS
- Cashier has permission to process payments (backend: `PROCESS_PAYMENT`)
- Invoice exists and is payable (outstanding balance > 0) and in a state allowing payment
- POS terminal/location is configured with a gateway (single gateway MVP)
- Frontend can call Moqui screens/services that proxy to backend payment APIs
- Backend provides endpoints for:
  - create/initiate payment intent (sale/capture or auth-only)
  - capture against existing auth (for same-session flow)
  - payment status inquiry (for unknown outcomes) and/or status fetch by intent id
  - receipt retrieval after success (or receipt id returned)

---

# 5. UX Summary (Moqui-Oriented)

## Entry points
- From **Invoice Detail / Checkout** screen: action â€œPay by Cardâ€
- (Optional) from â€œOutstanding Balanceâ€ banner or payment panel

## Screens to create/modify
1. **Modify**: `apps/pos/screen/Invoice/InvoiceDetail.xml` (or equivalent invoice checkout screen)
   - Add â€œPay by Cardâ€ action and payment status panel (if not already present)
2. **Create**: `apps/pos/screen/Payment/CardPaymentFlow.xml` (new dedicated flow screen)
   - Hosts the payment initiation UI, progress, and outcome handling
3. **Create/Modify**: `apps/pos/screen/Receipt/ReceiptView.xml` (if receipt viewer exists, wire to payment outcome)

> Exact file paths/names may differ in repo; implement using existing Moqui screen hierarchy and menu patterns from README conventions.

## Navigation context
- Route includes `invoiceId`
- Return path back to Invoice Detail after completion/cancel
- Preserve correlation identifiers in URL params only if non-sensitive (no tokens)

## User workflows

### Happy path A: SALE_CAPTURE (default)
1. Cashier clicks â€œPay by Cardâ€
2. Frontend creates payment intent as SALE_CAPTURE for amount due
3. UI shows â€œProcessingâ€¦â€ with spinner and disables duplicate submission
4. On success, show â€œPayment capturedâ€ + receipt link/button, and invoice shows Paid/updated balance

### Happy path B: AUTH_ONLY then CAPTURE (same session)
1. Cashier selects (if permitted) â€œAuthorize now, capture after confirmationâ€
2. Create auth-only intent; on success show â€œAuthorizedâ€
3. Cashier clicks â€œCaptureâ€ (immediate) and completes capture
4. On capture success show receipt link/button

### Alternate path: Amount exceeds threshold / requires approval
- If backend returns an authorization failure/permission requirement, show blocking message and guide to request manager credentials per existing POS pattern (if exists)

### Cancel/Back
- Cashier can cancel out of the UI before submission; once submitted, cancellation behavior depends on backend support (see Open Questions)

---

# 6. Functional Behavior

## Triggers
- User action â€œPay by Cardâ€
- User action â€œCaptureâ€ (for auth-only flow)
- Screen mount loads invoice/payment context
- Automatic status polling when payment outcome is pending/unknown

## UI actions
- Start payment:
  - Choose flow type (default SALE_CAPTURE; AUTH_ONLY available only if permission `SELECT_PAYMENT_FLOW`)
  - Confirm amount (read-only from invoice balance due; editable only if partial payments are allowedâ€”currently unclear)
  - Submit â€œProcess Cardâ€
- Show progress with deterministic states:
  - â€œCreating paymentâ€¦â€, â€œAuthorizingâ€¦â€, â€œCapturingâ€¦â€, â€œFinalizingâ€¦â€
- Show outcome summary:
  - Success: captured amount, timestamp, gateway reference (masked), receipt action
  - Failure: error reason, retry button (only when safe), and â€œReturn to invoiceâ€
  - Unknown/timeout: show â€œWeâ€™re confirming statusâ€¦â€ and continue status inquiry/poll

## State changes (frontend view state)
- Local UI state machine:
  - `idle` â†’ `submitting` â†’ (`succeeded` | `failed` | `unknown`)  
  - For auth-only: `authorized` â†’ `capturing` â†’ outcome
- Disable primary actions while `submitting/capturing` to prevent double-charge attempts; allow â€œCloseâ€ only after resolution or if backend indicates safe to exit.

## Service interactions
- Load invoice summary + existing payment intents (if any) for this invoice
- Initiate payment intent (sale/capture or auth-only)
- If unknown outcome, call status inquiry using idempotency key/intent id (backend supports inquiry per decisions)
- On success, load receipt content/metadata and provide print/email actions per existing receipt screen capabilities

---

# 7. Business Rules (Translated to UI Behavior)

## Validation
- Must have `invoiceId`
- Invoice must have `balanceDue > 0`
- Payment amount defaults to full balance due
- Enforce **no PAN/CVV storage** in frontend state, logs, or persisted local storage
- Flow selection:
  - Default is **SALE_CAPTURE**
  - AUTH_ONLY selectable only if backend indicates invoice flags or user permission allow it (backend decision references invoice flags such as `requiresManagerApproval`, `amountMayChange`, partial fulfillment). Frontend must rely on backend-provided capability flags; do not infer.

## Enable/disable rules
- â€œPay by Cardâ€ disabled if invoice is already paid/void or `balanceDue == 0`
- â€œCaptureâ€ enabled only when intent status is `AUTHORIZED` and user has permission for capture in-session (backend: `PROCESS_PAYMENT`; later capture is `MANUAL_CAPTURE`â€”not in scope unless returned by backend)

## Visibility rules
- Show flow selector only if user has `SELECT_PAYMENT_FLOW` and backend indicates auth-only is allowed for this invoice
- Show manager-approval messaging only when backend returns explicit error codes for limit/approval

## Error messaging expectations
- Map backend errors to user-safe messages:
  - 422: show validation message (missing customer data, invalid state)
  - 409: show conflict (â€œInvoice already paid / payment already processedâ€)
  - 503: show service unavailable + retry guidance
  - Gateway decline: show â€œCard declinedâ€ without sensitive details; include a reason code only if non-sensitive and provided
- Unknown outcome/timeouts: do not suggest retry that could double-charge; instead â€œChecking statusâ€¦â€ and offer â€œReturn to invoiceâ€ once status is known or inquiry fails.

---

# 8. Data Requirements

## Entities involved (frontend-visible)
- **Invoice** (read): `invoiceId`, `status`, `balanceDue`, `currencyUomId`, `customerAccountId`
- **PaymentIntent** (read/create): `paymentIntentId`, `invoiceId`, `paymentMethodType= à¤•à¤¾à¤°à¥à¤¡`, `flowType (SALE_CAPTURE|AUTH_ONLY)`, `status`, `authorizedAmount`, `capturedAmount`, `voidedRemainderAmount`, `gatewayProvider`, timestamps, `idempotencyKey`
- **PaymentTransactionRef** (read): `gatewayTransactionId`, `authCode`, `cardBrand`, `last4` (masked)
- **Receipt** (read): `receiptId`, `status`, `deliveryStatus`, content reference
- **AuditLog/AuditEvent** (read optional): `eventType`, `actorUserId`, `timestamp`, `entityRef`

## Fields (type, required, defaults)
- `invoiceId` (string, required)
- `amount` (decimal, required; default = invoice balance due; editability TBD)
- `currencyUomId` (string, required; default from invoice)
- `flowType` (enum, required; default SALE_CAPTURE)
- `idempotencyKey` (string, required; generated client-side per attempt; must not include PII)

## Read-only vs editable by state/role
- Amount:
  - Read-only unless partial payments are explicitly allowed (Open Question)
- Flow selector:
  - Read-only/hidden unless permission and backend allows
- Transaction references:
  - Always read-only and masked

## Derived/calculated fields
- â€œBalance due after paymentâ€ is derived from invoice refresh after payment success (do not calculate locally beyond display hints)

---

# 9. Service Contracts (Frontend Perspective)

> Moqui screen actions should call services (e.g., `services.xml` or remote REST) consistent with repo conventions. Endpoint names below are **contract placeholders** unless already defined; align to actual backend API routing.

## Load/view calls
- `GET InvoiceSummary(invoiceId)` â†’ invoice status, balance due, currency
- `GET PaymentIntentsByInvoice(invoiceId)` â†’ list current/previous intents for display and to prevent duplicates
- `GET PaymentIntent(paymentIntentId)` â†’ latest status + refs (used for polling)

## Create/update calls
- `POST CreatePaymentIntent`
  - Request: `invoiceId`, `amount`, `currency`, `flowType`, `idempotencyKey`, `terminalId/locationId` (if required)
  - Response: `paymentIntentId`, `status`, refs (masked), receipt pointer if immediately available
- `POST CapturePayment(paymentIntentId)`
  - Request: `amount` (if partial capture supported; else omit), `idempotencyKey`
  - Response: updated intent + receipt pointer

## Submit/transition calls
- `POST PaymentStatusInquiry(paymentIntentId or idempotencyKey)` (for unknown outcomes)
  - Response: definitive status or `PENDING`

## Error handling expectations
- All calls return structured errors with:
  - `errorCode`, `message`, `fieldErrors[]` (if 422)
  - `correlationId` for support
- Frontend must display correlationId in an expandable â€œDetailsâ€ section (non-sensitive)

---

# 10. State Model & Transitions

## Allowed states (as presented to UI)
(Exact enum values must match backend; map if backend differs)
- `CREATED` / `PENDING`
- `AUTHORIZED`
- `CAPTURED` (success)
- `DECLINED` / `FAILED`
- `EXPIRED` (auth window exceeded)
- `UNKNOWN` (client timed out; awaiting inquiry result)

## Role-based transitions
- Cashier with `PROCESS_PAYMENT`:
  - Can initiate SALE_CAPTURE
  - Can initiate AUTH_ONLY if `SELECT_PAYMENT_FLOW`
  - Can capture immediately after auth (same session) if backend allows
- Manager permissions (if applicable):
  - `OVERRIDE_PAYMENT_LIMIT` for amounts over threshold (backend defined $500 default configurable)

## UI behavior per state
- `PENDING`: show progress + disable submit
- `AUTHORIZED`: show â€œCaptureâ€ primary action (if allowed), plus â€œVoidâ€ only if explicitly in scope (not in this story)
- `CAPTURED`: show success + receipt actions, navigate back to invoice
- `FAILED/DECLINED`: show failure + safe retry (new idempotency key) only if backend indicates no side effect occurred
- `UNKNOWN`: lock re-submit; run inquiry/poll loop and present outcome

---

# 11. Alternate / Error Flows

## Validation failures
- Missing `invoiceId`: show error and route back to invoice list
- Invoice not payable (0 balance / Paid / Void): show â€œNo payment neededâ€ and disable actions

## Concurrency conflicts
- If another terminal/user pays invoice while this screen is open:
  - backend returns 409 or invoice refresh shows paid
  - UI stops polling and shows â€œInvoice already paidâ€ with return action

## Unauthorized access
- If user lacks `PROCESS_PAYMENT`: hide entry point; if deep-linked, show 403 screen

## Empty states
- No prior payment intents: show empty â€œNo card payments attempted yetâ€
- Receipt not yet available after capture: show â€œReceipt generatingâ€¦â€ and poll receipt status if endpoint exists; otherwise provide â€œRefreshâ€ and return to invoice

## Downstream/gateway timeouts
- If create/capture times out:
  - UI transitions to `UNKNOWN`
  - call status inquiry; if still unknown after N attempts (safe defaultâ€”see below), show â€œUnable to confirm; check invoice payment statusâ€ and navigate back without offering blind retry

---

# 12. Acceptance Criteria

### Scenario 1: Start SALE_CAPTURE card payment and succeed
**Given** a cashier with `PROCESS_PAYMENT` is viewing an invoice with `balanceDue > 0`  
**When** the cashier selects â€œPay by Cardâ€ and submits payment with flow type `SALE_CAPTURE`  
**Then** the UI shows processing state and prevents duplicate submission  
**And** on success the UI shows captured amount, masked card details (brand/last4 only), and a receipt action  
**And** returning to the invoice shows updated paid status or reduced balance due per backend response.

### Scenario 2: AUTH_ONLY then CAPTURE in the same session
**Given** a cashier with `PROCESS_PAYMENT` and `SELECT_PAYMENT_FLOW` is viewing an eligible invoice  
**When** the cashier selects flow type `AUTH_ONLY` and submits  
**Then** the UI shows the payment intent in `AUTHORIZED` state with a â€œCaptureâ€ action  
**When** the cashier clicks â€œCaptureâ€  
**Then** the UI completes capture and shows receipt access on `CAPTURED`.

### Scenario 3: Card declined (non-success)
**Given** a cashier initiates a card payment  
**When** the backend returns a declined/failed status with a non-sensitive reason  
**Then** the UI displays â€œCard declinedâ€ (no PAN/CVV) and provides options to retry or choose another payment method  
**And** the UI does not mark the invoice as paid.

### Scenario 4: Timeout/unknown outcome triggers inquiry instead of blind retry
**Given** a cashier submits a card payment  
**When** the request times out or returns an unknown outcome  
**Then** the UI enters â€œConfirming statusâ€ state and calls payment status inquiry  
**And** the UI does not enable â€œRetryâ€ until a definitive failed status is returned  
**And** once definitive status is received, the UI reflects that outcome.

### Scenario 5: Prevent storing card data
**Given** the cashier completes any payment attempt  
**When** the UI stores or logs client state  
**Then** no PAN, CVV, or full track data exists in browser storage, logs, or URLs  
**And** only token/transaction references and masked card metadata may be displayed.

### Scenario 6: Permission-gated flow selection
**Given** a cashier without `SELECT_PAYMENT_FLOW`  
**When** the cashier opens the card payment screen  
**Then** the flow type defaults to `SALE_CAPTURE` and AUTH_ONLY selection is not available.

---

# 13. Audit & Observability

## User-visible audit data
- Show (if provided): payment timestamp, cashier user id/name, terminal/location id, correlation id
- Show gateway references only in masked form (txn id may be shown if allowed by policy)

## Status history
- Display a simple timeline for the current payment intent: created â†’ authorized â†’ captured/failed (based on backend fields)

## Traceability expectations
- All frontend calls include a correlation id header (or Moqui standard) and pass/receive `idempotencyKey`
- UI should display backend `correlationId` for support without exposing sensitive payloads

---

# 14. Non-Functional UI Requirements

- **Performance**: Payment screen actions should respond to user input immediately; polling intervals must not overload backend
- **Accessibility**: All actions keyboard accessible; progress updates announced (ARIA live region) for screen readers
- **Responsiveness**: Works on typical POS tablet and desktop breakpoints
- **i18n/timezone/currency**: Amount formatting uses invoice currency; timestamps rendered in location timezone (if available) or user locale; no currency conversions performed client-side

---

# 15. Applied Safe Defaults
- **SD-UX-EMPTY-STATE**: Provide standard empty-state messaging for â€œno prior payment intentsâ€ because itâ€™s UI ergonomics and does not affect domain policy. (Sections: UX Summary, Alternate/Empty states)
- **SD-UX-PAGINATION-NONE-SMALL-LISTS**: Assume payment intents list is short and can render without pagination in POS context. Safe UI assumption only. (Sections: UX Summary, Data Requirements)
- **SD-ERR-HTTP-MAP**: Map 422/409/503 to validation/conflict/unavailable UI messages when backend implies these statuses. Standard error handling only. (Sections: Business Rules, Error Flows, Acceptance Criteria)
- **SD-OBS-CORRELATION-ID**: Include correlation id in requests and surface response correlation id in UI details. Observability boilerplate consistent with workspace defaults. (Sections: Service Contracts, Audit & Observability)

---

# 16. Open Questions

1. **Partial payments**: Is partial payment (amount less than invoice balance due) allowed at POS for card payments in this flow? If yes, what constraints (min amount, remaining balance handling, multiple payments per invoice)?
2. **Failure handling policy**: For gateway declines vs technical failures vs unknown outcomes, what exact retry affordances should the UI provide (immediate retry allowed? require manager? require waiting)?
3. **Void/cancel behavior**: If an AUTH_ONLY succeeds but cashier cancels the checkout, should the UI offer â€œVoid authorizationâ€ (requires `VOID_PAYMENT`) or leave the auth to expire automatically?
4. **Receipt delivery**: Print is default per backend decision; is **email receipt** in-scope here, and what is the required consent UX and email capture source (CRM vs prompt)?
5. **Concrete service endpoints**: What are the exact Moqui service names / REST routes for create intent, capture, inquiry, receipt fetch in this frontend repo (so screens can be wired without guesswork)?
6. **Invoice state update**: After capture, should the frontend rely on an event-driven refresh, or immediately re-fetch invoice summary; is there a canonical â€œinvoice payment statusâ€ endpoint?

---

---

## Original Story (Unmodified â€“ For Traceability)

Title: [FRONTEND] [STORY] Payment: Initiate Card Authorization and Capture â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/73

Labels: frontend, story-implementation, payment

## Frontend Implementation for Story

**Original Story**: [STORY] Payment: Initiate Card Authorization and Capture

**Domain**: payment

### Story Description

/kiro
# User Story

## Narrative
As a **Cashier**, I want to accept card payments so that invoices can be paid at checkout.

## Details
- Support auth then capture (or sale/capture).
- Store only tokens + transaction IDs.
- Produce receipt.

## Acceptance Criteria
- Auth/capture outcomes handled.
- Receipt produced.
- No card data stored.
- Audit recorded.

## Integrations
- Payment service API integration; accounting notified after success.

## Data / Entities
- PaymentIntent, PaymentTransactionRef, Receipt, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Experience
- domain :  Point of Sale

### Frontend Requirements

- Implement Vue.js 3 components with TypeScript
- Use Quasar framework for UI components
- Integrate with Moqui Framework backend
- Ensure responsive design and accessibility

### Technical Stack

- Vue.js 3 with Composition API
- TypeScript 5.x
- Quasar v2.x
- Moqui Framework integration

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ISSUE #77: [FRONTEND] [STORY] Workexec: Display Invoice and Request Finalization (Controlled) â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/77
File: ./scripts/story-work/frontend/77/after.md
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

STOP: Clarification required before finalization

## ğŸ·ï¸ Labels (Proposed)

### Required
- type:story
- domain:billing
- status:draft

### Recommended
- agent:billing-domain-agent
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:incomplete-requirements

**Rewrite Variant:** accounting-strict

---

## 1. Story Header

**Title:** [FRONTEND] [STORY] Billing: View Invoice & Request Finalization (Controlled) from Work Order  
**Primary Persona:** Service Advisor  
**Business Value:** Enables Service Advisors to review billing-accurate invoice details and initiate a controlled finalization request so the invoice can be locked and proceed to payment, with permissions and auditability enforced.

---

## 2. Story Intent

### As a / I want / So that
- **As a** Service Advisor  
- **I want** to view an invoice (items, taxes/fees, totals, status) for a completed Work Order and request invoice finalization when eligible  
- **So that** we can lock the invoice for payment processing and ensure accounting-posting readiness with proper controls

### In-scope
- Read-only invoice detail view (line items, taxes, fees, totals, traceability, statuses).
- Eligibility messaging for finalization (why allowed/blocked).
- Controlled â€œRequest Finalizationâ€ UI flow:
  - Permission gating and amount-limit handling.
  - Manager approval input when required (per backend rules).
  - Submit finalize request and render resulting status.
- Display posting-to-accounting status (e.g., POSTED/ERROR) as returned by Billing.

### Out-of-scope
- Editing invoice line items/prices/taxes (invoice is displayed, not authored here).
- Taking/processing payments (separate story).
- Implementing accounting retry logic, SLA alerts, or backend state machine (backend-owned).
- Revert-to-draft / unfinalize flow (explicitly excluded unless separately specified).

---

## 3. Actors & Stakeholders

- **Service Advisor** (initiates view and finalization request)
- **Shop Manager** (provides approval for override scenarios)
- **Billing system** (SoR for invoice lifecycle, totals, tax calculation)
- **Work Execution (Workexec)** (SoR for Work Order state; provides linkage/context)
- **Accounting system** (receives posting events; status displayed in UI via Billing view)
- **Audit/Compliance stakeholders** (need traceability of who requested/finalized/overrode)

---

## 4. Preconditions & Dependencies

### Preconditions
- User is authenticated in POS frontend.
- A Work Order context exists (e.g., user navigated from a Work Order screen) with a `workOrderId`.
- Billing has (or can create idempotently) an invoice associated to the Work Order **OR** an invoice already exists and is retrievable by `workOrderId`/`invoiceId`.

### Dependencies
- Backend Billing API(s) to:
  - Load invoice view by `workOrderId` and/or `invoiceId`.
  - Provide computed totals, tax breakdown, invoiceStatus, and â€œfinalizable reason/eligibilityâ€ fields.
  - Submit a finalize request (including manager approval fields when required).
- Authorization/permission service exposure to frontend (either via API-provided flags or a session permission model) for:
  - `FINALIZE_INVOICE` (and any override/manager-approval related permission if separate).
- Workexec UI navigation must provide a stable route into this invoice screen.

---

## 5. UX Summary (Moqui-Oriented)

### Entry points
- From Work Order details screen: â€œView Invoiceâ€ action (or a Billing/Invoice tab) that navigates into invoice view for that work order.

### Screens to create/modify (Moqui)
1. **New/Updated Screen:** `WorkOrder/InvoiceView.xml` (name indicative; final path must match repo conventions)
   - Parameters: `workOrderId` (required) and optionally `invoiceId` (if available).
2. **Optional embedded panel:** Invoice summary panel within existing Work Order screen that links to full invoice view.

### Navigation context
- Breadcrumb: Work Orders â†’ Work Order `<workOrderId>` â†’ Invoice
- Back navigation returns to Work Order view.

### User workflows
#### Happy path (eligible finalize)
1. Service Advisor opens invoice view from Work Order.
2. System loads invoice view (line items/taxes/fees/totals/status).
3. If status is DRAFT/EDITABLE and eligible, â€œRequest Finalizationâ€ action is enabled.
4. User clicks â€œRequest Finalizationâ€.
5. If manager approval not required: confirm dialog â†’ submit â†’ show updated status FINALIZED (and subsequent POSTED/ERROR changes as they occur).
6. If manager approval required: modal requests manager approval code + override reason â†’ submit â†’ show updated status.

#### Alternate paths
- Invoice not eligible: show clear blocking reasons and keep action disabled.
- Permission denied: show â€œinsufficient permissionsâ€ and disable action; no submit.
- Accounting posting pending/error: show posting status (read-only) with timestamp and any non-sensitive error summary returned by backend.

---

## 6. Functional Behavior

### Triggers
- Screen load with `workOrderId` (and/or `invoiceId`).
- User clicks â€œRequest Finalizationâ€.

### UI actions
- **On load:**
  - Call invoice view service.
  - Render sections:
    - Header: invoiceId, status, workOrderId, customer, totals.
    - Line items list.
    - Taxes/fees breakdown.
    - Audit/traceability fields (finalizedBy/finalizedAt, glEntryId if posted).
- **On â€œRequest Finalizationâ€:**
  - Perform client-side pre-checks only for presence of required fields for submission (e.g., manager approval code when required per API response).
  - Submit finalize request.
  - On success: refresh invoice view and display status transition result.
  - On failure: map errors to inline/global messages.

### State changes (frontend)
- Local UI state: loading, loaded, submitting, submitSuccess, submitError.
- No client-side mutation of invoice content; all authoritative state comes from backend response.

### Service interactions
- `loadInvoiceView` (read)
- `requestFinalizeInvoice` (command)
- `reloadInvoiceView` after finalize request result

---

## 7. Business Rules (Translated to UI Behavior)

> Backend rules are authoritative; UI must reflect them without inventing policy.

### Validation
- If backend indicates invoice is not eligible (e.g., work order not completed, data incomplete, already posted), UI must:
  - Disable finalization action.
  - Display backend-provided reason(s) in a human-readable form.
- If backend indicates manager approval required (based on role + amount thresholds):
  - UI must require manager approval code and override reason fields before enabling submit.

### Enable/disable rules
- â€œRequest Finalizationâ€ is enabled only when:
  - Backend indicates `invoiceStatus` is in an eligible pre-final state (e.g., DRAFT/EDITABLE), **and**
  - Backend indicates `finalizationAllowed=true` (or equivalent), **and**
  - User has permission (either from session permissions or backend returns `canFinalize=true`).
- If manager approval required, submit enabled only when required approval inputs are present and non-empty.

### Visibility rules
- Show posting status fields (POSTED/ERROR) only when provided.
- Show manager approval inputs only when backend indicates required.

### Error messaging expectations
- Permission denial: â€œYou do not have permission to finalize invoices.â€
- Validation/integrity errors: â€œInvoice cannot be finalized: <reason>â€ (using backend reason codes/messages).
- Downstream/accounting unavailable: show non-technical message; keep correlation/reference ID if provided.

---

## 8. Data Requirements

### Entities involved (frontend perspective)
- `InvoiceView` (read model)
- `FinalizeRequest` (command payload)
- `AuditLog` (read-only snippets, if included in InvoiceView)

### Fields (type, required, defaults)

#### InvoiceView (read)
Minimum required to render:
- `invoiceId` (string/UUID, required)
- `workOrderId` (string/UUID, required)
- `customerAccountId` (string/UUID, required)
- `invoiceStatus` (enum/string, required; e.g., DRAFT, FINALIZED, POSTED, ERROR, VOID)
- `lineItems[]` (array, required; may be empty)
  - `description` (string)
  - `quantity` (number)
  - `unitPrice` (decimal/money)
  - `lineTotal` (decimal/money)
- `taxes[]` (array)
  - `taxType` (string)
  - `amount` (decimal/money)
- `fees[]` (array)
  - `feeType` (string)
  - `amount` (decimal/money)
- `subtotal` (decimal/money, required)
- `grandTotal` (decimal/money, required)
- `currencyUomId` (string, required)
Finalization guidance:
- `finalizationAllowed` (boolean, required)
- `finalizationBlockReasons[]` (array of strings/codes, required when not allowed)
- `managerApprovalRequired` (boolean, required)
- `amountLimit` (decimal/money, optional)
Posting fields:
- `glEntryId` (string, optional)
- `postingStatus` (enum/string, optional; e.g., PENDING, POSTED, ERROR)
- `postingErrorSummary` (string, optional; must be non-sensitive)
Audit fields:
- `finalizedByUserId` (string, optional)
- `finalizedAt` (datetime, optional)

> Note: exact field names must match backend; if unknown, treat as contract-open-question (see Open Questions).

#### FinalizeRequest (write)
- `invoiceId` (string/UUID, required)
- `overrideReason` (string, required if managerApprovalRequired=true)
- `managerApprovalCode` (string, required if managerApprovalRequired=true)

### Read-only vs editable by state/role
- Invoice content: always read-only in this screen.
- Finalize request inputs: editable only prior to submission; hidden unless required.

### Derived/calculated fields
- Totals/taxes are derived by Billing and must be displayed as-is (no frontend recalculation beyond formatting).

---

## 9. Service Contracts (Frontend Perspective)

> Moqui screen should call backend services via standard Moqui service-calls; actual service names/paths must align with backend implementation.

### Load/view calls
- **Service:** `billing.InvoiceView.get` (placeholder)
- **Input:** `workOrderId` (or `invoiceId`)
- **Output:** `InvoiceView` DTO

### Create/update calls
- None (no invoice editing in scope).

### Submit/transition calls
- **Service:** `billing.Invoice.finalize.request` (placeholder)
- **Input:** `FinalizeRequest` (invoiceId + approval fields when needed)
- **Output:** Updated status and/or a refreshed `InvoiceView` payload.

### Error handling expectations
- Map HTTP/service errors:
  - `401/403`: show permission message; disable action.
  - `409`: show state conflict (e.g., already finalized/posted); force refresh.
  - `422`: show validation reasons (missing data, integrity issues); keep action disabled until refresh.
  - `503`: show service unavailable; allow retry (manual).

---

## 10. State Model & Transitions

### Allowed states (displayed)
- DRAFT/EDITABLE (eligible for request depending on validations)
- FINALIZED (read-only; indicates finalize succeeded and payment can proceed)
- POSTED (read-only; shows GL linkage)
- ERROR (read-only; posting failed; show error summary if provided)
- VOID (read-only; not finalizable)

### Role-based transitions (frontend initiation)
- Service Advisor:
  - Can request finalization when allowed and under amount limit, otherwise triggers manager approval requirement (backend-driven).
- Shop Manager:
  - Can request finalization without amount limit (backend-driven).

### UI behavior per state
- DRAFT/EDITABLE: show request finalization control (enabled/disabled based on eligibility).
- FINALIZED/POSTED/ERROR/VOID: hide or disable request finalization; display status and audit/posting information.

---

## 11. Alternate / Error Flows

### Validation failures
- Backend returns `422` with reason codes/messages (e.g., missing customer billing address, incomplete line items).
- UI displays reasons and disables finalization; provides â€œRefreshâ€ action.

### Concurrency conflicts
- Another user finalizes while viewing:
  - Finalize request returns `409`.
  - UI refreshes invoice view and shows â€œInvoice status changed. Page updated.â€

### Unauthorized access
- User lacks permission:
  - On load: view still allowed (if permitted); finalize action hidden/disabled.
  - On submit: `403` â†’ show error and log audit/telemetry event.

### Empty states
- No invoice found for workOrderId:
  - Show â€œNo invoice available for this work order.â€
  - Provide guidance: â€œEnsure work order is completed and invoice-ready.â€
  - (Whether frontend should trigger invoice draft creation is **not assumed**; see Open Questions.)

---

## 12. Acceptance Criteria (Gherkin)

### Scenario 1: View invoice details for completed work order
**Given** I am an authenticated Service Advisor  
**And** I navigate to the Invoice view for a Work Order with an existing invoice  
**When** the page loads  
**Then** I see invoice line items, taxes/fees, subtotal, and grand total  
**And** I see the invoice status and traceability fields (invoiceId, workOrderId)

### Scenario 2: Finalization action disabled when invoice is not eligible
**Given** I am viewing an invoice with status DRAFT/EDITABLE  
**And** the backend indicates `finalizationAllowed=false` with one or more blocking reasons  
**When** the invoice view renders  
**Then** the â€œRequest Finalizationâ€ action is disabled  
**And** the blocking reasons are displayed to the user

### Scenario 3: Permission required to request finalization
**Given** I am viewing an eligible invoice  
**And** I do not have permission to finalize invoices  
**When** the invoice view renders  
**Then** I cannot request finalization (action hidden or disabled)  
**And** I see a message indicating insufficient permission

### Scenario 4: Request finalization without manager approval
**Given** I am viewing an invoice where `finalizationAllowed=true` and `managerApprovalRequired=false`  
**When** I click â€œRequest Finalizationâ€ and confirm  
**Then** the system submits a finalize request for that invoice  
**And** the invoice status updates to FINALIZED (after refresh)  
**And** finalized audit fields (finalizedBy/finalizedAt) are displayed when provided

### Scenario 5: Request finalization with manager approval required
**Given** I am viewing an invoice where `finalizationAllowed=true` and `managerApprovalRequired=true`  
**When** I open the finalization modal  
**Then** I must enter manager approval code and override reason before I can submit  
**When** I submit the request with both fields populated  
**Then** the request is sent to the backend  
**And** the resulting invoice status is displayed (FINALIZED or an error state/message)

### Scenario 6: Conflict on finalize due to concurrent update
**Given** I am viewing an invoice that was eligible a moment ago  
**And** another user finalizes the invoice before I submit  
**When** I submit my finalize request  
**Then** I receive a conflict error  
**And** the UI refreshes to show the current invoice status

### Scenario 7: Posting status is displayed when available
**Given** an invoice has been finalized and backend provides posting status  
**When** I view the invoice  
**Then** I see POSTED with a GL Entry ID or ERROR with a non-sensitive error summary (if provided)

---

## 13. Audit & Observability

- Display user-visible audit fields when available: `finalizedBy`, `finalizedAt`, `postingStatus`, `glEntryId`.
- Frontend telemetry/logging (consistent with repo conventions):
  - Log events: `invoice_view_loaded`, `invoice_finalize_clicked`, `invoice_finalize_submitted`, `invoice_finalize_failed`, `invoice_finalize_succeeded`.
  - Include correlation ID from backend responses if provided.
- Do not log sensitive inputs (e.g., manager approval code); only log presence/attempt and masked metadata.

---

## 14. Non-Functional UI Requirements

- **Performance:** Invoice view should render within acceptable UX limits; show loading state while fetching.
- **Accessibility:** Actions and modal inputs must be keyboard-navigable; validation errors announced (ARIA).
- **Responsiveness:** Works on tablet resolutions used in shop floor.
- **i18n/timezone/currency:** Currency formatting must use `currencyUomId`; datetime shown in shop-local timezone (mechanism must follow existing app conventions).

---

## 15. Applied Safe Defaults

- **SD-UI-EMPTY-STATE-01**: Provide standard loading/empty/error states for invoice view; qualifies as UI ergonomics. (Impacted: UX Summary, Alternate/Error Flows)  
- **SD-UI-REFRESH-AFTER-COMMAND-01**: After successful finalize request, re-load InvoiceView from backend instead of locally mutating; safe because backend is SoR. (Impacted: Functional Behavior, Service Contracts)  
- **SD-ERR-MAP-HTTP-01**: Map 401/403/409/422/503 to standard user messages and retry affordances; safe as generic error handling without policy invention. (Impacted: Service Contracts, Alternate/Error Flows, Business Rules)

---

## 16. Open Questions

1. **Invoice retrieval contract:** Should the frontend load invoice by `workOrderId`, by `invoiceId`, or both? What are the exact service names and parameter names exposed in Moqui for Billing invoice view?  
2. **Draft creation behavior:** If no invoice exists for a completed work order, should the frontend:
   - (a) show â€œno invoiceâ€ only, or
   - (b) call an idempotent â€œcreate draft from work orderâ€ service automatically or via a button?
3. **Manager approval input semantics:** What is the exact â€œmanager approval codeâ€ format and validation rules (length, numeric/alphanumeric, expiration)? Is it a code, a credential re-auth, or a separate approval workflow token?  
4. **Permission source:** Are permissions exposed to frontend via session/identity claims, or should the invoice view response include `canFinalize` / `managerApprovalRequired` fully computed?  
5. **Posting/error display policy:** For `postingErrorSummary`, what content is allowed to be shown to Service Advisors (and what must be hidden)?  
6. **State naming:** Backend references DRAFT/EDITABLE and FINALIZED/POSTED/ERROR; what are the exact enum values returned so UI can map consistently?

---

## Original Story (Unmodified â€“ For Traceability)

Title: [FRONTEND] [STORY] Workexec: Display Invoice and Request Finalization (Controlled) â€” URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/77

FRONTEND STORY (FULL CONTEXT)

Title: [FRONTEND] [STORY] Workexec: Display Invoice and Request Finalization (Controlled)  
URL: https://github.com/louisburroughs/durion-moqui-frontend/issues/77  
Labels: frontend, story-implementation, payment

Frontend Implementation for Story

Original Story: [STORY] Workexec: Display Invoice and Request Finalization (Controlled)

Domain: payment

Story Description

/kiro  
# User Story

## Narrative  
As a Service Advisor, I want to display invoice details and request finalization so that we can proceed to payment.

## Details  
- Show invoice items, taxes/fees, totals.  
- If invoice not finalized, request finalization workflow (controlled).

## Acceptance Criteria  
- Invoice view consistent with workexec.  
- Finalize request requires permission.  
- Resulting status shown.

## Integrations  
- Workexec invoice APIs; accounting status follows after posting.

## Data / Entities  
- InvoiceView, FinalizeRequest, AuditLog

## Classification (confirm labels)  
- Type: Story  
- Layer: Experience  
- domain : Point of Sale

Frontend Requirements
- Implement Vue.js 3 components with TypeScript  
- Use Quasar framework for UI components  
- Integrate with Moqui Framework backend  
- Ensure responsive design and accessibility

Technical Stack
- Vue.js 3 with Composition API  
- TypeScript 5.x  
- Quasar v2.x  
- Moqui Framework integration


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #19: [BACKEND] [STORY] Order: Cancel Order with Controlled Void Logic
LABELS: payment,type:story,domain:positivity,status:ready-for-dev,agent:story-authoring,agent:workexec,agent:billing,agent:positivity
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:positivity
- status:ready-for-dev

### Recommended
- agent:story-authoring
- agent:positivity
- agent:billing
- agent:workexec

### Blocking / Risk
- none

**Rewrite Variant:** decision-record-applied

## Story Intent
As a **Store Manager**, I need to cancel an order to correct mistakes or respond to customer requests, while ensuring the cancellation respects the current payment and work-in-progress status to prevent financial loss or operational disruption.

## Actors & Stakeholders
- **Primary Actor**: Store Manager (initiates cancellation).
- **Primary Orchestrator (System)**: POS / `domain:positivity` (owns `Order` aggregate and drives orchestration).
- **Billing (`domain:billing`)**: payment state authority; performs void/refund.
- **Work Execution (`domain:workexec`)**: work order state authority; enforces cancellability and performs work-order cancellation.
- **Finance**: requires traceability for void/refund.
- **Operations**: requires deterministic states and failure handling.

## Preconditions
- An `Order` exists with `orderId`.
- Initiating user is authenticated/authorized for cancel.
- Order may be linked to:
  - a payment identifier (`paymentId` / `paymentIntentId` / `chargeId` depending on Billing model)
  - a `workOrderId`
- POS has connectivity to Workexec + Billing synchronous APIs.

## Functional Behavior
### 1) Domain ownership and orchestration (Decision Record)
- **Primary orchestrator**: `domain:positivity` (POS) owns `Order` state and drives the cancellation saga.
- **Workexec** is the sole authority for whether a work order is cancellable and must enforce/reject cancellation.
- **Billing** is the sole authority for payment reversal and must enforce/reject reversal.

### 2) POS cancellation saga (required)
1. Store Manager requests cancel for `orderId` and provides a `cancellationReason`.
2. POS validates permission and creates/derives an **idempotency key** for the cancel attempt.
3. POS loads `Order` and determines whether `workOrderId` and `paymentId` are present.
4. POS sets order to a persisted in-flight state (e.g., `CANCEL_REQUESTED` / `CANCEL_PENDING`) and begins orchestration.

### 3) Workexec gating and cancellation (first, per Decision Record)
- If `workOrderId` exists, POS calls Workexec:
  - **Pre-check (advisory UX)**: `GET /api/v1/work-orders/{workOrderId}` to obtain `status`, `cancellable`, and optional `nonCancellableReason`.
  - **Command (authoritative)**: `POST /api/v1/work-orders/{workOrderId}/cancel` with:
    - `orderId`
    - `requestedBy`
    - `reasonCode`
    - `idempotencyKey`
- If Workexec rejects (e.g., `409 Conflict`), POS stops the saga and the order remains not-cancelled.

### 4) Billing reversal (second, per Decision Record)
- If a payment exists and Workexec cancellation (if applicable) has succeeded, POS calls Billing:
  - `POST /api/v1/payments/{paymentId}/reverse`
  - Request includes `orderId`, `reasonCode`, `currency`, and `idempotencyKey`
  - POS expresses intent `type: VOID|REFUND`, but Billing may decide final based on settlement state.

### 5) Finalization and states
- If all required downstream actions succeed, POS transitions Order to a terminal `CANCELLED` state.
- POS emits canonical events for downstream consumers (audit/reporting).

## Alternate / Error Flows
- **Workexec rejects cancellation (`409`)**: POS transitions to a failure state (e.g., `CANCEL_FAILED_WORKEXEC`) and returns a deterministic user-facing message based on Workexec `nonCancellableReason`.
- **Billing reversal fails**:
  - POS transitions to `CANCEL_FAILED_BILLING` (or `CANCEL_REQUIRES_MANUAL_REVIEW`).
  - POS retries reversal with bounded retry/backoff; provides an admin re-trigger mechanism.
- **Timeouts**:
  - POS treats timeouts as failure for this attempt, persists state, and supports retry (idempotent).
- **Duplicate requests**:
  - POS returns the current cancellation state and does not re-run side effects (idempotency key + persisted saga state).

## Business Rules
- **BR1 (ownership)**: Workexec is authoritative for cancellability and must reject invalid cancellation commands.
- **BR2 (ordering)**: POS cancels work order first, then reverses payment (minimizes revenue-loss risk).
- **BR3 (consistency model)**: No distributed transactions. POS uses an orchestrated saga with persisted state and retry/compensation paths.
- **BR4 (auditable)**: Every cancellation attempt (success/failure) is captured via events/logging with correlation and idempotency identifiers.

## Data Requirements
- **Order** (POS-owned):
  - `orderId`
  - `status` includes in-flight + terminal cancel states (Decision Record examples):
    - `CANCEL_REQUESTED`, `WORKORDER_CANCELLED`, `PAYMENT_REVERSED`, `CANCELLED`
    - `CANCEL_FAILED_WORKEXEC`, `CANCEL_FAILED_BILLING`, `CANCEL_REQUIRES_MANUAL_REVIEW`
  - `cancellationReason` (string)
  - `workOrderId` (nullable)
  - `paymentId` (nullable)
  - `correlationId` (trace)
  - `cancellationIdempotencyKey`

- **Contracts (Decision Record minimums)**
  - Workexec `GET work-order` response includes: `id`, `status`, `cancellable`, optional `nonCancellableReason`, `updatedAt/version`.
  - Workexec `POST cancel` includes: `orderId`, `requestedBy`, `reasonCode`, `idempotencyKey`.
  - Billing `POST reverse` includes: `type` (intent), `amount` (optional), `currency`, `reasonCode`, `orderId`, `idempotencyKey`.

## Acceptance Criteria
- Cancelling an order uses a **POS-orchestrated saga** with a persisted cancellation state machine and idempotency.
- If a `workOrderId` exists:
  - POS calls Workexec cancel first.
  - If Workexec rejects, POS does not attempt payment reversal and returns a deterministic denial message.
- If a payment exists and Workexec cancellation (if applicable) succeeds:
  - POS calls Billing reversal using an idempotency key.
  - POS records success/failure and transitions to the appropriate terminal state.
- Partial failure handling exists:
  - Workexec success + Billing failure results in a persisted failure state and retry/admin re-trigger.
  - Billing success + Workexec failure is prevented by ordering; if detected, POS enters `CANCEL_REQUIRES_MANUAL_REVIEW` and emits an ops-visible alert/event.

## Audit & Observability
- **Tracing**: POS propagates `correlationId` to Workexec and Billing.
- **Logs**: Structured logs include `orderId`, `workOrderId`, `paymentId`, `correlationId`, `idempotencyKey`, and failure category.
- **Metrics** (minimum):
  - `cancellations.success.count`
  - `cancellations.failure.count` tagged by `reason` (`workexec_denial`, `billing_error`, `timeout`, `manual_review`)
- **Events**: POS emits domain events for cancellation progress/final state; Workexec and Billing emit their own lifecycle events.

## Open Questions (if any)
- none (resolved by Decision Record comment)

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #19 ‚Äî [BACKEND] [STORY] Order: Cancel Order with Controlled Void Logic

## Current Labels
- backend
- story-implementation
- payment

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Order: Cancel Order with Controlled Void Logic

**Domain**: payment

### Story Description

/kiro
# User Story

## Narrative
As a **Store Manager**, I want to cancel an order so that mistaken orders can be voided safely.

## Details
- If payment authorized/captured, require appropriate void/refund flow.
- Prevent cancel when work already started unless controlled.

## Acceptance Criteria
- Cancellation enforces policy.
- Proper payment reversal initiated.
- Workexec link handled (cancel link or create adjustment).

## Integrations
- Payment service integration required; workexec notified if linked.

## Data / Entities
- CancellationRecord, PaymentReversalRef, WorkexecLink, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Experience
- domain :  Point of Sale

### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #16: [BACKEND] [STORY] Catalog: View Product Details with Price and Availability Signals
LABELS: type:story,domain:positivity,status:ready-for-dev,agent:story-authoring
BODY:
**Rewrite Variant:** integration-conservative

## Story Intent
**As a** Service Advisor (via client apps),
**I want to** view a product‚Äôs master details plus location-scoped pricing and availability signals in a single API response,
**so that** I can explain options and availability to customers without stitching multiple backend calls.

## Actors & Stakeholders
- **Service Advisor (User):** Consumes product details, prices, and availability signals.
- **POS Backend (This system):** Aggregates data from authoritative services.
- **Product Catalog Service:** System of record for product master data (description/specs/substitution hints) and static lead-time hints.
- **Pricing Service:** System of record for pricing.
- **Inventory/Supply Chain Service:** System of record for on-hand/ATP and best-effort dynamic lead time.

## Preconditions
1. Caller is authenticated and authorized to read product and location data.
2. Request provides a valid `productId` and `locationId`.
3. Downstream service interfaces are reachable under normal conditions.

## Functional Behavior
### Endpoint
- `GET /api/v1/products/{productId}?location_id={locationId}`

### Processing (Happy Path)
1. Validate `productId` and `location_id`.
2. Fetch in parallel (or optimized sequence):
   - Product Catalog: master details, specs, substitution hints, static lead-time hint.
   - Pricing: MSRP + location-scoped store price (and currency).
   - Inventory: on-hand + ATP + best-effort dynamic lead time.
3. Aggregate into a single response with **explicit per-component status metadata**.
4. Return `200 OK`.

## Alternate / Error Flows
- **Product Not Found:** If Product Catalog returns not-found for `productId`, return `404 Not Found` and do not attempt to synthesize product data.
- **Invalid Location:** If `location_id` is invalid, return `400 Bad Request`.
- **Partial Failure (Graceful Degradation for browse/quote flows):**
  - This endpoint is a **browse/quote-building** read endpoint and MUST use **graceful degradation**.
  - If Pricing or Inventory is unavailable, return `200 OK` with:
    - the fields that could be retrieved
    - **status fields** indicating `OK | UNAVAILABLE | STALE`
    - `generatedAt` and `asOf` timestamps so callers can gate downstream actions.
  - Do not silently return `null` without a corresponding status.

## Business Rules
1. **Authority**
   - Product Catalog is authoritative for product master data and substitution hints.
   - Pricing is authoritative for price fields.
   - Inventory/Supply Chain is authoritative for availability fields and dynamic lead-time when available.

2. **Partial Failure Defaults**
   - If Inventory is unavailable: availability MUST be represented as **UNKNOWN** (not ‚Äúin stock‚Äù), using status metadata.
   - If Pricing is unavailable: pricing values MUST be `null` with `pricing.status=UNAVAILABLE`; consumers MUST prevent actions requiring price finalization.

3. **Lead Time Hints (Two-tier model)**
   - Always return catalog static lead-time hints when present.
   - Prefer best-effort dynamic lead time from Inventory/Supply Chain when available; it overrides catalog hint.

4. **Staleness Signaling**
   - Include `pricing.asOf` and `availability.asOf` (when applicable).
   - Include `pricing.status` and `availability.status`.

5. **Caching**
   - Cache read-only responses with short TTLs and staleness metadata.
   - Default aggregated TTL: **15 seconds** (min of dynamic components).
   - Component-level defaults:
     - Pricing TTL: **60 seconds**
     - Inventory availability TTL: **15 seconds**
     - Dynamic lead time TTL: **5 minutes**
     - Catalog static fields TTL: **24 hours** (or version-keyed)
   - If future pricing becomes account-specific, cache keys MUST include the pricing context (e.g., `customerAccountId` / price list identifiers).

## Data Requirements
### Request
- **Path Parameter:** `productId` (UUID)
- **Query Parameter:** `location_id` (UUID)

### Response (200 OK)
`ProductDetailView` JSON object with explicit per-component status metadata:
```json
{
  "productId": "string",
  "description": "string",
  "specifications": [
    { "name": "string", "value": "string" }
  ],
  "generatedAt": "2026-01-12T15:03:11Z",
  "pricing": {
    "status": "OK",
    "asOf": "2026-01-12T15:03:11Z",
    "msrp": "decimal",
    "storePrice": "decimal",
    "currency": "USD"
  },
  "availability": {
    "status": "OK",
    "asOf": "2026-01-12T15:03:11Z",
    "onHandQuantity": 10,
    "availableToPromiseQuantity": 8,
    "leadTime": {
      "source": "CATALOG",
      "minDays": 2,
      "maxDays": 5,
      "asOf": "2026-01-12T15:03:11Z",
      "confidence": "MEDIUM"
    }
  },
  "substitutions": [
    {
      "productId": "string",
      "reason": "string"
    }
  ]
}
```

## Acceptance Criteria
**Scenario 1: Successful Retrieval**
- **Given** `productId` and `locationId` exist
- **And** Product, Pricing, and Inventory are available
- **When** `GET /api/v1/products/{productId}?location_id={locationId}` is called
- **Then** return `200 OK`
- **And** `pricing.status=OK` and `availability.status=OK`
- **And** location-scoped price and availability fields are populated.

**Scenario 2: No Substitutions Configured**
- **Given** product exists and has no substitutions configured
- **When** the endpoint is called
- **Then** return `200 OK`
- **And** `substitutions` is an empty array.

**Scenario 3: Product Does Not Exist**
- **Given** `productId` does not exist in Product Catalog
- **When** the endpoint is called
- **Then** return `404 Not Found`.

**Scenario 4: Inventory Unavailable (Graceful Degradation)**
- **Given** product exists
- **And** Product Catalog and Pricing are available
- **And** Inventory is unavailable
- **When** the endpoint is called
- **Then** return `200 OK`
- **And** master data and pricing are populated
- **And** `availability.status=UNAVAILABLE` (or equivalent) and availability quantities are omitted or null
- **And** availability is represented as UNKNOWN (not in-stock).

**Scenario 5: Pricing Unavailable (Graceful Degradation)**
- **Given** product exists
- **And** Product Catalog and Inventory are available
- **And** Pricing is unavailable
- **When** the endpoint is called
- **Then** return `200 OK`
- **And** `pricing.status=UNAVAILABLE`
- **And** `pricing.msrp`/`pricing.storePrice` are null
- **And** availability signals remain populated.

## Audit & Observability
- Log request start/end including `productId` and `locationId`.
- Emit per-dependency latency metrics (Product, Pricing, Inventory).
- Emit counters for degraded responses (pricing unavailable, inventory unavailable).
- Include `generatedAt` and component `asOf` timestamps in the response.

## Resolved Questions (Decision Record)
Decisions applied from clarification issue #218 (comment: https://github.com/louisburroughs/durion-positivity-backend/issues/218#issuecomment-3738963265):
- Partial failure policy: graceful degradation for browse/quote endpoints with explicit status metadata; fail fast reserved for commit/checkout endpoints.
- Lead time: two-tier (Catalog static baseline + dynamic best-effort override) returned as structured `leadTime` with `source/minDays/maxDays/asOf/confidence`.
- Caching: cache read-only responses with short TTLs (pricing 60s, inventory 15s, lead time 5m, catalog 24h) and staleness metadata; aggregated TTL defaults to 15s.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #16 ‚Äî [BACKEND] [STORY] Catalog: View Product Details with Price and Availability Signals

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Catalog: View Product Details with Price and Availability Signals

**Domain**: user

### Story Description

/kiro
# User Story

## Narrative
As a **Service Advisor**, I want product detail views so that I can explain options and availability to customers.

## Details
- Show description, specs, MSRP, store price, substitutions hints.
- Show on-hand/ATP by location and external lead-time hints (optional).

## Acceptance Criteria
- Detail view loads reliably.
- Price and availability reflect selected location.
- Substitution suggestions available when configured.

## Integrations
- Product/pricing + inventory availability endpoints.

## Data / Entities
- ProductDetailView, AvailabilityView, SubstituteHint

## Classification (confirm labels)
- Type: Story
- Layer: Experience
- domain :  Point of Sale

### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*


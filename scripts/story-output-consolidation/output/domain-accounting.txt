‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #148: [BACKEND] [STORY] Invoicing: Calculate Taxes, Fees, and Totals on Invoice
LABELS: general,type:story,domain:accounting,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Current)
### Required
- type:story
- domain:accounting
- status:ready-for-dev

### Recommended
- agent:accounting
- agent:story-authoring

---
**Rewrite Variant:** accounting-strict
**Clarifications:** Resolved via #299
---

## Story Intent
As the System, I need to accurately calculate all financial totals (subtotal, taxes, fees, and grand total) for a draft invoice based on authoritative tax and fee rules. This ensures that a financially correct, auditable, and compliant invoice is prepared for issuance to the customer.

## Actors & Stakeholders
- **Actors**:
  - `System`: The automated process responsible for performing the calculations.
- **Stakeholders**:
  - `Accountant`: Relies on the accuracy and auditability of financial calculations for reporting and compliance.
  - `Service Advisor`: Needs to review the final, calculated invoice totals with the customer before issuance.
  - `Customer`: Receives the invoice and expects it to be accurate and transparent.
  - `Finance Department`: Uses the aggregated invoice data for financial forecasting and revenue recognition.

## Preconditions
- A draft `Invoice` entity exists in the system.
- The `Invoice` is associated with one or more `InvoiceItem` line entries, each with a defined price and quantity.
- Each `InvoiceItem` is associated with a product or service that has properties (e.g., `taxCode`) determining its taxability.
- An authoritative source for tax and fee rules (e.g., Tax Configuration Service) is available and accessible by the system.
- The original `Estimate` snapshot, associated with the work that generated the invoice, is available for variance comparison.

## Functional Behavior
### Trigger
An `Invoice` is transitioned to the `TotalsCalculationRequired` state. This event is triggered by:
1.  The creation of a new draft `Invoice` with line items.
2.  The addition, modification, or removal of an `InvoiceItem` on an existing draft `Invoice`.

### Process
1.  The System initiates the calculation process for the `Invoice`.
2.  For each `InvoiceItem`, the System resolves the applicable `TaxRule` and `FeeRule` from the authoritative configuration source based on the item's properties (e.g., `taxCode`, `productType`).
3.  The System calculates the `taxAmount` for each line item and any applicable invoice-level taxes.
4.  The System calculates any applicable line-item or invoice-level `feeAmount`.
5.  The System calculates the `InvoiceSubtotal` by summing the `lineTotal` of all `InvoiceItem`s.
6.  The System aggregates all calculated taxes into `TotalTax` and all fees into `TotalFees`.
7.  The System calculates the `GrandTotal` as the sum of `InvoiceSubtotal`, `TotalTax`, `TotalFees`, and any `RoundingAdjustment` required by policy.
8.  The System compares the calculated totals with the corresponding totals in the `EstimateSnapshot`. If a variance exists, a `Variance` record is created, detailing the amount and a system-generated `varianceReasonCode`.
9.  The System persists all calculated values (`Subtotal`, `TotalTax`, `TotalFees`, `GrandTotal`, etc.) on the `Invoice` entity.
10. A `CalculationSnapshot` is created and stored, containing an immutable record of the rules, rates, and values used for this specific calculation, ensuring auditability.
11. Upon successful completion, the `Invoice` state is transitioned to `TotalsCalculated`.

## Alternate / Error Flows
- **Flow: Incomplete Tax Basis**
  - **Trigger**: An `InvoiceItem` is missing required tax basis fields (taxCode, jurisdiction, pointOfSaleLocation, etc.).
  - **Outcome**: The calculation process fails. The `Invoice` state is transitioned to `CalculationFailed`. An error event is logged specifying the invoice and the line item with the missing data. The invoice is blocked from being issued until the data is corrected.

- **Flow: Unavailable Tax Service**
  - **Trigger**: The authoritative tax configuration source is unavailable or returns an error.
  - **Outcome**: The calculation process fails. The `Invoice` state is transitioned to `CalculationFailed`. A system alert is generated. The operation should be designed for graceful retries.

- **Flow: Variance Detected**
  - **Trigger**: The calculated `GrandTotal` differs from the `EstimateSnapshot.grandTotal`.
  - **Outcome**: This is considered a normal flow. The system automatically creates a `Variance` record with a reason code (e.g., `TAX_RULE_CHANGE`, `QUANTITY_CHANGE`). This variance is surfaced to the user for review before the invoice is issued.

## Business Rules
- **Rule-B1 (Authority)**: Tax and fee calculations must exclusively use the system's central Tax Configuration Service as the single source of truth for all rules and rates.
- **Rule-B2 (Immutability)**: Once an `Invoice` is transitioned to an `Issued` state, its calculated totals and the associated `CalculationSnapshot` are immutable and cannot be changed.
- **Rule-B3 (Auditability)**: Every component of the invoice total must be traceable. The `CalculationSnapshot` must provide a clear and complete audit trail from the `GrandTotal` back to the individual line items, tax rules, and rates applied.
- **Rule-B4 (Rounding)**: All monetary calculations use `RoundingMode.HALF_UP` with currency-scale precision (e.g., USD/EUR = 2 decimals). Round per-line, then sum. Persist explicit rounding deltas for audit.
- **Rule-B5 (Issuance Block)**: An invoice cannot be transitioned to the `Issued` state if its status is `CalculationFailed` or if it has unresolved blocking conditions (e.g., missing tax basis).
- **Rule-B6 (Variance Codes)**: System automatically detects and applies canonical variance reason codes. Variances exceeding thresholds require approval with `accounting:invoice:approve-variance` permission.
- **Rule-B7 (Tax Basis Validation)**: Mandatory fields include: `taxCode`, `jurisdiction`, `pointOfSaleLocation`, `productType`. Use fail-fast validation; override only with explicit permission and audit.

## Data Requirements
- **Entity: `Invoice`**
  - `invoiceId` (PK)
  - `status` (Enum: `Draft`, `TotalsCalculationRequired`, `TotalsCalculated`, `CalculationFailed`, `Issued`)
  - `subtotal` (Decimal)
  - `totalTax` (Decimal)
  - `totalFees` (Decimal)
  - `roundingAdjustment` (Decimal)
  - `grandTotal` (Decimal)
  - `estimateSnapshotId` (FK)
  - `invoiceDate` (Timestamp)
  - `jurisdiction` (String)
  - `shipAddressId` (FK)
  - `pointOfSaleLocationId` (FK)
  - `overriddenByUser` (String, nullable)
  - `overrideReason` (String, nullable)
  - `hasOverride` (Boolean, default: false)

- **Entity: `InvoiceItem`**
  - `invoiceItemId` (PK)
  - `taxCode` (String, Not Null)
  - `lineTotal` (Decimal)
  - `taxAmount` (Decimal)
  - `productId` (FK, Not Null)
  - `isExempt` (Boolean, default: false)

- **Entity: `CalculationSnapshot`**
  - `calculationSnapshotId` (PK)
  - `invoiceId` (FK, Unique)
  - `calculatedAt` (Timestamp)
  - `calculationDetails` (JSONB/Text): Immutable record of rules, rates, versions, rounding method, and deltas used in the calculation.

- **Entity: `Variance`**
  - `varianceId` (PK)
  - `invoiceId` (FK)
  - `varianceAmount` (Decimal)
  - `varianceReasonCode` (Enum: `TAX_RULE_CHANGE`, `QUANTITY_CHANGE`, `PRICE_CHANGE`, `DISCOUNT_APPLIED`, `FEE_ADDED`, `ROUNDING_VARIANCE`, `MANUAL_ADJUSTMENT`, `ESTIMATE_OUTDATED`, `CONFIGURATION_ERROR`)
  - `notes` (String)
  - `detectedAt` (Timestamp)
  - `approvedBy` (String, nullable)
  - `approvedAt` (Timestamp, nullable)

## Acceptance Criteria
- **AC1: Correct Totals for Standard Invoice**
  - **Given** a draft invoice with a line item priced at $100 and a quantity of 2.
  - **And** the applicable tax rule is a flat 10%.
  - **When** the system is triggered to calculate totals.
  - **Then** the invoice `subtotal` is $200.00.
  - **And** the `totalTax` is $20.00.
  - **And** the `grandTotal` is $220.00.
  - **And** the invoice status is updated to `TotalsCalculated`.
  - **And** rounding adjustment is $0.00 (exactly 2 decimal places).

- **AC2: Correct Totals for Mixed-Tax Invoice**
  - **Given** a draft invoice with a taxable item at $100 and a non-taxable item at $50.
  - **And** the applicable tax rate for the taxable item is 8%.
  - **When** the system calculates totals.
  - **Then** the invoice `subtotal` is $150.00.
  - **And** the `totalTax` is $8.00.
  - **And** the `grandTotal` is $158.00.
  - **And** no rounding variance exists between line sum and invoice subtotal.

- **AC3: Variance Detection due to Tax Rate Change**
  - **Given** an invoice whose `EstimateSnapshot` was created with a total of $105 based on a 5% tax rate.
  - **And** the current authoritative tax configuration specifies a 7% rate for the invoice items.
  - **When** the system calculates totals for the invoice.
  - **Then** the new `grandTotal` is $107.
  - **And** a `Variance` record is created with `varianceAmount` of $2.00 and `varianceReasonCode` of `TAX_RULE_CHANGE`.
  - **And** variance is audited with detection timestamp and reason.

- **AC4: Block on Incomplete Tax Data**
  - **Given** a draft invoice where a line item is missing its required `taxCode`.
  - **When** the system attempts to calculate totals.
  - **Then** the process fails.
  - **And** the invoice status is updated to `CalculationFailed`.
  - **And** the invoice cannot be transitioned to the `Issued` state.
  - **And** error response includes specific missing fields (taxCode, jurisdiction, pointOfSaleLocation, etc.).

- **AC5: Tax Basis Validation**
  - **Given** a draft invoice missing mandatory tax basis field (jurisdiction or pointOfSaleLocation).
  - **When** validation is performed.
  - **Then** calculation fails with RFC 7807 error listing specific missing fields.
  - **And** invoice remains in `CalculationFailed` state until corrected.

## Audit & Observability
- **Audit Trail**: Every state transition of an `Invoice` (e.g., `Draft` -> `TotalsCalculated`) must be logged as an audit event, including the actor (System), timestamp, and reason. The creation of a `CalculationSnapshot` is a primary audit event.
- **Logging**:
  - INFO: Log the start and successful completion of invoice total calculations, including the `invoiceId`.
  - ERROR: Log failures in detail, including `invoiceId`, error message, and stack trace, especially for failed dependencies like the tax service.
- **Metrics**:
  - `invoice_calculation_success_count`: Counter for successful calculations.
  - `invoice_calculation_failure_count`: Counter for failed calculations, tagged by error type (e.g., `data_missing`, `service_unavailable`).
  - `invoice_calculation_duration_ms`: Histogram of calculation latency.
  - `invoice_variance_detected_count`: Counter for invoices where a variance from the estimate was found, tagged by `varianceReasonCode`.

## Resolved Questions (from #299)
All clarification questions have been resolved:

1. **Rounding Policy**: Currency-scale rounding with HALF_UP; round per-line, then sum; persist rounding deltas.
2. **Tax Authority Source**: Internal Tax Configuration Service with optional third-party integration and fallback policies.
3. **Variance Reason Codes**: Nine canonical codes defined (TAX_RULE_CHANGE, QUANTITY_CHANGE, PRICE_CHANGE, DISCOUNT_APPLIED, FEE_ADDED, ROUNDING_VARIANCE, MANUAL_ADJUSTMENT, ESTIMATE_OUTDATED, CONFIGURATION_ERROR).
4. **Incomplete Tax Basis**: Mandatory fields: taxCode, jurisdiction, pointOfSaleLocation, productType; fail-fast validation; override with permission.

See comment thread for detailed implementation guidance.

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #148 ‚Äî [BACKEND] [STORY] Invoicing: Calculate Taxes, Fees, and Totals on Invoice

## Current Labels
- backend
- story-implementation
- general

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Invoicing: Calculate Taxes, Fees, and Totals on Invoice

**Domain**: general

### Story Description

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
System

## Trigger
Invoice draft is created or invoice lines are adjusted.

## Main Flow
1. System applies tax and fee rules to invoice lines based on snapshot/tax config.
2. System calculates subtotal, taxes, fees, rounding adjustments, and grand total.
3. System compares invoice totals to estimate snapshot totals and records variance reasons where applicable.
4. System updates invoice totals and stores calculation snapshot.
5. System prevents issuing invoice if tax basis is incomplete (policy).

## Alternate / Error Flows
- Tax configuration changed since estimate ‚Üí flag variance and require review.
- Missing tax codes ‚Üí block issuance and show actionable errors.

## Business Rules
- Tax calculation must be explainable and auditable.
- Mixed-tax scenarios must be supported.

## Data Requirements
- Entities: Invoice, InvoiceItem, TaxRule, CalculationSnapshot, EstimateSnapshot
- Fields: taxCode, taxRate, taxAmount, feeTotal, roundingAdjustment, varianceAmount, varianceReason

## Acceptance Criteria
- [ ] Invoice totals compute correctly for mixed-tax scenarios.
- [ ] System records variance vs estimate snapshot when applicable.
- [ ] Invoice cannot be issued when required tax basis is missing.

## Notes for Agents
Variance explanations reduce disputes‚Äîcapture them automatically when possible.


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #146: [BACKEND] [STORY] Invoicing: Support Authorized Invoice Adjustments
LABELS: type:story,domain:accounting,status:ready-for-dev,agent:story-authoring,agent:accounting
BODY:
## Story Intent
**As a** Back Office Manager,
**I want to** apply *authorized* adjustments to a **Draft** invoice (edit line items and/or apply invoice-level discounts),
**so that** I can correct errors or apply goodwill while keeping accounting state correct and fully auditable.

**Rewrite Variant:** integration-conservative

## Actors & Stakeholders
- **Back Office Manager:** Initiates and authorizes adjustments.
- **Accounting Service (`domain:accounting`):** System of record (SoR) for invoice financial state and rules.
- **Workorder Execution (`domain:workexec`):** Produces invoice inputs and may initiate an adjustment request, but does not own financial recalculation rules.
- **Auditor / Compliance:** Needs immutable, explainable history of adjustments.
- **Downstream Accounting/Posting consumers:** Subscribe to `InvoiceAdjusted` / `CreditMemoIssued` events.

## Preconditions
1. An invoice exists and is in status **`Draft`**.
2. The user is authenticated and authorized to perform invoice adjustments (existing permission concept: `invoice.adjust`).
3. Valid `ReasonCode` values for invoice adjustments exist and can be validated as active.

## Functional Behavior
1. **Trigger:** Back Office Manager initiates an adjustment on a **Draft** invoice.
2. **Input:** User submits one or more changes:
   - Line item change(s) (quantity, price, discount)
   - Invoice-level discount
   - Optional `reasonCode` and free-text `justification` (required when configured)
3. **Validation (Accounting-owned):**
   - Validate invoice is still `Draft` at commit time.
   - Validate authorization for invoice adjustment.
   - If configured, require and validate `reasonCode` (active) and require `justification`.
4. **Recalculation (Accounting-owned):**
   - Recalculate subtotal, taxes, and grand total from the adjusted invoice content.
5. **Negative Total Guardrail:**
   - If the recalculated grand total would be **< $0.00**, reject the adjustment as invalid for invoices and require a Credit Memo path (details below).
   - Adjustments may reduce total down to **exactly $0.00**, but **not below**.
6. **Persistence:**
   - Persist invoice changes atomically.
   - Mark invoice as adjusted (e.g., `isAdjusted = true`).
7. **Audit:**
   - Create an immutable audit record capturing actor, timestamp, reason/justification, and before/after financial snapshots (and enough detail to reconstruct what changed).
8. **Integration Events:**
   - Emit `InvoiceAdjusted` when the adjustment is applied directly to a **Draft** invoice and the resulting total is **>= $0.00**.
   - Emit `CreditMemoIssued` when the business action results in creation/issuance of a Credit Memo.

## Alternate / Error Flows
- **Unauthorized adjustment attempt:** Reject with `403 Forbidden`. No invoice mutation, no audit record, no event.
- **Invoice not in Draft:** Reject direct adjustment and require Credit Memo or other formally defined reversal/credit process. Return `409 Conflict` (or `422 Unprocessable Entity`) with a machine-readable error.
- **Adjustment would cause negative invoice total:** Reject with `409 Conflict` or `422 Unprocessable Entity` and error code `INVOICE_TOTAL_NEGATIVE_REQUIRES_CREDIT_MEMO`.
  - Optional (explicit mode): Support a request mode that *splits* into:
    1) adjust invoice down to `$0.00`, and
    2) create a Credit Memo for the remaining absolute value.
- **Missing/invalid reason code when required:** Reject with `400 Bad Request`.
- **Concurrent modification:** Detect via optimistic locking and reject with `409 Conflict`, prompting reload.

## Business Rules
1. **Domain Ownership / SoR:** `domain:accounting` owns invoice financial state and all recalculation/adjustment rules.
2. **Draft-only direct adjustments:** Only `Draft` invoices may be directly adjusted.
3. **Never allow negative invoice totals:** Resulting invoice total must be $\ge 0.00$.
4. **Credit Memo required for over-credit:** If the requested change would push below $0.00$, create a **Credit Memo** instead of allowing a negative invoice.
   - Requires separate authorization (Credit Memo permission concept; exact permission name TBD by Security/Authorization conventions).
5. **Audit is mandatory:** Every successful adjustment produces an immutable audit record.
6. **Idempotency:** Adjustment commands and resulting events must be deduplicated (e.g., idempotency key based on `invoiceId + auditEventId` or `invoiceId + adjustmentId`).

## Data Requirements
| Entity / Event | Field | Type | Notes |
|---|---|---|---|
| `Invoice` | `isAdjusted` | boolean | Defaults `false`; set `true` after first adjustment |
| `InvoiceAuditEvent` | `invoiceId`, `actorId`, `timestamp` | UUID/Timestamp | Immutable record |
| `InvoiceAuditEvent` | `reasonCode`, `justification` | String/Text | Required when configured |
| `InvoiceAuditEvent` | `changeDetails` | JSON | Before/after totals + changed line items summary |
| `InvoiceAdjusted` | `invoiceId`, `adjustmentId` | UUID | `adjustmentId` is idempotency anchor |
| `InvoiceAdjusted` | `previousTotals`, `newTotals` | JSON/structured | Include tax/subtotal/total |
| `CreditMemo` | `creditMemoId`, `sourceInvoiceId` | UUID | Separate accounting document/aggregate |
| `CreditMemoIssued` | `creditMemoId`, `sourceInvoiceId`, `amount` | UUID/Decimal | Emitted when credit memo created/issued |

## Acceptance Criteria
**Scenario 1: Successful Draft Invoice Adjustment (non-negative)**
- Given a `Draft` invoice
- And a Back Office Manager authorized for invoice adjustments
- And the system requires `reasonCode` + `justification`
- When the user applies an adjustment that results in $\text{newTotal} \ge 0.00$
- Then the invoice totals are recalculated correctly (subtotal/tax/total)
- And `isAdjusted = true`
- And an immutable audit record is written with before/after snapshots and reason/justification
- And an `InvoiceAdjusted` event is emitted

**Scenario 2: Unauthorized user attempts adjustment**
- Given a `Draft` invoice
- When a user without invoice adjustment authorization attempts any change
- Then the system returns `403`
- And no data is mutated
- And no audit/event is created

**Scenario 3: Adjustment would cause negative invoice total**
- Given a `Draft` invoice
- When the requested adjustment would make $\text{newTotal} < 0.00$
- Then the system rejects the request with `409` or `422`
- And the response includes error code `INVOICE_TOTAL_NEGATIVE_REQUIRES_CREDIT_MEMO`
- And the invoice remains unchanged

**Scenario 4: Non-Draft invoice cannot be directly adjusted**
- Given an invoice that is not `Draft`
- When a user attempts a direct adjustment
- Then the system rejects the request and instructs to use Credit Memo / reversal process
- And no `InvoiceAdjusted` event is emitted

**Scenario 5: Credit Memo issuance path emits event**
- Given a request that results in a Credit Memo creation/issuance
- When the system issues the Credit Memo
- Then a `CreditMemoIssued` event is emitted containing `creditMemoId`, `sourceInvoiceId` (if applicable), and amount

## Audit & Observability
- **Audit log:** `InvoiceAuditEvent` is immutable and contains sufficient detail to explain changes (before/after + actor + reason).
- **Application logs:**
  - `INFO` on success (`invoiceId`, `actorId`, `adjustmentId`)
  - `WARN` on business-rule rejects (negative total, missing reason code, not-draft)
  - `ERROR` on unauthorized attempts

## Resolved Decisions (from issue comments)
These decisions were applied from the resolution comment posted on 2026-01-14 ("Answers to Open Questions", generated by `clarification-resolver.sh`):
1. **Domain ownership:** `domain:accounting` is SoR for invoice financial state.
2. **Negative totals:** never allow negative invoice totals; use Credit Memo instead.
3. **Events:** `InvoiceAdjusted` for direct non-negative Draft adjustments; `CreditMemoIssued` whenever a Credit Memo is created/issued; implies a first-class `CreditMemo` entity/document.

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #146 ‚Äî [BACKEND] [STORY] Invoicing: Support Authorized Invoice Adjustments

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Invoicing: Support Authorized Invoice Adjustments

**Domain**: user

### Story Description

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24300028/Durion_Accounting_Event_Contract_v1.pdf)

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
Back Office Manager

## Trigger
A Draft invoice requires an adjustment (goodwill discount, correction).

## Main Flow
1. Authorized user edits invoice line items or applies a discount.
2. System requires a reason code and free-text justification if configured.
3. System recalculates taxes and totals.
4. System records adjustment audit event including before/after values.
5. System flags invoice as adjusted for reporting.

## Alternate / Error Flows
- Unauthorized user attempts adjustment ‚Üí block.
- Adjustment would cause negative totals ‚Üí block or require special permission.

## Business Rules
- Adjustments require permissions and audit trail.
- Adjustments must not break traceability; they must be explainable.

## Data Requirements
- Entities: Invoice, InvoiceItem, AuditEvent, ReasonCode
- Fields: adjustmentType, reasonCode, justification, beforeTotal, afterTotal, adjustedBy, adjustedAt

## Acceptance Criteria
- [ ] Only authorized roles can adjust invoices.
- [ ] Adjustments require reason codes and are auditable.
- [ ] Totals are recalculated correctly after adjustments.
- [ ] Invoice adjustments emit a corresponding accounting event
- [ ] Revenue, tax, and AR are adjusted correctly
- [ ] Adjustments reference the original invoice
- [ ] Authorization and reason code are required
- [ ] Multiple adjustments do not corrupt invoice totals

## Integrations

### Accounting
- Emits Event: InvoiceAdjusted or CreditMemoIssued
- Event Type: Posting (reversal / amendment)
- Source Domain: workexec
- Source Entity: Invoice
- Trigger: Authorized adjustment or credit issuance
- Idempotency Key: invoiceId + adjustmentVersion


## Notes for Agents
Keep adjustments rare and transparent; otherwise you erode trust in the system.


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #145: [BACKEND] [STORY] Invoicing: Finalize and Issue Invoice
LABELS: type:story,domain:accounting,domain:billing,status:ready-for-dev,agent:story-authoring,agent:accounting,agent:billing,risk:financial-integrity
BODY:
## Story Intent
**As an** Accounts Receivable Clerk,
**I want to** finalize and issue a draft invoice,
**so that** it becomes a locked, official billing record and downstream accounting can create AR and post appropriately.

**Rewrite Variant:** integration-conservative

## Actors & Stakeholders
- **Accounts Receivable Clerk:** Initiates issuance.
- **Billing Service (`domain:billing`):** System of record (SoR) for the `Invoice` entity and its lifecycle/state machine.
- **Accounting Service (`domain:accounting`):** Creates Accounts Receivable asynchronously upon `InvoiceIssued`.
- **Customer:** Receives the final invoice.
- **Auditor / Compliance:** Requires immutable history and non-repudiation.

## Preconditions
1. An `Invoice` exists in state `Draft`.
2. The invoice is associated with a valid `Customer` with required billing/delivery attributes.
3. The invoice contains one or more `InvoiceLine` items.
4. Upstream source domains (e.g., `workexec`) have completed billable work and have produced inputs needed for a draft invoice.
5. The initiating principal is authorized to issue invoices (existing permission concept: `invoice:issue`).

## Functional Behavior
### Happy Path: Successful Invoice Issuance
1. **Trigger:** Accounts Receivable Clerk initiates ‚ÄúIssue Invoice‚Äù for a `Draft` invoice.
2. **Validation (Billing-owned):** Validate all issuance rules (see Business Rules), including customer data completeness and invoice total consistency.
3. **Finalization + State Transition (Billing-owned, single transaction):**
   - Assign an `invoiceNumber` if not present (unique; sequential behavior is policy-driven).
   - Set `issuedAt` to server time and capture `issuedBy`.
   - Transition invoice state to `Issued`.
   - Enforce immutability: once `Issued`, invoice header/lines/totals cannot be edited.
4. **Event Emission (Billing-owned):** Publish `InvoiceIssued` reliably after commit (e.g., outbox pattern).
   - `InvoiceIssued.sourceDomain` is `"billing"`.
5. **Delivery:** Queue the finalized invoice document for delivery according to the customer‚Äôs `DeliveryPreference` (email/print).

## Alternate / Error Flows
- **Validation failure:** Reject issuance, keep invoice in `Draft`, and return actionable errors detailing what must be corrected.
- **Invalid state (duplicate issuance attempt):** If invoice is not `Draft` (e.g., `Issued`, `Paid`, `Void`), reject with `409 Conflict`.
- **Downstream unavailability:** Billing issuance succeeds even if the event bus is temporarily unavailable; `InvoiceIssued` is queued for later delivery.

## Business Rules
1. **Domain Ownership / SoR:** `domain:billing` owns the `Invoice` entity and its lifecycle/state transitions.
2. **Workexec contract:** `workexec` signals ‚Äúready for invoicing‚Äù / eligibility and does not directly issue invoices.
   - If `workexec` needs to initiate issuance, it calls a Billing command/API rather than mutating invoice state.
3. **Allowed transition:** `Draft` ‚Üí `Issued` only.
4. **Immutability:** Once `Issued`, the invoice is an immutable financial/billing record; corrections occur via out-of-scope credit/rebill processes.
5. **Issuance validations (must pass before issuing):**
   - Customer has `billingAddress`.
   - If delivery is Email, `emailAddress` is present and valid.
   - Totals are internally consistent: header total equals the sum of lines/taxes/discounts per system calculation rules.
   - Each line has quantity > 0 and non-negative unit price.
   - Tax calculations are finalized per applicable tax rules.

## Data Requirements
| Entity / Event | Field | Type | Notes |
|---|---|---|---|
| `Invoice` | `status` | Enum/String | `Draft` ‚Üí `Issued` |
| `Invoice` | `invoiceNumber` | String | Unique business key |
| `Invoice` | `issuedAt` | Timestamp | Set on issue |
| `Invoice` | `issuedBy` | String/UUID | Principal ID |
| `InvoiceIssued` | `eventId`, `eventTimestamp` | UUID/ISO8601 | Unique + timestamp |
| `InvoiceIssued` | `sourceDomain` | String | Must be `"billing"` |
| `InvoiceIssued` | `idempotencyKey` | String | `invoiceId:invoiceVersion` (or equivalent) |
| `InvoiceIssued` | `payload` | JSON | Full invoice snapshot (header, customer, totals, taxes, lines) |
| `AccountsReceivable` | created by accounting | ‚Äî | Created asynchronously by `domain:accounting` on `InvoiceIssued` |

## Acceptance Criteria
**Scenario 1: Successful invoice issuance**
- Given an invoice in `Draft` with all required data
- When the user issues the invoice
- Then invoice state becomes `Issued`
- And `invoiceNumber`, `issuedAt`, and `issuedBy` are set
- And the invoice becomes immutable
- And `InvoiceIssued` is published exactly once (idempotent)

**Scenario 2: Missing billing address blocks issuance**
- Given a `Draft` invoice where the customer has no billing address
- When the user attempts to issue
- Then the operation fails with actionable validation errors
- And the invoice remains `Draft`
- And no `InvoiceIssued` event is emitted

**Scenario 3: Re-issuing an already issued invoice is rejected**
- Given an invoice in `Issued`
- When issuance is attempted again
- Then the system returns `409 Conflict`
- And no duplicate `InvoiceIssued` event is emitted

**Scenario 4: Accounting creates AR asynchronously from InvoiceIssued**
- Given billing emits `InvoiceIssued`
- When accounting consumes the event
- Then accounting creates an `AccountsReceivable` entry idempotently (no duplicates on replay)

## Audit & Observability
- **Audit log:** Immutable audit entry on successful issuance capturing `invoiceId`, `invoiceNumber`, `issuedBy`, `issuedAt`, and key totals.
- **Metrics:**
  - `invoices_issued_total`
  - `invoice_issuance_failures_total{reason=...}`
  - `invoice_issuance_duration_seconds`
- **Logging:** Structured logs with `invoiceId` and `correlationId` for start/end/failure.

## Resolved Decisions (from issue comments)
These decisions were applied from the resolution comment posted on 2026-01-14 ("Decision Record ‚Äî Issue #145", generated by `clarification-resolver.sh`):
1. **SoR:** `domain:billing` owns `Invoice` and its lifecycle.
2. **Workexec contract:** `workexec` signals readiness only; `billing` performs `Draft ‚Üí Issued`.
3. **Event authority:** `InvoiceIssued.sourceDomain` must be `"billing"`.
4. **AR creation:** handled asynchronously in `domain:accounting` by consuming `InvoiceIssued` (idempotent).

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #145 ‚Äî [BACKEND] [STORY] Invoicing: Finalize and Issue Invoice

## Current Labels
- backend
- story-implementation
- payment

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Invoicing: Finalize and Issue Invoice

**Domain**: payment

### Story Description

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24300023/Durion_Accounting_Event_Contract_v1.pdf)

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
Back Office / Accounts Receivable Clerk

## Trigger
Draft invoice is reviewed and ready to be issued.

## Main Flow
1. User reviews invoice totals and traceability links.
2. User selects 'Issue Invoice'.
3. System validates invoice completeness (customer details, taxes, totals, traceability).
4. System transitions invoice to Issued/Posted state per workflow.
5. System locks invoice lines and records issuance audit event; prepares delivery (email/print) per preference.

## Alternate / Error Flows
- Validation fails (missing billing info) ‚Üí block issuance and show actionable errors.
- Invoice already issued ‚Üí prevent duplicate issuance.

## Business Rules
- Issuance is a state transition with validations and locking.
- Issued invoice should be immutable except via credit/rebill (out of scope).

 ## Data Requirements
  - Entities: Invoice, Customer, AuditEvent, DeliveryPreference
  - Fields: status, issuedAt, issuedBy, deliveryMethod, emailAddress, billingAddress

## Acceptance Criteria
- [ ] Invoice can be issued only when validations pass.
- [ ] Issued invoice is locked against edits.
- [ ] Issuance is auditable and invoice is prepared for delivery.
- [ ] InvoiceIssued event is emitted exactly once per invoice version
- [ ] Event includes full line-item, tax, and total breakdown
- [ ] Accounts Receivable is created correctly
- [ ] Revenue and tax liabilities post accurately
- [ ] Duplicate or replayed events do not double-post

## Integrations

### Accounting
- Emits Event: InvoiceIssued
- Event Type: Posting
- Source Domain: workexec
- Source Entity: Invoice
- Trigger: Invoice finalized and issued
- Idempotency Key: invoiceId + invoiceVersion


## Notes for Agents
Issuance ends quote-to-cash; protect the integrity and lock the record.


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #144: [BACKEND] [STORY] Events: Define Canonical Accounting Event Envelope
LABELS: order,type:story,domain:accounting,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Current)
### Required
- type:story
- domain:accounting
- status:ready-for-dev

### Recommended
- agent:accounting
- agent:story-authoring

---
**Rewrite Variant:** integration-conservative
**Conflict Resolution:** Resolved - domain:accounting confirmed as primary owner
---

## Story Intent
As a Domain Architect, I want to define and establish a standardized, versioned, and robust data contract for all accounting-related events generated across the system. This "Canonical Accounting Event Envelope" will ensure that financial data is communicated consistently and reliably between all producer modules (like Orders, Billing, Inventory) and the consumer module (Accounting), enabling accurate financial reporting and auditable traceability.

## Actors & Stakeholders
- **System (Event Producer):** Any microservice that generates a financial transaction (e.g., Order Service, Billing Service, Inventory Service). Producers are responsible for populating and publishing events that conform to this contract.
- **System (Event Consumer):** The Accounting Service, which is the authoritative system for financial data. It ingests events conforming to this contract to maintain the general ledger and other financial records.
- **Stakeholder (Accounting Team):** Defines the business requirements for financial data accuracy, completeness, and structure.
- **Stakeholder (Development Teams):** Engineering teams responsible for implementing event production in various microservices. They require a clear, stable, and accessible contract to adhere to.

## Preconditions
- A message bus or event streaming platform (e.g., Kafka, RabbitMQ) is established for inter-service communication.
- Core business entity concepts like `BusinessUnit` and `Currency` (with ISO 4217 codes) are defined and accessible system-wide.
- A decision has been made on where and how schemas will be published and managed (e.g., a schema registry, a shared code library).

## Functional Behavior
The core deliverable of this story is the formal definition of a data contract, not a runtime feature.

1.  **Schema Definition:** A formal, machine-readable schema for the `CanonicalAccountingEvent` will be created. This schema will serve as the single source of truth for the structure of all financial events.
2.  **Schema Publication:** The defined schema will be published to a shared, versioned Git repository (e.g., `durion-accounting-schemas`) under `/schemas/accounting/event-envelope/v{N}/` using JSON Schema (Draft 2020-12).
3.  **Schema Versioning:** The schema will be versioned using Semantic Versioning (SemVer, e.g., `1.0.0`). This allows the contract to evolve over time while providing backward-compatibility guarantees and a clear migration path.
4.  **Schema Governance:** Changes to schemas require PR review with mandatory accounting-domain approval to ensure financial semantics and audit requirements are maintained.

## Alternate / Error Flows
- **Schema Evolution:** Future changes to the schema must follow a managed process. Non-breaking changes (e.g., adding optional fields) can be introduced in minor versions. Breaking changes (e.g., removing fields, changing data types) require a major version increment and a coordinated upgrade plan for all producers and consumers.

## Business Rules
- **Rule-B1 (Authority):** The `domain:accounting` is the authoritative owner and arbiter of this canonical event contract. Other domains (order, billing, workexec) are producers that must conform.
- **Rule-B2 (Conformance):** All events with financial implications MUST conform to the published `CanonicalAccountingEvent` schema.
- **Rule-B3 (Uniqueness):** The `eventId` MUST be a globally unique identifier (e.g., UUID v4) for each event instance.
- **Rule-B4 (Timestamp Authority):** The `occurredAt` timestamp MUST be in UTC (ISO 8601 format) and represent the precise time the business event took place.
- **Rule-B5 (Traceability):** The combination of `sourceModule` and `sourceEntityRef` MUST provide an unambiguous, traceable link back to the originating entity.
- **Rule-B6 (Monetary Precision):** All monetary values MUST be represented in the smallest currency unit (e.g., cents) as integers to prevent floating-point precision errors.
- **Rule-B7 (Financial Breakdown):** The `lines` and `tax` arrays must accurately reflect the financial breakdown of the transaction. Negative values in `lines` should be used for discounts or returns.
- **Rule-B8 (Schema Publication):** Schemas stored in dedicated Git repository with versioned paths; changes via PR with accounting domain review.

## Data Requirements
The `CanonicalAccountingEvent` envelope shall contain the following fields:

| Field Name            | Data Type               | Description                                                                                             | Example                                     |
| --------------------- | ----------------------- | ------------------------------------------------------------------------------------------------------- | ------------------------------------------- |
| `eventId`             | UUID                    | Unique identifier for this specific event instance.                                                     | `"a1b2c3d4-..."`                            |
| `eventType`           | String (Enum)           | The specific business event that occurred.                                                              | `"INVOICE_FINALIZED"`                       |
| `schemaVersion`       | String (SemVer)         | The version of the event schema being used.                                                             | `"1.0.0"`                                   |
| `sourceModule`        | String (Enum)           | The originating microservice or domain.                                                                 | `"BILLING_SERVICE"`                         |
| `sourceEntityRef`     | String                  | The unique ID of the primary entity in the source module.                                               | `"inv-98765"`                               |
| `occurredAt`          | Timestamp (ISO 8601)    | The UTC timestamp when the business event happened.                                                     | `"2023-10-27T10:00:00Z"`                    |
| `businessUnitId`      | UUID                    | The identifier for the business unit or location associated with the event.                             | `"f5e4d3c2-..."`                            |
| `currencyUomId`       | String (ISO 4217)       | The three-letter currency code.                                                                         | `"USD"`                                     |
| `lines`               | Array[LineItem]         | An array of objects detailing the financial components of the event.                                    | `[{...}]`                                   |
| `tax`                 | Array[TaxItem]          | An array of objects detailing the tax components.                                                       | `[{...}]`                                   |
| `traceabilityContext` | Object                  | Optional key-value pairs for cross-domain entity references.                                            | `{"workOrderId": "wo-123", "poId": "po-456"}` |
| `metadata`            | Object                  | Optional key-value pairs for additional, non-essential context.                                         | `{"triggeringUserId": "u-abc"}`             |

**LineItem Object Structure:**
- `lineType`: Enum (`PARTS`, `LABOR`, `FEES`, `DISCOUNT`)
- `description`: String
- `quantity`: Decimal
- `unitPrice`: Integer (in cents)
- `totalAmount`: Integer (in cents)

**TaxItem Object Structure:**
- `taxType`: String (e.g., `STATE_TAX`, `FEDERAL_TAX`)
- `taxRate`: Decimal (e.g., `0.0825`)
- `taxableAmount`: Integer (in cents)
- `taxAmount`: Integer (in cents)

## Acceptance Criteria
- **AC1: Correct Schema Structure**
  - **Given** the `CanonicalAccountingEvent` schema definition is finalized
  - **When** a developer or service inspects the contract in the Git repository
  - **Then** the schema MUST contain all the fields specified in the Data Requirements section with their correct data types and constraints.

- **AC2: Schema Versioning Compliance**
  - **Given** the `CanonicalAccountingEvent` schema is published
  - **When** the `schemaVersion` field is inspected
  - **Then** its value MUST conform to the Semantic Versioning format (e.g., "1.0.0", "1.1.0").

- **AC3: Support for Complex Transactions**
  - **Given** a transaction involving parts, labor, a fee, and a discount
  - **When** an event is constructed for this transaction
  - **Then** the `lines` array MUST contain four separate `LineItem` objects, one for each component, with the discount represented by a negative `totalAmount`.

- **AC4: Full Traceability**
  - **Given** an invoice is generated from a work order
  - **When** the `INVOICE_FINALIZED` event is created
  - **Then** the `traceabilityContext` object MUST contain both the `invoiceId` and the originating `workOrderId` to ensure a complete audit trail.

- **AC5: Schema Publication and Governance**
  - **Given** a schema change is proposed
  - **When** a PR is submitted to the `durion-accounting-schemas` repository
  - **Then** it MUST receive approval from the accounting domain reviewer before merge.

## Audit & Observability
- **Schema Lifecycle Audit:** Any creation or update to the schema version in the Git repository MUST be an auditable event (via Git commit history), logging who made the change and when.
- **Contract Accessibility:** The schema definition MUST be easily discoverable and accessible to all development teams via the shared Git repository.
- **Consumer Logging:** Event consumers (especially the Accounting Service) SHOULD log the `eventType` and `schemaVersion` of every event they process to aid in debugging and monitoring.
- **Validation Tracking:** Producers should validate at build-time (CI) and/or runtime; validation failures should be logged with event details.

## Resolved Questions

### Domain Ownership (Resolved)
**Decision:** `domain:accounting` is confirmed as the primary owner of the canonical accounting event contract.

**Rationale:**
- The canonical event envelope defines financial semantics, invariants, and audit requirements
- Accounting is the authoritative consumer and arbiter of financial data structures
- Other domains (order, billing, workexec) are producers that conform to the accounting-owned contract

### Schema Registry/Publication Strategy (Resolved)
**Decision:** Use a shared, versioned Git repository with JSON Schema as the source of truth (v1).

**Implementation Details:**
- **Repository:** Dedicated repo (e.g., `durion-accounting-schemas`)
- **Format:** JSON Schema (Draft 2020-12)
- **Versioning:** SemVer at schema level (`v1`, `v1.1`, `v2`)
- **Storage Path:** `/schemas/accounting/event-envelope/v{N}/`
- **Governance:** Changes via PR with mandatory accounting-domain review
- **Consumption:** Producers validate at build-time (CI) and/or runtime

**Future Option:** Confluent Schema Registry may be adopted later if Kafka becomes mandated transport. Migration is straightforward with curated JSON Schema versions.

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #144 ‚Äî [BACKEND] [STORY] Events: Define Canonical Accounting Event Envelope

## Current Labels
- backend
- story-implementation
- order

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Events: Define Canonical Accounting Event Envelope

**Domain**: order

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Ingest Accounting Events (Cross-Module)

## Story
Events: Define Canonical Accounting Event Envelope

## Acceptance Criteria
- [ ] Event envelope includes eventId, eventType, sourceModule, sourceEntityRef, occurredAt, businessUnitId, currencyUomId, lines[], tax[], metadata, schemaVersion
- [ ] Supports multi-line totals (parts/labor/fees/discount/tax)
- [ ] Schema is versioned and published as a contract
- [ ] Traceability fields exist (workorderId, invoiceId, poId, receiptId, etc. where applicable)


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #143: [BACKEND] [STORY] Events: Receive Events via Queue and/or Service Endpoint
LABELS: type:story,domain:accounting,status:ready-for-dev
BODY:
**Rewrite Variant:** events-ingestion-contract
**Status:** Ready-for-dev (clarification #400 applied)

## Story Intent
As the **Accounting Ingestion Service**, I want to provide reliable synchronous (API) and asynchronous (broker) ingestion endpoints for producing modules to submit accounting-relevant events, so that all financial data is captured immutably and traceably in a single, authoritative location for subsequent processing and auditing.

## Actors & Stakeholders
- **Accounting Ingestion Service**: Receives events, validates contract + auth, persists immutably.
- **Producing Modules (service principals)**: Publish accounting events (e.g., Sales, Inventory, Billing).
- **Accounting Ops / Finance**: Investigate ingestion conflicts and audit events.
- **Platform Engineering / SRE**: Operate brokers, DLQs, and alerts.

## Preconditions
1. Raw event storage schema is provisioned.
2. Broker infrastructure is provisioned and accessible.
3. Service-to-service authentication is configured for sync endpoint.

## Functional Behavior
### 1) Canonical event contract (independent of transport)
- The ingestion contract is **transport-independent** (applies to REST and broker ingestion).
- Transport adapters vary by broker; the envelope and validation rules do not.

### 2) Broker stance
- **Multi-broker pluggable** ingestion.
- Default/reference transport in this repo: **Kafka** (topic-based).
- **SQS supported** as an alternative transport adapter.

### 3) Canonical envelope (Option B) ‚Äî resolved by clarification #400
Required fields:
- `specVersion` (required) e.g. `"durion.accounting.ingestion.v1"`
- `eventId` (required, UUIDv7)
- `eventType` (required, enumerated string)
- `sourceModule` (required, canonical producer/module identifier)
- `eventTimestamp` (required; when business event occurred)
- `schemaVersion` (required; payload schema version for this eventType)
- `payload` (required; domain payload only)

Optional fields:
- `correlationId` (optional; recommended; required only if producer already has one)

Notes:
- Broker/transport receipt metadata (topic, partition, offset, deliveryAttempt, receivedAt, etc.) is **receipt metadata** and is not part of the envelope.

### 4) Event ID authority
- **Producer generates `eventId`**.
- Requirements:
  - `eventId` MUST be UUIDv7
  - `eventId` MUST be globally unique per producer
- Exception (sync REST only): if a producer cannot generate UUIDv7, it may call the sync REST endpoint without `eventId` and the ingestion service may generate one for that sync path only.

### 5) Idempotency + duplicate handling
- Idempotency key: **`eventId`**.
- Conflict detection: compute a payload hash and compare.

Rules:
- **Replay** = same `eventId` + same payload hash ‚Üí idempotent success.
- **Conflict** = same `eventId` + different payload hash ‚Üí reject + flag for investigation.

Sync HTTP behavior:
- New event accepted ‚Üí `202 Accepted` with acknowledgement including at least `eventId`, `status`, `receivedAt`.
- Replay ‚Üí `200 OK` returning the original acknowledgement.
- Conflict ‚Üí `409 Conflict` with stable error code `INGESTION_DUPLICATE_CONFLICT`.

Queue/broker behavior:
- Replay ‚Üí ACK/commit and emit replay metric.
- Conflict ‚Üí ACK/commit **after** recording conflict + alerting (aligns with #142 conflict handling stance).

### 6) Auth contract
- Required scope: `SCOPE_accounting:events:ingest`
- Producer identity binding:
  - `sourceModule` MUST match the authenticated service principal mapping (`client_id` ‚Üí module name).
  - If mismatched: `403 Forbidden` with error code `INGESTION_FORBIDDEN_SOURCE_MISMATCH`.

## Alternate / Error Flows
- **Validation failure** (missing/invalid envelope fields): `400` `INGESTION_VALIDATION_FAILED`.
- **Unsupported schema** (unknown `schemaVersion` for `eventType`): `422` `INGESTION_SCHEMA_UNSUPPORTED`.
- **Dependency failure** (storage unavailable): `503` `INGESTION_DEPENDENCY_FAILURE`.

## Business Rules
- Envelope is canonical and transport-independent.
- Idempotency uses `eventId` only (not `(sourceModule,eventId)`), while auth enforces producer identity.

## Data Requirements
- Store raw envelope + receipt metadata immutably.
- Persist an acknowledgement/receipt record addressable by `eventId` to support `200` replay responses.

## Acceptance Criteria
- Sync API exists and accepts valid envelopes, returning `202` with acknowledgement.
- Broker consumer exists (Kafka default) and persists events before ACK/commit.
- Replays do not create duplicates and are treated as success.
- Conflicts are rejected/flagged and do not create poison-message hot loops.
- Auth enforces `SCOPE_accounting:events:ingest` and `sourceModule` matches authenticated principal mapping.

## Audit & Observability
- Metrics tagged by outcome:
  - accepted/new
  - replay (`INGESTION_DUPLICATE_REPLAY` as status)
  - conflict (`INGESTION_DUPLICATE_CONFLICT`)
  - validation/schema/dependency failures
- Logs include `eventId`, `eventType`, `sourceModule`, `correlationId` (if present).

## Resolved Questions
From clarification #400:
- Broker: multi-broker pluggable; Kafka default; SQS adapter supported.
- Event ID: producer-generated UUIDv7 (sync exception allowed only if producer cannot generate).
- Envelope: Option B canonical fields + receipt metadata excluded.
- Idempotency: `eventId` key + payload-hash conflict detection; explicit HTTP + queue semantics.
- Auth: required scope + `sourceModule` must match authenticated principal mapping.
- Stable error taxonomy adopted.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #143 ‚Äî [BACKEND] [STORY] Events: Receive Events via Queue and/or Service Endpoint

## Current Labels
- backend
- story-implementation
- general

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Events: Receive Events via Queue and/or Service Endpoint

**Domain**: general

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Ingest Accounting Events (Cross-Module)

## Story
Events: Receive Events via Queue and/or Service Endpoint

## Acceptance Criteria
- [ ] Provide a synchronous ingestion API endpoint for producing modules
- [ ] Provide an async ingestion channel (queue/topic) where configured
- [ ] Received events are persisted immutably before mapping/posting
- [ ] System returns acknowledgement with eventId and initial status


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #142: [BACKEND] [STORY] Events: Implement Idempotency and Deduplication
LABELS: general,type:story,domain:accounting,status:ready-for-dev
BODY:
**Rewrite Variant:** events-idempotency-audit
**Status:** Ready-for-dev (clarification #401 applied)

## Story Intent
As a **System Auditor**, I want the Accounting Event Ingestion service to be idempotent, so that events replayed due to network/client/broker redelivery do not create duplicate financial entries in the General Ledger (GL), ensuring data integrity and auditability.

## Actors & Stakeholders
- **Event Ingestion Service**: Receives accounting events, enforces idempotency/dedup, and triggers GL-impacting postings.
- **Source Systems / Producers**: Internal or external systems that generate accounting-relevant events.
- **Finance / Accounting Ops**: Own exception handling for idempotency conflicts and audit investigations.
- **System Auditors**: Verify integrity of financial transaction processing.
- **SRE / Support**: Assist in operational triage (DLQ, alerts, infra).

## Preconditions
- Event ingestion endpoint(s) exist and are secured.
- An idempotency store exists (primary DB table + archival storage tier).
- Source systems generate a unique `eventId` for each distinct business event.

## Functional Behavior
1) **Event ingestion + idempotency lookup**
- Service receives an accounting event with an `eventId` (idempotency key) and a domain payload.
- Service computes a canonical domain-payload hash (see Business Rules) and checks the idempotency store.

2) **New event processing (happy path)**
- If no record exists for `eventId`, create an idempotency record with status `PROCESSING`.
- Process the event and perform GL-impacting actions.
- On success: update idempotency record to `COMPLETED` and store response/GL reference.
- Return success (e.g., `201 Created` for HTTP ingestion, or commit offset/ack for broker ingestion).

3) **Replay (idempotent success)**
- If record exists for `eventId` with status `COMPLETED` and hashes match, do not re-process.
- Return the stored response (HTTP `200 OK`), or ack/commit in broker ingestion.

4) **Retry after failure**
- If record exists with status `FAILED` and hashes match, retry processing per the service‚Äôs retry policy.

5) **Conflicting duplicate (same `eventId`, different business facts)**
- If record exists for `eventId` but the incoming hash differs, treat as a high-severity **integrity incident**.
- Service must:
  1. Persist a conflict record (table-backed exceptions queue)
  2. Publish a conflict message to DLQ
  3. Emit CRITICAL alert/metric
  4. ACK/commit the original message/request to avoid poison-message hot loops

## Alternate / Error Flows
- **Concurrent first-write race**: If two requests arrive simultaneously, DB uniqueness on `eventId` prevents duplicate idempotency records; the loser re-reads the winning record and follows replay/processing behavior.
- **Conflict detected**: Return `409 Conflict` for HTTP ingestion; for broker ingestion, publish to DLQ + ack/commit (no re-drive loop).
- **Archival unavailable**: Do not fail ingestion solely due to archival/tiering outage; continue writing to hot store and emit a warning/metric (archival is eventual). (Retention still must be met once storage recovers.)

## Business Rules
### BR1: Idempotency key
- `eventId` is the sole idempotency key.

### BR2: Conflict handling (authoritative, from clarification #401)
- **DLQ is required** for conflicting duplicates.
- After persisting conflict + publishing to DLQ + emitting CRITICAL alert/metric, the consumer **ACKs/commits** the original message/request.
- Conflict resolution is an **Accounting Ops** workflow (exceptions queue), not an automated overwrite.

Conflict record state machine:
- `OPEN` ‚Üí `TRIAGED` ‚Üí terminal:
  - `RESOLVED_ACCEPT_ORIGINAL`
  - `RESOLVED_ACCEPT_NEW` (only via compensating/reversal accounting events; never overwrite original)
  - `RESOLVED_INVALID_PRODUCER`

### BR3: Payload hashing scope (authoritative, from clarification #401)
- Hash **domain payload only** (business event content), not transport/broker envelope.
- Canonicalization: canonical JSON normalization (sorted keys, stable number/string formatting, no whitespace).
- Exclude from hash only transport/observability volatility (explicit examples):
  - `correlationId`, `traceId`, `spanId`, `receivedAt`, `deliveryAttempt`, `retryCount`, `partition`, `offset`, `brokerMessageId`, `producerSendAt`
  - `meta.*` blocks explicitly documented as non-semantic observability metadata
- Include in hash: `eventType` and all business-relevant fields, including business timestamps that affect accounting semantics (e.g., `eventOccurredAt`, `postingDate`, `effectiveDate`).

### BR4: Retention (authoritative, from clarification #401)
- **GL-impacting idempotency records** retained for **‚â• 7 years** (configurable higher; must not be set lower).
- **Conflict records** retained for **‚â• 7 years**.
- Tiering default: keep **hot** in primary DB for **400 days**, then archive to cold storage until retention expiry.
- Deletion only after retention expiry; deletion must be logged/audited.

## Data Requirements
### Incoming Event (minimum)
- `eventId`: UUID (required)
- `eventType`: string (required)
- `payload`: JSON (required; domain payload)
- Optional transport metadata (excluded from hash as above)

### Idempotency store (hot tier)
- `eventId` (PK)
- `domainPayloadHash` (SHA-256 hex)
- `status` (`PROCESSING`, `COMPLETED`, `FAILED`)
- `responsePayload` (JSON)
- `glPostingReference` (string)
- `firstSeenAt`, `lastSeenAt`
- `archivedAt` (nullable)

### Conflict store (exceptions queue)
- `conflictId` (PK)
- `eventId`
- `originalDomainPayloadHash`
- `conflictingDomainPayloadHash`
- `conflictState` (`OPEN`, `TRIAGED`, `RESOLVED_ACCEPT_ORIGINAL`, `RESOLVED_ACCEPT_NEW`, `RESOLVED_INVALID_PRODUCER`)
- `flaggedAt`, `flaggedBy`
- `resolutionNotes` (nullable)
- `dlqMessageRef` (nullable)

### DLQ message
- Contains original event + conflict metadata + a link/reference to `conflictId`.

## Acceptance Criteria
### Scenario 1: New unique event processed
- Given no idempotency record exists for `eventId=ABC-123`
- When an event with `eventId=ABC-123` is ingested
- Then the event is processed and GL posting occurs once
- And the idempotency record is `COMPLETED`

### Scenario 2: Replay returns cached result
- Given `eventId=ABC-123` is `COMPLETED` and incoming domain hash matches
- When the same event is ingested again
- Then no new GL posting is created
- And the stored response is returned (or message is ACKed/committed as replay)

### Scenario 3: Conflicting duplicate is escalated and does not hot-loop
- Given an existing idempotency record for `eventId=XYZ-789`
- When an event with `eventId=XYZ-789` arrives with a different domain hash
- Then a conflict record is created (`OPEN`)
- And a DLQ message is published referencing the conflict record
- And CRITICAL alert/metric is emitted
- And the original message/request is ACKed/committed (no poison-message retry loop)

### Scenario 4: Retention + tiering policy enforced
- Given idempotency/conflict records are GL-impacting
- Then retention is configurable but never below 7 years
- And hot storage keeps records for ~400 days before archiving

## Audit & Observability
- Metrics:
  - `events.processed.count{status=new|replay|failed|conflict}`
  - `events.conflicts.count` (CRITICAL alert on >0)
  - `events.processing.latency`
  - `events.archive.backlog` / `events.archive.failures`
- Logging:
  - `INFO` new/replay
  - `WARN` failed eligible for retry
  - `ERROR` conflict detected (include `eventId`, `conflictId`, hashes)

## Resolved Questions
From clarification #401:
- Conflicts: DLQ required; persist conflict + alert; ACK/commit after recording/publishing; Accounting Ops resolves via exceptions workflow.
- Hashing: hash canonical domain payload only; exclude only transport/observability volatile metadata.
- Retention: idempotency + conflict records retained ‚â• 7 years, with 400-day hot + archive default.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #142 ‚Äî [BACKEND] [STORY] Events: Implement Idempotency and Deduplication

## Current Labels
- backend
- story-implementation
- general

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Events: Implement Idempotency and Deduplication

**Domain**: general

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Ingest Accounting Events (Cross-Module)

## Story
Events: Implement Idempotency and Deduplication

## Acceptance Criteria
- [ ] Duplicate submissions of same eventId are detected and do not create duplicate GL impact
- [ ] Conflicting duplicates (same eventId, different payload) are rejected and flagged
- [ ] Replays return the prior posting reference when already posted
- [ ] Retry workflow exists for failed events without duplicating postings


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #141: [BACKEND] [STORY] Events: Validate Event Completeness and Integrity
LABELS: general,type:story,domain:accounting,status:ready-for-dev
BODY:
STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** accounting-strict
---

## Story Intent
As a System Architect, I require a robust validation layer for all incoming accounting events to ensure that every event is structurally sound, internally consistent, and contains all necessary data before it is accepted for downstream processing. This gatekeeping function is critical to protect the integrity of the general ledger and prevent data corruption in financial reporting systems.

## Actors & Stakeholders
- **System Actor**: `Accounting Event Ingestion Service` - The microservice responsible for receiving and validating events.
- **Upstream Systems**: Any internal service (e.g., Sales, Inventory, Billing) that produces and sends accounting-relevant events.
- **Stakeholders**:
  - `Accounting Team`: Defines the validation rules and policies; relies on the accuracy of the processed data for financial reporting.
  - `System Auditors`: Require a clear and traceable record of all event processing decisions, especially for rejections and suspense items.
  - `Development Teams`: Consume the validation feedback (error codes) from the Ingestion Service to debug and correct their event-producing systems.

## Preconditions
- The `Accounting Event Ingestion Service` is running and has an exposed endpoint to receive events.
- The service has access to the authoritative schemas for all known event types.
- The service has read-access to data sources required for validating references (e.g., customer database, product catalog).

## Functional Behavior
1. The `Accounting Event Ingestion Service` receives a new accounting event payload via its API endpoint.
2. Upon receipt, the service immediately creates a processing record for the event and sets its initial status to `Received`.
3. The service then executes a series of validation steps in a predefined order:
    a. **Schema Validation**: Checks if the event payload conforms to the registered JSON schema for its `eventType`.
    b. **Referential Integrity Validation**: Verifies that all entity identifiers (e.g., `customerId`, `orderId`, `productId`) within the event exist in the corresponding source-of-truth systems.
    c. **Financial Consistency Validation**: Enforces business rules on monetary values (e.g., `subtotal + tax = total`).
4. If all validation steps pass successfully, the service updates the event's status to `Validated` and places it in a queue for the next stage of processing (e.g., Mapping).
5. If any validation step fails, the service immediately halts processing for that event, updates its status to `Rejected`, and follows the defined error handling flow.

## Alternate / Error Flows
- **Invalid Schema**: If the event payload does not conform to the schema for its `eventType`, its status is transitioned to `Rejected`. A structured error log is created detailing the specific schema violations. An HTTP `400 Bad Request` response with an actionable error code (`SCHEMA_VALIDATION_FAILED`) is returned to the calling system.
- **Missing Required Reference**: If a referenced entity ID does not exist in the source system, the event status is transitioned to `Rejected`. A structured error log is created, and an HTTP `400 Bad Request` with a specific error code (e.g., `REFERENCE_NOT_FOUND`) is returned.
- **Unknown Event Type**: If the `eventType` is not recognized by the system, the event is processed according to the defined business policy (see **Open Questions**). It is either rejected with an `UNKNOWN_EVENT_TYPE` error or its status is transitioned to `Suspense` for manual investigation.
- **Financial Inconsistency**: If the monetary values in the event fail consistency checks, its status is transitioned to `Rejected`. An HTTP `400 Bad Request` with a `FINANCIAL_INCONSISTENCY` error code is returned.

## Business Rules
- **BR1: Schema Adherence**: All incoming events MUST conform to their registered JSON schema.
- **BR2: Referential Integrity**: All foreign key identifiers within an event payload MUST correspond to an active, valid record in the referenced domain's system of record.
- **BR3: Financial Consistency**: Monetary fields within an event MUST adhere to defined accounting principles and checks (e.g., debits must equal credits, or line items must sum to a total). (See OQ2)
- **BR4: Idempotency**: The combination of `sourceSystem` and `eventId` must be unique to prevent duplicate processing. A duplicate submission should be acknowledged with a success response but not re-processed.
- **BR5: Unknown Event Policy**: The handling of unknown `eventType` values must follow a deterministic policy. (See OQ1)

## Data Requirements
### `AccountingEvent` (Incoming Payload)
- `eventId`: (string, UUID) Unique identifier for the event from the source system.
- `eventType`: (string, enum) The specific type of event (e.g., `ORDER_COMPLETED`, `PAYMENT_PROCESSED`).
- `eventTimestamp`: (timestamp, ISO 8601) The time the event occurred in the source system.
- `sourceSystem`: (string) The name of the service that generated the event.
- `payload`: (JSON object) The event-specific data, containing financial amounts, taxes, and entity references.

### `EventProcessingRecord` (Internal State)
- `processingId`: (UUID) The internal unique ID for this processing attempt.
- `eventId`: (string, UUID) Foreign key to the incoming event's ID.
- `status`: (string, enum) The current state of the event (`Received`, `Validated`, `Rejected`, `Suspense`, `Mapped`, `Posted`).
- `receivedTimestamp`: (timestamp) When the service first received the event.
- `lastUpdatedTimestamp`: (timestamp) When the status was last changed.
- `validationErrors`: (JSON object, nullable) A structured object containing details of any validation failures.

## Acceptance Criteria
**AC1: Successful Validation of a Correct Event**
- **Given** the `Accounting Event Ingestion Service` receives a valid event with a known `eventType`, a valid schema, correct references, and consistent financial data
- **When** the event is processed
- **Then** the event's status is recorded sequentially as `Received` and then `Validated`, and it is enqueued for the next processing stage.

**AC2: Rejection Due to Invalid Schema**
- **Given** the service receives an event with a known `eventType` but a payload that violates the corresponding schema
- **When** the event is processed
- **Then** the event's status is updated to `Rejected`, a detailed schema violation error is logged, and a `400 Bad Request` response with error code `SCHEMA_VALIDATION_FAILED` is returned to the caller.

**AC3: Rejection Due to Missing Reference**
- **Given** the service receives an event that is schema-valid but contains a `customerId` that does not exist
- **When** the event is processed
- **Then** the event's status is updated to `Rejected`, an error referencing the invalid `customerId` is logged, and a `400 Bad Request` response with error code `REFERENCE_NOT_FOUND` is returned.

**AC4: Rejection Due to Financial Inconsistency**
- **Given** the service receives a schema-valid event where `payload.subtotal` + `payload.tax` does not equal `payload.total`
- **When** the event is processed
- **Then** the event's status is updated to `Rejected`, the specific consistency failure is logged, and a `400 Bad Request` response with error code `FINANCIAL_INCONSISTENCY` is returned.

**AC5: Handling of Unknown Event Type**
- **Given** the service receives an event with an `eventType` that is not registered in the system
- **When** the event is processed
- **Then** the system follows the defined policy for unknown types (reject or suspense) as determined by the outcome of OQ1.

## Audit & Observability
- **Audit Trail**: Every status transition for an event (`Received`, `Validated`, `Rejected`, `Suspense`, etc.) MUST be recorded in an immutable audit log with timestamps and the responsible service principal.
- **Logging**: Detailed, structured logs MUST be generated for all rejected events, including the full event payload and the specific reason(s) for rejection.
- **Metrics**: The service MUST emit metrics for:
  - `events.received.count` (tagged by `eventType`)
  - `events.validated.count` (tagged by `eventType`)
  - `events.rejected.count` (tagged by `eventType` and `rejectionReason`)
  - `events.suspense.count` (tagged by `eventType`)
- **Alerting**: An alert MUST be configured to fire if the rate of rejected or suspense events exceeds a predefined threshold.

## Open Questions
- **OQ1: Policy for Unknown Event Types**: What is the definitive business policy for handling an event with an unknown `eventType`? Should it be (a) immediately rejected with an error, or (b) routed to a `Suspense` queue/ledger for manual review and classification?
- **OQ2: Financial Consistency Rules**: What are the specific, exhaustive financial consistency checks that must be enforced? Please provide the exact formulas and any acceptable tolerances for rounding (e.g., `grossAmount == netAmount + taxAmount`, `sum(lineItems.total) == order.total`).
- **OQ3: Error Code Granularity**: Please provide or point to the canonical list of actionable error codes to be returned to clients for each validation failure class (e.g., `SCHEMA_VIOLATION`, `MISSING_REQUIRED_FIELD`, `INVALID_REFERENCE_ID`, `INCONSISTENT_AMOUNTS`, `UNKNOWN_EVENT_TYPE`).

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #141 ‚Äî [BACKEND] [STORY] Events: Validate Event Completeness and Integrity

## Current Labels
- backend
- story-implementation
- general

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Events: Validate Event Completeness and Integrity

**Domain**: general

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Ingest Accounting Events (Cross-Module)

## Story
Events: Validate Event Completeness and Integrity

## Acceptance Criteria
- [ ] Invalid schema or missing required references are rejected with actionable error codes
- [ ] Unknown eventType is rejected or routed to suspense per policy
- [ ] Amount and tax consistency checks are enforced per policy
- [ ] Processing status transitions are recorded (Received‚ÜíValidated‚ÜíMapped‚ÜíPosted/Rejected/Suspense)


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #140: [BACKEND] [STORY] CoA: Create and Maintain Chart of Accounts
LABELS: general,type:story,domain:accounting,status:needs-review
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** accounting-strict
---

## Story Intent
**As a** Finance Manager or Accountant,
**I want to** create and maintain a Chart of Accounts (CoA) with clearly defined, effective-dated General Ledger (GL) accounts,
**so that** financial transactions can be accurately classified, aggregated, and reported according to standard accounting principles and regulatory requirements.

## Actors & Stakeholders
- **Primary Actor:**
    - `Finance Manager`: User persona responsible for defining, managing, and maintaining the financial structure and integrity of the Chart of Accounts.
- **System Actors:**
    - `Accounting Service`: The microservice that owns and manages the Chart of Accounts data and business logic.
    - `General Ledger System`: A consumer of the CoA, which uses GL accounts for posting journal entries.
- **Stakeholders:**
    - `Auditor`: Requires a clear, auditable history of all changes to the CoA.
    - `Reporting System`: Consumes the CoA structure to generate financial reports (e.g., Balance Sheet, Income Statement).

## Preconditions
- The Finance Manager is authenticated and authorized with `CoA:Manage` permissions.
- The Accounting service is running and accessible via its API.
- The canonical list of GL account types (`ASSET`, `LIABILITY`, `EQUITY`, `REVENUE`, `EXPENSE`) is defined and configured in the system.

## Functional Behavior
### 4.1. Create GL Account
A Finance Manager can create a new GL account by providing a unique account code, a descriptive name, and a valid account type. The account can be created with an immediate or future activation date (`activeFrom`). Upon creation, the account is active by default and has no expiration (`activeThru` is null).

- **Trigger:** API `POST /v1/gl-accounts` request.
- **Outcome:** A new `GLAccount` entity is created and persisted. The full entity, including system-generated fields (`accountId`, `createdAt`), is returned in the API response with an HTTP `201` status. An audit log entry is created for the event.

### 4.2. Retrieve GL Account(s)
A user can retrieve the details of a specific GL account by its unique system ID or account code. They can also retrieve a paginated list of all GL accounts, with support for filtering by `accountType` and `status` (e.g., active, inactive, scheduled).

- **Trigger:** API `GET /v1/gl-accounts/{id}` or `GET /v1/gl-accounts?filter=...` request.
- **Outcome:** The requested `GLAccount` object(s) are returned.

### 4.3. Update GL Account Name/Description
A Finance Manager can update mutable attributes of an existing GL account, such as its `accountName` or `description`. Core identifying attributes (`accountCode`, `accountType`) are immutable after creation.

- **Trigger:** API `PATCH /v1/gl-accounts/{id}` request.
- **Outcome:** The specified fields are updated, `updatedAt` and `updatedBy` are set, and an audit log is generated.

### 4.4. Deactivate GL Account
A Finance Manager can deactivate a GL account by setting its `activeThru` timestamp. This action is subject to deactivation policy rules. Deactivation does not delete the account; it makes it unavailable for future transactions after the specified date.

- **Trigger:** API `POST /v1/gl-accounts/{id}/deactivate` request with an `effectiveDate`.
- **Outcome:** If business rules are met, the account's `activeThru` field is updated. If rules are violated, the request is rejected with a clear error message.

## Alternate / Error Flows
- **Duplicate Account Code:** If a user attempts to create a GL account with an `accountCode` that already exists, the system must reject the request with a `409 Conflict` error.
- **Invalid Account Type:** If the provided `accountType` is not in the canonical list, the system must reject the request with a `400 Bad Request` error.
- **Invalid Effective Dates:** If `activeThru` is provided and is earlier than or equal to `activeFrom`, the request must be rejected with a `400 Bad Request` error.
- **Deactivation Policy Violation:** If an attempt is made to deactivate a GL account that does not meet the policy criteria (e.g., has a non-zero balance), the system must reject the request with a `422 Unprocessable Entity` error and a descriptive message explaining the reason.
- **Unauthorized Access:** Any attempt to perform CoA management functions without the required permissions must be rejected with a `403 Forbidden` error.

## Business Rules
- **BR1: Account Code Uniqueness:** `accountCode` must be globally unique and is case-insensitive for validation purposes but case-sensitive for storage and display.
- **BR2: Canonical Account Types:** `accountType` must be one of: `ASSET`, `LIABILITY`, `EQUITY`, `REVENUE`, `EXPENSE`. This list is non-extendable without a system change.
- **BR3: Immutability:** `accountCode` and `accountType` are immutable after an account is created. To change these, the existing account must be deactivated and a new one created.
- **BR4: Effective Dating:** An account is considered "active" if the current system time is on or after `activeFrom` and before `activeThru`. A null `activeThru` implies the account is active indefinitely.
- **BR5: Deactivation Prerequisites:** An account cannot be deactivated (have its `activeThru` date set) if it meets conditions defined in the deactivation policy. See **Open Questions**.

## Data Requirements
The `GLAccount` entity must contain the following attributes:

| Field Name      | Type              | Constraints                                         | Description                                    |
|-----------------|-------------------|-----------------------------------------------------|------------------------------------------------|
| `accountId`     | UUID              | Primary Key, Not Null                               | System-generated unique identifier.            |
| `accountCode`   | String            | Not Null, Unique, Indexed                           | The human-readable, unique code for the account. |
| `accountName`   | String            | Not Null                                            | The descriptive name of the account.           |
| `accountType`   | Enum              | Not Null (`ASSET`, `LIABILITY`, etc.)               | The financial classification of the account.   |
| `description`   | String            | Nullable                                            | A detailed description of the account's purpose. |
| `activeFrom`    | Timestamp with TZ | Not Null                                            | The date and time the account becomes active.    |
| `activeThru`    | Timestamp with TZ | Nullable                                            | The date and time the account becomes inactive.  |
| `createdAt`     | Timestamp with TZ | Not Null, System-managed                            | Timestamp of creation.                         |
| `updatedAt`     | Timestamp with TZ | Not Null, System-managed                            | Timestamp of last update.                      |
| `createdBy`     | UUID / String     | Not Null, System-managed                            | Identifier of the user who created the record. |
| `updatedBy`     | UUID / String     | Not Null, System-managed                            | Identifier of the user who last updated it.    |

## Acceptance Criteria

**AC1: Successful Creation of a New Asset Account**
- **Given** I am an authorized Finance Manager
- **When** I submit a request to create a new GL account with a unique `accountCode`, `accountName`, and `accountType` of `ASSET`
- **Then** the system returns a `201 Created` status
- **And** the response body contains the full details of the newly created account, including a system-generated `accountId`.

**AC2: Prevent Creation of Duplicate Account**
- **Given** a GL account with the code "1010-CASH" already exists
- **And** I am an authorized Finance Manager
- **When** I submit a request to create another GL account with the `accountCode` "1010-CASH"
- **Then** the system returns a `409 Conflict` error
- **And** the error message indicates that the account code is already in use.

**AC3: Successful Deactivation of an Unused Account**
- **Given** an active GL account exists that meets all deactivation policy criteria
- **And** I am an authorized Finance Manager
- **When** I submit a request to deactivate that account effective tomorrow
- **Then** the system returns a `200 OK` status
- **And** the account's `activeThru` is updated to tomorrow's date.

**AC4: Prevent Deactivation of an Account with a Non-Zero Balance**
- **Given** an active GL account exists with a non-zero balance
- **And** I am an authorized Finance Manager
- **When** I attempt to deactivate that account
- **Then** the system returns a `422 Unprocessable Entity` error
- **And** the error message clearly states that an account with a balance cannot be deactivated.

**AC5: Inactive Account Cannot Be Used for New Postings**
- **Given** a GL account has been deactivated with an `activeThru` date of yesterday
- **And** the General Ledger system attempts to post a new journal entry to this account
- **When** the transaction is processed
- **Then** the Accounting Service must reject the posting with an error indicating the account is inactive.

## Audit & Observability
- **Audit Trail:** Every creation, update, and deactivation of a `GLAccount` must generate an immutable audit log entry. The entry must capture the `before` and `after` state of the entity, the principal who performed the action, the source IP, and a precise timestamp.
- **Metrics:** The Accounting service must emit metrics for:
    - `gl_account.created.count` (tagged by `accountType`)
    - `gl_account.updated.count`
    - `gl_account.deactivated.count`
- **Logging:** Key decision points, such as a failed deactivation due to a policy violation, must be logged at an `INFO` or `WARN` level with structured context (e.g., `accountId`, `reason`).

## Open Questions
- **OQ1: Deactivation Policy Definition:** The story states "Deactivation rules are enforced per policy (e.g., balances/usage)". This policy needs to be precisely defined.
    - Is checking for a non-zero balance in the General Ledger the only condition?
    - Are there other checks required, such as recent transaction activity within the last 'X' days?
    - Are there dependencies, such as the account being part of a recurring transaction template or a financial report definition, that should block deactivation?

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #140 ‚Äî [BACKEND] [STORY] CoA: Create and Maintain Chart of Accounts

## Current Labels
- backend
- story-implementation
- general

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] CoA: Create and Maintain Chart of Accounts

**Domain**: general

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Maintain Chart of Accounts and Posting Categories

## Story
CoA: Create and Maintain Chart of Accounts

## Acceptance Criteria
- [ ] Accounts support types: Asset/Liability/Equity/Revenue/Expense
- [ ] Accounts are effective-dated (activeFrom/activeThru) and audit-logged
- [ ] Duplicate account codes are blocked
- [ ] Deactivation rules are enforced per policy (e.g., balances/usage)


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #139: [BACKEND] [STORY] Categories: Define Posting Categories and Mapping Keys
LABELS: general,type:story,domain:accounting,status:ready-for-dev
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** accounting-strict
---

## Story Intent
**As a** Financial Controller,
**I want to** define a centralized, auditable system of "Posting Categories" and map them to specific General Ledger (GL) accounts,
**so that** all financial events generated by producer systems (like POS) are consistently and accurately classified for automated journal entry creation.

This capability forms the foundational layer of the sub-ledger system, ensuring traceability and correctness for all financial reporting.

## Actors & Stakeholders
- **Financial Controller / Accountant**: The primary user responsible for defining, managing, and auditing the posting category and GL mapping rules.
- **System (Producer)**: Any internal service (e.g., POS, Inventory Management) that generates a financial event and needs to resolve a mapping key to the correct GL posting information.
- **Accounting System**: The consumer of these mappings, responsible for using them to generate journal entries in the General Ledger.
- **Auditor**: A stakeholder who needs a clear, immutable history of how financial mappings were configured and changed over time.

## Preconditions
- A Chart of Accounts (CoA) is defined and accessible within the system.
- The Financial Controller is authenticated and has the necessary permissions (`accounting.mappings.manage`) to configure posting categories and GL mappings.

## Functional Behavior

### 1. Management of Posting Categories
The Financial Controller can perform full CRUD (Create, Read, Update, Deactivate) operations on Posting Categories. A Posting Category is a business-friendly abstraction for a type of financial transaction (e.g., `REVENUE_LABOR`, `COGS_TIRES`, `PAYABLE_SALES_TAX_STATE`).

### 2. Management of Mapping Keys
The Financial Controller can define and manage mapping keys. These are stable, unique string identifiers that producer systems will use to look up posting instructions (e.g., `pos.sale.item.labor.standard_rate`). Each mapping key is deterministically linked to a single Posting Category.

### 3. Management of GL Mappings
The Financial Controller can create and manage the mapping from a Posting Category to a specific GL Account and its required dimensions (e.g., cost center, department).
- Each mapping must have an `effective_start_date`.
- An `effective_end_date` is optional; a null value implies the mapping is active indefinitely.
- The system must enforce that no two mappings for the same Posting Category have overlapping effective date ranges.

### 4. System Resolution of Mapping Keys
A producer system can query an endpoint with a mapping key and a transaction date. The system will:
1. Resolve the mapping key to its corresponding Posting Category.
2. Find the active GL mapping for that Posting Category based on the provided transaction date.
3. Return the correct GL Account and dimension information.

## Alternate / Error Flows
- **Invalid Key Resolution**: If a producer system requests resolution for a mapping key that does not exist, the system shall return a distinct "not found" error.
- **No Active Mapping**: If a key is resolved to a category but no active GL mapping exists for the given transaction date, the system shall return a distinct "unmappable transaction" error.
- **Overlapping Date Range**: If a user attempts to save a new GL mapping that has an effective date range overlapping with an existing mapping for the same Posting Category, the API shall reject the request with a `409 Conflict` error, clearly identifying the conflicting mapping.
- **Invalid GL Account**: If a user attempts to map a category to a GL Account ID that does not exist in the Chart of Accounts, the API shall reject the request with a `400 Bad Request` error.

## Business Rules
- Mapping keys must be unique system-wide.
- All changes to Posting Categories and their GL mappings must be immutable and create a new versioned record. Direct updates or hard deletes are prohibited.
- A Posting Category can only be deactivated, not deleted, to preserve historical integrity.
- A deactivated category cannot be used in new GL mappings.
- The resolution of a mapping key for a given date must be deterministic and idempotent.

## Data Requirements
### PostingCategory
- `posting_category_id` (UUID, PK)
- `category_code` (VARCHAR, UNIQUE, e.g., "REVENUE_LABOR")
- `description` (TEXT)
- `status` (ENUM: `ACTIVE`, `INACTIVE`)
- `created_at`, `updated_at`

### GLMapping
- `gl_mapping_id` (UUID, PK)
- `posting_category_id` (UUID, FK)
- `gl_account_id` (VARCHAR, FK to CoA)
- `dimensions` (JSONB or dedicated columns for e.g., `cost_center_id`, `department_id`)
- `effective_start_date` (DATE)
- `effective_end_date` (DATE, nullable)
- `created_at`
- `superseded_by_mapping_id` (UUID, FK, self-referential, nullable)

*Note: The original proposal of "Mapping Keys" is modeled here as `category_code` to ensure a deterministic 1:1 link between the producer's key and the category.*

## Acceptance Criteria
- **Given** a Financial Controller with valid permissions
  **When** they create a new Posting Category with code `REVENUE_PARTS` and description "Revenue from Parts Sales"
  **Then** the system successfully saves the new category with a status of `ACTIVE`.
- **Given** the `REVENUE_PARTS` posting category exists
  **When** the controller creates a new GL mapping for it to account `40010` with an `effective_start_date` of today
  **Then** the system saves the mapping and an audit event is logged.
- **Given** an active GL mapping exists for `REVENUE_PARTS` starting today
  **When** the controller attempts to create a second mapping for `REVENUE_PARTS` with an `effective_start_date` of yesterday
  **Then** the system rejects the request with a `409 Conflict` error message indicating an overlapping date range.
- **Given** a producer system needs to post a transaction for a parts sale
  **When** it requests the GL mapping for `REVENUE_PARTS` with today's date
  **Then** the system returns the details for GL account `40010`.
- **Given** a producer system requests a mapping for a non-existent code `COGS_WIDGETS`
  **When** the request is processed
  **Then** the system returns a `404 Not Found` error.
- **Given** the `REVENUE_PARTS` category is mapped starting next month
  **When** a producer system requests the mapping for `REVENUE_PARTS` with today's date
  **Then** the system returns an "unmappable transaction" error.

## Audit & Observability
- **Audit Trail**: Every creation or modification of a Posting Category or GL Mapping must generate an immutable audit log entry. The entry must capture the user ID, timestamp, the entity changed, and a snapshot of the change (before/after state or new state).
- **Metrics**: The mapping resolution service must emit metrics for:
  - `mapping.resolution.success.count`
  - `mapping.resolution.failure.count` (tagged by failure reason: `key_not_found`, `mapping_inactive_for_date`)
- **Alerting**: An alert should be configured to trigger if the rate of `mapping.resolution.failure.count` exceeds a predefined threshold over a 5-minute window.

## Open Questions
1.  **Overlap Policy**: What is the precise business policy for handling date-range overlaps? Should creating a new mapping with a start date automatically set the end date of the previous mapping, or should it always be an explicit rejection requiring manual correction?
2.  **Unmappable Transaction Handling**: What is the required system-wide behavior for an unmappable transaction? Should it fail the entire operation at the source (e.g., block the sale at the POS), or should it post to a pre-defined "Suspense Account" for later reconciliation?
3.  **Required Dimensions**: What is the definitive list of financial dimensions that must be captured in a GL mapping alongside the GL Account (e.g., Department, Location, Project Code)?

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #139 ‚Äî [BACKEND] [STORY] Categories: Define Posting Categories and Mapping Keys

## Current Labels
- backend
- story-implementation
- general

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Categories: Define Posting Categories and Mapping Keys

**Domain**: general

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Maintain Chart of Accounts and Posting Categories

## Story
Categories: Define Posting Categories and Mapping Keys

## Acceptance Criteria
- [ ] Posting categories exist for business meaning (Labor Revenue, Sales Tax Payable, COGS Tires, etc.)
- [ ] Mapping keys used by producers resolve deterministically to categories
- [ ] Category‚ÜíAccount/Dimensions mappings are effective-dated and audit-logged
- [ ] Invalid/overlapping mappings are rejected per policy


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #138: [BACKEND] [STORY] Mapping: Configure EventType ‚Üí Posting Rule Set
LABELS: type:story,domain:accounting,status:ready-for-dev,agent:story-authoring,agent:accounting
BODY:
## Story Intent
**As a** Financial Controller or System Administrator,
**I want to** configure and manage versioned posting rule sets that map business `EventType`s to general ledger postings,
**so that** journal entries are generated accurately, remain balanced, and are traceable to the exact rules version used.

**Rewrite Variant:** integration-conservative

## Actors & Stakeholders
- **Primary Actor:** Financial Controller / System Administrator
- **Accounting Service (`domain:accounting`):** Owns storage, versioning, validation, and execution of posting rules.
- **Upstream Event Producers (e.g., Sales/Inventory/etc.):** Own `EventType` semantics and event payload contracts.
- **Auditors:** Require traceability from journal entries back to posting rules and event inputs.
- **Developers:** Need a predictable contract for introducing new events + mappings.

## Preconditions
1. A Chart of Accounts (CoA) is defined and accessible to the Accounting service.
2. The actor is authenticated and authorized to manage accounting configuration.
3. The producing domain(s) for events in scope provide versioned event contract documentation (schema/repo/doc) that defines `EventType` and required payload fields.

## Functional Behavior
1. **CRUD + Listing:** Provide an API to create, read, update (via new version), and list `PostingRuleSet`s.
2. **Rule Set Model:** A `PostingRuleSet` maps a single `EventType` to a set of posting rules.
3. **Versioning + Immutability:**
   - Any modification creates a new immutable version.
   - Versions that have been used for posting must not be edited or deleted.
4. **Validation (atomic):**
   - Validate referenced GL accounts exist.
   - Validate referenced `EventType` is recognized for the configured integration scope.
   - Validate the rule set produces balanced entries (Total Debits = Total Credits) for supported conditions.
   - Reject invalid configurations with clear, actionable errors.
5. **Conditional Logic:** Rules within a set support conditional selection based on event payload attributes (e.g., `isTaxable`, `isInventoryItem`, `itemType`).
   - Conditional attributes must be present in the event payload (or derivable from it).
6. **Execution Traceability:** When processing an event:
   - Select rule set by `EventType` + condition(s).
   - Generate a `JournalEntry` that immutably references `postingRuleSetId` + `postingRuleSetVersion`.
7. **Operational safety (recommended):** Add a fail-fast validation at startup (or CI) to detect unknown `EventType` values in configuration.

## Alternate / Error Flows
- **Unbalanced rule set:** Reject with `400 Bad Request` and details describing the imbalance/condition that failed.
- **Invalid GL account reference:** Reject with `400 Bad Request` and identify invalid account ID(s).
- **Invalid/unknown `EventType`:** Reject with `400 Bad Request` and identify the invalid `EventType`.

## Business Rules
1. **Double-entry invariant:** Generated journal entries must be balanced.
2. **Rule version immutability:** Published/used versions cannot be modified; new changes require a new version.
3. **Traceability:** Every journal entry must link to the specific ruleset+version used.
4. **Deterministic posting:** Posting must be deterministic and replayable; avoid synchronous cross-service lookups during posting.

## Data Requirements
- **PostingRuleSet**
  - `ruleSetId` (UUID)
  - `version` (int)
  - `eventType` (string)
  - `rulesDefinition` (JSONB)
  - `status` (DRAFT | PUBLISHED | ARCHIVED)
  - `createdAt`, `updatedAt`
- **JournalEntry**
  - `journalEntryId` (UUID)
  - `sourceTransactionId` (UUID)
  - `postingRuleSetId` (UUID)
  - `postingRuleSetVersion` (int)
  - `journalLines` (debit/credit lines)
  - `postedAt` (timestamp)

## Acceptance Criteria
- **AC1: Balanced rule set creation**
  - Given a defined `EventType` and a valid CoA
  - When a published ruleset is created that balances
  - Then the system returns `201 Created` and persists version 1 as `PUBLISHED`

- **AC2: Reject unbalanced rule set**
  - Given a defined `EventType`
  - When a ruleset is created that does not balance
  - Then the system returns `400` with a clear validation failure message

- **AC3: Conditional logic application**
  - Given a ruleset that conditionally includes lines based on a payload attribute
  - When an event is processed with that attribute set
  - Then the resulting journal entry includes the correct conditional line(s)

- **AC4: Journal entry traceability**
  - Given an active ruleset at version N
  - When a matching event is processed
  - Then the journal entry references `postingRuleSetId` and `postingRuleSetVersion = N`

## Audit & Observability
- **Audit trail:** Log any creation/new-version/publish/archive action for posting rulesets with actor, timestamp, and before/after snapshot.
- **Logging:** Log successful and failed validations with `eventType` and failure reason.
- **Metrics:**
  - `posting_rule_evaluations_total{eventType,result}`
  - `posting_rule_validation_errors_total{eventType,reason}`

## Resolved Decisions (from issue comments)
These decisions were applied from the resolution comment posted on 2026-01-14 ("Decision Doc ‚Äî Issue #138", generated by `clarification-resolver.sh`):
1. **Domain ownership:** `domain:accounting` is the primary domain for posting rules and journal entry generation.
2. **`EventType` authority:** Upstream event producers own canonical `EventType` semantics; Accounting owns the mapping configuration and should not invent `EventType`s.
3. **Conditional attributes:** Required condition keys must be present in the event payload; do not add synchronous cross-service lookups during posting.

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #138 ‚Äî [BACKEND] [STORY] Mapping: Configure EventType ‚Üí Posting Rule Set

## Current Labels
- backend
- story-implementation
- inventory

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Mapping: Configure EventType ‚Üí Posting Rule Set

**Domain**: inventory

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Maintain Chart of Accounts and Posting Categories

## Story
Mapping: Configure EventType ‚Üí Posting Rule Set

## Acceptance Criteria
- [ ] Posting rules are versioned and referenced on every journal entry
- [ ] Rules produce balanced debit/credit outputs for representative test fixtures
- [ ] Rules support conditional logic (taxable/non-taxable, inventory/non-inventory)
- [ ] Publishing rules that don‚Äôt balance is blocked


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #137: [BACKEND] [STORY] GL: Build Balanced Journal Entry from Event
LABELS: general,type:story,domain:accounting,status:needs-review
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** accounting-strict
---

## Story Intent
As the General Ledger (GL) System, I need to consume domain events and transform them into complete, balanced, and auditable draft Journal Entries. This ensures that all financially significant activities occurring in other systems are accurately and reliably captured as formal accounting records, forming the foundation for financial reporting.

## Actors & Stakeholders
- **Primary Actor**: GL Subledger System (The automated system responsible for processing events and creating journal entries).
- **Stakeholders**:
    - **Accountant / Auditor**: Reviews the generated draft Journal Entries for accuracy and compliance before posting.
    - **System Administrator**: Configures and maintains the event-to-GL mapping rules that govern the transformation logic.
    - **Upstream System**: The source system that publishes the financially significant domain events (e.g., POS, Inventory, Billing).

## Preconditions
- A financially significant domain event has been published by an upstream system and is available for consumption.
- A valid and active event-to-GL-mapping rule exists for the specific event type and version.
- The Chart of Accounts (including all referenced Accounts, Categories, and Dimensions) is configured and accessible to the GL Subledger System.
- The system has a clearly defined policy for handling processing failures.

## Functional Behavior
1.  **Trigger**: The GL Subledger System consumes a new domain event from an event stream or queue.
2.  **Rule Lookup**: The system identifies the event type and version, and retrieves the corresponding active mapping rule.
3.  **Header Creation**: The system constructs a new Journal Entry (JE) header, populating it with metadata from the event, such as the transaction date, source system, and unique `eventId`. The header is also stamped with the version of the mapping rule used for the transformation.
4.  **Line Item Generation**: The system iterates through the instructions in the mapping rule to generate all required Journal Entry lines from the event payload. Each line specifies:
    - The target GL Account, Category, and any required Dimensions.
    - The amount and currency.
    - The entry type (Debit or Credit).
5.  **Balance Validation**: After generating all lines, the system calculates the sum of all debits and the sum of all credits, grouped by currency. It validates that for each currency, `SUM(Debits) = SUM(Credits)`.
6.  **Persistence**: Upon successful balance validation, the system saves the complete Journal Entry (header and all lines) to the database with a status of `Draft`.

## Alternate / Error Flows
- **Error - No Mapping Rule**: If no active mapping rule is found for the consumed event type, the process is aborted. No Journal Entry is created, and the event is routed for failure handling per system policy.
- **Error - Invalid Data**: If the event payload is missing data required by the mapping rule, or if a referenced GL Account/Dimension is invalid or inactive, the process is aborted. No Journal Entry is created, and the event is routed for failure handling.
- **Error - Unbalanced Entry**: If the balance validation check fails (debits do not equal credits for any currency), the system discards the partially constructed entry. The process is aborted, and the source event is routed for failure handling.

## Business Rules
- **BR1: Atomicity of Transformation**: A single source event must result in exactly one complete, balanced Journal Entry, or it must be rejected entirely. No partial or incomplete journal entries shall be persisted.
- **BR2: Balance Requirement**: For every currency represented within a single Journal Entry, the sum of all debit amounts must strictly equal the sum of all credit amounts.
- **BR3: Initial State**: All successfully generated Journal Entries must be created in a `Draft` state, indicating they are awaiting review and posting.
- **BR4: Failure Handling Policy**: Events that cannot be processed successfully must be handled according to a deterministic system policy (e.g., routing to a suspense account or a dead-letter queue). This policy is critical for audit and reconciliation.

## Data Requirements
- **Journal Entry Header**:
    - `journalEntryId` (PK, System-generated)
    - `sourceEventId` (FK, Traceability)
    - `sourceSystem` (e.g., 'POS', 'BILLING')
    - `mappingRuleVersionId` (FK, Traceability)
    - `transactionDate`
    - `status` (Enum: `Draft`, `Posted`, `Cancelled`)
    - `creationTimestamp`
- **Journal Entry Line**:
    - `journalEntryLineId` (PK, System-generated)
    - `journalEntryId` (FK to Header)
    - `glAccountId` (FK to Chart of Accounts)
    - `glCategoryId` (FK to Chart of Accounts)
    - `dimensionReferences` (JSONB or dedicated columns, e.g., `locationId`, `departmentId`)
    - `amount` (Decimal)
    - `currency` (ISO 4217 code)
    - `entryType` (Enum: `Debit`, `Credit`)

## Acceptance Criteria
**AC1: Successful Creation of a Balanced Journal Entry**
- **Given** a financially significant domain event is consumed
- **And** a valid and active mapping rule exists for the event type
- **When** the GL system processes the event
- **Then** a single new Journal Entry is created and persisted in a `Draft` state
- **And** the Journal Entry header contains a non-null reference to the `sourceEventId` and the `mappingRuleVersionId`
- **And** for each currency within the Journal Entry, the sum of all debit line amounts equals the sum of all credit line amounts
- **And** each Journal Entry line contains valid references to a GL Account, Category, and all required Dimensions.

**AC2: Rejection of an Event with No Matching Rule**
- **Given** a domain event is consumed
- **And** no active mapping rule exists for that event type
- **When** the GL system attempts to process the event
- **Then** no Journal Entry is created in the database
- **And** the event is routed to the configured failure handling mechanism (e.g., dead-letter queue).

**AC3: Rejection of a Logically Unbalanced Entry**
- **Given** a domain event is consumed
- **And** its corresponding mapping rule generates a set of lines where debits do not equal credits for a given currency
- **When** the GL system processes the event and performs the balance validation
- **Then** the validation fails
- **And** no Journal Entry is created in the database
- **And** the event is routed to the configured failure handling mechanism.

## Audit & Observability
- **Audit Logging**: Log the successful creation of every `Draft` Journal Entry, including the `journalEntryId`, `sourceEventId`, and `mappingRuleVersionId`.
- **Error Logging**: Log any processing failures with `ERROR` severity. The log must include the `sourceEventId`, the full event payload, and a clear reason for the failure (e.g., `NO_MAPPING_RULE_FOUND`, `UNBALANCED_ENTRY_ERROR`).
- **Metrics**:
    - `journal_entries.created.count`: Counter for successfully created draft JEs.
    - `journal_entries.failed.count`: Counter for events that failed processing, tagged by failure reason.
    - `journal_entry.processing.time`: Histogram measuring the latency from event consumption to JE persistence.

## Open Questions
- **OQ1: Failure Handling Policy**: The story states "Mapping failures route to suspense or rejection per policy". This policy must be explicitly defined before implementation.
    - a) Does the system post a pre-defined entry to a "Suspense Account"? If so, what are the rules for constructing that entry?
    - b) Or does the system reject the event to a dead-letter queue (DLQ) for manual review and reprocessing? This is the safer default.
    - c) Can this policy be configured globally, or does it vary per event type or source system?

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #137 ‚Äî [BACKEND] [STORY] GL: Build Balanced Journal Entry from Event

## Current Labels
- backend
- story-implementation
- general

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] GL: Build Balanced Journal Entry from Event

**Domain**: general

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Post Journal Entries to the General Ledger

## Story
GL: Build Balanced Journal Entry from Event

## Acceptance Criteria
- [ ] Mapped events create a draft journal entry with header refs (eventId/source refs/rule version)
- [ ] JE is balanced per currency (debits=credits)
- [ ] Each JE line includes category, account, and dimension references
- [ ] Mapping failures route to suspense or rejection per policy (no partial postings)


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #136: [BACKEND] [STORY] GL: Post Journal Entry with Period Controls and Atomicity
LABELS: general,type:story,domain:accounting,status:ready-for-dev
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** accounting-strict
---
## Story Intent
As the General Ledger System, I need to atomically post a valid journal entry while strictly enforcing accounting period controls, so that the company's financial records are updated accurately, consistently, and in the correct period.

## Actors & Stakeholders
- **System (Actor):** An automated system or service that originates a transaction requiring a journal entry (e.g., Sales, Invoicing, Payroll Sub-Ledger).
- **Accounting System (System):** The General Ledger (GL) system responsible for processing the posting request and maintaining the financial records.
- **Accountant / Controller (Stakeholder):** Responsible for the integrity and accuracy of the financial records, defining accounting period policies, and reviewing posting exceptions.

## Preconditions
- A well-formed and balanced journal entry (total debits equal total credits) exists and is ready for posting.
- The journal entry has a specified `posting_date` that determines its accounting period.
- The accounting periods (e.g., 'Open', 'Closed') are defined and their statuses are accessible to the system.
- All General Ledger accounts specified in the journal entry lines exist, are active, and are not locked.
- The source event or transaction that generated the journal entry is in a state that permits posting (e.g., 'Approved', 'Ready for Posting').

## Functional Behavior
1.  The Accounting System receives a request to post a `JournalEntry` from a source System.
2.  The system performs initial validation on the `JournalEntry` to ensure it is balanced and structurally valid.
3.  The system uses the `posting_date` to identify the corresponding `AccountingPeriod`.
4.  It verifies that the status of the identified `AccountingPeriod` is 'Open'.
5.  Upon successful validation, the system initiates a single, atomic database transaction.
6.  Within the transaction, the system performs the following operations:
    a. Creates immutable `LedgerEntry` records for each line item of the `JournalEntry`.
    b. Updates the balances of all affected GL accounts.
    c. Updates any relevant aggregate tables, such as a trial balance summary.
    d. Updates the status of the source event/document to 'Posted'.
    e. Records a permanent reference to the new `JournalEntryID` on the source event/document.
7.  The system commits the transaction.
8.  A success confirmation, including the new `JournalEntryID`, is returned to the calling system.

## Alternate / Error Flows
- **Unbalanced Journal Entry:** If the total debits do not equal total credits, the system rejects the request immediately with a `Validation:Unbalanced` error. No transaction is started.
- **Invalid GL Account:** If any line item references a non-existent, inactive, or locked GL account, the system rejects the request with a `Validation:InvalidAccount` error.
- **Closed Accounting Period:** If the `posting_date` falls within an `AccountingPeriod` that is 'Closed', the system rejects the request with a `BusinessRule:PeriodClosed` error. The rationale is logged for audit. (See Open Questions).
- **Transaction Failure:** If any operation within the database transaction fails (e.g., database connectivity loss, constraint violation), the entire transaction is rolled back. The ledger remains in its original state, and the source event status is unchanged. An error is logged and returned.

## Business Rules
- **Atomicity:** The posting of a journal entry is an all-or-nothing operation. All ledger lines must be created, and all balances updated, or the entire operation must be rolled back, leaving no trace in the GL.
- **Immutability of Posted Entries:** Once a journal entry is successfully posted, it cannot be modified or deleted. Any corrections must be made through a new, explicit reversing or correcting journal entry.
- **Strict Period Control:** Journal entries are forbidden from being posted to an `AccountingPeriod` with a 'Closed' status. The policy for handling such attempts must be strictly enforced.

## Data Requirements
- **`JournalEntry` (Input/Creation):**
    - `source_event_id`: UUID (Reference to the originating transaction)
    - `posting_date`: Date (Determines the accounting period)
    - `description`: String
    - `lines`: Array of `JournalEntryLine`
        - `account_id`: String (Identifier for a GL Account)
        - `debit`: Decimal (Must be >= 0)
        - `credit`: Decimal (Must be >= 0)
- **`LedgerEntry` (Output/Persistence):**
    - `ledger_entry_id`: UUID
    - `journal_entry_id`: UUID
    - `account_id`: String
    - `debit_amount`: Decimal
    - `credit_amount`: Decimal
    - `posted_timestamp`: DateTime
- **`AccountingPeriod` (Lookup):**
    - `period_id`: UUID
    - `start_date`: Date
    - `end_date`: Date
    - `status`: Enum ('Open', 'Closed')

## Acceptance Criteria
- **Scenario 1: Successful Posting to an Open Period**
    - **Given** a balanced journal entry with a `posting_date` that falls within an 'Open' accounting period
    - **When** the system receives a request to post the journal entry
    - **Then** a new journal entry is created in the GL, all corresponding ledger entries are recorded, the affected account balances are updated, the source event status is updated to 'Posted', and a success response is returned.

- **Scenario 2: Attempted Posting to a Closed Period**
    - **Given** a valid, balanced journal entry with a `posting_date` that falls within a 'Closed' accounting period
    - **When** the system receives a request to post the journal entry
    - **Then** the request is rejected with a `BusinessRule:PeriodClosed` error, no changes are made to the GL, and the source event status remains unchanged.

- **Scenario 3: Attempted Posting of an Unbalanced Entry**
    - **Given** a journal entry where total debits do not equal total credits
    - **When** the system receives a request to post the journal entry
    - **Then** the request is rejected with a `Validation:Unbalanced` error, and no financial records are altered.

- **Scenario 4: Transaction Fails Mid-Post**
    - **Given** a valid journal entry for an 'Open' accounting period
    - **When** the system attempts to post the entry but a database error occurs after some, but not all, lines are processed
    - **Then** the entire transaction is rolled back, the GL is restored to its pre-transaction state, and the source event status is not updated.

## Audit & Observability
- **Audit Trail:** Every posting attempt (successful or failed) must be logged with the `source_event_id`, initiating system/user, timestamp, and outcome.
- **Exception Reporting:** Failed postings due to closed periods must be recorded in an exception report or trigger a high-priority alert for the Accounting team to review.
- **Traceability:** A permanent, immutable link must exist between the `source_event_id` and the resulting `journal_entry_id` upon successful posting.

## Open Questions
- **OQ1: Closed Period Posting Policy:** The original story states "Closed periods block posting or redirect per policy". This policy is undefined and critical. What is the required behavior?
    - **A) Strict Block:** Always reject the posting. This is the safest accounting practice and the assumed default for this story.
    - **B) Post to Next Open Period:** Automatically change the posting date to the first day of the next available 'Open' period. This is risky as it can misrepresent financial activity timing.
    - **C) Allow with Override:** Block by default but allow posting if the request includes a specific override permission granted to a privileged user role. This would require an associated access control model.
    - **Decision Required:** Please confirm the policy. The current implementation will assume Strict Block (A).

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #136 ‚Äî [BACKEND] [STORY] GL: Post Journal Entry with Period Controls and Atomicity

## Current Labels
- backend
- story-implementation
- general

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] GL: Post Journal Entry with Period Controls and Atomicity

**Domain**: general

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Post Journal Entries to the General Ledger

## Story
GL: Post Journal Entry with Period Controls and Atomicity

## Acceptance Criteria
- [ ] Posting is atomic (all lines committed or none)
- [ ] Closed periods block posting or redirect per policy (with recorded rationale)
- [ ] Posting updates ledger/trial-balance aggregates
- [ ] Source event status transitions to Posted with JE reference


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #135: [BACKEND] [STORY] GL: Support Accrual vs Cash Basis Modes
LABELS: type:story,domain:accounting,status:ready-for-dev
BODY:
## Story Intent
**As a** Finance Manager or Accountant,
**I want to** configure the accounting basis (Accrual or Cash) for a business unit,
**so that** financial transactions are recorded in the General Ledger according to the correct accounting principles, ensuring compliant and accurate financial reporting.

## Actors & Stakeholders
- **Finance Manager / Accountant (User):** Configures the accounting basis for a business unit.
- **Accounting Service (System of Record):** Stores the accounting basis policy and generates/publishes journal entries.
- **Billing Service (Producer):** Emits invoice-related business events (e.g., `InvoiceIssued`).
- **Payments Service (Producer):** Emits payment-related business events (e.g., `PaymentReceived`, `PaymentApplied`, refunds/reversals).
- **Auditor:** Reviews accounting-basis changes and posting outcomes.

## Preconditions
- A Business Unit exists.
- Chart of Accounts is configured with required accounts for AR revenue cycle (e.g., Cash/Bank, Accounts Receivable, Revenue).
- User has permission to administer accounting policy (e.g., `ACCOUNTING_ADMIN`).
- Fiscal calendar exists (at minimum, the concept of a fiscal period boundary; recommended: fiscal month).

## Functional Behavior

### 1) Configure Accounting Basis (per Business Unit)
- A user with `ACCOUNTING_ADMIN` can set a business unit accounting basis to `ACCRUAL` or `CASH`.
- Default for a new business unit is `ACCRUAL`.
- The system records an immutable audit log entry for any change.

### 2) Posting Rules ‚Äî Scope
- This story applies to **AR / revenue-cycle GL posting behavior only**.
- Accounts Payable (AP) treatment is explicitly out of scope.

### 3) Posting Rules ‚Äî Accrual Basis (AR)
When basis is `ACCRUAL`:
- **On `InvoiceIssued`**: create a journal entry to recognize revenue and AR (per configured accounts).
- **On payment events**: payment should clear/settle AR (and should not create additional revenue recognition postings).

### 4) Posting Rules ‚Äî Cash Basis (AR)
When basis is `CASH`:
- **No GL entry** on `InvoiceIssued`.
- Recognize revenue on **payment events**:
  - **On `PaymentReceived` / payment capture**: post revenue recognition at time of payment.
  - **Partial payments**: recognize revenue proportional to cash received.
  - **Refund / chargeback / reversal**: reverse the cash-basis revenue posting for the refunded/reversed amount.
  - **Payment void / failed capture after previously marked paid**: reverse any previously created cash-basis entries tied to that payment.
- No GL entries should be created for unpaid invoice cancellation/void.

### 5) Basis Change Policy (Resolved)
- Basis changes are **only permitted effective at the start of a fiscal period** (recommended: fiscal month). No mid-period changes.
- A basis change must specify an **effective period start date/time**.
- Transactions are posted according to the basis effective at the posting date:
  - Accrual: invoice posting date
  - Cash: payment date

### 6) Boundary / Transition Rules (Resolved)
- **No retroactive re-posting** of already-posted GL entries.
- **No automatic catch-up conversion** for in-flight items at the boundary.
- Implementation must prevent double-recognition across the boundary.
  - Example: invoice issued under accrual (posted at issuance), then later paid after switching to cash ‚Üí payment must not create revenue again.

## Alternate / Error Flows
- **Unauthorized Basis Change**: reject with `403 Forbidden` and log.
- **Invalid Basis Value**: reject with `400 Bad Request`.
- **Invalid Effective Date**: reject if not aligned to fiscal period boundary (e.g., not at fiscal month start).
- **Closed/Locked Period**: reject basis change if effective period is closed/locked (if period close is implemented).
- **Journal Post Failure**: route source event to DLQ and trigger alert.

## Business Rules
- Exactly one active basis per business unit (`ACCRUAL` or `CASH`).
- Default basis is `ACCRUAL`.
- Basis changes are permission-controlled and audited.
- Basis changes must align to fiscal period boundaries; no mid-period changes.
- Scope is AR only for this story; AP basis behavior requires a separate story.

## Data Requirements
- **BusinessUnit**
  - `accountingBasis`: enum `ACCRUAL|CASH` (non-null, default `ACCRUAL`).

- **BusinessUnitAccountingBasisPolicy (recommended for history + effective dating)**
  - `businessUnitId`
  - `basis`: enum `ACCRUAL|CASH`
  - `effectiveFrom`: timestamp (must align to fiscal period start)
  - `changedByUserId`
  - `changedAt`: timestamp

- **Audit Log**
  - Immutable record of basis changes (old/new, who/when, effectiveFrom).

## Acceptance Criteria

**AC1: Configure Accounting Basis Successfully**
- **Given** I have `ACCOUNTING_ADMIN`
- **And** a business unit is currently `ACCRUAL`
- **When** I submit a change to `CASH` with an effective date aligned to fiscal period start
- **Then** the basis policy is updated
- **And** an audit log entry is created

**AC2: Accrual Basis ‚Äî Invoice then Payment**
- **Given** basis is `ACCRUAL`
- **When** `InvoiceIssued` is received for $100
- **Then** a journal entry is created to recognize revenue and AR
- **And when** a payment event is received for that invoice
- **Then** the journal posting clears/settles AR and does not recognize revenue again

**AC3: Cash Basis ‚Äî Invoice then Payment**
- **Given** basis is `CASH`
- **When** `InvoiceIssued` is received for $100
- **Then** no journal entry is created
- **And when** `PaymentReceived` is received for $100
- **Then** a journal entry is created to recognize revenue and cash/bank receipt

**AC4: Cash Basis ‚Äî Partial Payment**
- **Given** basis is `CASH`
- **When** `PaymentReceived` is received for $40 against a $100 invoice
- **Then** revenue is recognized for $40 (proportional to cash received)

**AC5: Cash Basis ‚Äî Refund/Reversal**
- **Given** basis is `CASH`
- **And** a prior `PaymentReceived` of $100 created cash-basis revenue postings
- **When** a refund/chargeback/reversal event is received for $25
- **Then** the system creates reversing entries for $25 against the original cash-basis posting

**AC6: Basis Change Constraints**
- **Given** I have `ACCOUNTING_ADMIN`
- **When** I attempt to change basis with an effective date not at fiscal period start
- **Then** the request is rejected
- **And** no basis policy change occurs

## Audit & Observability
- Emit `AccountingBasisChanged` on successful change including: `businessUnitId`, `oldBasis`, `newBasis`, `effectiveFrom`, `changedByUserId`, `timestamp`.
- Logs:
  - `INFO` for successful journal posts (include journal entry id + source event id).
  - `WARN` for unauthorized change attempts.
  - `ERROR` for event processing/posting failures (include event id + error).
- Metrics:
  - `journal_entries.posted.count` tagged by `basis` and `status`.

## Open Questions
None.

---

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #135 ‚Äî [BACKEND] [STORY] GL: Support Accrual vs Cash Basis Modes

## Current Labels
- backend
- story-implementation
- payment

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] GL: Support Accrual vs Cash Basis Modes

**Domain**: payment

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Post Journal Entries to the General Ledger

## Story
GL: Support Accrual vs Cash Basis Modes

## Acceptance Criteria
- [ ] Business unit can be configured as accrual or cash basis
- [ ] Accrual: invoices post AR/AP and payments clear AR/AP
- [ ] Cash basis behavior is policy-defined and consistent across posting/reporting
- [ ] Basis changes are audited and permission-controlled


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #134: [BACKEND] [STORY] GL: Provide Trial Balance and Drilldown to Source
LABELS: general,type:story,domain:accounting,status:needs-review
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** accounting-strict
---

## Story Intent
As a Controller, I need to generate a Trial Balance report and be able to drill down from any balance to its source transaction, so that I can verify the integrity of the General Ledger, perform financial analysis, and support internal/external audits.

## Actors & Stakeholders
- **Controller (Primary Actor):** Responsible for the accuracy and integrity of the company's financial records. They will generate, review, and analyze the trial balance.
- **Finance Manager / Accountant (Secondary Actor):** Uses the trial balance for period-end closing procedures and financial reporting.
- **Auditor (External Stakeholder):** Requires access to financial data and traceability to source events to conduct audits.
- **System (System Actor):** The General Ledger service that provides the data for the report.

## Preconditions
- The user is authenticated and has the necessary permissions to access the General Ledger reporting features.
- A Chart of Accounts has been configured in the system.
- Fiscal periods (e.g., monthly, quarterly) are defined and closed or open as appropriate.
- Journal entries have been posted to the General Ledger for the periods being reported on.
- Source systems (e.g., Billing, Work Execution) generate events with unique identifiers that are linked to journal entries.

## Functional Behavior

### 4.1 Generate Trial Balance Report
1.  **Trigger:** The Controller navigates to the financial reporting section and requests a new Trial Balance report.
2.  **Process:**
    a. The system presents the Controller with options to filter the report. Required filters include `Fiscal Period`. Optional filters include `Account` ranges and `Dimension(s)`.
    b. The Controller specifies the desired filter criteria and initiates the report generation.
    c. The system queries the General Ledger to calculate the opening, debit, credit, and closing balances for every account that matches the filter criteria for the specified period.
    d. The system presents the Trial Balance on screen, with totals for debits and credits.
    e. The system provides an option to export the displayed report to a CSV file.

### 4.2 Drill Down to Source Event
1.  **Trigger:** The Controller clicks on a specific balance (e.g., the closing balance for the "Accounts Receivable" account) within the generated Trial Balance report.
2.  **Process:**
    a. **Level 1 (Trial Balance -> GL Account Lines):** The system displays all the individual General Ledger transaction lines (debits and credits) that make up the selected balance for that account within the specified period.
    b. **Level 2 (GL Account Line -> Journal Entry):** The Controller clicks on a specific transaction line. The system displays the full Journal Entry (including all its lines, header information, and a reference to the source event) that the line belongs to.
    c. **Level 3 (Journal Entry -> Source Event):** The Controller clicks on the source event reference. The system retrieves and displays the details of the original business event (e.g., the specific customer invoice, repair order, or inventory movement) that triggered the accounting entry.

## Alternate / Error Flows
- **Invalid Period:** If the user enters a non-existent or malformed fiscal period, the system displays an input validation error and prevents report generation.
- **No Data:** If no transactions exist for the selected filters, the system displays a "No data found for the selected criteria" message instead of an empty report.
- **Permission Denied:** If the user attempts to generate a report for accounts or dimensions they are not authorized to view, the system either filters out the restricted data or displays a clear "Access Denied" error message, as defined by security policies.
- **Broken Source Link:** If the drill-down to a source event fails (e.g., the source record was purged or the link is invalid), the system displays an error message indicating the source event could not be retrieved, along with the source event ID for manual investigation.
- **Unbalanced GL:** If the total debits do not equal total credits in the trial balance, the report is still generated but displays a prominent warning indicating an imbalance in the General Ledger. This is a critical system integrity issue.

## Business Rules
- The Trial Balance must always show that total debits equal total credits for the selected population of accounts.
- Balances are calculated based on all `Posted` journal entries within the specified fiscal period. `Draft` or `Pending` entries are excluded.
- The drill-down path must be immutable and reflect the exact data at the time of the transaction.
- Access controls are non-negotiable and must be enforced at the API level, not just in the user interface.
- CSV export format must be standardized and include a header row.

## Data Requirements
- **Trial Balance Report:**
  - `ReportID`
  - `GenerationTimestamp`
  - `FiltersApplied` (Period, Dimensions, etc.)
  - `LineItems[]`:
    - `AccountID`
    - `AccountName`
    - `OpeningBalance`
    - `TotalDebits`
    - `TotalCredits`
    - `ClosingBalance`
  - `TotalDebits` (for the entire report)
  - `TotalCredits` (for the entire report)

- **Journal Entry:**
  - `JournalEntryID`
  - `PostingDate`
  - `Description`
  - `SourceEventID`
  - `SourceSystem`
  - `Status` (e.g., Posted, Draft)
  - `Lines[]`:
    - `AccountID`
    - `DebitAmount`
    - `CreditAmount`

## Acceptance Criteria

**AC1: Generate an Accurate Trial Balance for a Fiscal Period**
- **Given** journal entries have been posted for the fiscal period "2024-08"
- **When** the Controller requests a Trial Balance for "2024-08" with no other filters
- **Then** the system generates a report containing every GL account with activity in that period
- **And** the total debits for the report must exactly equal the total credits.

**AC2: Successful Drill-Down from Balance to Source Event**
- **Given** a Trial Balance report is displayed for "2024-08"
- **When** the Controller clicks the closing balance for the "Revenue" account
- **And then** clicks on a specific journal line from the resulting list
- **And then** clicks on the source event link in the full journal entry view
- **Then** the system displays the details of the original source event (e.g., Invoice #INV-123).

**AC3: Filter Trial Balance by a Dimension**
- **Given** journal entries have been posted and tagged with a "Location" dimension
- **When** the Controller requests a Trial Balance for "2024-08" filtered by `Location: "Main Street"`
- **Then** the report only includes balances derived from journal entries tagged with that specific dimension value.

**AC4: Export Report to CSV**
- **Given** a Trial Balance report is displayed on the screen
- **When** the Controller clicks the "Export to CSV" button
- **Then** a CSV file is downloaded that contains the exact data displayed in the report, including a header row.

**AC5: Enforce Access Control**
- **Given** the Controller's role is restricted from viewing "Executive Payroll" accounts
- **When** they generate a Trial Balance for a period containing entries to those accounts
- **Then** the report must not contain any data (no account lines, no amounts) related to the "Executive Payroll" accounts.

## Audit & Observability
- **Audit Log:**
  - Log every instance of a Trial Balance report generation, including the user who ran it and the filters applied.
  - Log every CSV export action and the user who initiated it.
  - Log any failed access attempts to restricted financial data with high severity.
- **Metrics:**
  - `report_generation_time_ms`: Histogram tracking the latency for generating trial balance reports.
  - `drilldown_requests_total`: Counter for each level of drill-down.
  - `permission_denied_errors_total`: Counter for access control failures.

## Open Questions
1.  **Dimensions:** The story mentions filtering by "dimensions". Which specific dimensions must be supported for the initial release? (e.g., Location, Department, Project, Cost Center).
2.  **Access Control Granularity:** The requirement for "access controls" is high-level. What is the precise model? Is it role-based access to specific accounts, specific dimensions, or a combination? Please provide the rules.
3.  **CSV Format:** What is the exact column layout, ordering, and naming convention required for the CSV export to support controller workflows?
4.  **Period Definition:** How is a "period" officially defined? Does it align strictly with calendar months, or do we need to support custom fiscal periods (e.g., 4-4-5 calendar)?
5.  **Source Event Schema:** While this story doesn't implement the source systems, what is the contract for the "Source Event" payload? What key fields must be displayed when a user drills down to the source?

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #134 ‚Äî [BACKEND] [STORY] GL: Provide Trial Balance and Drilldown to Source

## Current Labels
- backend
- story-implementation
- general

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] GL: Provide Trial Balance and Drilldown to Source

**Domain**: general

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Post Journal Entries to the General Ledger

## Story
GL: Provide Trial Balance and Drilldown to Source

## Acceptance Criteria
- [ ] Trial balance can be generated by period/account/dimensions
- [ ] Drilldown exists: balance ‚Üí ledger lines ‚Üí journal entry ‚Üí source event
- [ ] Exports supported (CSV) for controller workflows
- [ ] Access controls enforced for sensitive accounts/dimensions


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #133: [BACKEND] [STORY] AR: Create Customer Invoice from Invoice-Issued Event
LABELS: type:story,domain:accounting,status:ready-for-dev
BODY:
## Story Intent
As the Accounting / Accounts Receivable (AR) system, I need to consume `InvoiceIssued` events and create corresponding AR invoice records and balanced general ledger journal entries, so that customer obligations and company revenue are accurately and traceably recorded in the financial system of record.

## Actors & Stakeholders
- **Primary Actor (System):** Accounting / AR Service (owns AR sub-ledger + GL posting)
- **Initiator (Upstream):** Billing/Sales service publishing `InvoiceIssued`
- **Stakeholders:** Finance/Accounting team, Auditors

## Preconditions
- Accounting service subscribes to the `InvoiceIssued` event stream.
- Event schema for `InvoiceIssued` is versioned and accessible.
- Chart of Accounts is configured (AR, Revenue, Tax Payable at minimum).
- Failure handling exists (retry policy + DLQ).

## Functional Behavior
1. **Consume event:** Accounting service receives `InvoiceIssued`.
2. **Idempotency:** If an AR invoice already exists for `sourceInvoiceId` (or other unique key), acknowledge and stop.
3. **Validate payload:** Required identifiers/amounts must be present and non-negative.
4. **Resolve payment terms (`paymentTermsDays`) (resolved):**
   - If `event.paymentTermsDays` is non-null and > 0: use it.
   - Else lookup customer default terms in Accounting by `customerId`.
   - If still unresolved: fail processing (do not create invoice) and route to DLQ with `MissingPaymentTerms`.
5. **Create AR invoice:** Persist invoice header + lines.
   - `dueDate = invoiceDate + paymentTermsDays`.
   - `status = Posted/Open`.
6. **Resolve revenue GL account per line (resolved):**
   - If `lineItem.revenueGlAccountCode` present: use it.
   - Else if header-level revenue account exists in the event schema: use it.
   - Else resolve deterministically via Accounting mappings (priority):
     1) product/service ‚Üí revenue account (e.g., `productId`/`sku`/`serviceCode`)
     2) customer ‚Üí default revenue account
   - If still unresolved: fail processing and route to DLQ with `MissingRevenueGlAccountCode` (include identifiers).
7. **Generate balanced journal entry:** In one atomic DB transaction:
   - **Debit** AR for `totalAmount`
   - **Credit** Revenue for `subtotalAmount` (split by line if required by your GL model)
   - **Credit** Tax Payable for `taxAmount`
8. **Traceability:** Persist `sourceEventId` (`eventId`) and `sourceInvoiceId` on both AR invoice and journal entry, and link the records.
9. **Acknowledge event** on success.

## Alternate / Error Flows
- **Duplicate event:** log as duplicate; ack; no-op.
- **Invalid payload:** fail validation; no records created; DLQ + alert.
- **Missing terms / missing revenue account mapping:** fail; no records created; DLQ + alert.
- **DB failure:** rollback; retry per policy; DLQ after retries exhausted.

## Business Rules
- **Idempotency:** exactly one AR invoice + one journal entry per `sourceInvoiceId` (or chosen unique key).
- **Balanced JE:** total debits must equal total credits.
- **System of record:** Accounting owns AR invoices + GL journal entries.
- **No silent defaults:** missing payment terms or revenue account mapping must fail deterministically.

## Data Requirements
### `InvoiceIssued` event (minimum)
- `eventId` (UUID)
- `sourceInvoiceId` (string)
- `customerId` (string)
- `invoiceDate` (date)
- `currency` (ISO 4217)
- `lineItems[]` including amounts and optional `revenueGlAccountCode`
- `subtotalAmount`, `taxAmount`, `totalAmount`
- optional: `paymentTermsDays`

### AR Invoice
- `arInvoiceId` (PK)
- `sourceInvoiceId`, `sourceEventId`
- `customerId`, `invoiceDate`, `dueDate`
- `totalAmount`, `amountDue`, `currency`
- `status`
- `journalEntryId` (FK)

### Journal Entry
- `journalEntryId` (PK)
- `transactionDate`
- `sourceEventId`
- `lines[]` (glAccountCode, debit/credit, amount)

## Acceptance Criteria
- **AC1 (Happy path):** Valid `InvoiceIssued` ($115 total = $100 subtotal + $15 tax) creates:
  - AR Invoice with `totalAmount=115`, `dueDate` computed from terms
  - Balanced JE: Dr AR 115; Cr Revenue 100; Cr Tax Payable 15
  - Both records persist `sourceInvoiceId` + `eventId`
- **AC2 (Idempotency):** Re-delivery with same `sourceInvoiceId` creates no new records.
- **AC3 (Missing customerId):** Event fails validation; no records; DLQ + alert.
- **AC4 (Terms resolution):**
  - Uses `event.paymentTermsDays` when present and > 0
  - Else falls back to customer default terms in Accounting
  - If neither available: fail with `MissingPaymentTerms` and DLQ
- **AC5 (Revenue account resolution):**
  - Uses line-level revenue account when present
  - Else uses allowed fallback(s)
  - If still unresolved: fail with `MissingRevenueGlAccountCode` and DLQ

## Audit & Observability
- Structured logs at each stage with `eventId` + `sourceInvoiceId`.
- Metrics: processed success, duplicate count, validation failures, DLQ count.
- Alerts on DLQ events.

## Open Questions
None.

---

## Original Story (Unmodified ‚Äì For Traceability)
(See original content in the issue history prior to this rewrite.)

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #132: [BACKEND] [STORY] AR: Apply Payment to Open Invoice(s)
LABELS: type:story,domain:accounting,status:ready-for-dev,agent:story-authoring,agent:accounting
BODY:
## Story Intent
**As a** Back Office Accountant,
**I want to** apply a posted/settled customer payment to one or more open invoices,
**so that** the customer‚Äôs AR balance is settled correctly and accounting records remain accurate and auditable.

**Rewrite Variant:** integration-conservative

## Actors & Stakeholders
- **Back Office Accountant:** Initiates or reviews payment applications.
- **Accounting Service (`domain:accounting`):** System of record (SoR) for AR subledger application/allocation logic and invoice settlement state.
- **Payments Service (`domain:payments`):** System of record for payment capture/settlement lifecycle; triggers Accounting when a payment is posted/settled.
- **Billing Service (`domain:billing`):** Originates invoices; may consume invoice settlement status changes.
- **Auditor / Compliance:** Requires immutable and explainable allocation history.

## Preconditions
1. A payment exists and is **posted/settled** (not merely authorized) and is available for application.
2. The payment references a `customerId`.
3. One or more invoices for the customer are in `Open` or `Partially Paid` (or equivalent) state.
4. Actor is authorized to perform AR actions.

## Functional Behavior
### Trigger / Inputs
1. **Trigger:** Accounting receives a signal that a payment is available to apply.
   - Preferred: consume an event from Payments such as `payments.payment_posted` / `payments.payment_settled`.
2. **Input fields required (from Payments):**
   - `payment_id`, `customer_id`, `amount`, `currency`, `effective_at`
   - Optional: `payment_method`, `external_reference`
   - Optional: `allocation_hint[] = { invoice_id, amount }` if Payments supports user-directed allocations

### Application Flow (Accounting-owned)
1. Validate payment exists, is posted/settled, and has available unapplied amount.
2. Determine allocation list:
   - If `allocation_hint` present: validate invoice IDs belong to `customer_id` and amounts are valid.
   - Otherwise: apply by Accounting policy (exact policy can be configured later; the minimum requirement is deterministic behavior).
3. Apply amounts to invoices:
   - Reduce invoice open balance by applied amount.
   - Update invoice settlement state (`Open` ‚Üí `Partially Paid` ‚Üí `Paid`) based on remaining balance.
4. Persist an immutable application record linking `payment_id` to invoice allocations.
5. Produce the accounting-side financial postings (balanced journal entry) consistent with the posting model.
6. Ensure idempotency (replays do not double-apply) using `applicationEventId` / `eventId` and/or `payment_id` as a natural key.

## Alternate / Error Flows
- **Overpayment:** If payment amount exceeds eligible invoice balances:
  - Apply to invoices until none remain eligible
  - Record remaining amount as **Unapplied Cash** at the customer level (do not auto-create a Credit Memo)
- **Short-pay:** If payment is less than the invoice open balance:
  - Leave invoice as `Partially Paid`
  - Do not auto-write-off by default
- **Invalid invoice target:** If allocation references an invoice that is closed/void/not found/not tied to customer:
  - Reject the transaction with a clear validation error
- **Idempotent replay:** Duplicate application requests/events return success based on original outcome without reprocessing.

## Business Rules
1. **Domain ownership:** `domain:accounting` owns applying payments to invoices (AR subledger allocation, invoice settlement state, unapplied cash).
2. **Payments boundary:** `domain:payments` owns payment capture and settlement lifecycle; Accounting should only act on posted/settled payments.
3. **Overpayment default:** Excess funds are held as **Unapplied Cash**; Credit Memo creation is manual/explicit, not automatic.
4. **Short-pay default:** No automatic write-off; invoices remain `Partially Paid`.
5. **Balanced postings:** Financial postings must satisfy double-entry balance (Debits = Credits).

## Data Requirements
- **PaymentApplication**
  - `paymentId`
  - `applicationEventId` (idempotency)
  - `applicationDate` (use `effective_at` for accounting date)
  - `allocations[] = { invoiceId, appliedAmount }`
  - `unappliedAmount` (if any)
- **Invoice**
  - `openBalance` (or equivalent)
  - `settlementStatus` (`Open`/`Partially Paid`/`Paid`)

## Acceptance Criteria
- **Scenario 1: Apply payment across multiple invoices**
  - Given a posted payment for a customer and two open invoices
  - When Accounting applies the payment to both invoices
  - Then invoice balances are reduced correctly and statuses updated
  - And an immutable application record is persisted
  - And the operation is idempotent on replay

- **Scenario 2: Overpayment becomes Unapplied Cash**
  - Given a posted payment that exceeds all eligible invoice balances
  - When applied
  - Then remaining amount is recorded as Unapplied Cash (no auto Credit Memo)

- **Scenario 3: Short-pay leaves invoice Partially Paid**
  - Given a posted payment less than an invoice open balance
  - When applied
  - Then invoice remains Partially Paid with remaining balance due
  - And no automatic write-off is created

## Audit & Observability
- Record an immutable audit event for each payment application, including `paymentId`, `customerId`, invoice allocations, timestamps, and actor.
- Emit structured logs for success/failure with correlation IDs.
- Emit metrics for application success/failure, overpayment/unapplied creation, and idempotent replays.

## Resolved Decisions (from issue comments)
These decisions were applied from the resolution comment posted on 2026-01-14 ("Decision Doc ‚Äî Issue #132", generated by `clarification-resolver.sh`):
1. **Owner:** `domain:accounting` owns applying payments to invoices; Payments triggers availability.
2. **Overpayment:** Default policy is Unapplied Cash (no auto Credit Memo).
3. **Short-pay:** Default policy is Partially Paid (no automatic de minimis write-off by default).


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #131: [BACKEND] [STORY] AR: Issue Credit Memo / Refund with Traceability
LABELS: payment,type:story,domain:accounting,status:needs-review,status:ready-for-dev
BODY:
STOP: Conflicting domain guidance detected
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- status:needs-review
- blocked:domain-conflict
- blocked:clarification

### Recommended
- agent:accounting
- agent:payment
- agent:story-authoring

### Blocking / Risk
- blocked:domain-conflict
- blocked:clarification

---
**Rewrite Variant:** integration-conservative
---

## ‚ö†Ô∏è Domain Conflict Summary
- **Candidate Primary Domains:** `domain:accounting`, `domain:payment`
- **Why conflict was detected:** The story combines the creation of a financial instrument (Credit Memo, an Accounting concern) with the execution of a financial transaction (Refund, a Payment concern) without specifying which is the primary action and which is the side-effect. The system of record for the credit balance (Accounts Receivable) and the system of record for the refund transaction are distinct.
- **What must be decided:**
    1.  Is the primary user action creating a Credit Memo, which *may* lead to a refund? (Implies `domain:accounting` is primary).
    2.  Or is the primary user action issuing a Refund, which *must* be backed by a Credit Memo? (Implies `domain:payment` is primary).
    3.  Which domain owns the lifecycle state of the overall credit/refund process?
- **Recommended split:** Yes. Create two separate, linked stories:
    1.  An `accounting` story (this one) for creating and approving a Credit Memo, which establishes a credit on the customer's account.
    2.  A subsequent `payment` story for consuming that credit to either issue a cash refund or apply it to a future invoice.

---
## Story Intent
**As an** Accounts Receivable Clerk,
**I want to** create a traceable Credit Memo against a specific, previously finalized invoice,
**so that** I can formally correct billing errors or account for returned goods, ensuring all financial impacts are accurately recorded in the General Ledger and a clear audit trail is maintained.

## Actors & Stakeholders
- **AR Clerk** (Primary Actor): The user who initiates and creates the Credit Memo.
- **Accounting System** (System): The system of record for the General Ledger (GL), invoices, and Accounts Receivable (AR) balances.
- **Auditor** (Stakeholder): Requires a clear, immutable record of the transaction, its justification, and its link to the original invoice.
- **Payment System** (Downstream System): May be invoked in a subsequent process to issue a cash refund based on the credit established by this memo.

## Preconditions
- The user (AR Clerk) is authenticated and has the necessary permissions (`AR:CreateCreditMemo`).
- A finalized, posted invoice with a non-zero outstanding balance exists in the system.
- A set of valid `Reason Codes` for issuing credit memos is configured in the `Accounting` domain settings (e.g., 'Returned Goods', 'Pricing Error', 'Service Level Credit').

## Functional Behavior
**Trigger:** The AR Clerk selects a finalized invoice from the system and initiates the "Issue Credit Memo" action.

### Process
1.  The system presents the details of the original invoice for confirmation.
2.  The user specifies the amount to be credited, which can be a full or partial amount of the invoice total.
3.  The user **must** select a predefined `Reason Code` from a dropdown list.
4.  The user may add an optional free-text `Justification Note` for auditing purposes.
5.  Upon submission, the system validates the request against the business rules.
6.  On successful validation, the system:
    a. Creates a new `Credit Memo` entity with a unique identifier and a `Posted` status.
    b. Establishes a permanent link between the new `Credit Memo` and the original `Invoice`.
    c. Generates the corresponding, balanced General Ledger (GL) journal entries to:
        -   Debit a Revenue account (reversing revenue).
        -   Debit a Sales Tax Payable account (reversing tax).
        -   Credit the Accounts Receivable (AR) account for the customer, reducing the amount they owe.
    d. Atomically updates the outstanding balance of the original `Invoice`.

## Alternate / Error Flows
- **Error - Invalid Invoice State:** If the selected invoice is not in a `Posted` or `Finalized` state, the system rejects the action with an error message: "Credit Memos can only be issued against finalized invoices."
- **Error - Credit Exceeds Balance:** If the requested credit amount is greater than the outstanding balance of the invoice, the system rejects the action with an error: "Credit amount cannot exceed the invoice's outstanding balance."
- **Error - Missing Reason Code:** If the user submits without selecting a `Reason Code`, the system prevents submission and displays a validation error: "A reason code is required to issue a credit memo."

## Business Rules
- **BR1: Traceability:** A Credit Memo must be immutably linked to a single, existing, finalized Invoice.
- **BR2: Financial Integrity:** The total credited amount against an invoice cannot exceed the original total of that invoice.
- **BR3: Justification:** A `Reason Code` from the centrally managed list is mandatory for all Credit Memos.
- **BR4: Double-Entry Accounting:** All GL journal entries generated by the Credit Memo must be balanced (total debits must equal total credits).
- **BR5: Period-Close Handling:** If the original invoice's accounting period is closed, the system must post the Credit Memo's journal entries to the current open accounting period and correctly flag them as prior period adjustments, per defined accounting policy.

## Data Requirements
### Credit Memo Entity
- `creditMemoId` (PK, Unique Identifier)
- `originalInvoiceId` (FK, non-null, indexed)
- `customerId` (FK, non-null, indexed)
- `creditAmount` (Decimal, non-negative)
- `taxAmountReversed` (Decimal, non-negative)
- `totalAmount` (Decimal, non-negative, `creditAmount` + `taxAmountReversed`)
- `reasonCode` (String, from enumerated list, non-null)
- `justificationNote` (String, optional)
- `status` (Enum: `Draft`, `Posted`, `Applied`, `Voided`)
- `creationTimestamp` (DateTime)
- `postedTimestamp` (DateTime)
- `createdByUserId` (FK)

## Acceptance Criteria
### AC1: Successful Full Credit Memo Creation
- **Given** a finalized invoice #INV-123 for $110 ($100 subtotal + $10 tax) with a full outstanding balance.
- **And** the AR Clerk is authenticated and authorized.
- **When** the clerk creates a full credit memo against #INV-123 with the reason 'Returned Goods'.
- **Then** a new Credit Memo #CM-456 is created for a total of $110.
- **And** Credit Memo #CM-456 is traceably linked to Invoice #INV-123.
- **And** the outstanding balance of Invoice #INV-123 is updated to $0.
- **And** balanced GL journal entries are created to Debit Revenue for $100, Debit Sales Tax Payable for $10, and Credit Accounts Receivable for $110.

### AC2: Successful Partial Credit Memo Creation
- **Given** a finalized invoice #INV-123 for $110 with a full outstanding balance.
- **When** the user creates a partial credit memo for $55 against #INV-123 with the reason 'Pricing Error'.
- **Then** a new Credit Memo is created for a total of $55.
- **And** the outstanding balance of Invoice #INV-123 is updated to $55.
- **And** balanced GL journal entries are created that correctly reverse a proportional amount of revenue and tax.

### AC3: Rejection Due to Amount Exceeding Balance
- **Given** a finalized invoice #INV-123 for $110 with an outstanding balance of $50.
- **When** the user attempts to create a credit memo for $60.
- **Then** the system rejects the request with an error message "Credit amount cannot exceed the invoice's outstanding balance."
- **And** no Credit Memo or GL entries are created.

### AC4: Rejection Due to Missing Reason Code
- **Given** the user is on the 'Create Credit Memo' screen for a valid invoice.
- **When** the user provides a valid amount but attempts to submit without selecting a `Reason Code`.
- **Then** the submission is blocked, and a validation error is displayed on the screen.
- **And** no Credit Memo is created.

## Audit & Observability
- **Audit Trail:** An immutable audit log entry must be created for every Credit Memo creation event. The log must include: `timestamp`, `eventType` (`CREDIT_MEMO_POSTED`), `creditMemoId`, `originalInvoiceId`, `totalAmount`, `reasonCode`, and `actorUserId`.
- **Monitoring:** Emit metrics for `credit_memo.creation.success` and `credit_memo.creation.failure` (with failure reason as a tag).
- **Logging:** All GL posting activities must be logged with correlation IDs linking them back to the `creditMemoId` and `originalInvoiceId`.

## Open Questions
- **Q1 (Domain Conflict Resolution):** This story combines the creation of a `Credit Memo` (`accounting`) and implies a `Refund` (`payment`). To proceed, we need a decision on the recommended split. Is it acceptable to scope this story to *only* the `accounting` functions (creating the memo, adjusting AR), with a separate story to handle the `payment` refund?
- **Q2 (Refund Trigger):** Assuming Q1 is resolved in favor of splitting the stories, what is the business trigger to initiate a cash refund to the customer? Is it an automatic process when a credit memo is created for an already-paid invoice, or is it a separate manual user action in the Payment module?
- **Q3 (Period-Close Policy):** The original story states "Period-close policies handled". Please provide the specific accounting policy. Is it sufficient to post adjustments to the current open period, or are more complex rules for restating prior periods required?
- **Q4 (Approval Workflow):** Does the creation of a Credit Memo require an approval workflow? For example, do memos over a certain dollar amount require manager approval before they are `Posted` and impact the GL?

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #131 ‚Äî [BACKEND] [STORY] AR: Issue Credit Memo / Refund with Traceability

## Current Labels
- backend
- story-implementation
- payment

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] AR: Issue Credit Memo / Refund with Traceability

**Domain**: payment

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Accounts Receivable (Invoice ‚Üí Cash Application)

## Story
AR: Issue Credit Memo / Refund with Traceability

## Acceptance Criteria
- [ ] Credit memo references original invoice and offsets balances
- [ ] GL postings reverse revenue/tax and reduce AR (or drive refund payment)
- [ ] Reason code required and actions audited
- [ ] Period-close policies handled (adjusting entries if needed)


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #130: [BACKEND] [STORY] AP: Create Vendor Bill from Purchasing/Receiving Event
LABELS: payment,type:story,domain:accounting,status:ready-for-dev
BODY:
STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** accounting-strict
---

## Story Intent

**As a** system responsible for financial record-keeping,
**I want to** automatically create a Vendor Bill in a pending state upon receiving a notification of goods received or a vendor invoice,
**So that** Accounts Payable liabilities are recognized promptly and accurately, ensuring a clear audit trail from procurement to payment.

## Actors & Stakeholders

- **System (Accounting Service):** The primary actor responsible for consuming events and creating financial records.
- **AP Clerk (Accounts Payable):** The user who reviews, approves, and processes the created Vendor Bill for payment.
- **Inventory/Purchasing System:** The external system that is the source of the `GoodsReceivedEvent` or `VendorInvoiceReceivedEvent`.
- **Auditor:** A stakeholder who requires clear traceability from the physical event (receiving goods) to the financial records (Vendor Bill, General Ledger).

## Preconditions

- The system has access to a valid Chart of Accounts, including Accounts Payable, Inventory, and relevant Expense accounts.
- The `Vendor` and `Purchase Order` referenced in the incoming event exist and are in a valid state in the system.
- The event message bus/topic is configured, and the Accounting Service is subscribed to the relevant events.

## Functional Behavior

1.  **Event Consumption:** The Accounting Service shall listen for and consume either a `GoodsReceivedEvent` or a `VendorInvoiceReceivedEvent`.
2.  **Payload Validation:** Upon consumption, the system validates the event payload for required fields (e.g., `vendorId`, `purchaseOrderId`, `eventId`, line items).
3.  **Idempotency Check:** The system uses a unique identifier from the event (e.g., `eventId` or a composite key like `vendorInvoiceReference` + `vendorId`) to ensure the same event does not create a duplicate Vendor Bill. If a bill already exists for that identifier, the process stops and logs the duplicate attempt.
4.  **Vendor Bill Creation:** A new `VendorBill` entity is created in the system with an initial status (e.g., `Draft`, `Pending Approval`).
5.  **Data Mapping:** The `VendorBill` is populated with data from the event and the referenced Purchase Order, including vendor details, invoice reference, dates, and line items (product, quantity, price).
6.  **GL Impact Preview:** The system determines the correct General Ledger accounts based on the line items (e.g., Inventory Asset vs. Expense account) and stages the corresponding double-entry transaction (Debit Inventory/Expense, Credit Accounts Payable).
7.  **Traceability Linkage:** The new `VendorBill` record is explicitly linked to the source `eventId`, `purchaseOrderId`, and the resulting `JournalEntryId` once posted.

## Alternate / Error Flows

- **Duplicate Event:** If an event with a previously processed idempotency key is received, the system shall ignore the event, log a warning, and return a success confirmation to prevent retries.
- **Invalid References:** If the `vendorId` or `purchaseOrderId` in the event does not correspond to a valid record, the event is moved to a dead-letter queue (DLQ) for manual investigation, and an alert is raised.
- **Missing GL Account Configuration:** If the system cannot determine the correct debit-side GL account for a line item, the bill creation fails, the event is moved to a DLQ, and an alert is raised.
- **Data Validation Failure:** If the event payload is missing required fields, the event is rejected or moved to a DLQ, and an error is logged.

## Business Rules

- **Idempotency:** Bill creation must be idempotent based on a unique reference from the source event.
- **Default Due Date:** If an invoice due date is not provided, it should be calculated based on the vendor's default payment terms (e.g., Net 30 from the invoice date).
- **Three-Way Match Principle:** The creation logic must be designed to eventually support a three-way match (Purchase Order vs. Goods Receipt vs. Vendor Invoice), even if the initial trigger is a single event. The exact matching policy requires clarification.
- **Bill Status:** A newly created Vendor Bill must enter a non-payable state, such as `Draft` or `Pending Approval`, and cannot be paid until it is explicitly approved.

## Data Requirements

### VendorBill Entity
- `billId`: (UUID, PK)
- `vendorId`: (UUID, FK)
- `purchaseOrderId`: (UUID, FK)
- `sourceEventId`: (String, Indexed) - For traceability
- `vendorInvoiceReference`: (String) - Vendor's invoice number
- `status`: (Enum: `DRAFT`, `PENDING_APPROVAL`, `APPROVED`, `PAID`, `VOID`)
- `billDate`: (Date)
- `dueDate`: (Date)
- `totalAmount`: (Decimal)
- `lineItems`: (Array of Objects)
    - `productId`: (UUID)
    - `description`: (String)
    - `quantity`: (Decimal)
    - `unitPrice`: (Decimal)
    - `lineTotal`: (Decimal)
    - `debitAccountId`: (UUID, FK to GL Account)
- `creditAccountId`: (UUID, FK to GL Account - typically the main AP account)

### Triggering Event (e.g., `VendorInvoiceReceivedEvent`)
- `eventId`: (UUID) - Idempotency key
- `vendorId`: (UUID)
- `purchaseOrderId`: (UUID)
- `invoiceReference`: (String)
- `invoiceDate`: (Date)
- `lineItems`: (Array of Objects)

## Acceptance Criteria

**AC-1: Successful Bill Creation from Goods Receipt**
- **Given** a valid `GoodsReceivedEvent` for an inventory item is published
- **And** no Vendor Bill exists for this `eventId`
- **When** the Accounting Service consumes the event
- **Then** a new Vendor Bill is created in a 'Pending Approval' state
- **And** the bill's line items and amounts match the event payload
- **And** the corresponding GL journal entry is staged, debiting an Inventory asset account and crediting Accounts Payable.

**AC-2: Idempotency Prevents Duplicate Bill Creation**
- **Given** a Vendor Bill has already been created from `eventId-123`
- **When** a second event with the identical `eventId-123` is consumed
- **Then** no new Vendor Bill is created
- **And** the system logs a 'Duplicate event ignored' warning.

**AC-3: Error Handling for Invalid Purchase Order**
- **Given** a `VendorInvoiceReceivedEvent` is published with a `purchaseOrderId` that does not exist
- **When** the Accounting Service consumes the event
- **Then** no Vendor Bill is created
- **And** an error is logged specifying "Invalid Purchase Order reference"
- **And** the event is routed to a dead-letter queue for manual review.

**AC-4: Correct GL Posting for Expense Item**
- **Given** a valid `VendorInvoiceReceivedEvent` for a non-inventory expense item (e.g., 'Consulting Services') is published
- **When** the Accounting Service consumes the event
- **Then** a new Vendor Bill is created
- **And** the corresponding GL journal entry is staged, debiting the appropriate Expense account (e.g., 'Professional Fees') and crediting Accounts Payable.

## Audit & Observability

- **Audit Log:** An immutable audit log must record the creation of every Vendor Bill, linking it to the source event ID, user/system creator, and timestamp.
- **Metrics:** The system should emit metrics for `vendor_bills_created`, `duplicate_events_ignored`, and `bill_creation_failed`.
- **Logging:** Structured logs must be generated at each key step: event received, validation result, idempotency check, bill created, error encountered.
- **Events:** Upon successful creation, the system should publish a `VendorBillCreated` event for downstream consumers (e.g., approval workflows, forecasting).

## Open Questions

1.  **Authoritative Trigger & Matching Policy:** The story mentions "VendorInvoiceReceived (or GoodsReceived)". Which is the primary trigger for bill creation?
    -   **Option A (Receipt Accrual):** `GoodsReceivedEvent` creates the bill, and a later `VendorInvoiceReceivedEvent` is matched against it. This recognizes liability immediately.
    -   **Option B (Invoice Trigger):** `VendorInvoiceReceivedEvent` creates the bill, which is then matched against a `GoodsReceivedEvent` (3-way match).
    -   **Decision Needed:** The business must define the authoritative accounting policy. This is the most critical blocker.
2.  **Initial Bill State:** What is the exact initial state of a newly created bill (e.g., `Draft`, `Pending Approval`)? This determines the immediate next step in the workflow (e.g., data entry completion vs. manager review).
3.  **Discrepancy Handling:** What is the automated process if the quantities or prices on the triggering event do not match the associated Purchase Order? Should the bill be created and flagged for review, or should the process halt and raise an exception for manual intervention?

---

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #130 ‚Äî [BACKEND] [STORY] AP: Create Vendor Bill from Purchasing/Receiving Event

## Current Labels
- backend
- story-implementation
- payment

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] AP: Create Vendor Bill from Purchasing/Receiving Event

**Domain**: payment

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Accounts Payable (Bill ‚Üí Payment)

## Story
AP: Create Vendor Bill from Purchasing/Receiving Event

## Acceptance Criteria
- [ ] VendorInvoiceReceived (or GoodsReceived) event creates an AP bill with PO/receipt refs
- [ ] GL postings: Dr Expense/Inventory, Cr AP (per rules)
- [ ] Traceability links bill ‚Üî event ‚Üî journal entry
- [ ] Idempotent by vendorInvoiceRef/eventId


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #129: [BACKEND] [STORY] AP: Approve and Schedule Payments with Controls
LABELS: type:story,domain:accounting,status:ready-for-dev,agent:story-authoring,agent:accounting
BODY:
## Story Intent
**As an** Accounts Payable (AP) Manager or Clerk,
**I want to** approve bills and schedule them for payment through a controlled workflow,
**so that** financial obligations are met accurately and securely, with a clear audit trail.

## Actors & Stakeholders
- **Actors:**
  - `AP Clerk`: Enters and prepares bills for approval.
  - `AP Manager`: Approves bills and/or schedules payments, often with higher monetary thresholds.
  - `System`: Enforces state transitions, thresholds, and audit logging.
- **Stakeholders:**
  - `Finance Department`: Depends on accurate AP ledger and schedules for cash flow.
  - `Auditors`: Require an immutable record of approvals and scheduling.
  - `Treasury/Payments`: Executes scheduled payments.

## Preconditions
- A `Bill` exists in `DRAFT` state in `domain:accounting`.
- The caller is authenticated and evaluated by the shared authorization layer (`domain:security` or existing auth module).
- Approval thresholds / approval policy is configured in `domain:accounting` (versioned/audited configuration).

## Functional Behavior
### 1) Approve Bill (Accounting SoR)
1. **Trigger:** A user initiates an approval action on a `DRAFT` bill.
2. **Process (accounting):**
   - Verify authorization for approval (permission check via shared auth).
   - Validate the bill amount against the approver‚Äôs threshold (accounting-owned approval policy).
   - Transition bill status `DRAFT ‚Üí APPROVED`.
   - Record an immutable audit entry for the approval.
3. **Outcome:** The bill becomes eligible for payment scheduling.

### 2) Schedule Payment (Accounting SoR)
1. **Trigger:** A user initiates scheduling on an `APPROVED` bill.
2. **Process (accounting):**
   - Verify authorization for scheduling (permission check via shared auth).
   - Validate state prerequisite: bill must be `APPROVED`.
   - Capture scheduling inputs (e.g., `scheduledFor`, `paymentMethod`).
   - Transition bill status `APPROVED ‚Üí SCHEDULED`.
   - Record an immutable audit entry for the scheduling.
   - Emit a versioned event for payment execution consumption by `domain:payment`.
3. **Outcome:** The bill is scheduled for payment execution.

### 3) Execute Payment (Payments domain)
- `domain:payment` consumes the scheduling event to execute the payment.
- `domain:payment` MUST treat the scheduling event as idempotent (no duplicate disbursements on redelivery).
- `domain:payment` emits execution outcome events back (e.g., `Payment.Executed.v1`, `Payment.Failed.v1`).
- `domain:accounting` consumes outcome events to reflect execution outcomes in the accounting-owned bill lifecycle (e.g., later states such as `PAID` / `FAILED` if/when modeled).

## Alternate / Error Flows
- **Approval without permission:** Reject with authorization error; bill remains `DRAFT`.
- **Approval exceeds threshold:** Reject with business rule violation; bill remains `DRAFT`.
- **Schedule without permission:** Reject with authorization error; bill remains `APPROVED`.
- **Schedule on non-approved bill:** Reject with business rule violation; bill state unchanged.

## Business Rules
- **BR-1 (System of Record):** `domain:accounting` is the SoR for Bill lifecycle and state transitions (`DRAFT ‚Üí APPROVED ‚Üí SCHEDULED`, and subsequent states if added).
- **BR-2 (No direct mutation by payments):** `domain:payment` MUST NOT mutate Bill state directly; it reacts to accounting events and reports outcomes via events.
- **BR-3 (State prerequisite):** A bill MUST be `APPROVED` to be scheduled.
- **BR-4 (Authorization):** Approve/schedule actions require explicit authorization (evaluated by shared auth).
- **BR-5 (Threshold policy):** Approval thresholds / approval policy is owned by `domain:accounting` and applied during approval.
- **BR-6 (Idempotency):** `domain:payment` execution MUST be idempotent for a given scheduled payment; use `paymentId` as the idempotency key.

## Data Requirements
### Bill (Accounting)
- `billId` (UUID)
- `billNumber` (string)
- `vendorId` (UUID)
- `status` (Enum: `DRAFT`, `APPROVED`, `SCHEDULED`, ‚Ä¶)
- `amount` (money: currency + value)
- `approvedByUserId` (UUID, nullable)
- `approvedAt` (timestamp, nullable)

### Scheduling (Accounting)
- `paymentId` (UUID) (identifier used across domains)
- `scheduledFor` (date)
- `paymentMethod` (type + instrumentId)
- `scheduledByUserId` (UUID)
- `scheduledAt` (timestamp)

### Approval Policy (Accounting)
- Versioned policy stored in accounting (e.g., `policyId`, threshold definition, minimum approver role)
- Snapshot key details into scheduling events for immutable downstream context.

### Inter-domain Event Contract (Resolved)
- Scheduling event emitted by accounting: `Accounting.PaymentScheduled.v1`
- Outcome events emitted by payments: `Payment.Executed.v1` / `Payment.Failed.v1`

Minimum scheduling event fields include:
- `billId`, `billNumber`, `vendorId`
- `paymentId` (idempotency key)
- `scheduledFor`
- `amount` (currency + value)
- `paymentMethod` (type + instrumentId)
- `requestedByUserId`, `approvedByUserId`
- `approvalPolicySnapshot` (at least `policyId` + threshold)

## Acceptance Criteria
- **AC-1: Approve bill transitions state**
  - Given a bill in `DRAFT` and an authorized approver within threshold
  - When the approver approves the bill
  - Then the bill transitions to `APPROVED` and an approval audit entry is recorded

- **AC-2: Threshold enforcement**
  - Given a bill in `DRAFT` exceeding the caller‚Äôs approval threshold
  - When the caller attempts to approve
  - Then the request is rejected and the bill remains `DRAFT`

- **AC-3: Schedule requires approved state**
  - Given a bill in `DRAFT`
  - When a user attempts to schedule payment
  - Then the request is rejected and the bill remains `DRAFT`

- **AC-4: Schedule emits payment execution contract**
  - Given a bill in `APPROVED` and an authorized scheduler
  - When the bill is scheduled
  - Then the bill transitions to `SCHEDULED`, a scheduling audit entry is recorded, and `Accounting.PaymentScheduled.v1` is emitted containing `paymentId`

## Audit & Observability
- **Audit Log:** Every successful state transition MUST create an immutable audit entry including: `billId`, `oldStatus`, `newStatus`, `principalUserId`, and timestamp.
- **Events:** Emit `Accounting.PaymentScheduled.v1` on scheduling; consume payment outcome events to reflect execution outcomes.
- **Metrics:** Track counts of bills by state (`DRAFT`, `APPROVED`, `SCHEDULED`, ‚Ä¶) and payment execution outcomes (`executed`, `failed`).

## Open Questions
None. (Resolved in decision comment generated by `clarification-resolver.sh` on 2026-01-14.)

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #129 ‚Äî [BACKEND] [STORY] AP: Approve and Schedule Payments with Controls

## Current Labels
- backend
- story-implementation
- payment

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] AP: Approve and Schedule Payments with Controls

**Domain**: payment

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Accounts Payable (Bill ‚Üí Payment)

## Story
AP: Approve and Schedule Payments with Controls

## Acceptance Criteria
- [ ] Bill workflow supports Draft ‚Üí Approved ‚Üí Scheduled
- [ ] Approval thresholds and role permissions enforced
- [ ] Payment scheduling records date/method and audit trail
- [ ] Payment execution blocked unless approved


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #127: [BACKEND] [STORY] Close: Open/Close Accounting Periods with Locks
LABELS: reporting,type:story,domain:accounting,status:needs-review
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** accounting-strict
---

## Story Intent
**As a** Finance or Accounting Manager,
**I want to** create and manage accounting periods (open/close) for each business unit,
**so that** I can enforce financial controls, ensure data integrity for reporting, and prevent transactions from being posted to closed financial periods.

## Actors & Stakeholders
- **Actors:**
  - `Accounting Manager`: A user with privileges to manage the lifecycle of accounting periods (create, close, reopen).
  - `System`: The POS backend and accounting services that enforce period lock rules.
  - `Auditor`: A user who reviews the audit trail for period management actions, especially reopening.
- **Stakeholders:**
  - `Finance Department`: Primary beneficiary, responsible for the accuracy of financial records.
  - `Business Unit Managers`: Rely on accurate reporting derived from controlled accounting periods.
  - `Development Team`: Implements the period locking and enforcement logic.

## Preconditions
1. A system for managing user roles and permissions is in place.
2. A robust audit logging service is available and can be called by the accounting service.
3. The concept of a `Business Unit` is defined and available as a data entity to associate with accounting periods.
4. Transaction posting services are designed to incorporate a validation step against the accounting period status.

## Functional Behavior

### 1. Create Accounting Period
An `Accounting Manager` can define a new accounting period for a specific `Business Unit`.
- **Trigger:** User initiates the "Create Period" action via an API endpoint.
- **Process:**
  - The user provides a `Business Unit ID`, `Start Date`, and `End Date`.
  - The system validates that the new period does not overlap with any existing periods for the same `Business Unit`.
  - Upon successful validation, the system creates the period with an initial status of `Open`.
- **Outcome:** A new accounting period record is created and is ready to accept transactions.

### 2. Close Accounting Period
An `Accounting Manager` can close an `Open` accounting period.
- **Trigger:** User initiates the "Close Period" action for an existing `Open` period.
- **Process:**
  - The system validates that the user has the necessary permissions.
  - The period's status is changed from `Open` to `Closed`.
  - The system records the user ID of the person who closed the period and the timestamp of the closure.
- **Outcome:** The period is now `Closed`. The system will reject any subsequent attempts to post transactions with a date falling within this period's date range.

### 3. Reopen Accounting Period
A specially-privileged `Accounting Manager` can reopen a `Closed` accounting period.
- **Trigger:** User with elevated permissions initiates the "Reopen Period" action.
- **Process:**
  - The user must provide a mandatory `Reason` for reopening the period.
  - The system validates the user has `ACCOUNTING_PERIOD_REOPEN` permission.
  - The period's status is changed from `Closed` to `Open`.
  - The system generates a high-severity audit log event capturing the `periodId`, `reopenedByUserId`, `timestamp`, and the `reason`.
- **Outcome:** The period is `Open` again, and new transactions can be posted to it. An indelible audit trail of this exceptional action is created.

### 4. Posting Enforcement
The `System` automatically enforces the period status during any financial transaction posting.
- **Trigger:** Any service attempts to post a financial transaction.
- **Process:**
  - The posting service retrieves the transaction's date and associated `Business Unit`.
  - It queries the accounting period service to determine the status of the period corresponding to the transaction date for that `Business Unit`.
  - If the period status is `Closed`, the posting request is rejected with a specific error.
- **Outcome:** Financial integrity is maintained by preventing posts to closed periods.

## Alternate / Error Flows
- **Posting to Closed Period:**
  - If a transaction posting is attempted to a date within a `Closed` period, the API MUST reject the request with a clear error code (e.g., `409 Conflict`) and a descriptive message (e.g., `ERR_ACCOUNTING_PERIOD_CLOSED`).
- **Unauthorized Period Management:**
  - If a user without the required permissions attempts to create, close, or reopen a period, the API MUST reject the request with a `403 Forbidden` error.
- **Creating Overlapping Periods:**
  - If a user attempts to create a new period with a date range that overlaps with an existing period for the same `Business Unit`, the API MUST reject the request with a `409 Conflict` error.
- **Reopening Without a Reason:**
  - If a user attempts to reopen a period without providing a reason, the API MUST reject the request with a `400 Bad Request` error.

## Business Rules
- A `Business Unit` can have multiple, non-overlapping accounting periods.
- A period is defined by a `startDate` and an `endDate`, inclusive.
- The lifecycle of a period is `Open` -> `Closed` -> `Open`.
- A reason is **mandatory** for transitioning a period from `Closed` to `Open`.
- Permission to create/close periods (`ACCOUNTING_PERIOD_MANAGE`) is distinct from the permission to reopen a closed period (`ACCOUNTING_PERIOD_REOPEN`). The latter should be more restricted.
- The period-locking logic must be deterministic and consistently enforced across all transaction-posting services.

## Data Requirements
- **`AccountingPeriod` Entity:**
  - `id`: Unique identifier (UUID)
  - `businessUnitId`: Foreign key to the Business Unit entity
  - `startDate`: Date
  - `endDate`: Date
  - `status`: Enum (`OPEN`, `CLOSED`)
  - `createdAt`: Timestamp
  - `updatedAt`: Timestamp
  - `closedByUserId`: Foreign key to User entity (nullable)
  - `closedAt`: Timestamp (nullable)

- **`PeriodReopenAuditEvent` (for Audit Log):**
  - `eventId`: Unique identifier (UUID)
  - `accountingPeriodId`: Foreign key to the Accounting Period
  - `reopenedByUserId`: Foreign key to the User who performed the action
  - `reopenedAt`: Timestamp
  - `reason`: Text (non-nullable)
  - `clientIpAddress`: String

## Acceptance Criteria
**Scenario 1: Successfully closing an accounting period**
- **Given** an `Accounting Manager` is authenticated
- **And** an accounting period exists for Business Unit "HQ" with status `Open`
- **When** the manager submits a request to close that period
- **Then** the system successfully updates the period's status to `Closed`
- **And** records the manager's ID and the current timestamp as the closing details.

**Scenario 2: Rejecting a transaction posted to a closed period**
- **Given** an accounting period for Business Unit "HQ" covering last month is `Closed`
- **When** any system or user attempts to post a transaction with a date from last month to Business Unit "HQ"
- **Then** the API rejects the request with a `409 Conflict` status
- **And** the response body contains the error code `ERR_ACCOUNTING_PERIOD_CLOSED`.

**Scenario 3: Successfully reopening a closed period with proper authorization**
- **Given** a user with `ACCOUNTING_PERIOD_REOPEN` permission is authenticated
- **And** an accounting period for Business Unit "HQ" is `Closed`
- **When** the user submits a request to reopen that period with the reason "Correcting mis-categorized invoice #123"
- **Then** the system updates the period's status to `Open`
- **And** the system generates a detailed audit event for the reopening action.

**Scenario 4: Rejecting an attempt to reopen a period without permission**
- **Given** a standard `Accounting Manager` (without `ACCOUNTING_PERIOD_REOPEN` permission) is authenticated
- **And** an accounting period is `Closed`
- **When** the manager attempts to reopen the period
- **Then** the API rejects the request with a `403 Forbidden` error.

## Audit & Observability
- **Audit:**
  - A high-severity, immutable audit log entry MUST be created whenever a period is reopened. This log must include `who`, `what`, `when`, and `why` (the reason).
  - Log standard-severity events for period creation and closure.
- **Observability:**
  - **Metrics:** Track the number of rejected transactions due to closed periods (`postings.rejected.period_closed`).
  - **Alerting:** Configure a high-priority alert to notify the security/finance team whenever a `PeriodReopenAuditEvent` is logged.

## Open Questions
1.  **Permissions:** What are the specific user roles that will be granted `ACCOUNTING_PERIOD_MANAGE` and the more sensitive `ACCOUNTING_PERIOD_REOPEN` permissions? Please confirm these permission names are suitable.
2.  **Business Unit Definition:** What entity in our system represents a `Business Unit`? Is it a Location, a legal entity, or another construct? The implementation depends on the foreign key relationship.
3.  **Error Propagation:** Is the proposed error response (`409 Conflict` with code `ERR_ACCOUNTING_PERIOD_CLOSED`) sufficient for all upstream clients (e.g., POS terminals, third-party integrations) to handle this failure gracefully?
4.  **Period Temporality:** Can accounting periods be created for future dates? What is the policy on back-dating the creation of periods?
5.  **Domain Confirmation:** Please confirm that `domain:accounting` is the correct primary domain for this capability. The original issue had a `reporting` label, but the core function (controlling financial postings) is an accounting responsibility.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #127 ‚Äî [BACKEND] [STORY] Close: Open/Close Accounting Periods with Locks

## Current Labels
- backend
- story-implementation
- reporting

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Close: Open/Close Accounting Periods with Locks

**Domain**: reporting

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Period Close, Adjustments, and Reporting

## Story
Close: Open/Close Accounting Periods with Locks

## Acceptance Criteria
- [ ] Periods can be created and closed per business unit
- [ ] Closed periods block posting unless reopened with permission
- [ ] Reopen requires reason and is audit-logged
- [ ] Posting logic enforces period policy deterministically


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #126: [BACKEND] [STORY] Adjustments: Create Manual Journal Entry with Controls
LABELS: type:story,domain:accounting,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- none

---
**Rewrite Variant:** accounting-strict
---

## Story Intent
**As an** authorized financial user (e.g., Accountant, Controller),
**I need to** create a controlled, manual journal entry with supporting details,
**So that** I can make necessary financial adjustments to the General Ledger, ensuring accuracy and full auditability.

## Actors & Stakeholders
- **Accountant / Controller (Primary Actor)**: A user with specific permissions to create and manage financial adjustments.
- **System**: The POS backend system responsible for enforcing accounting rules and recording transactions.
- **Auditor (Stakeholder)**: A user who reviews financial records for compliance and accuracy. They are a consumer of the immutable, auditable output.

## Preconditions
1. The user is authenticated and possesses the `ACCOUNTING_ADJUSTMENT_CREATE` permission.
2. The target financial period for the journal entry's `postingDate` is in an `Open` state.
3. A pre-configured list of General Ledger (GL) accounts is available in the system.
4. A pre-configured list of `Reason Codes` for manual adjustments is available in the system.

## Functional Behavior
1. The Accountant initiates the creation of a new manual Journal Entry (JE).
2. The user provides the required header-level information:
    - `postingDate`: The effective date of the entry for financial reporting.
    - `description`: A clear, human-readable summary of the entry's purpose.
    - `reasonCode`: A selection from the pre-configured list of reasons for the adjustment.
3. The user adds two or more Journal Entry Lines, each containing:
    - A valid `glAccountId`.
    - A `debitAmount` or `creditAmount` (but not both).
    - An optional `memo` for line-item specific details.
4. The user submits the completed JE for posting.
5. The System performs validation checks against all defined business rules (see below).
6. Upon successful validation, the System:
    - Persists the Journal Entry and its lines to the General Ledger.
    - Assigns the JE a permanent, unique identifier.
    - Sets the JE status to `POSTED`, rendering it immutable.
    - Generates an audit log entry for the creation event.

## Alternate / Error Flows
- **Error - Unbalanced Entry**: If the sum of `debitAmount`s does not equal the sum of `creditAmount`s, the System rejects the submission with a `VALIDATION_ERROR:UNBALANCED_ENTRY` and does not create the JE.
- **Error - Posting to Closed Period**: If the `postingDate` falls within a `Closed` or `Archived` financial period, the System rejects the submission with a `VALIDATION_ERROR:PERIOD_CLOSED`.
- **Error - Invalid GL Account**: If any `glAccountId` provided is not a valid, active account, the System rejects the submission with `VALIDATION_ERROR:INVALID_ACCOUNT`.
- **Error - Missing Required Fields**: If `postingDate`, `description`, or `reasonCode` are missing, the System rejects the submission with a `VALIDATION_ERROR:MISSING_REQUIRED_FIELD`.
- **Error - Insufficient Permissions**: If the user lacks the `ACCOUNTING_ADJUSTMENT_CREATE` permission, the System denies the initial action.

## Business Rules
- **BR1: Immutability of Posted Entries**: A `POSTED` Journal Entry cannot be edited or deleted. Corrections must be performed by creating a new, separate reversing Journal Entry.
- **BR2: Balance Requirement**: For any given Journal Entry, the total value of all debit lines must exactly equal the total value of all credit lines. A JE with a single line is invalid.
- **BR3: Period Control**: A Journal Entry can only be posted to a financial period that is currently in an `Open` state.
- **BR4: Reason Code Mandate**: Every manual Journal Entry must be associated with a valid, non-null `reasonCode` from the master list.

## Data Requirements
This section defines the logical data model required to support this story.

### Journal Entry Header (`JournalEntry`)
| Field | Type | Constraints | Description |
|---|---|---|---|
| `journalEntryId` | UUID | Primary Key, System-Generated | Unique identifier for the entry. |
| `postingDate` | Date | Required | The date the entry affects the General Ledger. |
| `transactionDate` | DateTime | Required, Default: `NOW()` | The date and time the entry was created. |
| `description` | String | Required, Not Null | A summary of the entry's purpose. |
| `reasonCode` | Enum/String | Required, FK | A code explaining the reason for the manual adjustment. |
| `status` | Enum | Required | The state of the entry (e.g., `POSTED`, `REVERSED`). |
| `createdByUserId`| UUID | Required, FK | The ID of the user who created the entry. |

### Journal Entry Line (`JournalEntryLine`)
| Field | Type | Constraints | Description |
|---|---|---|---|
| `journalEntryLineId`| UUID | Primary Key, System-Generated | Unique identifier for the line item. |
| `journalEntryId` | UUID | Required, FK to `JournalEntry` | The parent Journal Entry. |
| `glAccountId` | UUID | Required, FK to `GLAccount` | The affected General Ledger account. |
| `debitAmount` | Money | Not Null, Min: 0 | The debit value. Must be 0 if `creditAmount` > 0. |
| `creditAmount` | Money | Not Null, Min: 0 | The credit value. Must be 0 if `debitAmount` > 0. |
| `memo` | String | Optional | Line-item specific description. |

## Acceptance Criteria
**Scenario 1: Successful Creation of a Balanced Journal Entry**
- **Given** an Accountant is logged in with `ACCOUNTING_ADJUSTMENT_CREATE` permissions
- **And** the financial period for "today" is `Open`
- **When** the Accountant creates a new manual Journal Entry with:
    - A valid `postingDate`, `description`, and `reasonCode`
    - A line for account `1010` with a debit of `$100.00`
    - A line for account `2020` with a credit of `$100.00`
- **Then** the system successfully validates and posts the entry
- **And** a new Journal Entry with status `POSTED` exists in the General Ledger.

**Scenario 2: Rejection of an Unbalanced Journal Entry**
- **Given** an Accountant is logged in with `ACCOUNTING_ADJUSTMENT_CREATE` permissions
- **And** the financial period for "today" is `Open`
- **When** the Accountant attempts to create a Journal Entry with a total debit of `$100.00` and a total credit of `$99.00`
- **Then** the system rejects the submission with a `VALIDATION_ERROR:UNBALANCED_ENTRY`
- **And** no new Journal Entry is created in the General Ledger.

**Scenario 3: Rejection of Posting to a Closed Financial Period**
- **Given** an Accountant is logged in with `ACCOUNTING_ADJUSTMENT_CREATE` permissions
- **And** the financial period for last month has a status of `Closed`
- **When** the Accountant attempts to create a balanced Journal Entry with a `postingDate` from last month
- **Then** the system rejects the submission with a `VALIDATION_ERROR:PERIOD_CLOSED`
- **And** no new Journal Entry is created in the General Ledger.

**Scenario 4: Posted Journal Entries are Immutable**
- **Given** a Journal Entry with ID `JE-123` has a status of `POSTED`
- **When** any user, regardless of permissions, attempts to update or delete `JE-123`
- **Then** the system denies the request with an `IMMUTABLE_RECORD` error.

## Audit & Observability
- **Audit Trail**: The creation of every manual Journal Entry MUST be recorded in an immutable audit log. The log entry must include `journalEntryId`, `createdByUserId`, `timestamp`, and the full payload of the created entry.
- **Logging**:
    - `INFO`: Log successful JE creation with `journalEntryId`.
    - `WARN`: Log all validation failures with details of the failure (e.g., `UNBALANCED_ENTRY`, `PERIOD_CLOSED`) and the user who made the attempt.
- **Metrics**:
    - `manual_je_creations.success.count`: A counter for successfully posted manual JEs.
    - `manual_je_creations.failure.count`: A counter for failed submission attempts, tagged by reason (e.g., `reason:unbalanced`, `reason:period_closed`).

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #126 ‚Äî [BACKEND] [STORY] Adjustments: Create Manual Journal Entry with Controls

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Adjustments: Create Manual Journal Entry with Controls

**Domain**: user

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Period Close, Adjustments, and Reporting

## Story
Adjustments: Create Manual Journal Entry with Controls

## Acceptance Criteria
- [ ] Authorized users can create manual JEs with reason code
- [ ] System blocks unbalanced manual JEs
- [ ] Posted manual JEs are immutable (corrections via reversal)
- [ ] Posting respects period controls and audit requirements


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #125: [BACKEND] [STORY] Reporting: Produce Core Financial Statements with Drilldown
LABELS: reporting,type:story,domain:accounting,status:ready-for-dev
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

**Rewrite Variant:** accounting-strict
## Story Intent
**As a** Financial Controller or Accountant,
**I want to** generate core financial statements (Profit & Loss and Balance Sheet) for a specified accounting period,
**So that I can** assess the company's financial health, perform period-end analysis, and meet regulatory reporting requirements.

## Actors & Stakeholders
- **Financial Controller / Accountant (User):** The primary user who generates, views, and analyzes the financial statements.
- **System Administrator:** Manages user roles and permissions, ensuring only authorized personnel can access sensitive financial data.
- **Auditor (Indirect):** A stakeholder who will consume the output of this functionality to perform financial audits. The reports must be accurate and reproducible.

## Preconditions
- A Chart of Accounts (COA) is configured in the system, defining accounts and their classifications (e.g., Asset, Liability, Equity, Revenue, Expense).
- The system contains posted General Ledger (GL) entries with associated accounts, dates, and amounts for the reporting period.
- The user is authenticated and has the necessary permissions to access the financial reporting module.

## Functional Behavior
1.  The user navigates to the financial reporting section of the application.
2.  The user selects the type of report to generate: "Profit & Loss Statement" or "Balance Sheet".
3.  The user specifies the required parameters for the report, such as the date range (for P&L) or a specific end date (for Balance Sheet).
4.  The system initiates a process to aggregate all relevant `Posted` GL entries based on the specified parameters and the account classifications in the COA.
5.  The system calculates the balances for each line item on the selected financial statement.
6.  The report is displayed to the user in a structured format.
7.  The user can interact with a line item on the statement (e.g., "Office Expenses") to "drill down".
8.  The drill-down view displays the list of general ledger accounts that contribute to that line item's total.
9.  From the account list, the user can further drill down to see the individual journal lines (GL entries) that make up that account's balance for the period.
10. The user has an option to export the generated report.

## Alternate / Error Flows
- **No Data for Period:** If no posted GL entries exist for the selected parameters, the system displays a message indicating "No data available for the selected period" instead of an empty or erroneous report.
- **Unauthorized Access:** If a user without the required permissions attempts to generate or view a report, the system denies access and displays an appropriate authorization error.
- **Invalid Parameters:** If the user provides invalid parameters (e.g., end date before the start date for a P&L), the system presents a validation error and prevents the report from being generated.

## Business Rules
- Financial statements must ONLY be generated from `Posted` General Ledger entries. Unposted or draft entries must be excluded.
- The structure of the P&L and Balance Sheet must conform to standard accounting principles. The specific structure and account mappings must be configurable or defined based on a specified standard.
- All calculations (e.g., summations, net income) must be precise and auditable.
- Access to financial reporting is role-based. Viewing, generating, and exporting can be controlled by distinct permissions.
- Reports for a closed accounting period must be immutable and reproducible. Running the same report for the same period at a later date must yield the exact same results.

## Data Requirements
- **GeneralLedgerEntry:** Requires fields for `EntryID`, `AccountID`, `TransactionDate`, `Amount` (Debit/Credit), `Status` (e.g., 'Posted', 'Draft'), and a link to the `SourceEventID`.
- **ChartOfAccounts:** Defines the hierarchy and classification of all financial accounts, including `AccountID`, `AccountName`, `AccountType` (Asset, Liability, Equity, Revenue, Expense), and `ParentAccountID`.
- **FinancialStatementDefinition:** A data structure or configuration that maps accounts from the Chart of Accounts to specific lines on the P&L and Balance Sheet.

## Acceptance Criteria
**Scenario 1: Generate a Profit & Loss Statement**
- **Given** a set of posted General Ledger entries for a specific accounting period, including revenue and expense transactions,
- **When** the Financial Controller requests a Profit & Loss statement for that period,
- **Then** the system generates a report showing total revenues, total expenses, and the resulting net income (or loss),
- **And** the figures correctly sum the amounts from the corresponding GL entries.

**Scenario 2: Generate a Balance Sheet**
- **Given** a set of posted General Ledger entries up to a specific date,
- **When** the Accountant requests a Balance Sheet as of that date,
- **Then** the system generates a report showing total assets, total liabilities, and total equity,
- **And** the fundamental accounting equation (Assets = Liabilities + Equity) is balanced.

**Scenario 3: Drill-down from a Statement Line to Source Transactions**
- **Given** a generated P&L statement is displayed,
- **When** the user clicks on the "Operating Expenses" line item,
- **Then** the system displays a list of all operating expense accounts (e.g., "Salaries", "Rent", "Utilities") and their balances for the period.
- **And When** the user then clicks on the "Rent" account,
- **Then** the system displays the individual journal lines that were posted to the "Rent" account within the period.

**Scenario 4: Unauthorized User Attempts to Access Reports**
- **Given** a user is logged in who does not have "View Financial Statements" permission,
- **When** they attempt to navigate to the financial reporting URL,
- **Then** the system presents an "Access Denied" error page and does not display any financial data.

**Scenario 5: Exporting a Financial Statement**
- **Given** a valid Balance Sheet has been generated for a specific date,
- **When** the user clicks the "Export" button,
- **Then** the system generates a file (e.g., CSV or PDF) containing the complete Balance Sheet data,
- **And** the downloaded file is correctly formatted and matches the on-screen report.

## Audit & Observability
- **Audit Log:** Every instance of a financial statement generation must be logged, capturing `UserID`, `ReportType`, `ReportParameters` (e.g., date range), `Timestamp`, and a `RequestID`.
- **Performance Monitoring:** The performance of the report generation queries should be monitored. Alerts should be configured for queries that exceed a predefined execution time threshold.
- **Data Integrity:** The system should have mechanisms (e.g., scheduled checks) to ensure the Balance Sheet always balances for any given period, flagging any anomalies.

## Open Questions
1.  **Chart of Accounts Mapping:** What is the specific Chart of Accounts (COA) structure to be used for mapping ledger accounts to statement lines? Is this a fixed structure, or does it need to be user-configurable?
2.  **Accounting Standard:** Which accounting standard (e.g., GAAP, IFRS) should the structure of the "basic" P&L and Balance Sheet follow? This impacts the naming and grouping of line items.
3.  **Access Control Granularity:** What are the specific roles and permissions required? Is there a difference between viewing reports and exporting them?
4.  **Export Formats:** What specific export formats are required for launch (e.g., PDF, CSV, XLSX)?
5.  **Multi-Entity/Currency:** How should the system handle multi-entity consolidation or multi-currency scenarios? (Assumption for now: This story covers a single entity in a single currency).

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #125 ‚Äî [BACKEND] [STORY] Reporting: Produce Core Financial Statements with Drilldown

## Current Labels
- backend
- story-implementation
- reporting

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Reporting: Produce Core Financial Statements with Drilldown

**Domain**: reporting

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Period Close, Adjustments, and Reporting

## Story
Reporting: Produce Core Financial Statements with Drilldown

## Acceptance Criteria
- [ ] Produce P&L and Balance Sheet (basic) from posted ledger lines
- [ ] Drilldown: statement line ‚Üí accounts ‚Üí journal lines ‚Üí source events
- [ ] Reports are reproducible for the same parameters
- [ ] Exports supported and access controls enforced


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #124: [BACKEND] [STORY] Audit: Maintain Immutable Ledger Audit Trail and Explainability
LABELS: type:story,domain:accounting,status:ready-for-dev
BODY:
## Story Intent
**As a** Financial Controller,
**I need** every financial posting to be immutable and fully traceable back to its source business event and the accounting mapping/rules versions that generated it,
**so that** audits, reconciliation, and regulatory compliance are achievable and explainable.

## Actors & Stakeholders
- **System (Primary Actor):** Accounting Service (creates JEs / ledger lines)
- **Financial Controller / Auditor:** audits and explains postings
- **Upstream Domains:** Sales / Inventory / Payments (authoritative sources for their business events)

## Preconditions
- Chart of Accounts exists and is accessible.
- Accounting mapping versions and rule versions are versioned and retrievable.
- Upstream domains publish uniquely identified business events.
- Accounting defines a ‚ÄúPosted‚Äù state for entries.

## Functional Behavior
1. **Select rule + mapping versions:** When processing a business event, Accounting identifies the applicable `mappingVersionId` and `ruleVersionId`.
2. **Create posting records:** Generate `JournalEntry` and `LedgerLine` records with full traceability fields.
3. **Persist traceability (resolved):** Persist these immutable UUID identifiers on every JE:
   - `sourceEventId` (UUIDv7 from upstream event)
   - `mappingVersionId` (UUIDv7 from Accounting mapping configuration)
   - `ruleVersionId` (UUIDv7 from Accounting rule set)
4. **Capture event snapshot (resolved):** Persist an immutable `sourceEventSnapshot` (JSONB) on the JE containing the details required for audit/posting.
5. **Post atomically:** Validate balanced debits/credits and transition to `POSTED` within a single transaction.
6. **Enforce immutability:** Once `POSTED`, prohibit direct update/delete of JEs and ledger lines.
7. **Correct via reversal:** Corrections are made by creating a new reversing JE referencing `originalJournalEntryId`.

## Alternate / Error Flows
- Missing traceability identifiers or versions ‚Üí fail the posting; no partial persistence.
- Attempted UPDATE/DELETE of `POSTED` records ‚Üí reject and emit a high-severity audit event.

## Business Rules
- **Immutability:** `POSTED` JournalEntries and LedgerLines are immutable.
- **Mandatory traceability:** All `POSTED` JournalEntries must include non-null `sourceEventId`, `mappingVersionId`, `ruleVersionId`.
- **Reversal-only corrections:** Corrections must be new reversing entries referencing the original.

## Data Requirements
- Traceability IDs are **UUIDs (RFC 4122 v7)**.
- `JournalEntry` includes:
  - `journalEntryId` (UUIDv7)
  - `sourceEventId` (UUIDv7)
  - `sourceEventType` (string)
  - `mappingVersionId` (UUIDv7)
  - `ruleVersionId` (UUIDv7)
  - `originalJournalEntryId` (UUIDv7, nullable)
  - `sourceEventSnapshot` (JSONB, immutable)
  - `status` (DRAFT/POSTED/REVERSED)
  - `postedTimestamp` (UTC)

## Explainability (resolved)
- **v1.0 (this story):** No public-facing explainability endpoint required; data model + internal audit tooling must support traceability queries.
- **v2.0 (future enhancement):** Optional public API like `GET /accounting/v1/traceability/{journalEntryId}` (out of scope here).

## Event Data Authority (resolved)
- Each upstream domain remains authoritative for its own event details.
- Accounting stores immutable event snapshots needed for posting/audit and links back to source domains for drilldown.

## Acceptance Criteria
- **AC1 (Immutability - Update Reject):** UPDATE attempt on `POSTED` entry is rejected (e.g., `409 Conflict`) and audited.
- **AC2 (Immutability - Delete Reject):** DELETE attempt on `POSTED` entry is rejected (e.g., `409 Conflict`) and audited.
- **AC3 (Traceability Present):** `POSTED` JE contains `sourceEventId`, `mappingVersionId`, `ruleVersionId`.
- **AC4 (Internal Traceability Query):** Internal tooling can retrieve chain: JE ‚Üí sourceEventId ‚Üí mappingVersionId ‚Üí ruleVersionId ‚Üí ledger lines ‚Üí audit log.
- **AC5 (Reversal Traceability):** Reversal JE references original JE via `originalJournalEntryId`.

## Audit & Observability
- Emit high-severity audit event for attempted mutation of posted records.
- Structured logs for JE posting include full traceability context.
- Metrics include `journal_entries_posted_total` and `journal_entries_reversed_total` tagged by `sourceEventType`.

## Open Questions
None (resolved via clarification #290).

---

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #124 ‚Äî [BACKEND] [STORY] Audit: Maintain Immutable Ledger Audit Trail and Explainability

## Current Labels
- backend
- story-implementation
- general

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Audit: Maintain Immutable Ledger Audit Trail and Explainability

**Domain**: general

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Reconciliation, Audit, and Controls

## Story
Audit: Maintain Immutable Ledger Audit Trail and Explainability

## Acceptance Criteria
- [ ] Ledger lines and JEs are immutable once posted (corrections via reversal)
- [ ] Store rule version and mapping version used for each posting
- [ ] Provide explainability view: event ‚Üí mapping ‚Üí rules ‚Üí JE ‚Üí ledger lines
- [ ] Full traceability from any GL line to source event/business document


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #123: [BACKEND] [STORY] Reconciliation: Support Bank/Cash Reconciliation Matching
LABELS: payment,type:story,domain:accounting,status:needs-review,status:ready-for-dev
BODY:
STOP: Conflicting domain guidance detected
STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- status:needs-review

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- blocked:domain-conflict
- blocked:clarification

## ‚ö†Ô∏è Domain Conflict Summary
- **Candidate Primary Domains:** `domain:accounting`, `domain:payment`
- **Why conflict was detected:** The issue has a legacy `payment` label, but the functional requirements explicitly describe a core accounting process (reconciliation). The `/kiro` block correctly identifies the domain as `accounting`. The reconciliation process consumes payment data but is owned and governed by accounting principles and workflows.
- **What must be decided:** Confirm that `domain:accounting` is the primary (authoritative) domain for the Bank Reconciliation feature. The `payment` domain will be a secondary, data-providing domain.
- **Recommended split:** No split needed. The story should be owned entirely by the `accounting` domain. The `payment` label should be removed and replaced with `domain:accounting`.

**Rewrite Variant:** accounting-strict

## Story Intent

**As an** Accountant,
**I need to** perform bank reconciliation by matching imported bank statement transactions with system-recorded payments and receipts,
**so that I can** ensure financial accuracy, identify discrepancies, and maintain a complete and auditable financial record for a given period.

## Actors & Stakeholders

- **Accountant (Primary User):** Performs the reconciliation, creates adjustments, and finalizes the reconciliation report.
- **System (POS Platform):** Acts as the source system for payment and receipt transactions to be reconciled.
- **Auditor (Indirect Consumer):** Consumes the finalized reconciliation reports and associated audit trails to verify financial integrity.

## Preconditions

1.  The user is authenticated as an 'Accountant' or a role with equivalent permissions for financial reconciliation.
2.  A chart of accounts, including specific General Ledger (GL) accounts for bank fees and interest, is configured in the system.
3.  A set of unreconciled payment and receipt transactions exists within the system for the period being reconciled.
4.  The bank statement for the corresponding period is available for import in a supported format (e.g., CSV, OFX).

## Functional Behavior

### 1. Initiate Reconciliation
- The Accountant selects a bank account and a date range to start a new reconciliation process.
- The system creates a `Reconciliation` entity in a `Draft` state, pre-populating the starting balance from the previous period's closing balance.

### 2. Import Bank Statement
- The Accountant uploads a bank statement file.
- The system parses the file, validates its format, and imports each line item as a `BankStatementLine` linked to the draft reconciliation.
- The system displays a two-sided view: imported bank statement lines on one side and unreconciled system transactions on the other.

### 3. Match Transactions
- The system may suggest potential matches based on date, amount, and reference number.
- The Accountant can manually match one or more system transactions to a single bank statement line (and vice-versa).
- As items are matched, they are moved from the "unmatched" to the "matched" state within the current reconciliation view.

### 4. Create Adjustments
- If a bank statement line (e.g., a bank fee or interest earned) has no corresponding system transaction, the Accountant can create an `Adjustment`.
- Creating an adjustment requires selecting a predefined reason (e.g., "Bank Fee"), associating it with the correct GL Account, and providing a description.
- This action generates the necessary journal entries to ensure the books remain balanced.

### 5. Finalize Reconciliation
- Once the difference between the adjusted book balance and the bank statement's closing balance is zero, the Accountant can finalize the reconciliation.
- The system transitions the `Reconciliation` entity and all associated matches/adjustments to a `Finalized` state.
- Once finalized, the reconciliation becomes immutable and cannot be edited or reopened.

### 6. Generate Report
- Upon finalization, the system generates a Reconciliation Report detailing the starting balance, all matched transactions, all adjustments, and the closing balance.

## Alternate / Error Flows

- **Import Failure:** If the uploaded bank statement file is in an unsupported format or is corrupted, the system displays a descriptive error message and does not import any data.
- **Mismatched Balances:** If the Accountant attempts to finalize a reconciliation where the adjusted book balance does not equal the statement's closing balance, the system prevents finalization and highlights the discrepancy.
- **Invalid Adjustment:** If an Accountant tries to create an adjustment without selecting a valid GL account, the system displays a validation error and prevents the adjustment from being saved.
- **Permission Denied:** If a user without the required permissions attempts to initiate or finalize a reconciliation, the system denies the action.

## Business Rules

- A `Reconciliation` can only be finalized if the calculated `(Book Balance + Adjustments - Statement Balance)` difference is zero.
- Once a `Reconciliation` is `Finalized`, it is read-only. Any corrections require reversing and re-issuing journal entries in a subsequent period, per standard accounting practices.
- All `Adjustments` must be mapped to a valid General Ledger account.
- A single system transaction can only be matched within one `Reconciliation`.

## Data Requirements

- **Reconciliation:**
  - `reconciliationId` (UUID, PK)
  - `bankAccountId` (FK)
  - `periodStartDate`, `periodEndDate` (Date)
  - `openingBalance`, `closingBalance` (Decimal)
  - `status` (Enum: `DRAFT`, `FINALIZED`)
  - `finalizedByUserId` (FK)
  - `finalizedAt` (Timestamp)
- **BankStatementLine:**
  - `statementLineId` (UUID, PK)
  - `reconciliationId` (FK)
  - `transactionDate` (Date)
  - `description` (String)
  - `amount` (Decimal)
  - `type` (Enum: `DEBIT`, `CREDIT`)
  - `status` (Enum: `UNMATCHED`, `MATCHED`)
- **ReconciliationMatch:**
  - `matchId` (UUID, PK)
  - `reconciliationId` (FK)
  - `statementLineId` (FK)
  - `systemTransactionId` (FK to Payment/Receipt domain)
- **ReconciliationAdjustment:**
  - `adjustmentId` (UUID, PK)
  - `reconciliationId` (FK)
  - `statementLineId` (FK, optional)
  - `glAccountId` (FK)
  - `amount` (Decimal)
  - `description` (String)
  - `journalEntryId` (FK)

## Acceptance Criteria

**Scenario 1: Successful One-to-One Transaction Matching**
- **Given** an Accountant has started a reconciliation for July with an imported bank statement.
- **And** the bank statement shows a debit of $55.50 on July 10th.
- **And** the POS system has an unreconciled payment of $55.50 from July 10th.
- **When** the Accountant selects both the bank statement line and the system payment and clicks "Match".
- **Then** both items are marked as "Matched" for the current reconciliation.
- **And** the outstanding difference to be reconciled is updated correctly.

**Scenario 2: Creating an Adjustment for a Bank Fee**
- **Given** an Accountant is reconciling a period.
- **And** the bank statement shows a $15.00 "Monthly Service Fee" line that has no corresponding system transaction.
- **When** the Accountant selects the fee and chooses the "Create Adjustment" action.
- **And** they select the "Bank Fees" GL account and save the adjustment.
- **Then** a new adjustment transaction is created and linked to the reconciliation.
- **And** a corresponding journal entry is posted to the General Ledger.
- **And** the bank statement line is marked as "Matched".

**Scenario 3: Generating a Finalized Reconciliation Report**
- **Given** a reconciliation has been fully matched and the difference is zero.
- **When** the Accountant clicks the "Finalize" button.
- **Then** the reconciliation status is changed to `Finalized` and it becomes read-only.
- **And** the system generates a downloadable Reconciliation Report containing the opening/closing balances, cleared transactions, and all adjustments.

**Scenario 4: Attempting to Finalize with a Discrepancy**
- **Given** an Accountant is reconciling a period.
- **And** there is a remaining difference of $10.00 between the adjusted book balance and the statement balance.
- **When** the Accountant attempts to finalize the reconciliation.
- **Then** the system displays an error message stating "Reconciliation cannot be finalized with a non-zero difference".
- **And** the reconciliation remains in the `Draft` state.

## Audit & Observability

- **Audit Trail:** Every significant action (Reconciliation created, statement imported, item matched/unmatched, adjustment created, reconciliation finalized) must be logged with the user ID, timestamp, and relevant entity IDs.
- **Events:** The system should emit domain events upon key state changes, such as `ReconciliationFinalized`, to allow downstream systems (e.g., reporting) to react.
- **Metrics:** Track the number of reconciliations in `Draft` vs. `Finalized` state, and the average time to finalize a reconciliation.

## Open Questions

1.  **Import Formats:** What specific file formats must be supported for bank statement import (e.g., CSV, OFX, BAI2)? For CSV, what is the required column structure?
2.  **Matching Tolerance:** Is there a requirement for a matching tolerance (e.g., automatically matching a $100.00 payment to a $99.99 bank line due to minor fees)? If so, what is the tolerance threshold and how are discrepancies handled in the GL?
3.  **Default GL Accounts:** Can default GL accounts be pre-configured for common adjustment types like "Bank Fee" and "Interest Earned" to streamline the user workflow?
4.  **Inter-Domain Contract:** What is the precise contract for retrieving unreconciled transactions from the `payment` domain? Does the `accounting` service query an API, or does it consume events? What is the authoritative definition of a "reconcilable" transaction?
5.  **Report Content:** What specific fields, subtotals, and summaries must be included in the final, auditable Reconciliation Report?

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #123 ‚Äî [BACKEND] [STORY] Reconciliation: Support Bank/Cash Reconciliation Matching

## Current Labels
- backend
- story-implementation
- payment

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Reconciliation: Support Bank/Cash Reconciliation Matching

**Domain**: payment

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Reconciliation, Audit, and Controls

## Story
Reconciliation: Support Bank/Cash Reconciliation Matching

## Acceptance Criteria
- [ ] Import/enter bank statement lines and match to payments/receipts
- [ ] Track matched/unmatched items with audit trail
- [ ] Allow controlled adjustments (fees/interest) via proper entries
- [ ] Produce reconciliation report


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #122: [BACKEND] [STORY] Controls: Route Unmapped or Failed Events to Suspense Queue and Reprocess
LABELS: type:story,domain:accounting,status:ready-for-dev,agent:story-authoring,agent:accounting
BODY:
## Story Intent
**As an** Accountant or System Administrator,
**I want** unmapped / business-rule posting failures to be routed into an accounting-owned suspense queue,
**so that** failures can be investigated and safely reprocessed to protect financial completeness and integrity.

## Actors & Stakeholders
- **Accountant:** Resolves accounting-rule/mapping failures and validates final outcomes.
- **System Administrator:** Investigates technical causes and triggers reprocessing (where authorized).
- **Event Ingestion / Posting Pipeline:** Detects failures and creates suspense entries.
- **General Ledger Posting (Accounting):** Downstream posting consumer for successful reprocessing.

## Preconditions
- An event ingestion + accounting posting pipeline exists.
- Accounting mapping / posting rules exist and are externally correctable (rule correction mechanism is out of scope here).
- Users are authenticated and authorized to view and reprocess suspense entries.

## Functional Behavior
### 1) Detect and Suspend (Accounting controls)
1. **Trigger:** The ingestion/posting pipeline processes an incoming event and encounters a recoverable **business-rule/mapping** failure.
2. **Classification:** Assign a structured `failure_reason_code` (e.g., `UNMAPPED_EVENT_TYPE`, `INVALID_MAPPING_VERSION`, `RULE_CONFLICT`).
3. **Persist suspense entry:**
   - MUST NOT discard the event.
   - MUST create a suspense entry with immutable original event payload (or immutable reference), failure code/details, timestamps, attempt counters, and status `SUSPENDED`.
   - SHOULD record accounting-relevant context (e.g., event type, intended posting intent, mapping/rule version attempted).

### 2) Reprocess (Manual or automated trigger)
1. **Trigger:** An authorized user (or an automated job) requests reprocessing for a specific suspense entry.
2. **Attempt logging:**
   - Increment `attempt_count` and write a reprocessing-attempt history record with timestamp + actor.
3. **Re-run logic:** Re-run mapping/posting using **current** rules by default.
4. **On success:**
   - Post successfully to the downstream ledger/posting component.
   - Update suspense entry status to `PROCESSED`.
   - Store `final_posting_reference_id` and `processed_at/resolved_at` for permanent traceability.
5. **On failure:**
   - Keep status `SUSPENDED` (or optionally move to `FAILED` after policy threshold).
   - Update latest error details + timestamps.

## Alternate / Error Flows
- **Reprocess terminal entry:** If reprocess is requested for a `PROCESSED` (or other terminal) entry, reject with `409 Conflict` and do not create duplicate postings.
- **Unauthorized access:** If the caller lacks permission to reprocess, reject with `403 Forbidden`.

## Business Rules
- **BR-1 (Domain ownership):** This suspense queue is an **accounting controls** mechanism (business-rule suspense), not a generic `workexec` DLQ.
- **BR-2 (Payload immutability):** Original event payload/reference in suspense is immutable.
- **BR-3 (Idempotency):** Reprocessing MUST be idempotent; a single suspense entry can produce at most one successful downstream posting.
- **BR-4 (Auditability):** Maintain an indelible history of reprocess attempts (who/when/outcome/details).

## Data Requirements
### Suspense Entry
- `suspense_entry_id` (UUID, PK)
- `original_event_payload` (JSONB/TEXT) or `original_event_ref` (immutable reference)
- `status` (ENUM: `SUSPENDED`, `PROCESSED`, optionally `FAILED`)
- `failure_reason_code` (TEXT/ENUM)
- `failure_details` (TEXT)
- `event_type` (TEXT)
- `mapping_version_attempted` (TEXT, nullable)
- `created_at`, `updated_at`, `processed_at` (timestamps)
- `attempt_count` (int)
- `final_posting_reference_id` (TEXT, nullable)
- `resolved_by_user_id` (UUID/TEXT, nullable)

### Reprocessing Attempt History
- `attempt_id` (PK)
- `suspense_entry_id` (FK)
- `attempted_at` (timestamp)
- `triggered_by_user_id` (UUID/TEXT)
- `outcome` (`SUCCESS` | `FAILURE`)
- `outcome_details` (TEXT)

## Retention & Purge (Resolved)
- `PROCESSED`: retain 90 days, then purge eligible.
- `SUSPENDED`: retain 365 days (or until processed), then purge eligible.
- `FAILED` (if used): retain 365 days, then purge eligible.
- Implement a scheduled cleanup job (e.g., daily) to delete by status + age.

## Acceptance Criteria
- **AC-1: Mapping failure creates suspense entry**
  - Given an incoming event that cannot be mapped/posted due to accounting-rule/mapping failure
  - When processed
  - Then a suspense entry is created as `SUSPENDED` with `failure_reason_code` and immutable original payload/reference

- **AC-2: Successful reprocess posts and closes entry**
  - Given a `SUSPENDED` entry and the underlying mapping/rule is corrected externally
  - When an authorized user triggers reprocessing
  - Then posting succeeds, the entry becomes `PROCESSED`, and `final_posting_reference_id` is stored

- **AC-3: Idempotent reprocess**
  - Given an entry is `PROCESSED`
  - When reprocess is requested again
  - Then the system returns `409 Conflict` and makes no duplicate posting

- **AC-4: Attempt history maintained**
  - Given reprocess is attempted
  - When it succeeds or fails
  - Then a history record is stored with timestamp, actor, outcome, and details, and `attempt_count` is incremented

## Audit & Observability
- Structured audit log for suspense state changes and reprocess attempts.
- Metrics: created count by `failure_reason_code`, reprocess attempts by outcome, active suspended gauge, and alerting on sustained growth.

## Open Questions
None. (Resolved in decision comment generated by `clarification-resolver.sh` on 2026-01-14.)

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #122 ‚Äî [BACKEND] [STORY] Controls: Route Unmapped or Failed Events to Suspense Queue and Reprocess

## Current Labels
- backend
- story-implementation
- admin

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Controls: Route Unmapped or Failed Events to Suspense Queue and Reprocess

**Domain**: admin

### Story Description

/kiro
# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Capability
[CAP] Reconciliation, Audit, and Controls

## Story
Controls: Route Unmapped or Failed Events to Suspense Queue and Reprocess

## Acceptance Criteria
- [ ] Unmapped/failed events go to Suspense with actionable missing-key details
- [ ] Admin can correct mapping/rules and reprocess
- [ ] Reprocess is idempotent (no duplicate postings)
- [ ] Attempt history and final posting references are retained


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #121: [BACKEND] [STORY] Accounting: Ingest InventoryIssued Event
LABELS: type:story,domain:accounting,status:ready-for-dev
BODY:
STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** accounting-strict
---

## Story Intent
**As an** Accounting System,
**I want to** process `InventoryIssued` events by creating corresponding double-entry journal postings,
**so that** inventory asset value is accurately decreased and the corresponding expense (Cost of Goods Sold or Work-in-Progress) is recognized in the general ledger at the time of use.

## Actors & Stakeholders
- **System Actors**:
    - `Accounting System`: The primary actor responsible for processing the event and maintaining the general ledger.
    - `Workorder Execution System`: The upstream system that is the source of the `InventoryIssued` event.
- **Human Stakeholders**:
    - `Accountant`: Relies on the accuracy and timeliness of these automated postings for financial reporting.
    - `Inventory Manager`: Is concerned with the accurate valuation and tracking of inventory assets.
    - `Auditor`: Requires clear traceability from financial statements back to source operations.

## Preconditions
- The `Accounting System` is successfully subscribed to the message topic/queue for `InventoryIssued` events.
- The company's Chart of Accounts, including specific GL accounts for Inventory Assets, Cost of Goods Sold (COGS), and Work-in-Progress (WIP), is configured in the system.
- The authoritative inventory valuation method (e.g., Average Cost, FIFO) is configured.
- Business rules for determining whether an inventory issue maps to a COGS vs. a WIP expense are defined and configured.

## Functional Behavior
### Trigger
The `Accounting System` receives an `InventoryIssued` event from the `Workorder Execution System`.

### Main Flow
1.  The system ingests the `InventoryIssued` event.
2.  The system validates the event payload against the `Durion Accounting Event Contract v1` schema.
3.  The system checks the event's idempotency key (`eventId`) against its record of processed events. If the key has already been processed, the flow terminates here (see Alternate Flow: Duplicate Event).
4.  The system retrieves the current valuation for the specified `inventoryItemId` using the configured valuation method (e.g., Average Cost).
5.  The system determines the target expense account (COGS or WIP) based on configured business rules (see Open Questions).
6.  The system constructs a double-entry journal transaction in a `pending` state:
    - **Credit:** The configured Inventory Asset GL account for the calculated value (`quantityIssued` √ó `unit_cost`).
    - **Debit:** The determined COGS or WIP GL account for the same value.
7.  The system persists the journal entry, linking it immutably to the source `eventId`, `workorderId`, and `inventoryIssueId` for full traceability.
8.  The system marks the `eventId` as successfully processed.
9.  The system acknowledges the event to the message bus.

## Alternate / Error Flows
- **Duplicate Event**: If the idempotency key (`eventId`) has already been processed, the system logs the detection of a duplicate, acknowledges the event to the message bus, and takes no further action.
- **Schema Validation Failure**: If the event payload fails schema validation, the system rejects the event, logs a structured error containing the payload and validation failures, and moves the message to a dead-letter queue (DLQ) for manual investigation.
- **Invalid Inventory Reference**: If the `inventoryItemId` from the event does not correspond to a known item in the accounting system's master data, the system logs a critical error, moves the event to the DLQ, and raises a high-priority alert.
- **GL Posting Failure**: If the journal entry fails to post to the General Ledger (e.g., due to a closed accounting period, inactive GL account), the system will initiate a configured retry policy. If all retries are exhausted, the event is moved to the DLQ and a high-priority alert is raised for manual intervention.

## Business Rules
- **Idempotency**: All event processing must be idempotent. A single `InventoryIssued` event, identified by its unique `eventId`, must result in exactly one corresponding journal entry.
- **Valuation**: The cost of issued inventory must be calculated using the system's configured authoritative inventory valuation method. This calculation must be logged and auditable.
- **Traceability**: Every resulting journal entry must be immutably traceable back to the unique `workorderId` and `inventoryIssueId` from the source event.
- **Balanced Transaction**: All generated journal entries must be balanced; total debits must equal total credits. The system must prevent the creation of unbalanced entries.

## Data Requirements
- **Incoming Event (`InventoryIssued` v1)**:
    - `eventId`: `UUID` - The unique identifier for the event, used as the idempotency key.
    - `eventTimestamp`: `ISO 8601 UTC` - The time the event occurred.
    - `inventoryItemId`: `String` - Authoritative identifier for the part/item.
    - `quantityIssued`: `Decimal` - The positive quantity of the item issued.
    - `unitOfMeasure`: `String` - The unit of measure for the quantity (e.g., `EACH`, `LITER`).
    - `workorderId`: `String` - Identifier for the source work order.
    - `inventoryIssueId`: `String` - Unique identifier for the specific issue transaction within the source system.
- **Internal Entities (`JournalEntry`, `JournalLine`)**:
    - `journalEntryId`: `UUID` - Primary key.
    - `transactionDate`: `Date` - The effective date of the accounting entry.
    - `description`: `String` - Human-readable description (e.g., "COGS for WO-12345, Part-X").
    - `sourceEventId`: `UUID` - The `eventId` from the source event.
    - `sourceSystem`: `String` - e.g., "WorkorderExecution".
    - `journalLines`: `Array<JournalLine>` - The set of debits and credits.
        - `glAccountId`: `String` - Identifier for the GL account being affected.
        - `debitAmount`: `Monetary`
        - `creditAmount`: `Monetary`

## Acceptance Criteria
- **AC1: Successful COGS Posting from Event**
    - **Given** the system is configured with the 'Average Cost' valuation method.
    - **And** the average cost of `Part-X` is $15.50.
    - **And** business rules are configured to post issues for 'Service' type work orders to the 'COGS' GL account.
    - **When** an `InventoryIssued` event is received for 2 units of `Part-X` against a 'Service' work order.
    - **Then** a new, balanced journal entry is created and persisted.
    - **And** the journal entry credits the 'Inventory Asset' GL account for $31.00.
    - **And** the journal entry debits the 'COGS' GL account for $31.00.
    - **And** the journal entry contains a reference to the source `eventId` and `workorderId`.

- **AC2: Idempotent Processing of Duplicate Event**
    - **Given** an `InventoryIssued` event with `eventId: "uuid-abc-123"` has already been successfully processed.
    - **And** this resulted in the creation of `journalEntryId: "je-xyz-789"`.
    - **When** a second event with the exact same `eventId: "uuid-abc-123"` is received.
    - **Then** the system acknowledges the event without creating a new journal entry.
    - **And** no changes are made to the balances of any GL accounts as a result of the second event.

- **AC3: Failed Processing of Invalid Event**
    - **Given** the system expects `quantityIssued` to be a positive decimal value.
    - **When** an `InventoryIssued` event is received where `quantityIssued` is `-5`.
    - **Then** the event fails schema validation and is not processed.
    - **And** the event message is moved to the dead-letter queue (DLQ).
    - **And** a structured error is logged detailing the validation failure.
    - **And** no journal entry is created.

## Audit & Observability
- **Audit Log**: An immutable audit trail must be created for every decision point, including:
    - Event received (with payload hash).
    - Idempotency check result (new or duplicate).
    - Valuation calculation performed (item, quantity, unit cost, total value).
    - Journal entry created (with `journalEntryId`).
- **Metrics**:
    - `events.ingested.count` (Counter, tagged by `event_type`, `source_system`)
    - `events.processed.success.count` (Counter)
    - `events.processed.duplicate.count` (Counter)
    - `events.processed.failure.count` (Counter, tagged by `failure_reason`: `schema`, `posting`, `unknown_item`)
    - `journal.entries.created.value` (Distribution Summary)
- **Alerting**: High-severity alerts must be triggered for:
    - Any event moved to the DLQ.
    - A sustained failure to connect to the General Ledger for posting.
    - A significant spike in the `events.processed.failure.count` metric.

## Open Questions
1.  **Valuation Method**: Where is the inventory valuation method (e.g., FIFO, Average Cost, Standard Cost) configured and maintained? Is this a global system setting, or can it vary by location, item category, or individual item?
2.  **COGS vs. WIP Logic**: What specific business logic or event attribute determines whether to post the expense to a Cost of Goods Sold (COGS) account versus a Work-in-Progress (WIP) account? (e.g., determined by work order type, item type, customer type, etc.)
3.  **GL Account Mapping**: How are the specific General Ledger (GL) account identifiers for `Inventory Asset`, `COGS`, and `WIP` determined? Are they hard-coded, configured globally, or mapped based on attributes like item category or location?

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #121 ‚Äî [BACKEND] [STORY] Accounting: Ingest InventoryIssued Event

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Accounting: Ingest InventoryIssued Event

**Domain**: user

### Story Description

/kiro
Focus on inventory valuation, COGS timing, and idempotent posting.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Actor
Accounting System

## Trigger
Receipt of `InventoryIssued` event from Workorder Execution

## Main Flow
1. Receive inventory issue event with part, quantity, and workorder reference
2. Validate event schema and idempotency key
3. Determine valuation method (configured, e.g., FIFO/average)
4. Reduce on-hand inventory quantity
5. Record corresponding COGS or WIP entry based on configuration
6. Persist posting references and source links

## Alternate / Error Flows
- Duplicate event ‚Üí ignore (idempotent)
- Invalid inventory reference ‚Üí reject and flag
- Posting failure ‚Üí retry or dead-letter

## Business Rules
- Inventory may only be reduced once per issued quantity
- Valuation method is configuration-driven
- Posting must be traceable to source workorder and part issue

## Data Requirements
- Entities: InventoryItem, InventoryTransaction, WorkorderRef
- Fields: quantity, valuationAmount, issueTimestamp

## Acceptance Criteria
- [ ] Inventory quantity is reduced correctly
- [ ] COGS/WIP is recorded per configuration
- [ ] Event is idempotent
- [ ] Posting references original workorder

## Classification (confirm labels)
- Type: Story
- Layer: Functional
- Domain: Accounting

## References
- Durion Accounting Event Contract v1

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299815/Durion_Accounting_Event_Contract_v1.pdf)

### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #120: [BACKEND] [STORY] Accounting: Ingest InventoryAdjustment Event
LABELS: type:story,domain:accounting,status:needs-review
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** accounting-strict
---

## Story Intent
As the Accounting System, I need to ingest `InventoryAdjusted` events from the Workorder Execution domain to create correcting journal entries. This ensures that the General Ledger (specifically Inventory Asset and Cost of Goods Sold accounts) accurately reflects the real-world state of inventory, maintaining financial integrity and providing a complete audit trail for all inventory adjustments.

## Actors & Stakeholders
- **Primary Actor:** Accounting System (the system responsible for processing the event and updating financial records).
- **Initiating System:** Workorder Execution System (the system that detects an inventory discrepancy and publishes the `InventoryAdjusted` event).
- **Stakeholders:**
  - **Accountant:** Relies on the accuracy of the generated journal entries for financial reporting and reconciliation.
  - **Financial Controller:** Oversees the integrity of the General Ledger and requires a clear audit trail for all adjustments.
  - **Auditor:** Requires traceable, verifiable records of all financial transactions, including corrections.

## Preconditions
- The `InventoryAdjusted` event contract is formally defined, versioned, and agreed upon by both the `domain:accounting` and `domain:workexec` teams.
- The Accounting System is subscribed to the appropriate message topic/queue where `InventoryAdjusted` events are published.
- The original inventory transaction (which is being adjusted) has a unique identifier that is present in the `InventoryAdjusted` event payload.
- The General Ledger accounts for "Inventory Asset" and "Cost of Goods Sold" are configured in the Accounting System.

## Functional Behavior
1.  The Accounting System's event listener consumes an `InventoryAdjusted` event.
2.  The system validates the event payload against the agreed-upon schema (e.g., presence of required fields, correct data types).
3.  The system uses the `sourceTransactionId` from the event to look up the original financial transaction (e.g., the journal entry for the initial sale or stock movement).
4.  The system calculates the financial impact of the adjustment based on the delta between `originalQuantity` and `adjustedQuantity`, using the item's valuation from the original transaction.
5.  A new, two-sided journal entry is created to reflect the adjustment. For example, a decrease in inventory would result in a credit to "Inventory Asset" and a debit to "COGS" (or a specific "Inventory Adjustment Expense" account).
6.  The new journal entry is permanently recorded and linked to both the original transaction and the triggering `InventoryAdjusted` event for full traceability. The description must include the `adjustmentReasonCode`.
7.  Upon successful processing, the event is acknowledged to prevent reprocessing.

## Alternate / Error Flows
- **Invalid Event Payload:** If the event fails schema validation, it is rejected, moved to a dead-letter queue (DLQ), an alert is generated, and processing for that event stops.
- **Original Transaction Not Found:** If the `sourceTransactionId` does not correspond to an existing transaction in the Accounting System, the event is rejected, moved to a DLQ, an alert is generated, and no journal entry is created.
- **Duplicate Event:** If an event with a previously processed `eventId` is received, the system identifies it as a duplicate, acknowledges the message without taking action, and logs the occurrence.
- **Prohibited Negative Inventory:** If the adjustment would cause the inventory asset account's value to become negative and this is prohibited by policy (see OQ1), the event is rejected, a business rule violation is logged, and no journal entry is created.

## Business Rules
- **BR-ACC-101 (Traceability):** All adjusting journal entries must contain immutable references to the source `eventId` and the `sourceTransactionId` of the transaction being corrected.
- **BR-ACC-102 (Reason Codes):** The `adjustmentReasonCode` provided in the event must be stored and included in the description field of the resulting journal entry.
- **BR-ACC-103 (Prohibition of Negative Asset Value):** An inventory adjustment must not result in a negative monetary value for the associated inventory asset account on the general ledger unless an explicit override flag is present in the event and the governing business policy allows it. (See O-1)
- **BR-ACC-104 (Idempotency):** Event processing must be idempotent. Processing the same `InventoryAdjusted` event multiple times must result in exactly one set of corresponding journal entries.

## Data Requirements
The `InventoryAdjusted` event payload MUST contain, at a minimum:
```json
{
  "eventId": "string (UUID)",
  "eventTimestamp": "string (ISO-8601)",
  "sourceTransactionId": "string (UUID)",
  "adjustmentId": "string (UUID)",
  "productId": "string",
  "locationId": "string",
  "originalQuantity": "number",
  "adjustedQuantity": "number",
  "adjustmentReasonCode": "string (enum: 'DAMAGED', 'THEFT', 'RECOUNT_CORRECTION', etc.)",
  "adjustingUserId": "string"
}
```

## Acceptance Criteria
### AC1: Successful Processing of a Standard Inventory Adjustment
- **Given** the Accounting System has a record of an original inventory transaction
- **And** a valid `InventoryAdjusted` event is received referencing that transaction
- **When** the event is processed
- **Then** a new, balanced journal entry is created that correctly adjusts the Inventory Asset and COGS accounts
- **And** the journal entry's description contains the `adjustmentReasonCode` from the event
- **And** the journal entry is linked to both the `eventId` and the `sourceTransactionId`.

### AC2: Rejection of an Adjustment Leading to Prohibited Negative Inventory
- **Given** the business policy prohibits negative inventory asset values
- **And** an `InventoryAdjusted` event is received that, if processed, would result in a negative value for an inventory asset account
- **When** the event is processed
- **Then** no journal entry is created
- **And** the event is moved to a dead-letter queue
- **And** an error is logged indicating a business rule violation.

### AC3: Rejection of an Event with a Missing Source Transaction
- **Given** an `InventoryAdjusted` event is received with a `sourceTransactionId` that does not exist in the Accounting System
- **When** the event is processed
- **Then** no journal entry is created
- **And** the event is moved to a dead-letter queue
- **And** an error is logged indicating the source transaction was not found.

### AC4: Idempotent Processing of Duplicate Events
- **Given** a specific `InventoryAdjusted` event has already been successfully processed
- **And** the same event (with the same `eventId`) is received again
- **When** the duplicate event is processed
- **Then** the system recognizes it as a duplicate and takes no further financial action
- **And** no new journal entries are created.

## Audit & Observability
- **Logging:**
  - Log the receipt of every `InventoryAdjusted` event with its `eventId`.
  - Log the outcome of processing (Success, Failure, Duplicate) for each event.
  - On failure, log the specific reason (e.g., "Invalid Schema", "Source Transaction Not Found", "Negative Inventory Prohibited").
- **Metrics:**
  - `events.inventory_adjusted.processed.count` (counter, tagged by outcome: success, failure, duplicate)
  - `events.inventory_adjusted.processing.duration` (timer)
- **Auditing:** The created journal entry must provide a clear and permanent audit trail linking back to the `adjustmentId` and `adjustingUserId` from the source system.

## Open Questions
- **OQ1 (Policy on Negative Inventory):** The rule "Negative inventory positions are prohibited unless explicitly allowed" requires clarification.
  - Under what specific business conditions (e.g., for specific item types, specific reason codes) is a negative inventory asset value permissible?
  - Should the `InventoryAdjusted` event contract be updated to include an `allowNegativeValueOverride: boolean` flag, to be set by an authorized user in the source system?
  - Who is the business stakeholder authorized to define this policy?

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #120 ‚Äî [BACKEND] [STORY] Accounting: Ingest InventoryAdjustment Event

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Accounting: Ingest InventoryAdjustment Event

**Domain**: user

### Story Description

/kiro
Handle inventory corrections with full auditability.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Actor
Accounting System

## Trigger
Receipt of `InventoryAdjusted` event from Workorder Execution

## Main Flow
1. Validate adjustment reason and quantities
2. Reverse or adjust prior inventory/COGS entries
3. Apply corrected inventory quantities
4. Record adjustment journal with reason code

## Business Rules
- Adjustments must reference original issue
- Negative inventory positions are prohibited unless explicitly allowed

## Acceptance Criteria
- [ ] Adjustments reconcile inventory correctly
- [ ] Prior postings are traceable and reversible

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## References
- Durion Accounting Event Contract v1

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299815/Durion_Accounting_Event_Contract_v1.pdf)

### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #119: [BACKEND] [STORY] Accounting: Ingest WorkCompleted Event
LABELS: type:story,domain:accounting,status:ready-for-dev
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** accounting-strict
---
## Story Intent
As the Accounting System, I need to process a `WorkCompleted` event so that I can finalize any Work-In-Progress (WIP) accounting and mark the associated workorder as eligible for invoicing, ensuring a timely and accurate billing process.

## Actors & Stakeholders
- **Accounting System (Primary Actor)**: The system responsible for consuming the event, performing financial calculations, and updating the workorder's accounting state.
- **Work Execution System (Event Source)**: The upstream system that performs the physical or digital work and emits the `WorkCompleted` event upon its conclusion.
- **Billing System (Downstream Consumer)**: A subsequent system that will consume the `INVOICE_ELIGIBLE` status to initiate customer invoicing.
- **Accountant (Human Stakeholder)**: Relies on the accuracy of WIP reconciliation and the timely transition of workorders to an invoice-eligible state for financial reporting and revenue cycle management.

## Preconditions
1.  A `WorkCompleted` event is received via the enterprise message bus on the designated topic.
2.  The event payload conforms to the schema defined in the `Durion Accounting Event Contract v1`.
3.  The workorder referenced by the `workorderId` in the event exists within the Accounting System.
4.  The workorder's current accounting status is `WORK_IN_PROGRESS` or a similar state that permits this transition.

## Functional Behavior
### Happy Path: `WorkCompleted` Event Processing
1.  **Trigger**: The `Accounting System`'s event listener consumes a `WorkCompleted` event.
2.  **Event Validation**: The system validates the event payload against its required schema (e.g., presence and format of `eventId`, `workorderId`, `completionTimestamp`).
3.  **Workorder Retrieval**: The system retrieves the corresponding workorder's accounting record using the `workorderId` from the event.
4.  **Idempotency Check**: The system verifies that this `eventId` has not been processed previously for this workorder to prevent duplicate transactions.
5.  **Conditional WIP Reconciliation**:
    - The system checks the `WIP_ACCOUNTING_ENABLED` system configuration.
    - If `true`, the system executes the WIP reconciliation sub-process. This involves creating and posting journal entries to move accumulated costs from the WIP General Ledger (GL) asset account to a 'Cost of Goods Sold' (COGS) or 'Finished Work' expense account.
    - If `false`, this step is skipped.
6.  **Status Update**: The system updates the `accountingStatus` of the workorder record to `INVOICE_ELIGIBLE`.
7.  **State Persistence**: All changes, including new journal entries and the workorder status update, are committed atomically to the database.
8.  **Outcome**: The workorder is now flagged as ready to be invoiced, and its costs are correctly reflected in the general ledger. The event is acknowledged as successfully processed.

## Alternate / Error Flows
- **Invalid Event Payload**: If the event fails schema validation, the system will not process it. The event is routed to a Dead Letter Queue (DLQ) with a `validation_error` reason.
- **Workorder Not Found**: If the `workorderId` from the event does not match any record in the system, the event is routed to the DLQ with a `workorder_not_found` reason.
- **Invalid State Transition**: If the workorder is not in a valid state for this transition (e.g., it is already `INVOICED` or `CANCELLED`), the event is acknowledged but ignored to maintain state integrity, and a warning is logged. The idempotency check should handle cases where it is already `INVOICE_ELIGIBLE`.
- **WIP Reconciliation Failure**: If the creation of journal entries fails (e.g., due to a data issue or GL system error), the entire transaction is rolled back. The workorder status remains unchanged. The event is routed to a retry queue and, after exhausting retries, to the DLQ with a `wip_reconciliation_failed` reason for manual investigation.

## Business Rules
- **No Revenue Recognition**: This process finalizes costs but does **not** create an invoice, recognize revenue, or generate an Accounts Receivable (AR) entry. It is a preparatory step for the billing cycle.
- **Configurable WIP Handling**: The execution of WIP-related journal entries is strictly controlled by the `WIP_ACCOUNTING_ENABLED` system configuration. When disabled, this event only serves to update the workorder's status.
- **Idempotency**: Event processing must be idempotent. Receiving the same `WorkCompleted` event multiple times must not result in duplicate journal entries or errors after the first successful processing.

## Data Requirements
### Input: `WorkCompleted` Event
The event payload must contain, at a minimum:
- `eventId`: `UUID` - Unique identifier for this event instance.
- `eventTimestamp`: `ISO 8601` - Timestamp of when the event was generated.
- `workorderId`: `UUID` - The unique identifier of the workorder that was completed.
- `completionTimestamp`: `ISO 8601` - The business timestamp of when the work was officially completed.
- `finalCostSummary`: `Object` - A structured object detailing the final costs (e.g., labor, parts). *Clarification needed, see Open Questions*.

### State Changes: Workorder Accounting Entity
- `accountingStatus`: `WORK_IN_PROGRESS` ‚û°Ô∏è `INVOICE_ELIGIBLE`
- `completionProcessedTimestamp`: Set to the timestamp when processing is complete.
- Associated `JournalEntry` records created if WIP is enabled.

## Acceptance Criteria
- **AC1: Success with WIP Enabled**
  - **Given** the `WIP_ACCOUNTING_ENABLED` configuration is `true`
  - **And** a valid `WorkCompleted` event is received for a workorder with accumulated WIP costs
  - **When** the event is processed
  - **Then** the corresponding journal entries are created to move costs from the WIP GL account to the Finished Work GL account
  - **And** the workorder's `accountingStatus` is updated to `INVOICE_ELIGIBLE`.

- **AC2: Success with WIP Disabled**
  - **Given** the `WIP_ACCOUNTING_ENABLED` configuration is `false`
  - **And** a valid `WorkCompleted` event is received
  - **When** the event is processed
  - **Then** no new journal entries are created
  - **And** the workorder's `accountingStatus` is updated to `INVOICE_ELIGIBLE`.

- **AC3: Failure on Unknown Workorder**
  - **Given** a `WorkCompleted` event is received with a `workorderId` that does not exist
  - **When** the system attempts to process the event
  - **Then** the event is routed to the Dead Letter Queue with a `workorder_not_found` reason.

- **AC4: Idempotent Processing**
  - **Given** a `WorkCompleted` event for a specific workorder has already been successfully processed
  - **When** the exact same `eventId` is received again
  - **Then** the system acknowledges the event without making duplicate GL entries or state changes
  - **And** a log is generated indicating a duplicate event was handled.

## Audit & Observability
- **Audit Log**: An immutable audit trail must be created for the state transition, capturing the `workorderId`, the old status (`WORK_IN_PROGRESS`), the new status (`INVOICE_ELIGIBLE`), the responsible `system` principal, and the `eventId` that triggered the change.
- **Metrics**:
  - `events.work_completed.processed.success`: A counter, tagged by outcome (e.g., `wip_enabled`, `wip_disabled`).
  - `events.work_completed.processed.failure`: A counter, tagged by reason (e.g., `validation_error`, `not_found`, `wip_failure`).
  - `events.work_completed.processing.latency`: A timer/histogram measuring the duration from event consumption to acknowledgement.
- **Logging**: Structured logs containing the `workorderId` and `eventId` must be emitted for key stages: event consumption, validation success/failure, WIP processing start/end, and final outcome.

## Open Questions
1.  **Event Payload for WIP**: What specific fields are guaranteed to be in the `WorkCompleted` event's `finalCostSummary`, as defined by the `Durion Accounting Event Contract v1`? Does it contain a final, authoritative breakdown of costs (labor, parts, fees), or must the Accounting service look these up from another data source using the `workorderId`?
2.  **GL Account Determination**: What is the precise GL account number or logic to determine the 'Finished Work' or 'COGS' destination account for the WIP transfer? Is this a single system-wide account, or is it determined by properties of the workorder (e.g., business unit, work type, location)?

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #119 ‚Äî [BACKEND] [STORY] Accounting: Ingest WorkCompleted Event

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Accounting: Ingest WorkCompleted Event

**Domain**: user

### Story Description

/kiro
Determine WIP finalization or readiness for invoicing.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Actor
Accounting System

## Trigger
Receipt of `WorkCompleted` event from Workorder Execution

## Main Flow
1. Validate completion event and source workorder
2. If WIP accounting enabled:
   - Transfer WIP to Finished Work
3. Mark workorder as invoice-eligible
4. Persist completion accounting state

## Business Rules
- Completion does not create AR or revenue
- WIP handling is configuration-driven

## Acceptance Criteria
- [ ] WIP is reconciled (if enabled)
- [ ] Workorder marked invoice-ready

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## References
- Durion Accounting Event Contract v1

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299815/Durion_Accounting_Event_Contract_v1.pdf)

### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #118: [BACKEND] [STORY] Accounting: Reverse Completion on Workorder Reopen
LABELS: type:story,domain:accounting,status:ready-for-dev
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** accounting-strict
---

## Story Intent
**As the** Accounting System,
**I need to** atomically reverse all financial entries and state changes associated with a workorder's completion when it is reopened,
**So that** the General Ledger remains accurate, premature invoicing is prevented, and financial audit trails are complete.

## Actors & Stakeholders
- **System Actor**: `Accounting Service` - The microservice responsible for processing accounting-related events and maintaining the financial integrity of workorders.
- **Triggering System**: `Work Execution System` - The system of record for workorder status, which emits the `WorkorderReopened` event.
- **Stakeholders**:
  - `Accountant` - Relies on the accuracy of the General Ledger (GL) and the `InvoiceReady` status for billing operations.
  - `Financial Controller` - Responsible for the overall integrity of financial records and reporting.

## Preconditions
1.  A `WorkorderCompleted` event for the target `workorderId` has been successfully processed by the `Accounting Service`.
2.  General Ledger journal entries exist, reflecting the transfer of value from a Work-in-Progress (WIP) account to a Finished Goods or Cost of Goods Sold (COGS) account for the workorder.
3.  The workorder's accounting record is marked with `InvoiceReady = true`.
4.  An invoice has **not** yet been generated for this workorder.

## Functional Behavior
### Trigger
The `Accounting Service` consumes a `WorkorderReopened` event from the enterprise message bus (e.g., Kafka topic `workexec.workorder.events`).

#### Expected Event Payload (`WorkorderReopened`)
```json
{
  "eventId": "uuid",
  "eventType": "WorkorderReopened",
  "eventTimestamp": "ISO-8601",
  "correlationId": "uuid",
  "payload": {
    "workorderId": "uuid",
    "reopenedByUserId": "string",
    "reopenedTimestamp": "ISO-8601",
    "reasonCode": "string",
    "reasonText": "string | null"
  }
}
```

### Main Success Scenario
1.  **Consume Event**: The `Accounting Service` consumes the `WorkorderReopened` event.
2.  **Idempotency Check**: The service checks if this `eventId` has been processed before. If so, it acknowledges the message and stops (see Alternate Flows).
3.  **Fetch State**: The service retrieves the current accounting state for the `workorderId`, including the original completion journal entry ID.
4.  **Validate Business Rules**: The service confirms that no invoice has been generated for this workorder. If an invoice exists, the process fails (see Error Flows).
5.  **Generate Reversal Journal Entry**: A new, offsetting General Ledger transaction is created. This transaction reverses the original completion entry (e.g., DEBIT `WIP Inventory` and CREDIT `Finished Goods Inventory`). The new entry must reference the original journal entry ID for auditability.
6.  **Update Workorder Accounting State**: The internal record for the workorder is updated:
    - `status` is changed from `Completed` to `Reopened` (or `InProgress`).
    - `isInvoiceReady` flag is set to `false`.
7.  **Persist Audit Log**: A detailed, immutable audit record is created documenting the reversal.
8.  **Acknowledge Event**: The message is acknowledged on the bus.
9.  **(Optional) Emit Event**: The service may emit a `WorkorderAccountingCompletionReversed` event for downstream consumers (e.g., reporting).

## Alternate / Error Flows
- **Duplicate Event**: If the `eventId` has been processed before, the system logs a warning, acknowledges the message, and takes no further action.
- **Workorder Not Found**: If the `workorderId` does not exist in the accounting system, log a critical error and move the event to a dead-letter queue (DLQ) for manual investigation.
- **Workorder Already Invoiced**: If the workorder has an associated invoice, the process **must fail**. A critical error is logged, the event is moved to a DLQ, and an alert is raised. The financial state is not changed.
- **Original Completion Entry Not Found**: If the original journal entry cannot be located, the process fails. A critical error is logged, the event is moved to a DLQ, and an alert is raised.

## Business Rules
- A workorder completion **cannot** be reversed if an invoice linked to it has been generated. This is a hard-stop financial control.
- All reversal journal entries must explicitly link back to the original journal entry they are reversing.
- The `reopenedByUserId` and `reasonCode` from the triggering event must be stored in the audit log for the reversal transaction.
- The reversal transaction (GL entry, state update, audit log) must be atomic. If any part fails, the entire operation must be rolled back.

## Data Requirements
- **Journal Entry Schema**:
    - `journalEntryId` (PK)
    - `transactionDate`
    - `description` (e.g., "Reversal of WO-123 completion")
    - `originalJournalEntryId` (FK)
    - `lines`: `[{accountId, debit, credit}]`
- **Workorder Accounting Record**:
    - `workorderId` (PK)
    - `isInvoiceReady` (boolean)
    - `accountingStatus` (e.g., `InProgress`, `Completed`, `Reopened`, `Invoiced`)
- **Audit Log Schema**:
    - `auditId` (PK)
    - `timestamp`
    - `eventType`: `WORKORDER_COMPLETION_REVERSED`
    - `entityId`: `workorderId`
    - `userId`: `reopenedByUserId`
    - `details`: JSON blob containing context like `reasonCode`, `originalJournalEntryId`, and `reversalJournalEntryId`.

## Acceptance Criteria
- **Given** a workorder is in a `Completed` accounting state with `isInvoiceReady = true` and has an associated WIP-to-Finished-Goods journal entry
  **When** a valid `WorkorderReopened` event is received for that workorder
  **Then** a new reversing journal entry is created in the General Ledger, the workorder's `isInvoiceReady` flag is set to `false`, and a detailed audit log is persisted.

- **Given** a workorder has been `Invoiced`
  **When** a `WorkorderReopened` event is received for that workorder
  **Then** the operation is rejected, a critical error is logged stating the "already invoiced" conflict, and no financial records are altered.

- **Given** a `WorkorderReopened` event has already been successfully processed
  **When** the same event with the same `eventId` is received again
  **Then** the system identifies it as a duplicate, takes no action, and acknowledges the message successfully.

- **Given** a valid `WorkorderReopened` event is received
  **When** the corresponding original completion journal entry cannot be found
  **Then** the operation is rejected, a critical error is logged, and the event is routed to a dead-letter queue for investigation.

## Audit & Observability
- **Audit**: An immutable audit trail must be recorded for every successful reversal. This log must contain: `workorderId`, `reopenedByUserId`, `reopenedTimestamp`, `reasonCode`, `originalJournalEntryId`, and the new `reversalJournalEntryId`.
- **Logging**:
    - INFO: Event received (`eventId`, `workorderId`).
    - WARN: Duplicate event detected.
    - ERROR: Validation failed (e.g., already invoiced, workorder not found).
    - INFO: Reversal successfully processed.
- **Metrics**:
    - `workorder.completion.reversals.success` (counter)
    - `workorder.completion.reversals.failure` (counter, tagged by `reason:invoiced`, `reason:not_found`, etc.)
    - `workorder.completion.reversals.latency` (timer)

## Open Questions
1.  **OQ1 (Critical)**: What are the specific General Ledger (GL) account numbers/IDs for the standard Work-in-Progress (WIP) and Finished Goods/COGS accounts that this process must use for the reversal entries?
2.  **OQ2 (Authorization)**: The original story mentions "Validate reopen authorization". Is trust in the incoming event from the `Work Execution System` sufficient, or does the `Accounting Service` need to perform its own authorization check by calling an external service (e.g., an IAM or Permissions service)?
3.  **OQ3 (Data Consistency)**: What is the expected behavior if the `workorderId` from the event is not found in the accounting system's database? Should this be treated as a transient error to be retried, or a permanent failure to be moved to a DLQ? The current assumption is DLQ.

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #118 ‚Äî [BACKEND] [STORY] Accounting: Reverse Completion on Workorder Reopen

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Accounting: Reverse Completion on Workorder Reopen

**Domain**: user

### Story Description

/kiro
Safely reverse completion-related accounting state.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Actor
Accounting System

## Trigger
Receipt of `WorkorderReopened` event

## Main Flow
1. Validate reopen authorization
2. Reverse WIP/finished postings if present
3. Mark workorder as not invoice-ready
4. Record reversal audit trail

## Acceptance Criteria
- [ ] Accounting state matches reopened workorder
- [ ] Reversal is fully auditable


## References
- Durion Accounting Event Contract v1

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299815/Durion_Accounting_Event_Contract_v1.pdf)



### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #117: [BACKEND] [STORY] Accounting: Ingest InvoiceIssued Event
LABELS: type:story,domain:accounting,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- none

---
**Rewrite Variant:** accounting-strict
---

## Story Intent
As the Accounting System, I want to process issued invoices from the Work Execution domain so that revenue, tax liabilities, and accounts receivable are accurately recorded in the general ledger in a timely and idempotent manner.

## Actors & Stakeholders
- **System**: Accounting System (The system responsible for processing the event and maintaining the General Ledger).
- **Upstream System**: Work Execution System (The system that originates the `InvoiceIssued` event).
- **Stakeholders**: Finance Department, Auditors (Rely on the accuracy and traceability of financial records).

## Preconditions
1. The Accounting System is subscribed to and can consume messages from the `InvoiceIssued` event topic.
2. The General Ledger is configured with the necessary control accounts for Accounts Receivable, Revenue, and Tax Liabilities.
3. The event payload schema is defined and available as per the `Durion Accounting Event Contract v1`.
4. The system has access to a persistent store to track processed event/invoice identifiers for idempotency.

## Functional Behavior

### Trigger
The system receives an `InvoiceIssued` event from the enterprise message bus.

### Main Success Scenario
1. The system consumes the `InvoiceIssued` event.
2. An idempotency check is performed using a composite key of `invoiceId` and `invoiceVersion` from the event payload. The check confirms this is a new, unprocessed event.
3. The event payload is validated against the schema defined in the `Durion Accounting Event Contract v1`.
4. A single, atomic database transaction is initiated for all subsequent ledger postings.
5. A new Accounts Receivable (AR) entry is created, debiting the AR control account for the invoice's total amount.
6. For each revenue line item in the event, a corresponding credit entry is posted to the specified revenue account.
7. For each tax breakdown in the event, a corresponding credit entry is posted to the specified tax liability account for that jurisdiction.
8. The system verifies that the sum of all credits (revenue + tax) equals the total AR debit.
9. All ledger entries are persisted, and a reference to the source `invoiceId` and `eventId` is stored with the transaction.
10. The `invoiceId`/`invoiceVersion` combination is recorded in the processed events log to ensure future idempotency.
11. The transaction is committed.

## Alternate / Error Flows
- **Duplicate Event Received**: If the idempotency check finds the `invoiceId`/`invoiceVersion` has already been processed, the system will discard the event, log the duplicate occurrence, and take no further action. No financial entries will be created.
- **Invalid Event Payload**: If the event fails schema validation (e.g., missing required fields, malformed data), the system will reject the event, move the message to a Dead-Letter Queue (DLQ) for investigation, and generate a high-priority alert. No financial entries will be created.
- **Unknown GL Account**: If a revenue or tax account code specified in the event payload does not exist in the Chart of Accounts, the system will reject the event, move it to the DLQ, and generate a high-priority alert. The entire transaction will be rolled back.

## Business Rules
- **BR-ACC-01 (Revenue Recognition Trigger)**: Revenue is officially recognized only upon the successful processing of a valid `InvoiceIssued` event. This event is the legal and financial trigger.
- **BR-ACC-02 (Ledger Segregation)**: Revenue and tax liabilities must be posted to separate and distinct general ledger accounts as defined by the Chart of Accounts. They cannot be combined.
- **BR-ACC-03 (Idempotency Guarantee)**: Each unique invoice version (defined by `invoiceId` and `invoiceVersion`) must be processed exactly once. Subsequent attempts to process the same version must be ignored.
- **BR-ACC-04 (Transactional Integrity)**: All ledger entries (AR Debit, Revenue Credits, Tax Credits) for a single invoice must be created as a single, atomic financial transaction. A failure in posting any single entry must result in a complete rollback of all entries for that invoice.

## Data Requirements

### Incoming Event Data (`InvoiceIssued` v1)
The event payload must conform to the `Durion Accounting Event Contract v1` and contain, at minimum:
- `eventId`: Unique identifier for the event message.
- `eventTimestamp`: ISO 8601 timestamp of event creation.
- `invoiceId`: Unique identifier for the invoice.
- `invoiceVersion`: A version number or timestamp for the invoice, for handling revisions.
- `issueDate`: The legal date of invoice issuance.
- `customerId`: Identifier for the customer.
- `totalAmount`: The total value of the invoice.
- `revenueItems`: An array of objects, each containing `amount`, `description`, and `revenueAccountCode`.
- `taxItems`: An array of objects, each containing `amount`, `jurisdiction`, and `taxLiabilityAccountCode`.

### Internal Entities
- `LedgerTransaction`: Header record for the set of financial postings.
- `LedgerEntry`: Individual debit or credit line item in a transaction.
- `ProcessedEventLog`: A record of processed `invoiceId`/`invoiceVersion` combinations to enforce idempotency.

## Acceptance Criteria

### AC-1: Successful Invoice Ingestion
- **Given** the system receives a valid `InvoiceIssued` event that has not been processed before
- **When** the event is processed
- **Then** a new atomic ledger transaction is created and persisted
- **And** the Accounts Receivable account is debited by the invoice `totalAmount`
- **And** each revenue account from `revenueItems` is credited with the corresponding amount
- **And** each tax liability account from `taxItems` is credited with the corresponding amount
- **And** the sum of all credits equals the total AR debit
- **And** the event's `invoiceId` and `invoiceVersion` are logged as processed.

### AC-2: Idempotent Processing of Duplicate Event
- **Given** an `InvoiceIssued` event for `invoiceId: "INV-123"` and `invoiceVersion: 1` has already been successfully processed
- **When** the system receives another event with `invoiceId: "INV-123"` and `invoiceVersion: 1`
- **Then** the system identifies it as a duplicate and discards it
- **And** no new ledger entries are created in the General Ledger
- **And** a log entry is created indicating a duplicate event was received and ignored.

### AC-3: Rejection of Invalid Event
- **Given** the system receives an `InvoiceIssued` event with a missing `totalAmount` field
- **When** the system attempts to validate the event
- **Then** the event is rejected
- **And** the event message is moved to a Dead-Letter Queue (DLQ)
- **And** a high-priority alert is generated for operational review
- **And** no ledger entries are created.

## Audit & Observability
- All created ledger transactions and their constituent entries must be traceable back to the originating `eventId` and `invoiceId`.
- A structured log event must be emitted for every successfully processed invoice, containing the `invoiceId` and the corresponding `ledgerTransactionId`.
- A warning-level log event must be emitted for every detected and ignored duplicate event.
- An error-level log event and a metric counter must be triggered for any event that fails validation and is sent to the DLQ.
- The system should expose metrics for the number of invoices processed, the number of duplicates ignored, and the number of processing failures.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #117 ‚Äî [BACKEND] [STORY] Accounting: Ingest InvoiceIssued Event

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Accounting: Ingest InvoiceIssued Event

**Domain**: user

### Story Description

/kiro
Post AR, revenue, and tax liabilities from issued invoices.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Actor
Accounting System

## Trigger
Receipt of `InvoiceIssued` event from Workorder Execution

## Main Flow
1. Validate invoice payload and idempotency
2. Create Accounts Receivable entry
3. Post revenue by classification
4. Post tax liabilities by jurisdiction
5. Persist posting references

## Business Rules
- Invoice is the legal revenue trigger
- Taxes must be posted separately from revenue
- Posting must be idempotent per invoice version

## Data Requirements
- Entities: Invoice, AR, RevenueAccount, TaxLiability
- Fields: invoiceId, totals, taxBreakdown

## Acceptance Criteria
- [ ] AR balance increases correctly
- [ ] Revenue posted to correct accounts
- [ ] Tax liabilities recorded accurately
- [ ] Duplicate events do not double-post

## References
- Durion Accounting Event Contract v1

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299815/Durion_Accounting_Event_Contract_v1.pdf)

### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #115: [BACKEND] [STORY] Accounting: Ingest PaymentReceived Event
LABELS: payment,type:story,domain:accounting,status:ready-for-dev
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:accounting
- status:draft

### Recommended
- agent:accounting
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** accounting-strict
---

## Story Intent
As the Accounting System, I need to ingest and process `PaymentReceived` events to accurately record cash receipts, create corresponding unapplied payment records, and ensure data integrity through idempotency, so that financial records are timely, accurate, and auditable.

## Actors & Stakeholders
- **System Actor:** Accounting System
- **Triggering Actor:** Any external system capable of receiving payments (e.g., POS System, Payment Gateway, Bank Feed Processor).
- **Stakeholders:**
    - **Accountant:** Needs to reconcile cash accounts and apply payments to open invoices.
    - **Financial Controller:** Relies on accurate and timely cash flow reporting.

## Preconditions
1. The Accounting System is configured with an event bus subscription to the `PaymentReceived` topic.
2. The schema for the `PaymentReceived` event conforms to the `Durion Accounting Event Contract v1`.
3. General ledger accounts for `Cash` (or specific bank accounts) and `Unapplied Payments` are configured in the system.
4. The system has a mechanism to persist and query idempotency keys (`externalTxnId`) to prevent duplicate processing.

## Functional Behavior
Upon receiving a `PaymentReceived` event, the system will execute the following flow:

1.  **Consume & Validate:** The system ingests the event from the message queue.
2.  **Idempotency Check:** The system checks if the `externalTxnId` from the event has been processed before. If it has, the event is acknowledged and ignored (see Alternate Flows).
3.  **Schema Validation:** The system validates the event payload against the `Durion Accounting Event Contract v1`.
4.  **Entity Creation:** If validation and idempotency checks pass, the system creates a new `Payment` entity with a status of `UNAPPLIED`.
5.  **Customer Association:** The system attempts to associate the payment with an existing `Customer` record using the reference information provided in the event. If no customer can be identified, the `customerId` on the `Payment` entity will be left null (see Open Questions).
6.  **Journal Entry Generation:** The system generates and persists a double-entry journal transaction to reflect the cash receipt:
    -   **Debit:** The appropriate `Cash` or `Bank` asset account.
    -   **Credit:** The `Unapplied Payments` liability/suspense account.
7.  **Persistence:** The `Payment` entity, its associated `JournalEntry`, and the idempotency key are committed to the database in a single atomic transaction.
8.  **Acknowledgement:** The system sends a final acknowledgement to the message queue to confirm successful processing and prevent redelivery.

## Alternate / Error Flows
-   **Duplicate Event:** If the `externalTxnId` already exists, the system logs the duplicate attempt, acknowledges the message to remove it from the queue, and takes no further action.
-   **Invalid Schema:** If the event payload fails schema validation, the system rejects the message, sending it to a Dead-Letter Queue (DLQ) for manual inspection. An alert is triggered.
-   **Currency Mismatch:** If the event's `currency` is not supported or configured for the business entity, the event is rejected and moved to the DLQ.
-   **Database/Persistence Failure:** If the database transaction fails for any reason (e.g., connection loss, constraint violation), the entire operation is rolled back. The message is not acknowledged, allowing the message bus to attempt redelivery according to its configured retry policy. After exhausting retries, the message is moved to the DLQ.

## Business Rules
-   **Idempotency:** Processing is strictly idempotent based on the `externalTransactionId` field from the event source. A unique constraint must be enforced on this field in the database.
-   **Cash Recognition:** Cash is recognized immediately upon successful ingestion of the event. The debit to a cash/bank account reflects this.
-   **Accounts Receivable (AR):** Ingesting a payment does *not* automatically reduce a customer's AR balance. The payment is recorded as "unapplied cash" until a separate business process (manual or automated) applies it to one or more specific invoices.
-   **Immutability:** Once a `Payment` and its associated journal entry are recorded, they are considered immutable. Any corrections must be made through explicit reversing journal entries.

## Data Requirements
### `Payment` Entity
| Field                 | Type          | Constraints                                          | Description                                                               |
| --------------------- | ------------- | ---------------------------------------------------- | ------------------------------------------------------------------------- |
| `paymentId`           | UUID          | Primary Key, Not Null                                | Internal unique identifier for the payment record.                        |
| `customerId`          | UUID          | Foreign Key (nullable)                               | Reference to the customer, if identifiable.                               |
| `status`              | Enum          | Not Null, Default: `UNAPPLIED`                       | The current state of the payment (e.g., `UNAPPLIED`, `APPLIED`).          |
| `amount`              | Decimal(19,4) | Not Null, > 0                                        | The monetary value of the payment.                                        |
| `currency`            | Char(3)       | Not Null, ISO 4217                                   | The currency of the payment.                                              |
| `paymentMethod`       | Enum          | Not Null                                             | Method of payment (e.g., `CASH`, `CREDIT_CARD`, `BANK_TRANSFER`).         |
| `receivedTimestamp`   | Timestamp UTC | Not Null                                             | Timestamp when the payment was received by the source system.             |
| `externalTransactionId` | String(255)   | Not Null, Unique                                     | The unique identifier from the source system, used for idempotency.       |
| `sourceSystem`        | String(50)    | Not Null                                             | The name of the system that originated the event (e.g., 'POS_TERMINAL_A'). |
| `sourceEventPayload`  | JSONB         | Not Null                                             | The original, unmodified event payload for audit and traceability.        |

## Acceptance Criteria
**AC1: Successful Ingestion of a Unique Payment Event**
-   **Given** the Accounting System has not previously processed a payment with `externalTransactionId` "TXN-123"
-   **When** a valid `PaymentReceived` event is received with `externalTransactionId` "TXN-123" for $100.00 USD
-   **Then** a new `Payment` record is created with status `UNAPPLIED` and amount 100.00.
-   **And** a journal entry is created debiting the `Cash` account by 100.00 and crediting the `Unapplied Payments` account by 100.00.
-   **And** the `externalTransactionId` "TXN-123" is recorded to prevent duplicates.

**AC2: Idempotent Handling of a Duplicate Payment Event**
-   **Given** the Accounting System has already successfully processed a payment with `externalTransactionId` "TXN-123"
-   **And** the `Cash` account balance is $500.00
-   **When** another `PaymentReceived` event is received with the same `externalTransactionId` "TXN-123"
-   **Then** the system identifies it as a duplicate and discards the event.
-   **And** no new `Payment` or `JournalEntry` records are created.
-   **And** the `Cash` account balance remains $500.00.

**AC3: Handling a Payment with an Unidentifiable Customer**
-   **Given** the system receives a valid `PaymentReceived` event
-   **And** the customer reference information in the event does not match any existing customer in the system
-   **When** the event is processed
-   **Then** a new `Payment` record is created successfully with a `null` `customerId`.
-   **And** the payment is available in a system-wide "Unapplied and Unassigned Payments" work queue for manual association.

**AC4: Rejection of an Event with an Unsupported Currency**
-   **Given** the system is configured to only accept "USD" and "CAD"
-   **When** a `PaymentReceived` event is received with currency "EUR"
-   **Then** the system rejects the event processing.
-   **And** no `Payment` or `JournalEntry` is created.
-   **And** the event is routed to the Dead-Letter Queue (DLQ) for investigation.

## Audit & Observability
1.  **Structured Logging:** All stages of event processing (ingestion, validation, persistence, rejection) must be logged with a correlation ID that tracks the event from ingress to completion.
2.  **Metrics:** The system must emit metrics for:
    -   `payments.ingested.count` (tagged by status: `success`, `duplicate`, `failed`)
    -   `payments.ingested.amount` (tagged by currency)
    -   `payments.ingestion.latency` (histogram)
3.  **Alerting:** Alerts should be configured for:
    -   A significant increase in the rate of schema validation failures.
    -   Any message landing in the Dead-Letter Queue (DLQ).
    -   Sustained high processing latency.
4.  **Traceability:** The created `Payment` record and its corresponding `JournalEntry` must be directly and easily traceable back to the source event via the `externalTransactionId` and the stored `sourceEventPayload`.

## Open Questions
1.  **Currency Mismatch Policy:** The original story states a currency mismatch should be "rejected or flagged for review". The proposed safe default is to reject and DLQ. Is this the correct final policy? Or should an unapplied payment be created and placed in a special "currency review" state?
2.  **Unidentified Customer Handling:** The current design allows creating a `Payment` with a `null` `customerId`. Is this acceptable, or should these payments be assigned to a generic "Suspense Customer" record to simplify reporting and GL structure?

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #115 ‚Äî [BACKEND] [STORY] Accounting: Ingest PaymentReceived Event

## Current Labels
- backend
- story-implementation
- payment

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Accounting: Ingest PaymentReceived Event

**Domain**: payment

### Story Description

/kiro
Focus on cash recognition, AR reduction, and idempotency.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Actor
Accounting System

## Trigger
Receipt of `PaymentReceived` event from an external payment source
(e.g., POS terminal, bank feed, payment processor, manual entry)

## Main Flow
1. Receive payment event with amount, currency, method, and reference(s)
2. Validate event schema and idempotency key
3. Identify target customer and candidate open invoices
4. Record cash receipt in appropriate cash/bank account
5. Create unapplied payment record or proceed to invoice application
6. Persist payment with full source metadata

## Alternate / Error Flows
- Duplicate event ‚Üí ignore (idempotent)
- Unknown customer or reference ‚Üí create unapplied payment
- Currency mismatch ‚Üí reject or flag for review
- Posting failure ‚Üí retry or dead-letter

## Business Rules
- Payment receipt reduces cash suspense or increases cash immediately
- Payment does not reduce AR until applied to invoice(s)
- Idempotency is enforced per external transaction reference

## Data Requirements
- Entities: Payment, CashAccount, Customer
- Fields: amount, currency, method, receivedTimestamp, externalTxnId

## Acceptance Criteria
- [ ] Cash/bank balance increases correctly
- [ ] Payment is recorded exactly once
- [ ] Unapplied payments are visible and traceable
- [ ] Payment references external source transaction

## References
- Durion Accounting Event Contract v1

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299815/Durion_Accounting_Event_Contract_v1.pdf)


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #114: [BACKEND] [STORY] Accounting: Apply Payment to Invoice
LABELS: type:story,domain:accounting,status:ready-for-dev,agent:story-authoring,agent:accounting
BODY:
## Story Intent
As an Accounting System, I need to apply a cleared payment to one or more open invoices, so that Accounts Receivable (AR) is reduced correctly, invoice balances/statuses reflect the application, and any overpayment becomes an explicit AR customer credit.

## Actors & Stakeholders
- **Primary Actor:** Accounting System (automatic rules and/or clerk-initiated workflow)
- **Initiating User:** Accounting Clerk
- **Service Owner:** Accounting Service (AR sub-ledger + invoice balance lifecycle)
- **Upstream Domain:** Payment domain (owns payment authorization/capture/clearing)
- **Stakeholders:** Finance, Auditors

## Preconditions
- A payment has been **cleared/settled** in the Payment domain and is available for application.
- One or more invoices exist for the same customer in a payable state (e.g., `Open`, `PartiallyPaid`) with `balanceDue > 0`.
- Payment currency matches invoice currency.
- Caller is authenticated and authorized to apply payments.

## Functional Behavior

### Inter-Domain Contract (Payment ‚Üí Accounting)
- **Decision:** Event-driven integration. The Payment domain publishes a `PaymentCleared` (or equivalent) event; Accounting consumes it.
- **Minimum required fields:** `paymentId`, `customerId`, `clearedAt`, `currency`, `amount` (plus recommended metadata like `eventId` / idempotency key).

### Payment Availability (Accounting internal state)
1. On `PaymentCleared`, Accounting creates/updates an internal ‚Äúpayment available to apply‚Äù record (e.g., `AccountingPayment` / `ReceivablePayment`) with:
   - `totalAmount`
   - `unappliedAmount = totalAmount`
   - status `AVAILABLE`

### Trigger (Apply payment)
A user or automated process submits an Accounting command to apply a payment across invoices, e.g.:
- `POST /accounting/payments/{paymentId}/applications`
- Request includes `applicationRequestId` (idempotency key) and a list of `{ invoiceId, amountToApply }`.

### Main Success Scenario
1. Accounting receives the apply request.
2. Validate payment is `AVAILABLE` and has sufficient remaining value.
3. Validate each target invoice is applicable (not `PaidInFull` / `Voided` / `Cancelled`).
4. Validate requested amounts:
   - Each `amountToApply` is `> 0` and `<= invoice.balanceDue`.
   - Sum of `amountToApply` does not exceed the payment‚Äôs available amount.
5. Create immutable `PaymentApplication` record(s) linking `paymentId` + `invoiceId` + `appliedAmount` + timestamps.
6. Update invoice derived state:
   - Decrease `invoice.balanceDue` by `appliedAmount`.
   - Set status to `PaidInFull` if balance becomes `0`, else `PartiallyPaid`.
7. Update payment available state:
   - Decrease `unappliedAmount` by total applied amount.
8. **Overpayment policy (Decision):** If payment value exceeds invoice application total, create an explicit AR credit balance:
   - Create `CustomerCredit` with `customerId`, `currency`, `amount = remaining`, `sourcePaymentId`, timestamps.
   - Represent remaining value consistently as a credit (recommended: set `unappliedAmount` to `0` after credit creation so the credit is the representation of remaining value).
9. Emit events for downstream consumers:
   - `PaymentAppliedToInvoice` (per invoice application)
   - `CustomerCreditCreated` (when overpayment yields credit)

## Alternate / Error Flows
- **Invoice not applicable:** Reject with `VALIDATION_ERROR:INVOICE_NOT_APPLICABLE`; no partial writes.
- **Insufficient funds:** Reject with `VALIDATION_ERROR:INSUFFICIENT_FUNDS`; no partial writes.
- **Currency mismatch:** Reject with `VALIDATION_ERROR:CURRENCY_MISMATCH`; no partial writes.

## Business Rules
- **Domain authority (Decision):** Accounting is the system of record for `PaymentApplication` lifecycle/state; Payment remains SoR for Payment lifecycle (auth/capture/settlement/refunds).
- One payment can be applied to multiple invoices; one invoice can have multiple payments.
- Application is **atomic** across all target invoices.
- Applications are **idempotent** via `applicationRequestId` (retries must not create duplicates).
- **Reversals (Decision):** No hard deletes. Reversal is a **compensating transaction** recorded as a reversal entity/event that offsets the original application and updates derived balances.

## Data Requirements
- `ReceivablePayment` (or equivalent): `paymentId`, `customerId`, `currency`, `totalAmount`, `unappliedAmount`, `status`, `clearedAt`, `sourceEventId`
- `PaymentApplication`: `paymentApplicationId`, `paymentId`, `invoiceId`, `customerId`, `currency`, `appliedAmount`, `applicationTimestamp`, `applicationRequestId`, `traceId`
- `CustomerCredit`: `creditId`, `customerId`, `currency`, `amount`, `sourcePaymentId`, `createdAt`, `traceId`
- `PaymentApplicationReversal`: `reversalId`, `originalPaymentApplicationId`, `reversedAt`, `reversedBy`, `reason`, `amount`

## Acceptance Criteria
- **Apply fully to one invoice:** invoice becomes `PaidInFull`, payment decreases appropriately, events emitted.
- **Apply partially to one invoice:** invoice becomes `PartiallyPaid`, payment decreases appropriately, events emitted.
- **Apply across multiple invoices:** all applications persist atomically; correct resulting balances/statuses.
- **Overpayment creates credit (Decision):** when payment exceeds applied total, `CustomerCredit` is created for remainder.
- **Reversal is compensating (Decision):** reversal creates a new record, does not delete original application, and restores derived balances as defined by policy.

## Audit & Observability
- Structured logs include `traceId`, `applicationRequestId`, `paymentId`, and all `invoiceId`s.
- Metrics:
  - `payment_applications_total{status=success|failure}`
  - `payment_application_latency_ms`
- Events emitted (names may be finalized as part of implementation):
  - `PaymentAppliedToInvoice`
  - `PaymentApplicationFailed`
  - `CustomerCreditCreated`
  - `PaymentApplicationReversed`

## Open Questions
- None. Decisions were supplied in the issue comments (see Decision Record dated 2026-01-14).

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #114 ‚Äî [BACKEND] [STORY] Accounting: Apply Payment to Invoice

## Current Labels
- backend
- story-implementation
- payment

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Accounting: Apply Payment to Invoice

**Domain**: payment

### Story Description

/kiro
Apply payments to invoices with clear AR reconciliation.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: accounting

## Actor
Accounting System

## Trigger
User action or automated rule to apply a recorded payment to one or more invoices

## Main Flow
1. Select payment and target open invoice(s)
2. Validate invoice status and remaining balance
3. Apply payment amount to invoice(s)
4. Reduce Accounts Receivable balance accordingly
5. Update invoice payment status (partial/paid)
6. Persist application records

## Alternate / Error Flows
- Overpayment ‚Üí create credit balance
- Invoice closed or voided ‚Üí block application
- Partial application across multiple invoices

## Business Rules
- AR reduction occurs only when payment is applied
- One payment may apply to multiple invoices
- One invoice may have multiple payments
- Application must be reversible with audit

## Data Requirements
- Entities: PaymentApplication, Invoice, AR
- Fields: appliedAmount, invoiceId, applicationTimestamp

## Acceptance Criteria
- [ ] AR balance reduces correctly
- [ ] Invoice status updates accurately
- [ ] Partial payments are supported
- [ ] Application is auditable and reversible

## References
- Durion Accounting Event Contract v1

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299815/Durion_Accounting_Event_Contract_v1.pdf)


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #79: [BACKEND] [STORY] Timekeeping: Export Approved Time for Accounting/Payroll
LABELS: type:story,domain:accounting,status:ready-for-dev,agent:story-authoring,agent:accounting,agent:people
BODY:
## Story Intent
As an Accounting Clerk, I need to export approved time entries for a date range and location(s), so payroll and cost accounting can be processed accurately using the payroll-facing identifiers and a stable definition of ‚ÄúAPPROVED‚Äù.

## Actors & Stakeholders
- **Primary actor:** Accounting Clerk
- **Primary owner of export contract + payroll rules (Decision):** Accounting (`domain:accounting`)
- **System of record for timekeeping data + approval state (Decision):** People/Timekeeping (`domain:people`)
- **Auditor:** requires immutable audit trail of sensitive exports

## Preconditions
- Accounting Clerk is authorized to export time.
- Time entries exist in `domain:people` with a well-defined `APPROVED` state.
- Payroll-facing identifier mappings exist in `domain:accounting` (or export will exclude unmapped entries).

## Functional Behavior
### 1) Request export (Accounting-owned)
- Accounting exposes a secure export function (API and/or scheduled job) that supports:
  - `startDate` (inclusive)
  - `endDate` (inclusive)
  - `locationId` (one or more)
  - `format` (`CSV` or `JSON`)

### 2) Retrieve source data (People-owned)
- Accounting retrieves time entries from People via a stable read contract (API or events) for entries that are:
  - in state `APPROVED`
  - and within the requested date range and location(s)

### 3) Map identifiers (Accounting-owned) ‚Äî critical
- Export uses **payroll/accounting identifiers** as authoritative.
- Accounting maps:
  - `timekeepingEmployeeId ‚Üí payrollEmployeeId`
  - `timekeepingLocationId ‚Üí payrollLocationId / costCenterCode`

### 4) Handle missing mappings
- If a required mapping is missing for an entry, the entry MUST NOT be exported.
- The system records a remediation artifact (e.g., export error record/log/dead-letter) identifying the missing mapping.

### 5) Assemble file + deliver
- Assemble mapped approved entries into `CSV` or `JSON`.
- Provide download (pull) and/or store for retrieval depending on deployment approach.

### 6) Audit
- Record an immutable audit event for each export request (parameters + outcome).

## Alternate / Error Flows
- No matching approved entries ‚Üí return `200` with empty dataset (CSV header only or empty JSON array).
- Invalid parameters (e.g., `endDate < startDate`, unknown locations) ‚Üí `400`.
- Unauthorized ‚Üí `403`.
- People/timekeeping service unavailable ‚Üí `503`.

## Business Rules
- Export includes **only** entries in exact state `APPROVED`.
- Date range is inclusive.
- Export is idempotent: same request yields same output if source data and mappings are unchanged.

## Decisions Applied (from 2026-01-14 Decision Record)
### Domain ownership
- `domain:accounting` owns export contract, schema/versioning, transformation rules, and reconciliation behavior.
- `domain:people` owns timekeeping data and the approval state machine.

### Authoritative identifiers
- Payroll/accounting IDs are authoritative; do not assume timekeeping IDs match.
- Accounting owns mapping tables/entities (e.g., `PayrollIdentityMap`) from timekeeping IDs to payroll IDs.

### Formal definition of `APPROVED`
A time entry is `APPROVED` when:
1. Required payroll-export validations have passed.
2. An authorized approval action is recorded producing:
   - `approvedAt`
   - `approvedBy`
3. The entry is ready for payroll and should be stable.

Immutability expectation:
- Once `APPROVED`, exported ‚Äúwork facts‚Äù must not change silently.
- Post-approval changes require revoke/unapprove, adjustment event, or versioned revision with re-approval.

## Data Requirements
Each exported row/record MUST include payroll-facing identifiers:
- `timeEntryId` (source traceability)
- `payrollEmployeeId` (authoritative)
- `employeeName` (display)
- `payrollLocationId` or `costCenterCode` (authoritative)
- `locationName` (display)
- `entryDate`
- `hoursWorked`
- `approvedAt` (approval timestamp)
- `approvedBy` (approver reference)

## Acceptance Criteria
- **AC1: CSV export includes only approved entries**
  - Given a mix of `APPROVED` and non-approved entries
  - When exporting for a date range/location
  - Then only `APPROVED` entries appear in the output.

- **AC2: Unmapped IDs are excluded and reported**
  - Given an approved time entry with missing employee or location mapping
  - When exporting
  - Then the entry is excluded
  - And a remediation artifact is recorded (missing mapping details).

- **AC3: Empty export returns success**
  - Given no approved entries match the criteria
  - When exporting
  - Then the response is `200` with an empty dataset.

- **AC4: Audit event recorded for export**
  - When an export request completes (success or failure)
  - Then an immutable audit event is recorded with requester, parameters, status, count, and correlationId.

## Audit & Observability
- Audit captures: `requestingPrincipalId`, `sourceIpAddress`, `timestampUtc`, parameters, outcome, `recordsExportedCount`, `correlationId`.
- Metrics:
  - `time_export_requests_total{status,format}`
  - `time_export_duration_seconds`
  - `time_export_records_exported_total`
  - `time_export_records_skipped_total{reason=missing_mapping}`
- Logs must not contain sensitive export contents.

## Open Questions
- None. Decisions were supplied in the issue comments (Decision Record generated by `clarification-resolver.sh` on 2026-01-14).

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #79 ‚Äî [BACKEND] [STORY] Timekeeping: Export Approved Time for Accounting/Payroll

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Timekeeping: Export Approved Time for Accounting/Payroll

**Domain**: user

### Story Description

/kiro
# User Story

## Narrative
As an **Accounting user**, I want **to export approved time** so that **it can be used for payroll or cost accounting**.

## Details
- Export by date range and location.
- Provide CSV/JSON output.

## Acceptance Criteria
- Only approved time is exported.
- Export includes person identifiers and location.
- Export activity is audited.

## Integration Points (workexec/shopmgr)
- None required initially.

## Data / Entities
- TimeEntry

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: People Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #5: [BACKEND] [STORY] Accounting: Reconcile POS Status with Accounting Authoritative Status
LABELS: type:story,domain:accounting,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:accounting
- status:ready-for-dev

### Recommended
- agent:accounting
- agent:story-authoring

---

## Story Intent

Enable **Cashiers and Service Advisors** to view the **authoritative accounting status** of invoices and transactions directly within the POS interface, ensuring that displayed status (pending posting, posted, reconciled) reflects the accounting system's system-of-record state, thereby reducing customer disputes, internal confusion, and manual reconciliation effort.

This story establishes **event-driven synchronization** between the POS transaction layer and the accounting posting layer, making accounting the single source of truth for financial status.

---

## Actors & Stakeholders

### Primary Actors
- **Cashier**: Views invoice accounting status when handling customer inquiries or resolving payment disputes
- **Service Advisor**: Views accounting status for orders and invoices during follow-up or collections
- **Accounting System**: System of record for financial posting status; emits authoritative status events
- **POS Status Synchronizer Service**: Subscribes to accounting events and updates local POS status cache

### Secondary Stakeholders
- **Accounting Team**: Monitors reconciliation metrics and investigates discrepancies
- **Customer**: Benefits indirectly from accurate status display (e.g., knows when payment has cleared)
- **Audit Service**: Logs all status synchronization events for compliance and troubleshooting

---

## Preconditions

1. Invoice exists in POS with local status (e.g., "submitted", "pending accounting")
2. Accounting system has received invoice and processed it (or is processing)
3. Accounting system is configured to emit `InvoiceStatusChanged` and `PostingConfirmed` events to event bus
4. POS Status Synchronizer Service is subscribed to accounting event topics
5. User has permission to view invoice details in POS

---

## Functional Behavior

### 1. Receive and Process Accounting Status Events

**Trigger**: Accounting system emits `InvoiceStatusChanged` or `PostingConfirmed` event

**Flow**:
1. Accounting system posts event to event bus with:
   - Invoice ID
   - New accounting status (e.g., "PENDING_POSTING", "POSTED", "RECONCILED", "REJECTED")
   - Posting reference (GL entry ID, batch ID)
   - Timestamp
   - Event type
2. POS Status Synchronizer Service receives event
3. Service validates event payload (invoice ID exists, status is recognized)
4. Service updates local POS status record:
   - `accountingStatus`: New status from event
   - `accountingStatusUpdatedAt`: Event timestamp
   - `postingReference`: Drilldown reference to accounting system
   - `lastSyncEvent`: Event ID for traceability
5. Service logs synchronization event to audit log
6. Service publishes internal POS notification (optional): "Invoice X status updated to POSTED"

**Outcome**: POS local status is synchronized with accounting authoritative status

---

### 2. Display Authoritative Accounting Status in POS

**Trigger**: Cashier or Service Advisor views invoice details in POS

**Flow**:
1. User opens invoice detail screen
2. POS retrieves invoice record including:
   - Local POS status (e.g., "PAYMENT_RECEIVED")
   - Accounting status (e.g., "POSTED")
   - Accounting status timestamp
   - Posting reference
3. POS displays accounting status prominently:
   - Status badge: "Posted to Accounting" (green) or "Pending Posting" (yellow)
   - Last updated timestamp: "Updated 2 minutes ago"
   - If discrepancy exists between local POS status and accounting status, show both with warning icon
4. User can click drilldown link to view accounting system posting details (if permissions allow)

**Outcome**: User sees authoritative accounting status without needing to check accounting system separately

---

### 3. Provide Drilldown to Accounting System

**Trigger**: User clicks "View in Accounting" or drilldown link on invoice detail screen

**Flow**:
1. POS retrieves posting reference from invoice record (e.g., GL entry ID, batch ID)
2. POS constructs deep link to accounting system (e.g., `https://accounting.example.com/entries/{entryId}`)
3. POS opens link in new tab/window or embedded iframe (depending on UX)
4. Accounting system authenticates user (SSO or session passthrough)
5. Accounting system displays posting detail (debit/credit lines, posting date, status, audit trail)

**Outcome**: User can drill down to accounting detail without manually searching or context-switching

---

### 4. Handle Status Discrepancies (POS vs Accounting)

**Trigger**: Accounting status and local POS status do not match expected progression

**Flow**:
1. POS detects discrepancy:
   - Example: Local POS status is "PAYMENT_RECEIVED" but accounting status is "REJECTED"
2. POS displays warning to user:
   - "‚ö†Ô∏è Status Mismatch: POS shows payment received, but accounting rejected posting. See details."
3. User views details:
   - POS status: PAYMENT_RECEIVED (updated 10 minutes ago)
   - Accounting status: REJECTED (updated 5 minutes ago)
   - Reason: "Invoice total does not match payment total"
4. User can escalate to supervisor or accounting team for resolution
5. System logs discrepancy event to audit log with both statuses, timestamps, and user who viewed it

**Outcome**: Discrepancies are surfaced to users immediately, not discovered during end-of-day reconciliation

---

## Alternate / Error Flows

### 1. Accounting Event Lost or Delayed

**Trigger**: Accounting system emits event but POS never receives it (network issue, event bus failure)

**Flow**:
1. POS has local status "PENDING_POSTING" with `accountingStatusUpdatedAt` timestamp
2. After configurable timeout (e.g., 1 hour), POS detects stale accounting status
3. POS Status Synchronizer Service polls accounting API for current status (fallback mechanism)
4. Service updates local status based on polling result
5. If polling also fails, system logs critical alert and displays "Accounting status unavailable" in UI
6. User can manually request sync or contact accounting team

---

### 2. Accounting Status Event for Unknown Invoice

**Trigger**: Accounting system emits event for invoice ID that does not exist in POS

**Flow**:
1. POS Status Synchronizer Service receives event with unknown invoice ID
2. Service logs warning: "Received accounting event for unknown invoice: {invoiceId}"
3. Service checks if invoice was deleted or archived
4. If not found in any POS state:
   - Service publishes dead-letter event
   - Service alerts monitoring system for manual investigation
5. Event is not retried (avoids infinite retry loop)

**Outcome**: Orphaned events do not cause system instability

---

### 3. User Lacks Permission to View Accounting Status

**Trigger**: User opens invoice detail but does not have permission to view accounting data

**Flow**:
1. POS checks user permissions
2. If `VIEW_ACCOUNTING_STATUS` permission is missing:
   - POS hides accounting status section
   - POS shows message: "Accounting details restricted. Contact supervisor."
3. Local POS status is still visible
4. Access attempt is logged to audit log

---

### 4. Accounting System Emits Conflicting Events

**Trigger**: Accounting system emits two events for same invoice with conflicting statuses (e.g., "POSTED" followed by "PENDING_POSTING")

**Flow**:
1. POS Status Synchronizer Service receives first event: "POSTED"
2. Service updates local status to "POSTED"
3. Service receives second event: "PENDING_POSTING" with earlier timestamp
4. Service detects timestamp conflict (second event is older than current state)
5. Service ignores older event and logs warning: "Received out-of-order event for invoice {invoiceId}"
6. Service alerts monitoring for accounting event ordering issue

**Outcome**: Out-of-order events do not cause status regression

---

### 5. Drilldown Link to Accounting System Fails

**Trigger**: User clicks drilldown link but accounting system is unavailable or returns error

**Flow**:
1. User clicks "View in Accounting"
2. POS attempts to open deep link to accounting system
3. Accounting system returns 503 Service Unavailable or times out
4. POS displays error message: "Accounting system temporarily unavailable. Try again later."
5. POS copies posting reference to clipboard for manual lookup
6. Error is logged to monitoring system

---

## Business Rules

### 1. Accounting Status is Authoritative (Conflict Resolution Rule)

When POS local status and accounting status conflict, **accounting status is the headline** for financial decision-making.

POS local status represents internal workflow state (e.g., "invoice created", "payment received").
Accounting status represents financial posting state (e.g., "posted to GL", "reconciled with bank").

If accounting status is "REJECTED", "REVERSED", "VOIDED", or "ON_HOLD", POS MUST surface this to users immediately with error banner, requiring resolution workflow. POS does not silently continue.

**Manual override is not a status change:** It is an exception record (`AccountingStatusException`) with reason, approver, timestamp, and full audit trail. Accounting remains source of truth; exception only affects POS workflow routing.

---

### 2. Status Progression Rules

**POS-facing Accounting Status Enum (v1 - stable contract):**

1. **PENDING_POSTING**: Accepted by accounting intake; not yet posted to GL.
2. **POSTED**: GL entries created and committed.
3. **RECONCILED**: Matched to bank statement / settlement source (or payment gateway settlement) per accounting rules.
4. **REJECTED**: Accounting rejected intake or posting (validation failure, imbalanced, closed period, etc.).
5. **REVERSED**: A posted entry was reversed (credit memo/reversal journal).
6. **VOIDED**: Invoice voided in accounting (no longer collectible; may or may not have prior posting).
7. **ON_HOLD**: Held for approval/credit/exception; no posting progression until released.
8. **DISPUTED**: Flagged as in dispute (workflow state; posting may already exist).

**Lifecycle constraints (POS-facing):**

- Typical: `PENDING_POSTING ‚Üí POSTED ‚Üí RECONCILED`
- Exceptional transitions allowed:
  - `PENDING_POSTING ‚Üí REJECTED`
  - `POSTED ‚Üí REVERSED` (and optionally `‚Üí RECONCILED` prior to reversal)
  - Any state `‚Üí ON_HOLD` (administrative hold), and `ON_HOLD ‚Üí PENDING_POSTING|POSTED|REJECTED` (release outcome)
  - Any state `‚Üí DISPUTED` (flag), `DISPUTED ‚Üí {prior state}` not allowed; instead emit new authoritative status with reason
  - `VOIDED` is terminal from POS perspective (still retained for audit)

Backward progression (e.g., POSTED ‚Üí PENDING_POSTING) is **abnormal** and MUST trigger alert.

---

### 3. Drilldown Permissions (Three-Tier Model)

**Tier 1: VIEW_ACCOUNTING_STATUS**
- May see accounting status badge, timestamp, and high-level reason (if REJECTED/ON_HOLD/DISPUTED).
- Default: Cashier, Service Advisor, Manager, Supervisor.

**Tier 2: REFRESH_ACCOUNTING_STATUS**
- May trigger manual polling refresh.
- Default: Cashier, Manager, Supervisor.

**Tier 3: VIEW_ACCOUNTING_DETAIL**
- May use drilldown link, see postingReference fields (GL entry/batch IDs), and access deep link.
- Default: Accounting role, Manager, Supervisor only.

**UI Behavior:**
- If user lacks VIEW_ACCOUNTING_STATUS: hide accounting section entirely.
- If user has status but not detail: show badge and timestamp; hide GL identifiers and drilldown link.

---

### 4. Event Idempotency and Delivery Guarantee

**Delivery guarantee:** At-least-once delivery with idempotent consumer.

**Idempotency key:** `eventId` (UUID) + `invoiceId`. Store a processed-event table with retention ‚â• 30 days (configurable) to deduplicate.

**Retry policy (consumer):**
- If processing fails due to transient errors (DB/redis/network): retry with exponential backoff (e.g., 1m, 5m, 15m) up to N=10 attempts.
- After max attempts: send to **DLQ** with full payload and error metadata; alert.

**Maximum event age:**
- Process events up to 7 days old (for recovery), but mark `metadata.lateEvent=true` and raise metric.

---

### 5. Stale Status Detection and Fallback Polling

If `accountingStatusUpdatedAt` is older than **1 hour** (default, configurable), POS MUST:
- Display staleness indicator: "Last synced 2 hours ago"
- Offer manual refresh button
- Log staleness metric for monitoring

**Fallback polling triggers:**
- If event bus outage detected (no events consumed for topic for >10 minutes), enable background polling for "recently active invoices" (last 24h) at a low rate to reduce drift.

Cashiers SHOULD be trained to manually refresh stale status before making payment decisions.

---

### 6. Audit Trail Requirements

Every status synchronization event MUST be logged to audit log with:
- Invoice ID
- Old status (before event)
- New status (from event)
- Event timestamp
- Event ID
- User who viewed status (if applicable)
- Any discrepancies detected
- Sync source (EVENT, POLLING, MANUAL_REFRESH)
- Latency (event timestamp to sync completion)

Audit logs MUST be retained for minimum 7 years for financial compliance.

---

### 7. Archive-Not-Delete Policy

**POS policy:** Invoices are **archived**, not deleted, once issued/paid/closed.

**Status synchronizer:** Must update accounting status for **archived invoices** as well (same table/partition).

**Retention:** Keep invoice + accounting status + audit trail for **7 years**. If jurisdiction requires longer, make retention configurable; default remains 7 years.

**Unknown invoice events:**
- If invoiceId not found in active table, check archive store.
- If not found anywhere: send to DLQ as orphan event + alert.

---

## Data Requirements

### PostingConfirmation (Event Payload from Accounting)

```json
{
  "eventId": "string (UUID)",
  "eventType": "enum (INVOICE_STATUS_CHANGED, POSTING_CONFIRMED)",
  "invoiceId": "string (UUID)",
  "accountingStatus": "enum (PENDING_POSTING, POSTED, RECONCILED, REJECTED, REVERSED, VOIDED, ON_HOLD, DISPUTED)",
  "postingReference": {
    "glEntryId": "string (UUID)",
    "batchId": "string",
    "postingDate": "date (ISO 8601)"
  },
  "timestamp": "timestamp (ISO 8601)",
  "reason": "string (optional, e.g., rejection reason)",
  "nativeStatus": "string (optional, for diagnostics only; POS ignores)",
  "metadata": {
    "accountingSystemVersion": "string",
    "processedBy": "string (accounting system user or job)"
  }
}
```

---

### InvoiceAccountingStatus (POS Local Model)

```json
{
  "invoiceId": "string (UUID)",
  "posLocalStatus": "enum (CREATED, PAYMENT_RECEIVED, SUBMITTED_TO_ACCOUNTING, CLOSED)",
  "accountingStatus": "enum (PENDING_POSTING, POSTED, RECONCILED, REJECTED, REVERSED, VOIDED, ON_HOLD, DISPUTED)",
  "accountingStatusUpdatedAt": "timestamp (ISO 8601)",
  "postingReference": {
    "glEntryId": "string (UUID)",
    "batchId": "string",
    "postingDate": "date",
    "drilldownUrl": "string (deep link to accounting system)"
  },
  "lastSyncEvent": "string (UUID, event ID for traceability)",
  "discrepancyDetected": "boolean",
  "discrepancyReason": "string (optional)"
}
```

---

### AccountingStatusSyncAuditLog (Audit Model)

```json
{
  "auditId": "string (UUID)",
  "invoiceId": "string (UUID)",
  "eventId": "string (UUID)",
  "oldStatus": "string",
  "newStatus": "string",
  "syncedAt": "timestamp (ISO 8601)",
  "discrepancyDetected": "boolean",
  "viewedByUserId": "string (UUID, optional)",
  "metadata": {
    "syncSource": "enum (EVENT, POLLING, MANUAL_REFRESH)",
    "latencyMs": "integer (event timestamp to sync completion)"
  }
}
```

---

## Acceptance Criteria

### AC1: Accounting Status Overrides Local POS State in Display

**Given** an invoice has POS local status "PAYMENT_RECEIVED"  
**And** accounting system emits `PostingConfirmed` event with status "POSTED"  
**When** the POS Status Synchronizer Service processes the event  
**Then** the invoice's `accountingStatus` field is updated to "POSTED"  
**And** when a user views the invoice, the accounting status badge displays "Posted to Accounting" prominently  
**And** the local POS status is still visible but secondary

---

### AC2: Pending vs Posted States Are Clearly Displayed

**Given** an invoice has accounting status "PENDING_POSTING"  
**When** a Cashier views the invoice detail screen  
**Then** the accounting status badge displays "Pending Posting" with a yellow indicator  
**And** the badge shows last updated timestamp (e.g., "Updated 5 minutes ago")  
**When** the accounting status changes to "POSTED"  
**And** the Cashier refreshes or reopens the invoice  
**Then** the badge displays "Posted" with a green indicator

---

### AC3: Drilldown to Accounting System Works with Permission Check

**Given** an invoice has been posted to accounting with `glEntryId: 12345`  
**And** the user has `VIEW_ACCOUNTING_DETAIL` permission  
**When** the user clicks "View in Accounting" on the invoice detail screen  
**Then** a new browser tab opens with the accounting system's GL entry detail page for entry 12345  
**And** the user is automatically authenticated via SSO (no login prompt)

**Given** the user lacks `VIEW_ACCOUNTING_DETAIL` permission  
**When** the user views the invoice detail screen  
**Then** the "View in Accounting" link is hidden; accounting status badge remains visible

---

### AC4: Status Discrepancies Are Surfaced to User

**Given** an invoice has POS local status "PAYMENT_RECEIVED"  
**And** accounting system emits event with status "REJECTED" and reason "Invoice total mismatch"  
**When** the POS Status Synchronizer Service processes the event  
**Then** the invoice's `discrepancyDetected` flag is set to true  
**And** the `discrepancyReason` is populated with "Invoice total mismatch"  
**When** a user views the invoice  
**Then** a warning banner is displayed: "‚ö†Ô∏è Status Mismatch: Accounting rejected this invoice. Reason: Invoice total mismatch."  
**And** both POS and accounting statuses are shown side-by-side for comparison

---

### AC5: Audit Log Captures All Synchronization Events

**Given** accounting system emits `InvoiceStatusChanged` event for invoice 456  
**When** the POS Status Synchronizer Service processes the event  
**Then** an audit log entry is created with:  
  - `invoiceId: 456`  
  - `oldStatus: PENDING_POSTING`  
  - `newStatus: POSTED`  
  - `eventId:` (from event)  
  - `syncedAt:` (current timestamp)  
**And** the audit log is persisted to the audit database

---

### AC6: Stale Accounting Status Triggers Fallback Polling

**Given** an invoice's `accountingStatusUpdatedAt` timestamp is 2 hours old  
**And** the staleness threshold is configured to 1 hour  
**When** a user views the invoice  
**Then** the system displays "Accounting status may be outdated (last synced 2 hours ago)"  
**And** a "Refresh Status" button is displayed  
**When** the user clicks "Refresh Status"  
**Then** the POS Status Synchronizer Service polls the accounting API for current status  
**And** the invoice's accounting status is updated with the latest value  
**And** the user sees the updated status immediately

---

### AC7: Out-of-Order Events Are Ignored

**Given** an invoice has accounting status "POSTED" with timestamp "2026-01-05T10:00:00Z"  
**When** the POS Status Synchronizer Service receives an event with status "PENDING_POSTING" and timestamp "2026-01-05T09:55:00Z" (earlier)  
**Then** the service ignores the event because it is older than current state  
**And** the invoice's accounting status remains "POSTED"  
**And** a warning is logged: "Ignored out-of-order event for invoice {invoiceId}"

---

### AC8: Critical Status Changes Sync Within SLA

**Given** accounting system emits event with status in [POSTED, REJECTED, REVERSED, VOIDED]  
**When** the POS Status Synchronizer Service processes the event  
**Then** the invoice's accounting status is updated within **p95 < 5 seconds**, **p99 < 30 seconds**

**Given** accounting system emits event with status in [PENDING_POSTING, ON_HOLD, DISPUTED, RECONCILED]  
**When** the POS Status Synchronizer Service processes the event  
**Then** the invoice's accounting status is updated within **p95 < 30 seconds**, **p99 < 2 minutes**

---

## Audit & Observability

### Required Audit Events

1. **AccountingStatusSynchronized**
   - Timestamp, invoice ID, old status, new status, event ID, sync source (event/polling), latency

2. **StatusDiscrepancyDetected**
   - Timestamp, invoice ID, POS status, accounting status, discrepancy reason, viewing user ID

3. **DrilldownLinkAccessed**
   - Timestamp, user ID, invoice ID, accounting reference (GL entry ID), success/failure

4. **StaleStatusDetected**
   - Timestamp, invoice ID, last sync timestamp, staleness duration (hours), user action (viewed/refreshed)

5. **AccountingEventIgnored**
   - Timestamp, event ID, invoice ID, reason (duplicate, out-of-order, unknown invoice)

6. **FallbackPollingTriggered**
   - Timestamp, invoice ID, reason (event loss, staleness), polling result (success/failure)

---

### Metrics to Track

- **Status Sync Latency**: Time from accounting event emission to POS status update (target: p95 <5s for critical, p95 <30s for non-critical)
- **Event Processing Rate**: Events processed per minute
- **Discrepancy Rate**: Percentage of invoices with POS/accounting status mismatch (target: <1%)
- **Stale Status Count**: Number of invoices with outdated accounting status at any given time (target: <10)
- **Fallback Polling Success Rate**: Percentage of manual refresh requests that succeed (target: >95%)
- **Drilldown Link Failures**: Count of failed accounting system deep links per day (target: <5)
- **Out-of-Order Event Count**: Count of ignored out-of-order events (should be near zero)
- **DLQ Event Count**: Events sent to dead-letter queue per day (target: <5)

---

## Resolved Open Questions Summary

‚úÖ **Q1 - Accounting Status Enum (v1 contract):** PENDING_POSTING, POSTED, RECONCILED, REJECTED, REVERSED, VOIDED, ON_HOLD, DISPUTED with defined lifecycle constraints.

‚úÖ **Q2 - Conflict Resolution:** Accounting is authoritative for financial posting; POS operational state separate. Manual overrides create exception records, not status changes. Accounting remains source of truth.

‚úÖ **Q3 - Event Delivery Guarantee:** At-least-once delivery with idempotent processing. Retry up to 10x with exponential backoff; DLQ after max attempts. 7-day max event age. Fallback polling after 1 hour staleness or event bus outage.

‚úÖ **Q4 - Permissions (Three-Tier):** VIEW_ACCOUNTING_STATUS (badge only), REFRESH_ACCOUNTING_STATUS (manual refresh), VIEW_ACCOUNTING_DETAIL (drilldown + GL refs). Different defaults per role.

‚úÖ **Q5 - Drilldown Scope:** Posting summary in POS (GL entry ID, posting date, batch ID, amount, counterparty, processor); full detail via SSO deep link to accounting system.

‚úÖ **Q6 - Archive-Not-Delete Policy:** Invoices archived, not deleted. Status synchronizer updates archived invoices too. 7-year retention. Unknown invoices checked in archive store before DLQ.

‚úÖ **Q7 - Latency SLA (Two-Tier):** Critical statuses (POSTED, REJECTED, REVERSED, VOIDED) p95 <5s, p99 <30s. Non-critical (PENDING_POSTING, ON_HOLD, DISPUTED, RECONCILED) p95 <30s, p99 <2min.

---

## Original Story (Unmodified ‚Äì For Traceability)

# Issue #5 ‚Äî [BACKEND] [STORY] Accounting: Reconcile POS Status with Accounting Authoritative Status

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Accounting: Reconcile POS Status with Accounting Authoritative Status

**Domain**: user

### Story Description

/kiro
# User Story

## Narrative
As a **Cashier**, I want POS to reflect accounting's authoritative status so that disputes are minimized.

## Details
- Show "pending posting" vs "posted."
- Provide drilldown refs.

## Acceptance Criteria
- Accounting status overrides local state.
- Pending/posted states clear.
- Audit of reconciliation.

## Integrations
- Accounting emits InvoiceStatusChanged/PostingConfirmed events.

## Data / Entities
- PostingConfirmation, InvoiceStatusChangedEvent, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Experience
- domain :  Point of Sale

### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*


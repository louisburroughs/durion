‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #196: [BACKEND] [STORY] Cost: Maintain Standard/Last/Average Cost with Audit
LABELS: type:story,layer:functional,kiro,domain:inventory,status:needs-review
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:inventory
- status:ready-for-dev

### Recommended
- agent:inventory
- agent:story-authoring

---

**Rewrite Variant:** integration-conservative

## Story Intent
**As a** system architect,
**I want** to establish a robust mechanism to maintain and audit three distinct cost types (Standard, Last, and Average) for each inventory item,
**so that** the business has accurate, traceable inventory valuation data for financial reporting, operational analysis, and auditing purposes.

## Actors & Stakeholders
- **System:** The primary actor, responsible for automatically updating Last and Average costs based on inventory events.
- **Inventory Manager:** A user responsible for viewing inventory costs and managing the Standard Cost.
- **Finance Manager:** A user with accounting oversight who may also adjust Standard Cost.
- **Accountant / Finance Team:** Key stakeholders who rely on accurate and auditable cost data for calculating Cost of Goods Sold (COGS), valuing inventory on the balance sheet, and performing financial analysis.
- **Auditor:** A stakeholder who requires a clear, immutable history of all changes to inventory costs for compliance and verification.

## Preconditions
- A canonical `Inventory Item` or `SKU` entity exists within the system and can be uniquely identified.
- System events that trigger cost changes, such as 'Purchase Order Received', are published and consumable by the Inventory service.
- User roles and permissions framework exists to gate access to manual cost adjustments.
- `InventoryManager` and `FinanceManager` roles are defined and assignable.

## Functional Behavior

### 1. Standard Cost Management
- The `Standard Cost` is a predetermined or planned cost for an item used for **reference, planning, and variance analysis** purposes.
- It is **NOT** used for financial valuation (COGS or balance sheet).
- It is only updated through an explicit, permissioned manual action by an authorized user (`InventoryManager` or `FinanceManager`).
- It does not change automatically based on purchasing or receiving activities.
- **Permission Required:** `inventory.cost.standard.update`
- **Audit Required:** Every manual change must include a `reasonCode` field explaining the adjustment.

### 2. Last Cost Update (Event-Driven)
- The `Last Cost` represents the most recent unit purchase price of an item.
- It is **informational only** and not used for financial valuation.
- **Trigger:** The system processes a 'Purchase Order Received' event for an inventory item.
- **Action:** The system automatically updates the `Last Cost` for the item to the unit cost specified in the received purchase order line.
- **Manual Updates:** Users are **prohibited** from manually editing `Last Cost`. This field is exclusively system-managed.

### 3. Average Cost Recalculation (Event-Driven)
- The `Average Cost` is a **Weighted Average Cost (WAC)** of all units of an item currently in stock.
- This is the **authoritative costing method** for:
  - Cost of Goods Sold (COGS)
  - Inventory valuation on the balance sheet
- **Trigger:** The system processes a 'Purchase Order Received' event for an inventory item.
- **Action:** The system recalculates the `Average Cost` using the following formula:
  ```
  NewAverageCost = ((OldQtyOnHand * OldAverageCost) + (ReceivedQty * ReceivedUnitCost)) / (OldQtyOnHand + ReceivedQty)
  ```
- **Manual Updates:** Users are **prohibited** from manually editing `Average Cost`. This field is exclusively system-calculated.
- **Authority:** The Inventory domain agent is responsible for defining and maintaining this calculation logic. Accounting domain must NOT re-derive or reinterpret this formula.

### 4. Cost Change Auditing
- Every change to `Standard Cost`, `Last Cost`, or `Average Cost` must generate an immutable audit log entry.
- The audit entry must capture:
  - Item identifier
  - Cost type that changed
  - Old value
  - New value
  - Timestamp
  - Source of change (e.g., `user_id` for manual updates, `purchase_order_id` for automatic updates)
  - User/system process that initiated it
  - For manual Standard Cost changes: a required `reasonCode` field

## Alternate / Error Flows
- **Error - Receiving Item with Invalid Cost:** If a 'Purchase Order Received' event contains a non-positive (`<= 0`) unit cost, the cost update transaction for that item must be rejected, and an error must be logged. The existing `Last Cost` and `Average Cost` should remain unchanged.
- **Error - Transaction Failure:** All cost updates (e.g., updating Last and Average cost simultaneously) and the creation of their corresponding audit log entries must occur within a single atomic transaction. If any part of the process fails, the entire transaction must be rolled back to maintain data integrity.
- **Flow - Manual Update of System-Managed Costs:** Users attempting to manually edit `Last Cost` or `Average Cost` fields must receive a validation error. These fields are exclusively managed by the system in response to events.
- **Flow - Manual Standard Cost Update Without Reason:** If a user attempts to update `Standard Cost` without providing a `reasonCode`, the system must reject the request with a validation error.

## Business Rules
- All monetary values for cost must be stored with a minimum precision of 4 decimal places.
- The weighted average cost calculation must be deterministic and follow the specified formula precisely.
- **Initial values for new items:** All three cost fields (`standardCost`, `lastCost`, `averageCost`) must be initialized to `null` (NOT zero) when a new inventory item is created. Zero implies a real cost and creates accounting ambiguity.
- **On first receipt:** `lastCost` and `averageCost` are set to the unit cost from the first receipt. `standardCost` remains `null` unless explicitly set.
- **Costing method hierarchy:**
  - **Primary (authoritative):** Weighted Average Cost (WAC) for COGS and financial valuation
  - **Reference only:** Standard Cost (for planning and variance analysis)
  - **Informational only:** Last Cost (recent purchase price)
- **FIFO/LIFO:** Not in scope. These methods are explicitly NOT assumed or supported.
- **Domain ownership:** Inventory domain is the system of record for all item costs. Accounting domain consumes but does not own or recalculate cost data.

## Data Requirements

### `InventoryItem` Entity (Proposed additions)
- `standardCost` (Decimal/Money, nullable, precision: 4 decimal places)
- `lastCost` (Decimal/Money, nullable, precision: 4 decimal places)
- `averageCost` (Decimal/Money, nullable, precision: 4 decimal places)

### `ItemCostAudit` Entity (New)
- `auditId` (UUID, Primary Key)
- `itemId` (UUID/String, Foreign Key to InventoryItem, indexed)
- `timestamp` (Timestamp, indexed)
- `costTypeChanged` (Enum: 'STANDARD', 'LAST', 'AVERAGE')
- `oldValue` (Decimal/Money, nullable)
- `newValue` (Decimal/Money, nullable)
- `changeSourceType` (Enum: 'MANUAL', 'PURCHASE_ORDER')
- `changeSourceId` (String, e.g., User ID or Purchase Order ID)
- `actor` (String, e.g., 'system' or 'user:john.doe')
- `reasonCode` (String, required for MANUAL changes to standardCost, nullable otherwise)

## Acceptance Criteria

**Scenario 1: Manually Updating Standard Cost with Reason**
- **Given** an inventory item with a `Standard Cost` of `10.00`.
- **And** an authorized Inventory Manager (with `inventory.cost.standard.update` permission) is logged in.
- **When** the manager updates the `Standard Cost` to `12.50` with reason code "SUPPLIER_PRICE_INCREASE".
- **Then** the item's `Standard Cost` in the database is `12.50`.
- **And** a new `ItemCostAudit` record is created showing the change from `10.00` to `12.50` for the 'STANDARD' cost type, with a 'MANUAL' source, and the provided reason code.

**Scenario 2: Manual Standard Cost Update Rejected Without Reason**
- **Given** an inventory item with a `Standard Cost` of `10.00`.
- **And** an authorized Inventory Manager is logged in.
- **When** the manager attempts to update the `Standard Cost` to `12.50` without providing a `reasonCode`.
- **Then** the update is rejected with a validation error.
- **And** the item's `Standard Cost` remains `10.00`.
- **And** no audit record is created.

**Scenario 3: Receiving a Purchase Order Updates Last and Average Cost**
- **Given** an inventory item with `QtyOnHand` of `100`, a `Last Cost` of `5.00`, and an `Average Cost` of `5.50`.
- **When** a 'Purchase Order Received' event is processed for `50` units of this item at a `ReceivedUnitCost` of `6.00`.
- **Then** the item's `Last Cost` is updated to `6.00`.
- **And** the item's `Average Cost` is recalculated to `5.6667` ( (100 * 5.50) + (50 * 6.00) ) / (100 + 50).
- **And** two new `ItemCostAudit` records are created: one for the `Last Cost` change and one for the `Average Cost` change, both linked to the Purchase Order ID with 'PURCHASE_ORDER' source type.

**Scenario 4: First Receipt Initializes Costs**
- **Given** a newly created inventory item with `standardCost`, `lastCost`, and `averageCost` all `null`.
- **And** this is the first receipt for the item.
- **When** a 'Purchase Order Received' event is processed for `20` units at a `ReceivedUnitCost` of `8.00`.
- **Then** the item's `Last Cost` is set to `8.00`.
- **And** the item's `Average Cost` is set to `8.00`.
- **And** the item's `Standard Cost` remains `null`.
- **And** audit records are created for both `Last Cost` and `Average Cost` changes (from `null` to `8.00`).

**Scenario 5: Receiving a Purchase Order with Zero Cost**
- **Given** an inventory item with a `Last Cost` of `5.00` and an `Average Cost` of `5.50`.
- **When** a 'Purchase Order Received' event is processed with a `ReceivedUnitCost` of `0.00`.
- **Then** the cost update transaction is rejected.
- **And** the item's `Last Cost` remains `5.00` and `Average Cost` remains `5.50`.
- **And** an error is logged detailing the rejection reason and the source Purchase Order.
- **And** no audit records are created.

**Scenario 6: Unauthorized User Cannot Manually Update Standard Cost**
- **Given** an inventory item with a `Standard Cost` of `10.00`.
- **And** a user without `inventory.cost.standard.update` permission is logged in.
- **When** the user attempts to update the `Standard Cost` to `12.50`.
- **Then** the update is rejected with an authorization error.
- **And** the item's `Standard Cost` remains `10.00`.
- **And** no audit record is created.

**Scenario 7: User Cannot Manually Update Average Cost**
- **Given** an inventory item with an `Average Cost` of `5.50`.
- **And** an authorized Inventory Manager is logged in.
- **When** the manager attempts to manually update the `Average Cost` to `6.00`.
- **Then** the update is rejected with a validation error stating that Average Cost is system-calculated only.
- **And** the item's `Average Cost` remains `5.50`.
- **And** no audit record is created.

**Scenario 8: Transaction Rollback on Audit Failure**
- **Given** an inventory item requires cost updates from a purchase order receipt.
- **When** the cost calculations succeed but the audit log write fails.
- **Then** the entire transaction is rolled back.
- **And** the item's costs remain unchanged.
- **And** an error is logged indicating the transaction failure.

## Audit & Observability
- **Audit Trail:** The `ItemCostAudit` table serves as the primary, non-repudiable log of all cost changes. It must be queryable by item ID, date range, cost type, and change source type.
- **Logging:** Structured logs should be emitted for:
  - Every successful cost update transaction (including all calculated values)
  - Detailed error logs for any failed transactions, including the event payload that caused the failure
  - Manual cost adjustment attempts (both successful and rejected)
- **Metrics:** The system should expose metrics for:
  - `inventory.cost.updates.count` (counter, tagged by cost_type: standard/last/average, outcome: success/failure, source: manual/purchase_order)
  - `inventory.cost.manual_adjustments.rejected.count` (counter, tagged by reason: no_reason_code/unauthorized/invalid_cost_type)
  - `inventory.cost.calculation.duration.ms` (timer for WAC calculations)
  - `inventory.cost.audit.write.failures.count` (counter for audit failures)

## Domain Clarification Resolution

All blocking domain conflicts have been resolved:

### 1. Domain Ownership
**Decision:** **Inventory domain** is the system of record for inventory item costs.
- Inventory service owns data tables and APIs for reading current/historical costs
- Accounting service treats cost as authoritative input and does not recalculate or override item cost
- This follows standard ERP patterns (Inventory owns cost; Accounting posts using it)

### 2. Authoritative Logic for Cost Calculation
**Decision:** **Inventory-domain-agent** is responsible for defining and implementing cost calculation logic, including Weighted Average Cost (WAC).
- Inventory domain calculates and maintains `averageCost`, updates `lastCost`, and manages `standardCost`
- Accounting domain uses provided costs for postings and must NOT re-derive or reinterpret cost formulas
- Any change to cost calculation logic requires explicit inventory-domain clarification and audit coverage

### 3. Primary Costing Method
**Decision:** **Weighted Average Cost (WAC)** is the default and authoritative costing method for:
- Cost of Goods Sold (COGS)
- Inventory valuation on the balance sheet

**Notes:**
- Standard Cost is for reference/planning/variance analysis, not authoritative for valuation
- Last Cost is informational, not used for financial valuation
- FIFO/LIFO are out of scope and not assumed
- Hybrid valuation is not permitted without explicit accounting approval

### 4. Permissions for Manual Cost Adjustments
**Decision:** Manual updates to `standardCost` only are permitted and restricted.

**Authorized Roles:**
- `InventoryManager`
- `FinanceManager` (accounting oversight)

**Rules:**
- ‚úÖ `standardCost` ‚Üí allowed with permission + audit + reasonCode
- ‚ùå `averageCost` ‚Üí never allowed (system-calculated only)
- ‚ùå `lastCost` ‚Üí never allowed (receipt-driven only)

### 5. Initial State for New Inventory Items
**Decision:** Costs are initialized to `null` (NOT zero) to avoid accounting ambiguity.

**On Item Creation (before any receipts):**
- `standardCost` = `null`
- `lastCost` = `null`
- `averageCost` = `null`

**On First Receipt:**
- `lastCost` ‚Üí unit cost from receipt
- `averageCost` ‚Üí equals `lastCost` (first receipt baseline)
- `standardCost` ‚Üí remains `null` unless explicitly set

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #196 ‚Äî [BACKEND] [STORY] Cost: Maintain Standard/Last/Average Cost with Audit

## Current Labels
- backend
- story-implementation
- type:story
- layer:functional
- kiro

## Current Body
## ü§ñ Implementation Issue - Created by Durion Workspace Agent

### Original Story
**Story**: #196 - Cost: Maintain Standard/Last/Average Cost with Audit
**URL**: https://github.com/louisburroughs/durion/issues/196
**Domain**: general

### Implementation Requirements
This issue was automatically created by the Missing Issues Audit System to address a gap in the automated story processing workflow.

The original story processing may have failed due to:
- Rate limiting during automated processing
- Network connectivity issues
- Temporary GitHub API unavailability
- Processing system interruption

### Implementation Notes
- Review the original story requirements at the URL above
- Ensure implementation aligns with the story acceptance criteria
- Follow established patterns for backend development
- Coordinate with corresponding frontend implementation if needed

### Technical Requirements
**Backend Implementation Requirements:**
- Use Spring Boot with Java 21
- Implement RESTful API endpoints following established patterns
- Include proper request/response validation
- Implement business logic with appropriate error handling
- Ensure database operations are transactional where needed
- Include comprehensive logging for debugging
- Follow security best practices for authentication/authorization


### Notes for Agents
- This issue was created automatically by the Missing Issues Audit System
- Original story processing may have failed due to rate limits or network issues
- Ensure this implementation aligns with the original story requirements
- Backend agents: Focus on Spring Boot microservices, Java 21, REST APIs, PostgreSQL. Ensure API contracts align with frontend requirements.

### Labels Applied
- `type:story` - Indicates this is a story implementation
- `layer:functional` - Functional layer implementation
- `kiro` - Created by Kiro automation
- `domain:general` - Business domain classification
- `story-implementation` - Implementation of a story issue
- `backend` - Implementation type

---
*Generated by Missing Issues Audit System - 2025-12-26T17:38:49.367996314*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #178: [BACKEND] [STORY] Fulfillment: Issue/Consume Picked Items to Workorder
LABELS: type:story,layer:functional,kiro,domain:inventory,status:needs-review
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:inventory
- status:draft

### Recommended
- agent:inventory
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** inventory-flexible
---
## Story Intent
As an Inventory System, I need to process the consumption of picked parts against a specific workorder so that stock levels are accurately decremented and the cost of goods sold can be correctly attributed to the job.

## Actors & Stakeholders
- **Primary Actor:** `System` ‚Äì The Inventory Service, which processes the consumption request. This action is typically initiated by a user in another system (e.g., a Parts Manager or Technician via a Work Execution UI).
- **Stakeholders:**
  - `Parts Manager`: Responsible for accurate inventory counts and fulfilling parts requests for workorders.
  - `Mechanic/Technician`: Consumes the parts to perform the work on the vehicle.
  - `Service Advisor`: Needs visibility into job progress, which includes parts consumption.
  - `Inventory Manager`: Responsible for the overall health and accuracy of the inventory system.
  - `Accounting`: Requires accurate data for job costing and tracking Cost of Goods Sold (COGS).

## Preconditions
- A `Workorder` exists in a state that permits parts consumption (e.g., `In Progress`).
- The inventory items intended for consumption have been successfully moved to a `Picked` (or `Staged`) status and are logically associated with the specific `Workorder`.
- The initiating user or system possesses the necessary permissions to execute inventory consumption transactions.

## Functional Behavior
### 4.1. Consume Picked Items
The system provides an endpoint to consume items from inventory that have been previously picked for a workorder.

- **Trigger:** An API request is received containing the `workorderId` and a list of `lineItemId` and `quantity` pairs to be consumed.
- **Process:**
  1. The system validates that the `Workorder` exists and is in a valid state for consumption.
  2. For each item in the request, the system verifies:
     - The item is currently in a `Picked` status.
     - The item is associated with the provided `workorderId`.
     - The requested `quantity` to consume does not exceed the `quantity` that was picked.
  3. The system transitions the status of the consumed items from `Picked` to `Consumed`.
  4. The `Quantity on Hand` for the corresponding SKU is decremented by the consumed quantity.
  5. For each consumed item, an immutable `InventoryLedger` transaction is created. This entry records the `transactionType` as `WORKORDER_CONSUMPTION`, the negative quantity change, the `workorderId`, the current item cost (COGS), a timestamp, and the user/system that initiated the action.
  6. The system emits a `WorkorderPartsConsumed` event containing the `workorderId` and details of the consumed items.
- **Outcome:** The inventory state is updated, a permanent ledger record is created, and downstream systems are notified of the consumption.

## Alternate / Error Flows
- **Workorder in Invalid State:** If the workorder is not in an active state (e.g., it is `Completed`, `On Hold`, or `Cancelled`), the system rejects the entire request with a `409 Conflict` error and a descriptive message.
- **Item Not in Picked State:** If an item is not in the `Picked` status for the given workorder, the system rejects the request with a `400 Bad Request` error detailing which item is invalid.
- **Insufficient Picked Quantity:** If the requested quantity to consume exceeds the quantity picked for an item, the system rejects the request with a `400 Bad Request` error.
- **Item Not Associated with Workorder:** If an item in the request was not picked for the specified `workorderId`, the system rejects the request with a `400 Bad Request` error.
- **Unauthorized Access:** If the initiator lacks permissions, the system rejects the request with a `403 Forbidden` error.

## Business Rules
- Inventory consumption is an immutable financial transaction. Once an item is consumed, it cannot be "un-consumed."
- To reverse a consumption, a separate, compensating "Return to Stock" transaction must be performed, which creates its own ledger entry.
- All consumption transactions must be tied to a valid `Workorder`. Consumption of general shop supplies not tied to a specific job is handled by a different transaction type.
- The cost recorded in the inventory ledger must be the item's cost at the exact time of the consumption transaction.

## Data Requirements
### 7.1. API Request: `POST /v1/inventory/consume`
```json
{
  "workorderId": "wo-12345",
  "items": [
    {
      "pickedItemId": "pick-abc-789",
      "sku": "SKU-OILFILTER-A",
      "quantity": 1
    },
    {
      "pickedItemId": "pick-def-456",
      "sku": "SKU-AIRFILTER-B",
      "quantity": 1
    }
  ]
}
```

### 7.2. Inventory Ledger Entry
- `transactionId`: Unique identifier for the ledger entry.
- `timestamp`: ISO 8601 timestamp of the transaction.
- `transactionType`: `WORKORDER_CONSUMPTION`.
- `sku`: The stock-keeping unit of the item.
- `quantityChange`: The change in quantity (e.g., `-1`).
- `newQuantityOnHand`: The resulting quantity on hand for the SKU.
- `context`: `{ "workorderId": "wo-12345", "userId": "parts-mgr-01" }`.
- `costAtTransaction`: The cost of the item at the time of consumption.

### 7.3. Event: `WorkorderPartsConsumed`
- `eventId`: Unique ID for the event.
- `timestamp`: Event creation timestamp.
- `workorderId`: The associated workorder.
- `consumedItems`: An array of objects detailing the SKU, quantity, and cost of each consumed item.

## Acceptance Criteria
**AC-1: Successful Consumption of Picked Items**
- **Given** a workorder `wo-123` is `In Progress`
- **And** item `SKU-A` has a quantity of 2 in `Picked` status for `wo-123`
- **And** the inventory `Quantity on Hand` for `SKU-A` is 10
- **When** a request is made to consume 2 units of `SKU-A` for `wo-123`
- **Then** the system returns a `200 OK` success response
- **And** the `Quantity on Hand` for `SKU-A` becomes 8
- **And** an `InventoryLedger` entry is created for `SKU-A` with a `quantityChange` of -2 and `transactionType` of `WORKORDER_CONSUMPTION`
- **And** a `WorkorderPartsConsumed` event is emitted.

**AC-2: Attempt to Consume Item Not Picked for the Workorder**
- **Given** a workorder `wo-123` is `In Progress`
- **And** item `SKU-B` has been picked for a different workorder, `wo-456`
- **When** a request is made to consume `SKU-B` for `wo-123`
- **Then** the system rejects the request with a `400 Bad Request` error
- **And** the response body indicates `SKU-B` is not associated with `wo-123`.

**AC-3: Attempt to Consume More Quantity Than Picked**
- **Given** a workorder `wo-123` is `In Progress`
- **And** item `SKU-C` has a quantity of 1 in `Picked` status for `wo-123`
- **When** a request is made to consume 2 units of `SKU-C` for `wo-123`
- **Then** the system rejects the request with a `400 Bad Request` error
- **And** the response body indicates the requested quantity exceeds the picked quantity.

**AC-4: Attempt to Consume Parts for a Completed Workorder**
- **Given** a workorder `wo-789` is in `Completed` status
- **And** item `SKU-D` was previously picked for it
- **When** a request is made to consume `SKU-D` for `wo-789`
- **Then** the system rejects the request with a `409 Conflict` error
- **And** the response body indicates the workorder is not in a valid state for consumption.

## Audit & Observability
- **Audit Trail:** Every consumption event must be recorded in an immutable audit log. The log must include the initiator (user/system), timestamp, `workorderId`, and details of all items consumed (SKU, quantity, cost).
- **Logging:** Structured logs (e.g., JSON) should be generated for the start and end of the transaction, including `workorderId` and a transaction correlation ID. Errors must be logged with a full stack trace and request context.
- **Metrics:**
  - `inventory.consumption.success`: Counter for successful consumption transactions.
  - `inventory.consumption.failure`: Counter for failed consumption transactions, tagged by error type.
  - `inventory.consumption.latency`: Histogram measuring the duration of the consumption API call.

## Open Questions
1. The original story body in issue #236 is not available. What are the specific, nuanced requirements, business rules, or edge cases from that original story? This rewrite is based on domain best practices for the given title.
2. What is the authoritative source for an item's cost (COGS) at the time of consumption? Is this value retrieved from a pricing or accounting service, or is it stored with the inventory record?
3. Should the entire consumption transaction be atomic? If a request contains five items and the third one fails validation, should the consumption of the first two items be rolled back? (Assumption: Yes, the entire operation should be atomic.)

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #178 ‚Äî [BACKEND] [STORY] Fulfillment: Issue/Consume Picked Items to Workorder

## Current Labels
- backend
- story-implementation
- type:story
- layer:functional
- kiro

## Current Body
## ü§ñ Implementation Issue - Created by Durion Workspace Agent

### Original Story
**Story**: #236 - Fulfillment: Issue/Consume Picked Items to Workorder
**URL**: https://github.com/louisburroughs/durion/issues/236
**Domain**: general

### Implementation Requirements
This issue was automatically created by the Missing Issues Audit System to address a gap in the automated story processing workflow.

The original story processing may have failed due to:
- Rate limiting during automated processing
- Network connectivity issues
- Temporary GitHub API unavailability
- Processing system interruption

### Implementation Notes
- Review the original story requirements at the URL above
- Ensure implementation aligns with the story acceptance criteria
- Follow established patterns for backend development
- Coordinate with corresponding frontend implementation if needed

### Technical Requirements
**Backend Implementation Requirements:**
- Use Spring Boot with Java 21
- Implement RESTful API endpoints following established patterns
- Include proper request/response validation
- Implement business logic with appropriate error handling
- Ensure database operations are transactional where needed
- Include comprehensive logging for debugging
- Follow security best practices for authentication/authorization


### Notes for Agents
- This issue was created automatically by the Missing Issues Audit System
- Original story processing may have failed due to rate limits or network issues
- Ensure this implementation aligns with the original story requirements
- Backend agents: Focus on Spring Boot microservices, Java 21, REST APIs, PostgreSQL. Ensure API contracts align with frontend requirements.

### Labels Applied
- `type:story` - Indicates this is a story implementation
- `layer:functional` - Functional layer implementation
- `kiro` - Created by Kiro automation
- `domain:general` - Business domain classification
- `story-implementation` - Implementation of a story issue
- `backend` - Implementation type

---
*Generated by Missing Issues Audit System - 2025-12-26T17:38:00.563548597*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #177: [BACKEND] [STORY] Fulfillment: Return Unused Items to Stock with Reason
LABELS: type:story,layer:functional,kiro,domain:inventory,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:inventory
- status:draft

### Recommended
- agent:inventory
- agent:story-authoring

### Blocking / Risk
- none

**Rewrite Variant:** inventory-flexible
## Story Intent
**As a** Warehouse Manager or Service Advisor,
**I want to** return unused, saleable items from a completed work order back into stock, providing a reason for the return,
**so that** our inventory records are accurate, items are available for future orders, and we can track why parts are being returned.

## Actors & Stakeholders
- **Warehouse Manager**: The primary actor responsible for managing stock levels and processing returns.
- **Service Advisor**: A secondary actor who may also process returns associated with work orders they manage.
- **System**: The POS/Inventory management system responsible for processing the transaction.
- **Inventory Agent**: The domain agent responsible for the business logic and state management of inventory.
- **Accounting Department (Stakeholder)**: Relies on accurate inventory data for financial reporting and asset valuation.

## Preconditions
1.  The user is authenticated and has the necessary permissions (e.g., `inventory:return:create`).
2.  The work order (`workOrderId`) exists and is in a `Completed` or `Closed` state, making it eligible for returns.
3.  The items being returned were originally allocated to the specified work order.
4.  The system has a pre-configured, non-empty list of valid return reason codes.

## Functional Behavior
1.  **Trigger**: The user initiates the "Return Items to Stock" process, selecting a completed work order.
2.  The system presents a list of all items and quantities that were consumed by that work order.
3.  The user selects one or more items to return and specifies the quantity for each. The return quantity cannot exceed the quantity consumed by the work order.
4.  For each selected item, the user must choose a reason for the return from a predefined dropdown list (e.g., 'Not Needed', 'Wrong Part Ordered', 'Customer Refused').
5.  The user confirms the return transaction.
6.  **Outcome**: The system executes the following actions atomically:
    a. Creates a permanent `InventoryReturn` record linked to the original `WorkOrder`.
    b. For each item in the return, it creates an `InventoryLedger` entry of type `RETURN_TO_STOCK`.
    c. Increments the `quantityOnHand` for the corresponding item SKU at the designated stock location.
    d. Emits an `Inventory.ItemReturnedToStock` event for downstream consumers (e.g., Accounting).
7.  The system displays a success confirmation to the user, including a transaction ID for the return.

## Alternate / Error Flows
- **Error Flow 1: Attempt to return more items than consumed**
    - **Trigger**: User enters a return quantity for an item that is greater than the quantity consumed on the work order.
    - **Outcome**: The system rejects the submission, displaying an inline error message: "Return quantity cannot exceed the consumed quantity of [X]."

- **Error Flow 2: Missing return reason**
    - **Trigger**: User attempts to confirm the return without selecting a reason for one or more returned items.
    - **Outcome**: The system rejects the submission and highlights the fields requiring a reason.

- **Error Flow 3: Invalid work order state**
    - **Trigger**: A user attempts to initiate a return against a work order that is not in a `Completed` or `Closed` state.
    - **Outcome**: The system prevents the action and displays a notification: "Returns can only be processed for completed or closed work orders."

- **Error Flow 4: System or network failure**
    - **Trigger**: A database or network error occurs during the transaction processing.
    - **Outcome**: The entire inventory transaction is rolled back. No changes are committed to the inventory levels or ledger. An error is logged, and a user-friendly error message is displayed.

## Business Rules
- A return reason is mandatory for every item being returned to stock.
- Only items from a `Completed` or `Closed` work order can be returned.
- The quantity of an item being returned cannot exceed the quantity originally consumed by the work order.
- All inventory adjustments related to a single return transaction must be processed atomically.
- The financial reconciliation of returned items is out of scope for this story and will be handled by the Accounting domain, which consumes the event emitted by the Inventory domain.

## Data Requirements
The system must be able to create and persist an `InventoryReturn` entity with the following attributes:

```json
{
  "inventoryReturnId": "uuid", // Primary Key
  "workOrderId": "uuid",       // FK to WorkOrder
  "locationId": "uuid",        // FK to Location where stock is returned
  "processedByUserId": "uuid", // FK to User
  "processedAt": "timestamp_utc",
  "returnedItems": [
    {
      "sku": "string",
      "quantityReturned": "integer",
      "returnReasonCode": "enum" // e.g., NOT_NEEDED, WRONG_PART, CUSTOMER_REFUSED
    }
  ]
}
```

A corresponding `InventoryLedger` entry should be created for each item, referencing the `inventoryReturnId`.

## Acceptance Criteria
**AC 1: Successful Return of Unused Items**
- **Given** a `Completed` work order that consumed 5 units of `SKU-123`.
- **And** the current stock for `SKU-123` is 50.
- **When** a Warehouse Manager initiates a return for that work order, specifies a quantity of 2 for `SKU-123`, and selects the reason 'Not Needed'.
- **Then** the system successfully processes the return.
- **And** a new `InventoryReturn` record is created.
- **And** the `quantityOnHand` for `SKU-123` becomes 52.
- **And** an `Inventory.ItemReturnedToStock` event is emitted containing the details of the return.

**AC 2: Attempt to Return More Items Than Consumed**
- **Given** a `Completed` work order that consumed 5 units of `SKU-123`.
- **When** a user attempts to return 6 units of `SKU-123` against that work order.
- **Then** the system rejects the request.
- **And** an error message is displayed indicating the return quantity exceeds the consumed quantity.
- **And** the stock level for `SKU-123` remains unchanged.

**AC 3: Attempt to Return Without a Reason**
- **Given** a `Completed` work order with items eligible for return.
- **When** a user selects 1 unit of `SKU-123` to return but does not select a return reason.
- **And** the user tries to confirm the transaction.
- **Then** the system rejects the submission.
- **And** a validation message is displayed prompting the user to select a reason.
- **And** no inventory records are changed.

## Audit & Observability
- **Audit Event**: An `Inventory.ItemReturnedToStock` event MUST be emitted on successful completion. The event payload should include `workOrderId`, `inventoryReturnId`, `processedByUserId`, and a list of returned items with SKUs, quantities, and reasons.
- **Logging**:
    - INFO: Log the initiation and successful completion of the return transaction, including `workOrderId` and `inventoryReturnId`.
    - WARN: Log any failed validation attempts, such as returning excess quantity.
    - ERROR: Log any exceptions during the database transaction, including the full stack trace and relevant IDs.
- **Metrics**:
    - `inventory.returns.success.count`: Counter incremented for each successful return transaction.
    - `inventory.returns.failure.count`: Counter incremented for each failed return attempt.
    - `inventory.returns.items.returned`: Histogram tracking the number of items per return transaction.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #177 ‚Äî [BACKEND] [STORY] Fulfillment: Return Unused Items to Stock with Reason

## Current Labels
- backend
- story-implementation
- type:story
- layer:functional
- kiro

## Current Body
## ü§ñ Implementation Issue - Created by Durion Workspace Agent

### Original Story
**Story**: #237 - Fulfillment: Return Unused Items to Stock with Reason
**URL**: https://github.com/louisburroughs/durion/issues/237
**Domain**: general

### Implementation Requirements
This issue was automatically created by the Missing Issues Audit System to address a gap in the automated story processing workflow.

The original story processing may have failed due to:
- Rate limiting during automated processing
- Network connectivity issues
- Temporary GitHub API unavailability
- Processing system interruption

### Implementation Notes
- Review the original story requirements at the URL above
- Ensure implementation aligns with the story acceptance criteria
- Follow established patterns for backend development
- Coordinate with corresponding frontend implementation if needed

### Technical Requirements
**Backend Implementation Requirements:**
- Use Spring Boot with Java 21
- Implement RESTful API endpoints following established patterns
- Include proper request/response validation
- Implement business logic with appropriate error handling
- Ensure database operations are transactional where needed
- Include comprehensive logging for debugging
- Follow security best practices for authentication/authorization


### Notes for Agents
- This issue was created automatically by the Missing Issues Audit System
- Original story processing may have failed due to rate limits or network issues
- Ensure this implementation aligns with the original story requirements
- Backend agents: Focus on Spring Boot microservices, Java 21, REST APIs, PostgreSQL. Ensure API contracts align with frontend requirements.

### Labels Applied
- `type:story` - Indicates this is a story implementation
- `layer:functional` - Functional layer implementation
- `kiro` - Created by Kiro automation
- `domain:general` - Business domain classification
- `story-implementation` - Implementation of a story issue
- `backend` - Implementation type

---
*Generated by Missing Issues Audit System - 2025-12-26T17:37:57.987608191*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #176: [BACKEND] [STORY] Counts: Plan Cycle Counts by Location/Zone
LABELS: type:story,layer:functional,kiro,domain:inventory,status:ready-for-dev
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:inventory
- status:draft

### Recommended
- agent:inventory
- agent:story-authoring

### Blocking / Risk
- blocked:clarification
- risk:missing-requirements

**Rewrite Variant:** inventory-flexible

## Story Intent
**As an** Inventory Manager,
**I want to** create a scheduled Cycle Count Plan for specific locations and zones within a warehouse,
**so that** I can proactively manage and execute targeted inventory counts to improve stock accuracy and operational efficiency.

## Actors & Stakeholders
- **Inventory Manager (Primary Actor):** Responsible for creating, scheduling, and overseeing cycle count plans.
- **System:** The POS/Inventory Management platform responsible for creating and storing the plan, and generating the associated count tasks.
- **Warehouse Staff (Downstream Consumer):** Executes the counts based on the generated plan.
- **Auditors (Stakeholder):** Rely on the history of count plans and results to verify inventory accuracy and process compliance.

## Preconditions
1. The user is authenticated and has `INVENTORY_PLAN_CREATE` permissions.
2. At least one `Location` with defined `Zones` exists in the system.
3. Inventory stock records exist for items within the target zones.

## Functional Behavior
1.  **Trigger:** The Inventory Manager navigates to the "Cycle Counting" section of the application and initiates the creation of a new "Cycle Count Plan".
2.  **Plan Creation:**
    - The user is prompted to select a `Location` from a list of available locations.
    - Upon selecting a `Location`, the user is presented with a list of associated `Zones`. The user can select one or more zones for the count.
    - The user must specify a `scheduledDate` for the plan to be executed.
    - The user provides an optional `planName` or `description` for easy identification.
3.  **Plan Generation:**
    - Upon submitting the details, the System validates the inputs.
    - If valid, the System creates a new `CycleCountPlan` record with a unique identifier and a status of `PLANNED`.
    - The plan is linked to the selected `Location` and `Zone(s)`.
    - The System generates a list of `StockKeepingUnits` (SKUs) within the selected zones that are to be included in the count.
4.  **Confirmation:** The user receives a confirmation that the Cycle Count Plan has been successfully created and can view it in the list of planned counts.

## Alternate / Error Flows
- **Error - Invalid Location/Zone:** If the user attempts to create a plan for a `Location` or `Zone` that does not exist (e.g., via a stale API call), the system will return a `404 Not Found` error with a clear message: "The specified location or zone could not be found."
- **Error - Date in the Past:** If the user selects a `scheduledDate` that is in the past, the system will return a `400 Bad Request` error with the message: "Scheduled date must be in the future."
- **Edge - Zone with No Inventory:** If a plan is created for a zone that contains no inventory items, the plan is still created successfully, but the associated count list will be empty. The plan status might reflect this (e.g., `PLANNED_NO_ITEMS`).

## Business Rules
- A `CycleCountPlan` must be associated with exactly one `Location`.
- A `CycleCountPlan` must be associated with at least one `Zone`.
- The `scheduledDate` cannot be in the past.
- Once a `CycleCountPlan` status moves from `PLANNED` to `IN_PROGRESS`, its scope (location, zones) cannot be modified.

## Data Requirements
A new data entity, `CycleCountPlan`, is required with the following conceptual schema:

| Field | Type | Description | Example |
| :--- | :--- | :--- | :--- |
| `planId` | UUID | Unique identifier for the plan. | `f47ac10b-58cc-4372-a567-0e02b2c3d479` |
| `locationId` | UUID | Foreign key to the `Location` entity. | `e2a3b10c-12ab-43cd-87ef-1a23b4c5d680` |
| `zoneIds` | Array<UUID> | List of foreign keys to `Zone` entities. | `['z1...', 'z2...']` |
| `planName` | String | User-defined name for the plan. | "Q4 High-Value Goods Count - Zone A" |
| `status` | Enum | The current state of the plan. | `PLANNED`, `IN_PROGRESS`, `COMPLETED`, `CANCELLED` |
| `scheduledDate` | Date | The date the count is scheduled for. | `2025-11-15` |
| `createdBy` | UserID | The ID of the user who created the plan. | `user-123` |
| `createdAt` | Timestamp | Timestamp of plan creation. | `2025-10-20T10:00:00Z` |
| `updatedAt` | Timestamp | Timestamp of last plan modification. | `2025-10-20T10:00:00Z` |

## Acceptance Criteria
**Scenario 1: Successfully Create a Cycle Count Plan**
- **Given** I am an Inventory Manager with `INVENTORY_PLAN_CREATE` permissions,
- **And** a Location "Warehouse A" with Zones "Zone A1" and "Zone A2" exists,
- **When** I submit a request to create a new Cycle Count Plan for "Warehouse A", targeting "Zone A1", with a `scheduledDate` in the future,
- **Then** the system returns a `201 Created` status,
- **And** a new `CycleCountPlan` record is created in the database with a status of `PLANNED` and associated with "Warehouse A" and "Zone A1".

**Scenario 2: Attempt to Create a Plan with a Past Date**
- **Given** I am an Inventory Manager,
- **When** I submit a request to create a new Cycle Count Plan with a `scheduledDate` that is in the past,
- **Then** the system returns a `400 Bad Request` error,
- **And** the response body contains a clear error message indicating the date must be in the future.

**Scenario 3: Attempt to Create a Plan for a Non-Existent Location**
- **Given** I am an Inventory Manager,
- **When** I submit a request to create a new Cycle Count Plan with a `locationId` that does not exist in the system,
- **Then** the system returns a `404 Not Found` error,
- **And** no new `CycleCountPlan` record is created.

## Audit & Observability
- **Audit Log:** An audit event MUST be generated upon the creation, modification, or deletion of any `CycleCountPlan`. The event must include the `planId`, the user performing the action, and the changes made.
- **Logging:** Structured logs should be emitted for the start and end of the plan creation process, including `planId`, `locationId`, and `zoneIds`. Any validation failures or processing errors must be logged at the `ERROR` level.
- **Metrics:**
  - `cycle_count_plans.created.count`: A counter metric incremented each time a plan is successfully created, tagged by `location`.
  - `cycle_count_plans.creation.errors.count`: A counter metric for failed plan creation attempts, tagged by `error_type` (e.g., `validation_error`, `db_error`).

## Open Questions
1.  **Scope of Items:** How are the specific items within a zone selected for counting? Is it all items in the zone, a random sample, items based on ABC analysis (velocity), or something else? This is the most critical missing piece of logic.
2.  **Plan Statuses:** Are the proposed statuses (`PLANNED`, `IN_PROGRESS`, `COMPLETED`, `CANCELLED`) sufficient for the full lifecycle, or are others like `PENDING_APPROVAL` or `RECOUNT_REQUIRED` needed?
3.  **Recurrence:** Is there a requirement to create recurring cycle count plans (e.g., "Count Zone A every Monday")?
4.  **Permissions:** Is a single `INVENTORY_PLAN_CREATE` permission sufficient, or do we need separate permissions for viewing, updating, and cancelling plans?
5.  **Empty Zones:** How should the UI/API respond when a plan is successfully created for a zone that has no items to count? Should this be a warning?

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #176 ‚Äî [BACKEND] [STORY] Counts: Plan Cycle Counts by Location/Zone

## Current Labels
- backend
- story-implementation
- type:story
- layer:functional
- kiro

## Current Body
## ü§ñ Implementation Issue - Created by Durion Workspace Agent

### Original Story
**Story**: #238 - Counts: Plan Cycle Counts by Location/Zone
**URL**: https://github.com/louisburroughs/durion/issues/238
**Domain**: general

### Implementation Requirements
This issue was automatically created by the Missing Issues Audit System to address a gap in the automated story processing workflow.

The original story processing may have failed due to:
- Rate limiting during automated processing
- Network connectivity issues
- Temporary GitHub API unavailability
- Processing system interruption

### Implementation Notes
- Review the original story requirements at the URL above
- Ensure implementation aligns with the story acceptance criteria
- Follow established patterns for backend development
- Coordinate with corresponding frontend implementation if needed

### Technical Requirements
**Backend Implementation Requirements:**
- Use Spring Boot with Java 21
- Implement RESTful API endpoints following established patterns
- Include proper request/response validation
- Implement business logic with appropriate error handling
- Ensure database operations are transactional where needed
- Include comprehensive logging for debugging
- Follow security best practices for authentication/authorization


### Notes for Agents
- This issue was created automatically by the Missing Issues Audit System
- Original story processing may have failed due to rate limits or network issues
- Ensure this implementation aligns with the original story requirements
- Backend agents: Focus on Spring Boot microservices, Java 21, REST APIs, PostgreSQL. Ensure API contracts align with frontend requirements.

### Labels Applied
- `type:story` - Indicates this is a story implementation
- `layer:functional` - Functional layer implementation
- `kiro` - Created by Kiro automation
- `domain:general` - Business domain classification
- `story-implementation` - Implementation of a story issue
- `backend` - Implementation type

---
*Generated by Missing Issues Audit System - 2025-12-26T17:37:55.200248514*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #57: [BACKEND] [STORY] Master: Create Product Record (Part/Tire) with Identifiers and Attributes
LABELS: type:story,domain:inventory,status:ready-for-dev
BODY:
## Story Intent
As a Product Administrator, create and manage an authoritative master record for each product (parts, tires) so all systems reference a single, consistent source of truth for product information.

## Actors & Stakeholders
- **Product Administrator (Primary):** Creates, edits, and manages the product master catalog.
- **System (POS Backend):** Enforces business rules and persists product data.
- **Inventory System (Consumer):** Uses product master for stock tracking.
- **Work Execution System (Consumer):** Uses product master to schedule/execute jobs (e.g., tire install).
- **Auditor (Stakeholder):** Reviews product changes for compliance/traceability.

## Preconditions
- Product Administrator is authenticated with `product:manage` permission.
- Manufacturers exist and are referenceable by unique `manufacturerId`.
- Product Categories exist.

## Functional Behavior
### 1) Create Product
- Trigger: Admin submits "Create Product" request.
- Process: validate data; check identifier uniqueness; generate system-wide unique `productId`; create with default `status: ACTIVE`; audit creation.
- Outcome: product available to dependent systems.

### 2) Update Product
- Trigger: Admin submits "Update Product" for a `productId`.
- Process: retrieve record; validate new data; enforce immutability rules (SKU immutable); apply changes; audit field-level changes.
- Outcome: product updated.

### 3) Change Status (Deactivate/Reactivate)
- Trigger: Admin initiates status change.
- Process: locate product; verify allowed; update status to `INACTIVE` or `ACTIVE`; audit status change; when deactivating with open dependencies, flag work orders and notify PO admin (see Business Rules).
- Outcome: status changed; downstream modules see availability impact.

### 4) Search Products
- Trigger: search query via UI/API.
- Process: support exact search by SKU, MPN; keyword search across description, category name, attributes, and product name.
- Outcome: return matching products.

## Alternate / Error Flows
- Duplicate identifier: reject create when SKU already exists or Manufacturer+MPN already exists (`409 Conflict`).
- Invalid manufacturer: reject when `manufacturerId` not found (`400 Bad Request`).
- Missing required fields: reject create with validation errors.

## Business Rules
1. SKU is globally unique and immutable after creation.
2. Manufacturer + MPN pair must be unique across products.
3. The application owns its primary key (`productId`); external identifiers (e.g., UPC) are not primary keys.
4. SKU is immutable; `manufacturerId`, `mpn`, and other fields are editable.
5. Product status is `ACTIVE` or `INACTIVE`; default on create is `ACTIVE`.
6. Deactivation is permitted even when inventory exists, work orders are open, or purchase orders include the product; deactivation must flag affected work orders and notify the PO admin for impacted POs.
7. Tire size/spec is captured within the product description (not a separate structured schema).
8. Searchable fields for keyword queries: description, category name, attributes, product name.

## Data Requirements
| Field | Type | Constraints / Notes | Entity |
| --- | --- | --- | --- |
| productId | UUID | PK, system-generated | Product |
| status | Enum | `ACTIVE`, `INACTIVE` | Product |
| name | String | Required | Product |
| description | String | Required, may include tire size/spec | Product |
| unitOfMeasure | String | Required (e.g., "Each", "Pair") | Product |
| manufacturerId | UUID | FK to Manufacturer | Product |
| categoryId | UUID | FK to Category | Product |
| sku | String | Required, Unique, Immutable, Indexed | ProductIdentifier |
| mpn | String | Required, Indexed; unique in combination with manufacturerId | ProductIdentifier |
| upc | String | Optional; may be unique but not a primary key | ProductIdentifier |
| attributes | JSONB / Text | Optional key-value attributes | ProductAttribute |
| createdAt | Timestamp | System-managed | Product |
| updatedAt | Timestamp | System-managed | Product |

## Acceptance Criteria
**AC1: Create product succeeds**
- Given an authenticated Product Admin with `product:manage`
- And manufacturer `mfg-123` exists
- When creating a product with unique SKU `ABC-1001`, MPN `XYZ-2002`, valid `manufacturerId`, required fields, and description (with tire spec if applicable)
- Then the system returns `201 Created`, persists the product with `status: ACTIVE`, and audits creation.

**AC2: Duplicate identifiers rejected**
- Given a product exists with SKU `ABC-1001` or Manufacturer+MPN `mfg-123`/`XYZ-2002`
- When creating another product with the same SKU or same Manufacturer+MPN pair
- Then the request is rejected with `409 Conflict` indicating the duplicate identifier.

**AC3: Deactivate with dependencies**
- Given product `prod-456` is `ACTIVE` and is referenced by inventory, open work orders, or open purchase orders
- When setting `prod-456` to `INACTIVE`
- Then status updates to `INACTIVE`, work orders referencing `prod-456` are flagged, PO admin is notified for impacted POs, and the action is audited.

**AC4: Reactivate product**
- Given product `prod-789` is `INACTIVE`
- When setting status to `ACTIVE`
- Then status updates to `ACTIVE` and the change is audited.

**AC5: Search across keyword fields**
- Given products with descriptive text, category names, attributes, and names
- When performing keyword search
- Then results include matches from description, category name, attributes, and product name; SKU/MPN exact search remains supported.

## Audit & Observability
- Audit all create, update, and status changes with: `productId`, event type (`PRODUCT_CREATED`, `PRODUCT_UPDATED`, `PRODUCT_STATUS_CHANGED`), actor ID, timestamp, and before/after field values for updates.
- Emit metrics for creation/update rates and errors (validation failures, conflicts).

## Open Questions
- None. Clarification #246 resolved prior questions.

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #57 ‚Äî [BACKEND] [STORY] Master: Create Product Record (Part/Tire) with Identifiers and Attributes

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Master: Create Product Record (Part/Tire) with Identifiers and Attributes

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Product Admin**, I want to create a product with SKU/MPN, manufacturer, type, and attributes so that all modules reference a consistent product master.

## Details
- Identifiers: internal SKU, manufacturer part number, optional UPC.
- Attributes: description, category, tire size/spec, UOM, active/inactive.

## Acceptance Criteria
- Create/update/deactivate product.
- Search by SKU/MPN/keywords.
- Changes audited.

## Integrations
- Inventory and Workexec reference productId consistently.

## Data / Entities
- Product, ProductIdentifier, ProductAttribute, ManufacturerRef, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Product / Parts Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #55: [BACKEND] [STORY] Master: Set Product Lifecycle State (Active/Discontinued) with Effective Dates
LABELS: type:story,domain:inventory,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:inventory
- status:ready-for-dev

---

## Story Intent
**As a** Product Manager,
**I want to** set and change the lifecycle state of a product (Active, Inactive, Discontinued),
**so that** the system enforces which products are available for sale and which are not.

## Actors & Stakeholders
- **Primary Actor:** `Product Manager` or `Inventory Admin` (sets the state).
- **Secondary Actor:** `Authorization Engine` (enforces permission to override discontinued products).
- **Indirect User:** `Service Advisor` (sees product availability via UI; may be prevented from selecting discontinued products).
- **Stakeholder:** `Sales Manager` (needs visibility into lifecycle changes for reporting).

## Preconditions
- A product exists in the Product Catalog.
- The user has permission to modify product lifecycle state (implicit `product:lifecycle:update` permission).

## Functional Behavior
1. **Input:** A user (Product Manager) navigates to a product detail page and opens a "Lifecycle" editor.
2. **Select State:** The user selects a new lifecycle state:
   - `ACTIVE`: Product is actively sellable.
   - `INACTIVE`: Product is temporarily not available for sale (e.g., out of stock, temporarily suspended).
   - `DISCONTINUED`: Product is permanently discontinued.
3. **Set Effective Date:** The user optionally specifies when the state change takes effect (defaults to "immediately").
4. **Confirmation & Audit:** The state change is persisted with:
   - The new state.
   - Effective start timestamp (UTC).
   - User who made the change.
   - Audit reason (optional, but required for overrides).
5. **Return to Availability:** Products marked `INACTIVE` can be returned to `ACTIVE` at any time. Products marked `DISCONTINUED` CANNOT be returned to `ACTIVE` (irreversible).

## Alternate / Error Flows
- **Permission Denied:** If the user lacks permission (e.g., `product:lifecycle:override_discontinued`) to mark a product as discontinued or override an existing discontinued state, the system displays an error and prevents the change.
- **Invalid Effective Date:** If the effective date is in the past or is malformed, the system rejects the change with a validation error.
- **Already Discontinued:** If a product is marked as `DISCONTINUED` and the user attempts to mark it as `ACTIVE` again, the system prevents this with a clear error message.

## Business Rules
- **Irreversibility:** Once marked `DISCONTINUED`, a product **cannot** be returned to `ACTIVE` or `INACTIVE`. The only option is to mark it with a replacement product.
- **Effective Date Semantics:** The lifecycle state change takes effect at the specified UTC timestamp. Prior transactions and commitments are unaffected.
- **Replacement Products:** A discontinued product **may** have one or more replacement products listed. This is informational and does NOT automatically redirect sales.
- **Permissions:** Overriding a product's lifecycle state (e.g., forcing a product back to active when it should remain discontinued) requires an explicit permission: `product:lifecycle:override_discontinued`. This permission is assigned to roles like `ProductAdmin` or (optionally) `PricingManager` or `InventoryController`.

## Data Requirements
### `Product` Entity (Extended Fields)
| Field Name | Type | Description | Example |
|---|---|---|---|
| `productId` | UUID | Primary key. | `prod_abc123` |
| `lifecycleState` | Enum | One of: ACTIVE, INACTIVE, DISCONTINUED. | `ACTIVE` |
| `lifecycleStateEffectiveAt` | TimestampZ | UTC timestamp when the state becomes effective. | `2023-10-27T08:00:00Z` |
| `lastStateChangedBy` | UUID (UserRef) | The user who last changed the state. | `user_xyz789` |
| `lastStateChangedAt` | TimestampZ | When the state was last changed. | `2023-10-27T08:00:00Z` |
| `lifecycleOverrideReason` | String | Reason for overriding a discontinued state (optional, required if override permission used). | `Reintroduced per customer request` |

### `ProductReplacement` Entity (New)
| Field Name | Type | Description | Example |
|---|---|---|---|
| `replacementId` | UUID | Primary key. | `repl_001` |
| `originalProductId` | UUID (ProductRef) | The discontinued product. | `prod_abc123` |
| `replacementProductId` | UUID (ProductRef) | The recommended replacement. | `prod_def456` |
| `priorityOrder` | Integer | Display order (lower = higher priority). | `1` |
| `notes` | String | Optional context for the replacement. | `Upgraded to v2.0 with better performance` |
| `effectiveAt` | TimestampZ | When this replacement is valid. | `2023-10-27T08:00:00Z` |

## Acceptance Criteria
**AC-1: Set a Product to INACTIVE**
- **Given** a product `PROD-A` with state `ACTIVE`
- **And** I have permission `product:lifecycle:update`
- **When** I set the state to `INACTIVE` with an effective date of `2023-11-01T00:00:00Z`
- **Then** the product state is updated to `INACTIVE`
- **And** the `lifecycleStateEffectiveAt` is set to `2023-11-01T00:00:00Z`
- **And** an audit event `ProductLifecycleChanged` is published with the user, reason, and effective date.

**AC-2: Set a Product to DISCONTINUED**
- **Given** a product `PROD-B` with state `ACTIVE`
- **And** I have permission `product:lifecycle:override_discontinued`
- **When** I set the state to `DISCONTINUED` with override reason `End of Life`
- **Then** the product state is updated to `DISCONTINUED`
- **And** the product can no longer be sold (Service Advisor cannot add it to Work Orders).

**AC-3: Prevent Re-activation of a Discontinued Product**
- **Given** a product `PROD-C` with state `DISCONTINUED`
- **When** I attempt to set the state to `ACTIVE` or `INACTIVE`
- **Then** the system rejects the change with the error message: "Discontinued products cannot be reactivated. Specify a replacement product instead."

**AC-4: Add Replacement Product to Discontinued Item**
- **Given** product `PROD-D` is `DISCONTINUED`
- **And** I have permission `product:lifecycle:update`
- **When** I add `PROD-E` as a replacement with priority `1`
- **Then** the system creates a `ProductReplacement` record linking `PROD-D` ‚Üí `PROD-E`
- **And** the replacement is visible in the product's lifecycle detail page.

**AC-5: Effective Date with Timezone Handling**
- **Given** a user in timezone `America/New_York` enters an effective date of `2023-11-01` (date-only, no time)
- **When** the system processes this lifecycle change
- **Then** the system interprets it as `2023-11-01T00:00:00Z` (start of day UTC, or start of day in the product's governing timezone if specified)
- **And** the state change takes effect at that moment.

## Audit & Observability
- **Audit Trail:** An event `ProductLifecycleChanged` shall be published upon every state change. This event must include:
  - `productId`
  - `oldState`
  - `newState`
  - `effectiveAt`
  - `changedBy` (user)
  - `reason` (optional)
  - `overridePermissionUsed` (boolean)
- **Logging:** All state changes, both successful and denied, must be logged with structured context.
- **Metrics:**
  - `product.lifecycle.state_change.success.count`
  - `product.lifecycle.state_change.denied.count`

---

## Resolved Questions

### Question 1: Lifecycle State List (RESOLVED)

**Question:** What are the exact lifecycle states, and how do they differ?

**Answer:** Three states + one metadata field:

| State | Meaning | Sellable | Can Return To Active | Notes |
|---|---|---|---|---|
| `ACTIVE` | Product is actively available for sale. | ‚úÖ Yes | N/A | Default state. |
| `INACTIVE` | Product is temporarily unavailable (e.g., out of stock, under revision). | ‚ùå No | ‚úÖ Yes | Reversible. Use for temporary pause. |
| `DISCONTINUED` | Product is permanently end-of-life. | ‚ùå No | ‚ùå NO | Irreversible. Use for EOL. |
| `REPLACED_BY` (attribute on `DISCONTINUED`) | If discontinued, which product replaces it? | N/A | N/A | List of `ProductReplacement` records. |

**Clarification:** "Replaced" is **not a state**‚Äîit is an optional **attribute** of a discontinued product, captured as a list of replacement suggestions in the `ProductReplacement` entity.

### Question 2: Override Permissions (RESOLVED)

**Question:** Which roles can mark a product as discontinued or override a discontinued decision?

**Answer:** **Permission-based, not role-based.** Use the explicit permission: `product:lifecycle:override_discontinued`

**Assignment Strategy:**
- **Permission Owner:** `domain:security` (defines, assigns, audits)
- **Default Assignees:** `ProductAdmin`, and optionally `PricingManager` or `InventoryController` (configurable per org)
- **Enforcement:** Every state change to `DISCONTINUED` or override of an existing `DISCONTINUED` state MUST use this permission.
- **Audit:** Every use of this permission must be logged with:
  - Who used it
  - When
  - Which product
  - Override reason (mandatory free-text field)
  - Policy version

**Not Role-Hardcoded:** Do not hardcode "only ProductAdmins can mark things discontinued." Instead, use permissions that can be assigned flexibly.

### Question 3: Replacement Cardinality (RESOLVED)

**Question:** Can a single discontinued product have multiple replacement products?

**Answer:** **Yes‚Äîone-to-many replacements are explicitly allowed.**

**Implementation:**
- When marking a product as `DISCONTINUED`, the user **may** specify one or more replacements.
- Each replacement is a `ProductReplacement` record with:
  - `originalProductId` (the discontinued product)
  - `replacementProductId` (the new product)
  - `priorityOrder` (display order; lower = higher priority)
  - `notes` (optional context, e.g., "Same function, updated design")
  - `effectiveAt` (when this replacement applies)

**Rationale:**
- Some products have multiple successors (e.g., different capacities, price points, markets).
- Replacement suggestions are **advisory**‚Äîthey do NOT automatically block or reroute orders.

### Question 4: Effective Date Granularity (RESOLVED)

**Question:** Should the effective date support date-only input, or must it always be a full timestamp?

**Answer:** **Support date-only input; interpret as start of day UTC (or product's governing timezone).**

**Implementation:**
- UI accepts both:
  - Full timestamp: `2023-11-01T14:30:00Z`
  - Date-only: `2023-11-01` (user-provided)
- **Conversion Logic:**
  - If date-only is provided, interpret as `YYYY-MM-DD 00:00:00` in the **product's governing timezone** (if defined).
  - Fallback: If no governing timezone exists, use `00:00:00 UTC`.
- **Storage:** Always store as UTC `TimestampZ` in the database.
- **Example:**
  - User (in `America/New_York`) inputs `2023-11-01` (date-only).
  - If product has governing timezone `America/New_York`, interpret as `2023-11-01T00:00:00 EST` ‚Üí `2023-11-01T05:00:00 UTC`.
  - If no governing timezone, interpret as `2023-11-01T00:00:00 UTC`.

---

## Original Story (Unmodified ‚Äì For Traceability)
## [STORY] Master: Set Product Lifecycle State (Active/Discontinued) with Effective Dates

**Description**:

This story covers the ability to set and change a product's lifecycle state (Active ‚Üí Inactive, Inactive ‚Üí Active, Active ‚Üí Discontinued). The system should enforce lifecycle states so that discontinued products cannot be sold, and should record the effective date and reason for the change.

**Domain**: Product & Catalog

**Actors**:
- Product Manager
- Inventory Administrator

**Narrative**:
As a **Product Manager**, I want to mark products as **Active**, **Inactive**, or **Discontinued** with an effective date, so that the system enforces which products can be sold and which cannot.

**Acceptance Criteria** (Initial):
1. ‚úÖ Lifecycle states: ACTIVE, INACTIVE, DISCONTINUED
2. ‚úÖ Only authorized users (with `product:lifecycle:override_discontinued` permission) can mark a product as Discontinued
3. ‚úÖ Discontinued products are not selectable in Work Order/Estimate entry
4. ‚úÖ Effective date is stored; changes only take effect at the specified moment
5. ‚úÖ Audit trail: all changes logged with reason, user, timestamp

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #48: [BACKEND] [STORY] Availability: Expose On-hand and Available-to-Promise by Location (from Inventory)
LABELS: type:story,domain:inventory,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:inventory
- status:ready-for-dev

### Recommended
- agent:inventory
- agent:story-authoring

---
**Rewrite Variant:** inventory-flexible
---

## Story Intent

**As a** Service Advisor using a Point of Sale (POS) or quoting tool,
**I want to** view the real-time on-hand quantity and available-to-promise (ATP) quantity for a specific product, broken down by fulfillment location,
**So that I can** confidently inform customers about product availability, set accurate fulfillment expectations, and avoid promising inventory that is already committed.

## Actors & Stakeholders

- **Primary Actor:** `POS System` (acting on behalf of the Service Advisor). This system is the direct client of the new API endpoint.
- **Primary Stakeholder:** `Service Advisor`. The end-user whose workflow is improved by having accurate availability data.
- **Secondary Stakeholders:**
    - `Inventory Manager`: Relies on the accurate reporting of inventory levels managed by this domain.
    - `Product/Catalog System`: Provides the canonical product identifiers (`productId`) used for lookup.

## Preconditions

1.  A canonical list of `Products` with unique identifiers (`productId`) exists and is managed by the Product domain.
2.  A canonical list of `Locations` (e.g., warehouses, stores) with unique identifiers (`locationId`) exists.
3.  The Inventory system is the designated System of Record for tracking product quantities (`on-hand`, `reserved`, `incoming`) at each location.
4.  The client system (e.g., POS) is authenticated and authorized to query inventory availability.

## Functional Behavior

This story describes the creation of a new, read-only API endpoint that exposes inventory availability for a given product across all relevant locations.

### 1. Query Availability by Product

- **Trigger:** An authorized client system sends an HTTP `GET` request to the Availability API endpoint.
- **Endpoint (Proposed):** `GET /api/v1/inventory/availability`
- **Query Parameter:** `productId` (string, required) - The unique identifier for the product being queried.
- **System Process:**
    1.  The system receives the request and validates the `productId` parameter.
    2.  It queries the inventory data store for the specified `productId`.
    3.  For each location where the product exists, the system retrieves the current on-hand quantity.
    4.  The system calculates the Available-to-Promise (ATP) quantity for each location based on defined business rules.
    5.  The system constructs and returns a JSON response containing a list of availability details per location.
- **Outcome:** The client receives a `200 OK` response with the availability data.

## Alternate / Error Flows

- **Flow 1: Product Not Found**
    - **Trigger:** A request is made for a `productId` that does not exist in the Product/Inventory system.
    - **Outcome:** The API returns an `HTTP 404 Not Found` status with a clear error message.

- **Flow 2: Product Has No Inventory Records**
    - **Trigger:** A request is made for a valid `productId` that has never been stocked or currently has no inventory records at any location.
    - **Outcome:** The API returns an `HTTP 200 OK` status with an empty list in the response body, indicating zero availability everywhere.

- **Flow 3: Invalid Request**
    - **Trigger:** The `productId` query parameter is missing from the request.
    - **Outcome:** The API returns an `HTTP 400 Bad Request` status with a clear error message.

## Business Rules

- **BR1: On-Hand Quantity Definition**
    - The `onHandQuantity` MUST represent the total physical quantity of the product currently present at a given location. It is a direct reflection of the inventory ledger for that SKU/location pair.
- **BR2: Available-to-Promise (ATP) Calculation**
    - The `availableToPromiseQuantity` is a calculated value defined as: **ATP = On-Hand ‚àí Reservations**
    - Expected replenishments are explicitly excluded from v1 ATP calculation.

## Data Requirements

The API endpoint shall return a JSON object with the following structure.

### `AvailabilityView` (Response Body)

```json
{
  "productId": "SKU-12345",
  "locations": [
    {
      "locationId": "LOC-WH-01",
      "locationName": "Main Warehouse",
      "onHandQuantity": 100,
      "availableToPromiseQuantity": 85
    },
    {
      "locationId": "LOC-STORE-02",
      "locationName": "Downtown Store",
      "onHandQuantity": 12,
      "availableToPromiseQuantity": 10
    }
  ]
}
```

### Field Definitions

| Field                        | Type    | Description                                                                                             | Required |
| ---------------------------- | ------- | ------------------------------------------------------------------------------------------------------- | -------- |
| `productId`                  | String  | The unique identifier of the product that was queried.                                                  | Yes      |
| `locations`                  | Array   | A list of objects, each representing inventory at a specific location. May be empty.                    | Yes      |
| `locations.locationId`       | String  | The unique identifier for the location.                                                                 | Yes      |
| `locations.locationName`     | String  | The human-readable name of the location.                                                                | Yes      |
| `locations.onHandQuantity`   | Integer | The current physical stock count at the location. Cannot be negative.                                   | Yes      |
| `locations.availableToPromiseQuantity` | Integer | The calculated quantity available for new sales commitments. Can be negative. | Yes      |

## Acceptance Criteria

**AC-1: Successful Retrieval for In-Stock Product**
- **Given** a product with ID `SKU-123` has 50 units on-hand and 40 units ATP at "Warehouse A", and 10 units on-hand and 8 units ATP at "Store B";
- **When** a `GET /api/v1/inventory/availability?productId=SKU-123` request is made
- **Then** the system returns a `200 OK` status
- **And** the response body contains the `productId` `SKU-123`
- **And** the `locations` array contains two entries, one for "Warehouse A" and one for "Store B", with their respective `onHandQuantity` and `availableToPromiseQuantity` values.

**AC-2: Correct Handling for Product with No Stock**
- **Given** a product with ID `SKU-456` is a valid product but has no inventory records at any location
- **When** a `GET /api/v1/inventory/availability?productId=SKU-456` request is made
- **Then** the system returns a `200 OK` status
- **And** the response body's `locations` array is empty.

**AC-3: Error on Non-Existent Product**
- **Given** the product ID `SKU-999` does not exist
- **When** a `GET /api/v1/inventory/availability?productId=SKU-999` request is made
- **Then** the system returns a `404 Not Found` status.

**AC-4: Error on Missing Product ID**
- **Given** a client is authorized
- **When** a `GET /api/v1/inventory/availability` request is made without a `productId` parameter
- **Then** the system returns a `400 Bad Request` status.

**AC-5: ATP Calculation is Correct**
- **Given** the business rule for ATP calculation is defined as `ATP = On-Hand ‚àí Reservations`
- **And** a product has known quantities for on-hand and active reservations
- **When** an availability request is made for that product
- **Then** the returned `availableToPromiseQuantity` correctly reflects the formula.

## Audit & Observability

- **Logging:**
    - Log each API request with the `productId` and client identifier.
    - Log the response status code and latency for each request.
    - Log any errors encountered during data retrieval or calculation, including stack traces for exceptions.
- **Metrics:**
    - Monitor request volume (`requests_total`).
    - Monitor request latency (`request_latency_seconds`).
    - Monitor error rates by status code (`http_4xx_total`, `http_5xx_total`).

## Resolved Questions

### Question 1: ATP Formula (BLOCKER RESOLVED)

**Question:** What is the authoritative formula for calculating Available-to-Promise (ATP)?

**Answer:** 

**ATP = On-Hand ‚àí Reservations**

Expected replenishments are explicitly **OUT OF SCOPE for v1 ATP** and must not be included in the ATP calculation.

**Rationale:**
Including expected replenishments introduces purchasing assumptions, supplier reliability dependencies, date-sensitive promise logic, partial receipt complexity, and reconciliation risk. For v1, ATP must be ledger-derived, deterministic, explainable, and safe for commitment decisions.

**Component Definitions:**

**On-Hand (authoritative source):**
- **Source:** Inventory Ledger
- **Definition:** Net physical quantity currently in stock at a location/storage
- **Included movements:** `GOODS_RECEIPT`, `TRANSFER_IN`, `RETURN_TO_STOCK`, `ADJUSTMENT_IN`, `COUNT_VARIANCE_IN`
- **Minus:** `GOODS_ISSUE`, `TRANSFER_OUT`, `SCRAP_OUT`, `ADJUSTMENT_OUT`, `COUNT_VARIANCE_OUT`
- **Note:** On-Hand explicitly excludes allocations and reservations

**Reservations (included in ATP subtraction):**
- **Source:** Inventory Reservation / Allocation subsystem
- **Definition:** Quantities explicitly committed to downstream demand but not yet physically issued
- **Include only ACTIVE reservations:** `RESERVED`, `ALLOCATED`, `PICK_ASSIGNED` (if stock is logically locked), `ISSUE_PENDING`
- **Exclude:** `CANCELLED`, `RELEASED`, `EXPIRED`, `FULFILLED` (already issued ‚Üí reflected in On-Hand)
- **Important:** Reservations are location-specific and must match the same `(productId, locationId, storageLocationId)` scope as On-Hand

**Expected Replenishments (explicitly excluded in v1):**
Not included in ATP:
- Purchase Orders (`PO_CREATED`, `PO_CONFIRMED`)
- Inbound ASNs
- In-transit transfers
- Supplier promises
- Manufacturer/distributor feeds
- Backorders
- Planned replenishment

**Optional future extension (v2+):** If/when included, they must be date-qualified (promise date), confidence-weighted, and exposed as a separate field (never silently added to ATP).

**Final Implementation Statement:**
> Available-to-Promise (ATP) is defined as current On-Hand quantity minus active Reservations. Expected replenishments are not included in ATP for this implementation. Reservations include only active, location-scoped commitments that have not yet resulted in physical issue.

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #48 ‚Äî [BACKEND] [STORY] Availability: Expose On-hand and Available-to-Promise by Location (from Inventory)

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Availability: Expose On-hand and Available-to-Promise by Location (from Inventory)

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Service Advisor**, I want on-hand/ATP by location so that I can quote with realistic fulfillment expectations.

## Details
- Query inventory for on-hand and ATP.
- Optional reservations and expected replenishment.

## Acceptance Criteria
- Availability API returns quantities by location.
- Consistent productId mapping.
- SLA for estimate UI.

## Integrations
- Product ‚Üí Inventory availability query; Inventory ‚Üí Product responses/events.

## Data / Entities
- AvailabilityView, LocationQty, ReservationSummary

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Product / Parts Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #47: [BACKEND] [STORY] Availability: Normalize Distributor Inventory Feeds (Stub via Positivity)
LABELS: type:story,domain:inventory,status:ready-for-dev,agent:story-authoring,agent:inventory
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:inventory
- status:ready-for-dev

### Recommended
- agent:inventory
- agent:story-authoring

---
**Rewrite Variant:** inventory-flexible
---

## Story Intent
As an Integration Operator, I need an automated pipeline to ingest raw distributor availability feeds (via Positivity), normalize disparate formats into a canonical internal model, and persist a unified, queryable source of truth for external parts availability. This unified availability is consumed downstream (e.g., Work Execution) to inform estimates and scheduling.

## Actors & Stakeholders
- **Actors**
  - **System**: Ingests, normalizes, and persists availability data.
  - **Integration Operator**: Monitors pipeline health and handles exceptions.
- **Stakeholders**
  - **Inventory Manager**: Uses availability and lead times for planning.
  - **Service Advisor**: Indirectly relies on accuracy through Work Execution.
  - **Positivity Domain**: Upstream source providing raw feed payloads.
  - **Work Execution Domain**: Primary downstream consumer of normalized availability.

## Preconditions
1. A SKU mapping mechanism exists to resolve `distributorSku` ‚Üí internal `productId`.
2. A feed source exists (v1 supports a stub connector; see Resolved Questions).
3. An exception queue/topic exists for routing records that fail normalization/mapping.

## Functional Behavior
1. System is triggered to process a new distributor availability feed.
2. For each item record, system attempts to resolve `distributorSku` to internal `productId`.
3. **On successful SKU mapping**:
   - Normalize raw fields (quantity, lead time, ship-from region) to canonical schema.
   - Persist normalized record idempotently (UPSERT keyed by `productId + distributorId + shipFromRegionCode?` per schema choice).
   - Stamp `lastUpdatedAt` and `normalizationPolicyVersion`.
4. **On failed SKU mapping**:
   - Publish the original raw record to exception queue with `SKU_UNMAPPED`.
5. **On normalization parse failure** (lead time/region):
   - Publish the original raw record to exception queue with an appropriate reason code (see Resolved Questions).

## Alternate / Error Flows
- **Malformed Source Data**: Route to exception queue with `MALFORMED_DATA`.
- **Persistence Failure**: Fail the job, log error, and retry with backoff.
- **Exception Queue Publish Failure**: Retry with backoff; alert if retries exhausted.

## Business Rules
- **BR1: Idempotency is mandatory**: Reprocessing the same feed produces the same final DB state (no duplicates).
- **BR2: Mapping authority**: `DistributorSkuMap` is authoritative; no embedded mapping logic.
- **BR3: Record-level atomicity**: One bad record must not block processing of other records.
- **BR4: Explainable normalization**: Store `normalizationPolicyVersion` and preserve raw lead time/region fields for traceability and reprocessing.

## Data Requirements
### Input (Raw Feed)
- `distributorId`: string
- `asOf`: datetime (UTC)
- `items[]`:
  - `distributorSku`: string
  - `manufacturerPartNumber`: string (optional)
  - `availableQty`: number|string
  - `leadTimeRaw`: string
  - `shipFromRegionRaw`: string

### Output (Normalized Availability)
- `productId`: UUID
- `distributorId`: string
- `quantityAvailable`: int (>= 0)
- `leadTimeDaysMin`: int|null
- `leadTimeDaysMax`: int|null
- `shipFromRegionCode`: string (ISO 3166-2 preferred; ISO 3166-1 fallback)
- `normalizationPolicyVersion`: string
- `rawLeadTimeRaw`: string
- `rawShipFromRegionRaw`: string
- `lastUpdatedAt`: datetime (UTC)

### Exception Queue Message
- `payload`: raw record
- `reasonCode`: enum (`SKU_UNMAPPED`, `LEAD_TIME_UNPARSABLE`, `REGION_UNMAPPED`, `REGION_AMBIGUOUS`, `MALFORMED_DATA`)
- `errorMessage`: string
- `firstSeenAt`: datetime (UTC)
- `lastSeenAt`: datetime (UTC)
- `occurrenceCount`: int
- `distributorId`: string

## Acceptance Criteria
- **AC1: Mapped SKU produces normalized record**
  - **Given** a feed item whose SKU maps to `productId=P1`
  - **When** ingestion runs
  - **Then** a normalized availability record is upserted for that distributor and product
  - **And** the record includes `normalizationPolicyVersion` and `lastUpdatedAt`
  - **And** no exception message is published for that item.

- **AC2: Unmapped SKU routes to exception**
  - **Given** a feed item with an unmapped `distributorSku`
  - **When** ingestion runs
  - **Then** an exception message is published with `reasonCode=SKU_UNMAPPED`
  - **And** other valid items are still processed.

- **AC3: Lead time range normalization**
  - **Given** `leadTimeRaw="24-48 hours"`
  - **When** ingestion normalizes lead time
  - **Then** it stores `leadTimeDaysMin=1` and `leadTimeDaysMax=2`.

- **AC4: Unparseable lead time routes to exception**
  - **Given** `leadTimeRaw` cannot be parsed by supported patterns
  - **When** ingestion runs
  - **Then** an exception message is published with `reasonCode=LEAD_TIME_UNPARSABLE`.

- **AC5: Ship-from region normalization**
  - **Given** `shipFromRegionRaw="Dallas, TX"` and country context is available/inferable as US
  - **When** ingestion runs
  - **Then** it stores `shipFromRegionCode="US-TX"`.

- **AC6: Idempotent reprocessing**
  - **Given** a feed was processed successfully
  - **When** the exact same feed is processed again
  - **Then** the normalized DB state remains logically unchanged (UPSERT)
  - **And** `lastUpdatedAt` is refreshed.

## Audit & Observability
- **Logging**: Log start/end of each job with distributor, record counts (received/succeeded/failed).
- **Metrics**:
  - `normalized_records.count` (tag by distributor)
  - `exception_records.count` (tag by distributor and reasonCode)
  - `feed_processing.duration` (tag by distributor)
- **Alerting**: Alert when exception rate exceeds a configurable threshold (e.g., 5%) or backlog age exceeds SLA.

## Resolved Questions
Decisions applied from Clarification #240 (issuecomment-3739215330).

### RQ1: Normalization rule ownership
- **Decision**: Normalization rules are owned by the ingest/normalization service (availability) as a **versioned transformation policy**.
- Persist `normalizationPolicyVersion`, `rawLeadTimeRaw`, and `rawShipFromRegionRaw` so outputs are explainable and reprocessable.

### RQ2: Lead time normalization
- **Supported v1 formats**: simple durations (e.g., ‚Äú2 days‚Äù, ‚Äú48 hours‚Äù), ranges (‚Äú24-48 hours‚Äù, ‚Äú2-3 days‚Äù), shorthand (‚ÄúT+1‚Äù), qualitative (‚Äúsame day‚Äù, ‚Äúbackorder‚Äù, ‚Äúcall for availability‚Äù).
- **Conversion**:
  - Hours ‚Üí days: `ceil(hours/24)`
  - Ranges: normalize both ends; ensure `min <= max`
  - Non-integers: `ceil()` each end
  - Business days: treat as calendar days in v1 (no holiday calendar), but retain qualifier for future
  - Qualitative:
    - ‚Äúsame day‚Äù ‚Üí 0 (preferred)
    - ‚Äúin stock‚Äù without lead time ‚Üí null (do not assume)
    - ‚Äúbackorder/call‚Äù ‚Üí null and route to exception if lead time is required downstream
- **Failure policy**: unparseable ‚Üí exception `LEAD_TIME_UNPARSABLE`.

### RQ3: Ship-from region normalization
- **Canonical**: Prefer **ISO 3166-2** (e.g., `US-TX`), fallback to **ISO 3166-1 alpha-2** (`US`).
- **Mapping**:
  1. Normalize tokens (trim/uppercase/remove punctuation)
  2. Attempt: ISO 3166-2 ‚Üí known state/province name ‚Üí abbreviations (only with country context) ‚Üí country name
  3. Ambiguous (e.g., ‚ÄúCA‚Äù) without country context ‚Üí exception `REGION_AMBIGUOUS`
  4. Unmappable ‚Üí exception `REGION_UNMAPPED`
- Maintain a versioned mapping table (`rawToken ‚Üí regionCode`) with `mappingVersion`.

### RQ4: Exception queue SLA and operational plan
- **Ownership**: primary monitoring by Operations / Inventory Data Steward; secondary by on-call for availability/integration service.
- **Recommended SLA tiers**:
  - P1 (blocks sales/fulfillment): 4 business hours
  - P2 (non-blocking): 2 business days
  - P3 (rare/info): 5 business days
- Exception message should include `firstSeenAt`, `lastSeenAt`, `occurrenceCount` and alerting on spikes/backlog age.

### RQ5: V1 stub connector scope
- **Decision**: v1 stub means **no live Positivity integration required**.
- Implement a stable input contract ingestible from local file/static endpoint/mocked topic.
- **Recommended stub contract**:
  - Input: JSON file (array) or NDJSON
  - Config: `AVAIL_FEED_STUB_PATH`
  - Trigger: manual or short dev polling schedule
  - Example payload:

  ```json
  {
    "distributorId": "UUIDv7",
    "asOf": "2026-01-12T00:00:00Z",
    "items": [
      {
        "distributorSku": "ABC123",
        "manufacturerPartNumber": "MPN-9",
        "availableQty": 10,
        "leadTimeRaw": "24-48 hours",
        "shipFromRegionRaw": "Dallas, TX"
      }
    ]
  }
  ```

## Open Questions (if any)
- None.

---
## Original Story (Unmodified ‚Äì For Traceability)
## Backend Implementation for Story

**Original Story**: [STORY] Availability: Normalize Distributor Inventory Feeds (Stub via Positivity)

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As an **Integration Operator**, I want to ingest distributor availability feeds so that a unified availability view can be presented.

## Details
- Map distributor SKUs to internal productId.
- Normalize qty, lead time, ship-from region.
- Stub connector acceptable in v1.

## Acceptance Criteria
- Ingestion idempotent.
- Mapping errors routed to exception queue.
- Normalized availability queryable.

## Integrations
- Positivity connectors fetch feeds; product normalizes for inventory/workexec.

## Data / Entities
- ExternalAvailability, DistributorSkuMap, ExceptionQueue

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Product / Parts Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #46: [BACKEND] [STORY] Availability: Normalize Manufacturer Inventory Feeds (Stub via Positivity)
LABELS: type:story,domain:inventory,status:draft,status:ready-for-dev
BODY:
# [BACKEND] [STORY] Availability: Normalize Manufacturer Inventory Feeds (Stub via Positivity)

> **Story Status:** Ready for Development  
> **Domain:** Inventory Control  
> **Clarification Issue:** #239 (Resolved)

---

## 1. Story Intent

Enable the POS system to receive and normalize manufacturer inventory availability data delivered via the Positivity integration service. This story focuses on consuming a standardized feed format, resolving manufacturer part numbers to internal product IDs, and storing normalized availability data for downstream consumption by availability query and allocation services.

**Key Objective:** Establish a reliable pipeline for manufacturer inventory data that maintains referential integrity with the internal product catalog while handling unmapped parts gracefully.

---

## 2. Actors & Stakeholders

### Primary Actors
- **Positivity Integration Service**: External service that delivers standardized manufacturer inventory feeds
- **pos-inventory Service**: Consumes and normalizes the feed data
- **pos-product Service**: Authoritative source for manufacturer part number mapping

### Stakeholders
- **Inventory Management Team**: Requires accurate manufacturer availability data
- **Operations Team**: Monitors unmapped parts and maintains part mapping
- **Shop Staff**: Depends on accurate availability for ordering decisions

---

## 3. Preconditions

1. **Manufacturer Part Map Exists**: The `pos-product` service maintains a `ManufacturerPartMap` that resolves manufacturer part numbers to internal product IDs.
   - API endpoint available: `GET /product/v1/manufacturer-part-map:resolve`
   - Batch API available: `POST /product/v1/manufacturer-part-map:resolve`
   - Map maintenance is handled by a separate story (not in scope here)

2. **Positivity Feed Available**: The Positivity integration service delivers manufacturer inventory feeds in a standardized JSON format.

3. **Target Database**: `pos-inventory` service has database schema for storing normalized availability records.

---

## 4. Functional Behavior

### 4.1 Feed Consumption

**Input**: Positivity delivers a standardized JSON feed with the following schema:

```json
{
  "schemaVersion": "1",
  "manufacturerId": "UUIDv7",
  "asOf": "2026-01-12T00:00:00Z",
  "items": [
    {
      "manufacturerPartNumber": "string",
      "availableQty": 12,
      "uom": "EA",
      "unitPrice": { "amount": 100.00, "currency": "USD" },
      "leadTimeDays": { "min": 1, "max": 3 },
      "minOrderQty": 4,
      "packSize": 1,
      "sourceLocationCode": "string"
    }
  ]
}
```

**Processing Steps**:
1. Receive feed from Positivity (REST pull or event stream - implementation choice)
2. Validate schema version compatibility
3. Extract manufacturerId and asOf timestamp
4. For each item in the feed:
   - Extract manufacturerPartNumber
   - Call pos-product API to resolve to internal productId
   - If mapped: prepare normalized record with productId
   - If unmapped: record in unmapped parts backlog for operations follow-up

### 4.2 Part Number Resolution

**API Call to pos-product**:
```
GET /product/v1/manufacturer-part-map:resolve?manufacturerId={manufacturerId}&manufacturerPartNumber={mpn}

Response:
{
  "productId": "UUIDv7",
  "confidence": "HIGH",
  "metadata": {...}
}
```

**Batch Resolution** (preferred for performance):
```
POST /product/v1/manufacturer-part-map:resolve
Body:
{
  "manufacturerId": "UUIDv7",
  "parts": [
    { "mpn": "ABC-123" },
    { "mpn": "XYZ-789" }
  ]
}

Response:
{
  "results": [
    { "mpn": "ABC-123", "productId": "...", "confidence": "HIGH" },
    { "mpn": "XYZ-789", "productId": null, "reason": "UNMAPPED" }
  ]
}
```

### 4.3 Normalized Record Storage

For successfully mapped items, store a normalized availability record:

**NormalizedAvailability Entity**:
- `id`: UUIDv7 (primary key)
- `productId`: UUIDv7 (foreign key to pos-product)
- `manufacturerId`: UUIDv7
- `manufacturerPartNumber`: string
- `availableQty`: decimal
- `uom`: string
- `unitPrice`: money (amount + currency)
- `leadTimeDaysMin`: integer
- `leadTimeDaysMax`: integer
- `minOrderQty`: integer (nullable - store if present, null otherwise)
- `packSize`: integer
- `sourceLocationCode`: string
- `asOf`: timestamp
- `receivedAt`: timestamp (system-generated)
- `schemaVersion`: string

### 4.4 Unmapped Parts Handling

For items that cannot be resolved to a productId:
- Insert into `UnmappedManufacturerParts` table/queue:
  - `manufacturerId`
  - `manufacturerPartNumber`
  - `firstSeen`: timestamp
  - `lastSeen`: timestamp
  - `occurrenceCount`: integer (increment on duplicate)
  - `status`: PENDING_REVIEW

**Note**: Operations team will use a separate tool/story to review and create mappings for unmapped parts.

---

## 5. Alternate / Error Flows

### 5.1 Invalid Schema Version
- **Trigger**: Incoming feed has unsupported schemaVersion
- **Action**: Log error, reject feed, alert operations
- **Outcome**: Feed is not processed; system remains stable

### 5.2 pos-product API Unavailable
- **Trigger**: Batch resolution API call fails or times out
- **Action**: Log error, optionally retry with exponential backoff
- **Outcome**: Feed processing is delayed; no data is partially stored

### 5.3 Partial Mapping Failure
- **Trigger**: Some items resolve successfully, others fail
- **Action**: 
  - Store successfully mapped items
  - Add unmapped items to UnmappedManufacturerParts
  - Log summary (e.g., "Processed 95/100 items, 5 unmapped")
- **Outcome**: Partial success; unmapped items tracked for follow-up

### 5.4 Duplicate Feed Delivery
- **Trigger**: Positivity re-sends the same feed (same manufacturerId + asOf)
- **Action**: Detect duplicate using upsert logic on (productId, manufacturerId, asOf)
- **Outcome**: Idempotent processing; no duplicate records created

### 5.5 Missing Optional Fields
- **Trigger**: `minOrderQty` is absent from feed item
- **Action**: Store null in database field
- **Outcome**: Record is saved; enforcement logic (out of scope) handles null gracefully

---

## 6. Business Rules

### BR-1: System of Record for Manufacturer Part Mapping
- **Authority**: `pos-product` service is the authoritative source
- **Access**: Via API only (no direct database access)
- **Scope**: Mapping maintenance is a precondition; this story consumes the map

### BR-2: Feed Format
- **Format**: Single standardized JSON format with versioned schema
- **Manufacturer-Specific Parsing**: NOT supported in pos-inventory; handled by Positivity
- **Transport**: REST pull or event stream (implementation choice)
- **Idempotency**: Required; use (manufacturerId, asOf, productId) as natural key

### BR-3: Minimum Order Quantity Handling
- **Presence**: Field may be absent in feed
- **Storage**: Store if present; otherwise store null
- **Enforcement**: Out of scope for this story (not enforced in ordering/cart logic)
- **Complex Rules**: Out of scope (tiered min orders, mixed-case constraints)

### BR-4: Unmapped Parts Policy
- **Action**: Surface for operations follow-up
- **Storage**: Optional backlog table/queue
- **Resolution**: Separate story for mapping maintenance

### BR-5: Data Freshness
- **Timestamp**: Use `asOf` from feed as authoritative time
- **Retention**: Define TTL or archival policy (implementation decision)

---

## 7. Data Requirements

### 7.1 Input Schema (from Positivity)

```json
{
  "schemaVersion": "1",
  "manufacturerId": "UUIDv7",
  "asOf": "ISO8601 timestamp",
  "items": [
    {
      "manufacturerPartNumber": "string",
      "availableQty": "number (decimal)",
      "uom": "string (e.g., EA, CASE)",
      "unitPrice": {
        "amount": "number (decimal)",
        "currency": "string (ISO 4217)"
      },
      "leadTimeDays": {
        "min": "integer",
        "max": "integer"
      },
      "minOrderQty": "integer (optional)",
      "packSize": "integer",
      "sourceLocationCode": "string"
    }
  ]
}
```

### 7.2 Output Schema (NormalizedAvailability)

**Database Table**: `normalized_availability`

| Column | Type | Nullable | Description |
|--------|------|----------|-------------|
| id | UUID | No | Primary key |
| productId | UUID | No | FK to pos-product |
| manufacturerId | UUID | No | Source manufacturer |
| manufacturerPartNumber | VARCHAR | No | Original MPN |
| availableQty | DECIMAL | No | Quantity available |
| uom | VARCHAR | No | Unit of measure |
| unitPriceAmount | DECIMAL | No | Price amount |
| unitPriceCurrency | VARCHAR | No | Price currency |
| leadTimeDaysMin | INTEGER | No | Minimum lead time |
| leadTimeDaysMax | INTEGER | No | Maximum lead time |
| minOrderQty | INTEGER | Yes | Minimum order quantity |
| packSize | INTEGER | No | Pack size |
| sourceLocationCode | VARCHAR | No | Manufacturer location |
| asOf | TIMESTAMP | No | Feed timestamp |
| receivedAt | TIMESTAMP | No | System receipt time |
| schemaVersion | VARCHAR | No | Feed schema version |

**Indexes**:
- Primary key on `id`
- Unique index on `(productId, manufacturerId, asOf)`
- Index on `asOf` for time-based queries
- Index on `productId` for availability lookups

### 7.3 Unmapped Parts Schema

**Database Table**: `unmapped_manufacturer_parts`

| Column | Type | Nullable | Description |
|--------|------|----------|-------------|
| id | UUID | No | Primary key |
| manufacturerId | UUID | No | Source manufacturer |
| manufacturerPartNumber | VARCHAR | No | Unmapped MPN |
| firstSeen | TIMESTAMP | No | First occurrence |
| lastSeen | TIMESTAMP | No | Most recent occurrence |
| occurrenceCount | INTEGER | No | Number of times seen |
| status | ENUM | No | PENDING_REVIEW, RESOLVED, IGNORED |

**Indexes**:
- Primary key on `id`
- Unique index on `(manufacturerId, manufacturerPartNumber)`
- Index on `status` for operations queries

---

## 8. Acceptance Criteria

### AC-1: Feed Consumption
- [ ] System successfully receives feed from Positivity service
- [ ] Schema version is validated before processing
- [ ] Invalid schema versions are rejected with appropriate error

### AC-2: Part Number Resolution
- [ ] System calls pos-product API to resolve manufacturer part numbers
- [ ] Batch resolution API is used for performance (preferred)
- [ ] Successfully mapped items are processed and stored
- [ ] Unmapped items are recorded in unmapped parts backlog

### AC-3: Normalized Record Storage
- [ ] Mapped items are stored in `normalized_availability` table
- [ ] All required fields are populated correctly
- [ ] Optional `minOrderQty` field is stored as null when absent from feed
- [ ] Duplicate feeds are handled idempotently (no duplicate records)

### AC-4: Unmapped Parts Handling
- [ ] Unmapped parts are recorded in `unmapped_manufacturer_parts` table
- [ ] First occurrence timestamp is captured
- [ ] Occurrence count is incremented for repeated unmapped parts
- [ ] Operations team can query unmapped parts for review

### AC-5: Error Handling
- [ ] Invalid schema versions are logged and rejected
- [ ] pos-product API unavailability is handled gracefully (retry with backoff)
- [ ] Partial mapping failures result in partial success (mapped items stored, unmapped tracked)
- [ ] All error conditions are logged with appropriate detail

### AC-6: Data Integrity
- [ ] Foreign key to pos-product is enforced (productId must exist)
- [ ] Unique constraint on (productId, manufacturerId, asOf) prevents duplicates
- [ ] All timestamps are stored in UTC
- [ ] Currency codes follow ISO 4217

### AC-7: API Contract Compliance
- [ ] pos-product resolution API is called correctly (not direct DB access)
- [ ] Batch API payload format matches contract
- [ ] Response parsing handles all documented response fields

### AC-8: Performance
- [ ] Batch resolution is used instead of individual API calls
- [ ] Feed processing completes within reasonable time (e.g., < 60s for 1000 items)
- [ ] Database indexes support efficient availability queries

---

## 9. Audit & Observability

### 9.1 Logging Requirements
- **Feed Receipt**: Log `manufacturerId`, `asOf`, item count, `receivedAt`
- **Mapping Results**: Log successful mappings count, unmapped count
- **Errors**: Log schema validation failures, API errors, database errors
- **Performance**: Log processing duration, batch sizes

### 9.2 Metrics
- **Feed Processing Rate**: Items/second
- **Mapping Success Rate**: Percentage of items successfully mapped
- **Unmapped Parts Count**: Trending count of unmapped parts
- **API Latency**: p50, p95, p99 for pos-product API calls
- **Processing Duration**: End-to-end feed processing time

### 9.3 Alerts
- **Schema Version Mismatch**: Immediate alert on unsupported version
- **High Unmapped Rate**: Alert if > 10% of items are unmapped
- **API Unavailability**: Alert if pos-product API is unreachable
- **Processing Failures**: Alert on feed processing errors

### 9.4 Audit Trail
- All feed processing events should be auditable:
  - Feed received timestamp
  - Processing outcome (success/partial/failure)
  - Items processed count
  - Items unmapped count
  - Error details (if any)

---

## 10. Original Story (Preserved for Traceability)

> *This section contains the original story text before clarification resolution.*
> *It is preserved for audit and traceability purposes only.*

**Original Request**: Normalize Manufacturer Inventory Feeds (Stub via Positivity)

**Original Open Questions** (Now Resolved):
1. Mapping Authority - **Resolved**: pos-product is SoR, accessed via API
2. Feed Specification - **Resolved**: Single standardized JSON format
3. Minimum Order Rules - **Resolved**: Optional presence in feed, store if present

**Clarification Issue**: #239  
**Resolution Date**: 2026-01-12

---

## Story Metadata

- **Story ID**: #46
- **Domain**: domain:inventory
- **Type**: type:story
- **Status**: status:ready-for-dev
- **Priority**: TBD
- **Clarification Issue**: #239 (Resolved)
- **Labels**: domain:inventory, type:story, status:ready-for-dev
- **Dependencies**: 
  - pos-product service with manufacturer part map API
  - Positivity integration service with standardized feed format

---

**Story Finalized**: 2026-01-12  
**Updated By**: Story Authoring Agent (Clarification Resolution)


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #40: [BACKEND] [STORY] Topology: Sync Locations from durion-hr
LABELS: type:story,domain:inventory
BODY:
## Backend Implementation for Story

**Original Story**: [STORY] Topology: Sync Locations from durion-hr

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **System**, I want to sync location identifiers and metadata from durion-hr so that inventory is scoped to valid shops and mobile sites.

## Details
- Import locationId, name, status, timezone, and tags.
- Keep a local reference table for FK integrity.

## Acceptance Criteria
- Location refs created/updated idempotently.
- Deactivated locations cannot receive new stock movements.
- Audit sync runs.

## Integrations
- HR ‚Üí Inventory location roster API/events.

## Data / Entities
- LocationRef, SyncLog

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #39: [BACKEND] [STORY] Topology: Create Storage Locations (Floor/Shelf/Bin/Cage/Truck) and Hierarchy
LABELS: type:story,domain:inventory,status:ready-for-dev,agent:story-authoring,agent:inventory
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:inventory
- status:needs-review

### Recommended
- agent:inventory
- agent:story-authoring

---
**Rewrite Variant:** inventory-flexible
---
## Story Intent
**Goal:** To establish a foundational capability for defining a physical storage topology within a site, enabling precise inventory tracking and management.
**Rationale:** Accurate stock placement and retrieval depend on a well-defined and managed hierarchy of storage locations. This feature provides the necessary structure for all subsequent inventory movements and work execution tasks.

## Actors & Stakeholders
- **Actor:** `Inventory Manager` - The primary user responsible for defining, organizing, and maintaining the storage location hierarchy.
- **Actor:** `System` - The software agent responsible for enforcing business rules like uniqueness and hierarchical integrity.
- **Stakeholder:** `Work Execution System` - Consumes `storageLocationId` to direct picking, putting, and transfer tasks.
- **Stakeholder:** `Shop Manager System` - May consume location data to provide operational hints or display inventory layouts.

## Preconditions
1. The user performing the action is authenticated and authorized as an `Inventory Manager`.
2. A parent `Site` entity must exist to which the storage locations will be associated.
3. The set of valid `StorageType` values is defined and available to the system.

## Functional Behavior
### 1. Create Storage Location
- **Trigger:** The `Inventory Manager` initiates the creation of a new storage location.
- **Process:**
    1. The user provides the required attributes: `name`, `barcode`, `storageType`, and a parent `siteId`.
    2. The user may optionally provide a `parentLocationId` to place the new location within the hierarchy.
    3. The user may optionally provide attributes like `capacity` (e.g., volume, weight, unit count) and `temperature` constraints.
    4. The `System` validates the provided data against business rules (see below).
    5. Upon successful validation, the `System` persists the new `StorageLocation` record with an initial `status` of `Active`.
- **Outcome:** A new, active storage location is created and addressable within the site's hierarchy.

### 2. Update Storage Location
- **Trigger:** The `Inventory Manager` modifies an existing storage location.
- **Process:**
    1. The user selects an existing storage location to edit.
    2. The user modifies attributes such as `name`, `barcode`, `capacity`, or `temperature`.
    3. The `System` validates the changes. Note: Changing the `parentLocationId` is a valid but sensitive operation that must be checked for hierarchy cycles.
- **Outcome:** The storage location's attributes are updated.

### 3. Deactivate Storage Location
- **Trigger:** The `Inventory Manager` deactivates a storage location that is no longer in use.
- **Process:**
    1. The user selects an existing, active storage location.
    2. The user initiates the deactivation command.
    3. The `System` evaluates current stock at the location:
       - If the location is empty, proceed to deactivate.
       - If the location contains stock, the user must provide a `destinationLocationId` (within the same `Site`). The `System` will programmatically move all stock to the destination using an atomic transfer operation, then deactivate the source location. If the transfer fails, no changes are committed and the location remains `Active`.
    4. The `System` changes the location's `status` from `Active` to `Inactive` once prerequisites are satisfied.
- **Outcome:** The storage location is marked as `Inactive` and cannot be used for new inventory operations. Historical records are preserved.

## Alternate / Error Flows
- **Duplicate Barcode:** If a user attempts to create or update a location with a barcode that already exists within the same `Site`, the `System` must reject the operation and return a descriptive error.
- **Hierarchy Cycle:** If a user attempts to set a `parentLocationId` that would result in a cyclical relationship (e.g., making a location its own grandparent), the `System` must reject the operation and return an error.
- **Invalid Parent:** If the specified `parentLocationId` or `siteId` does not exist, the operation must fail with an appropriate error message.
- **Deactivation Missing Destination:** If the location contains stock and no `destinationLocationId` is provided, the operation must fail with `DESTINATION_REQUIRED`.
- **Deactivation Invalid Destination:** If `destinationLocationId` is invalid, belongs to a different `Site`, or is `Inactive`, the operation must fail with `INVALID_DESTINATION`.
- **Deactivation Transfer Failure:** If the stock transfer cannot be completed, the operation must fail and no changes are committed.

## Business Rules
1.  **Barcode Uniqueness:** A `barcode` must be unique within a given `Site`. The same barcode may exist in different sites.
2.  **Acyclic Hierarchy:** The parent-child relationships for storage locations must form a directed acyclic graph (DAG). No cycles are permitted.
3.  **Site as Root:** Every storage location must ultimately belong to a single `Site`.
4.  **Defined Types:** The `storageType` for a location must be one of the enumerated, pre-defined values: `Floor`, `Shelf`, `Bin`, `Cage`, `Yard`, `MobileTruck`, `Quarantine`.
5.  **Immutability:** The `storageLocationId` (primary key), once created, is immutable.
6.  **Deactivation Policy (Decided):** Non-empty locations cannot be deactivated without a stock transfer. The user must provide a valid `destinationLocationId` within the same `Site`. The `System` performs a transactional transfer of all stock to the destination and then deactivates the source. Orphaning stock is prohibited.

## Data Requirements
### `StorageLocation` Entity
| Field | Type | Constraints | Description |
|---|---|---|---|
| `storageLocationId` | UUID | Primary Key, Not Null, Immutable | Unique system identifier for the location. |
| `siteId` | UUID | Foreign Key, Not Null, Indexed | The site this location belongs to. |
| `parentLocationId` | UUID | Foreign Key, Nullable | The parent location in the hierarchy. Null if it's a top-level location within the site. |
| `name` | String | Not Null | Human-readable name for the location (e.g., "Aisle 5, Shelf 3"). |
| `barcode` | String | Not Null, Indexed | Barcode value for scanning. Unique per site. |
| `storageType` | Enum | Not Null | The type of location (e.g., Shelf, Bin, Cage). |
| `status` | Enum | Not Null, Default: `Active` | The current state of the location (`Active`, `Inactive`). |
| `capacity` | JSONB | Nullable | Optional field to define capacity constraints (e.g., `{ "weight_kg": 100, "volume_m3": 2.5 }`). |
| `temperature` | JSONB | Nullable | Optional field for temperature constraints (e.g., `{ "min_celsius": 2, "max_celsius": 8 }`). |
| `createdAt` | Timestamp | Not Null | Timestamp of creation. |
| `updatedAt` | Timestamp | Not Null | Timestamp of last update. |

### `DeactivateLocationRequest` (API input)
| Field | Type | Constraints | Description |
|---|---|---|---|
| `destinationLocationId` | UUID | Required if source has stock; must be `Active` and same `Site` | Stock transfer destination prior to deactivation. |

## Acceptance Criteria
### Scenario: Successfully Create a Top-Level Storage Location
- **Given** an `Inventory Manager` is logged in
- **And** a `Site` with `siteId` "S1" exists
- **When** the manager creates a new storage location with `name` "Main Floor", `barcode` "FL-01", `storageType` "Floor", and `siteId` "S1"
- **Then** the system successfully creates the new storage location
- **And** the location's `status` is `Active`
- **And** its `parentLocationId` is null.

### Scenario: Successfully Create a Child Storage Location
- **Given** a storage location "FL-01" exists within `siteId` "S1"
- **When** the manager creates a new location with `name` "Shelf A1", `barcode` "SH-A1", `storageType` "Shelf", and `parentLocationId` of "FL-01"
- **Then** the system successfully creates the new storage location
- **And** its `parentLocationId` correctly points to "FL-01".

### Scenario: Prevent Creation of a Location with a Duplicate Barcode
- **Given** a storage location with `barcode` "BIN-X99" already exists in `siteId` "S1"
- **When** the manager attempts to create another location in `siteId` "S1" with `barcode` "BIN-X99"
- **Then** the system must reject the request with a "Duplicate Barcode" error.

### Scenario: Prevent Creation of a Hierarchy Cycle
- **Given** a location hierarchy exists: "Site S1" -> "Floor-1" -> "Shelf-A" -> "Bin-A1"
- **When** the manager attempts to update "Floor-1" to have "Bin-A1" as its parent
- **Then** the system must detect a cycle and reject the update with a "Hierarchy Cycle Detected" error.

### Scenario: Successfully Deactivate an Empty Location
- **Given** an empty, `Active` storage location "Cage-03" exists
- **When** the manager deactivates "Cage-03"
- **Then** the system updates its `status` to `Inactive`.

### Scenario: Deactivate a Non-Empty Location with Transfer
- **Given** an `Active` storage location "Bin-12" contains stock
- **And** an `Active` destination location "Bin-13" exists within the same `Site`
- **When** the manager attempts to deactivate "Bin-12" and provides `destinationLocationId = Bin-13`
- **Then** the system transfers all stock from "Bin-12" to "Bin-13" atomically
- **And** the system sets "Bin-12" to `Inactive`.

### Scenario: Reject Deactivation of Non-Empty Location without Destination
- **Given** an `Active` storage location "Bin-12" contains stock
- **When** the manager attempts to deactivate "Bin-12" without providing a destination
- **Then** the system rejects the operation with `DESTINATION_REQUIRED`.

## Audit & Observability
- **Audit Trail:** All create, update, deactivate (including transfer) operations on `StorageLocation` must generate an audit log entry. The log must include the actor (`userId`), the change details (before/after), and a timestamp, plus transfer details (`source`, `destination`, `quantities`).
- **Metrics:** The system should expose metrics for the total number of storage locations per site and per type, plus `deactivation_transfers_total` and `deactivation_transfer_failures_total`.

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #38: [BACKEND] [STORY] Configuration: Define Default Staging and Quarantine Storage Locations for a Site
LABELS: type:story,domain:inventory,domain:location,status:ready-for-dev
BODY:
# [BACKEND] [STORY] Configuration: Define Default Staging and Quarantine Storage Locations for a Site

## üè∑Ô∏è Labels (Applied)

### Required
- type:story
- status:ready-for-dev
- domain:location
- domain:inventory

### Recommended
- agent:story-authoring

---

## ‚úÖ Clarification Resolutions Applied

**Clarification Issue**: #235
**Resolved Date**: 2026-01-12
**Resolved By**: @louisburroughs

### Resolution Summary

1. **Story Split Confirmed**: This story now focuses ONLY on configuration. A separate story for receiving workflow execution has been created (see Related Stories below).

2. **Uniqueness Rule Confirmed**: A `StorageLocation` cannot be designated as both default Staging and default Quarantine. This is enforced via validation.

3. **Permission Model Confirmed**: Permission definition and enforcement for quarantine moves is out of scope for this story and belongs to `domain:security` and `domain:inventory` execution stories.

---

## Story Intent

As an **Inventory Manager**, I want to configure default staging and quarantine storage locations for each site, so that all receiving workflows are standardized, consistent, and adhere to inventory handling policies.

## Actors & Stakeholders

- **Primary Actor:**
  - **Inventory Manager:** Responsible for configuring and maintaining the operational topology and policies of a warehouse or site.

- **Secondary Actors & Stakeholders:**
  - **System:** The POS/WMS system that must persist and expose the configured defaults.
  - **`domain:workexec`:** A key stakeholder and consumer of this configuration (consuming story: see Related Stories).
  - **`domain:audit`:** Requires events to be published when these critical site configurations are modified.

## Preconditions

1. The system has a concept of a `Site` or `Location` which represents a distinct physical or logical facility (e.g., a warehouse).
2. The system has a concept of a `StorageLocation` which represents a specific place within a `Site` where inventory can be held (e.g., a bin, a rack, or an area).
3. An authentication and authorization system is in place, capable of granting permissions to the `Inventory Manager` role to modify `Site` configurations.

## Functional Behavior

This story focuses **exclusively** on the **configuration** of the default locations. The consumption of these settings by receiving or other processes is handled in separate stories.

1. **Trigger:** An authorized `Inventory Manager` uses an API to update the default location settings for a specific `Site`.

2. **Behavior:**
   - The manager provides the unique identifier for a `Site`.
   - The manager provides the unique identifier of an existing `StorageLocation` to be designated as the **Default Staging Location**.
   - The manager provides the unique identifier of an existing `StorageLocation` to be designated as the **Default Quarantine Location**.

3. **Outcome:**
   - The system validates that both provided `StorageLocation` identifiers are:
     - Valid
     - Distinct (not the same location)
     - Belong to the specified `Site`
   - The system persists these two references against the `Site`'s configuration.
   - The system emits a `SiteDefaultsUpdated` event with the old and new values for auditing purposes.

## Alternate / Error Flows

1. **Unauthorized Access:** If the user does not have the required permissions to modify the `Site` configuration, the system rejects the request with a `403 Forbidden` error.

2. **Invalid `Site` ID:** If the specified `Site` does not exist, the system rejects the request with a `404 Not Found` error.

3. **Invalid `StorageLocation` ID:** If either the staging or quarantine `StorageLocation` ID does not exist or does not belong to the specified `Site`, the system rejects the request with a `400 Bad Request` or `422 Unprocessable Entity` validation error.

4. **Duplicate Location Assignment (Business Rule Violation):** If the same `StorageLocation` ID is provided for both staging and quarantine roles, the system rejects the request with a `400 Bad Request` validation error with error code `DEFAULT_LOCATION_ROLE_CONFLICT`.

## Business Rules

1. Each `Site` MUST be configurable with exactly one `Default Staging Location`.
2. Each `Site` MUST be configurable with exactly one `Default Quarantine Location`.
3. **The `Default Staging Location` and `Default Quarantine Location` for a single `Site` MUST be two distinct `StorageLocation`s.** (Enforced to prevent operational ambiguity and ensure physical/procedural separation.)
4. Inventory placed in a `Quarantine Location` is considered non-available stock. The permission model for moving items **out of** quarantine (e.g., `inventory.move.from_quarantine`) is defined and enforced by separate security and inventory execution stories. This story only marks the location as quarantine.

## Data Requirements

- The `Site` (or `Location`) entity/resource requires two new fields, both of which are references to a `StorageLocation`:
  - `defaultStagingLocationId: UUID`
  - `defaultQuarantineLocationId: UUID`

- An API endpoint must be created or updated to manage these settings:
  - **Example:** `PUT /api/v1/sites/{siteId}/default-locations`
  - **Example Payload:**
    ```json
    {
      "defaultStagingLocationId": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
      "defaultQuarantineLocationId": "6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b"
    }
    ```

## Acceptance Criteria

### AC1: Configure Defaults Successfully
- **Given** I am an authenticated `Inventory Manager`
- **And** Site "WH-1" exists with Storage Locations "STAGING-A" and "QUARANTINE-B"
- **When** I submit a request to set "STAGING-A" as the default staging location and "QUARANTINE-B" as the default quarantine location for "WH-1"
- **Then** the system returns a `200 OK` success response
- **And** a subsequent GET request for the configuration of "WH-1" shows the correct IDs for the default locations.

### AC2: Reject Invalid Storage Location
- **Given** I am an authenticated `Inventory Manager`
- **And** Site "WH-1" exists
- **When** I submit a request to set a non-existent Storage Location "FAKE-ID" as the default staging location
- **Then** the system returns a client error response (e.g., `400 Bad Request` or `422 Unprocessable Entity`) with a descriptive error message.

### AC3: Reject Duplicate Role Assignment (Business Rule Enforcement)
- **Given** I am an authenticated `Inventory Manager`
- **And** Site "WH-1" exists with Storage Location "COMMON-AREA"
- **When** I submit a request to set "COMMON-AREA" as both the default staging and default quarantine location
- **Then** the system returns a `400 Bad Request` validation error with error code `DEFAULT_LOCATION_ROLE_CONFLICT`
- **And** the error message states that the locations must be distinct.

### AC4: Reject Unauthorized Request
- **Given** I am an authenticated user without `Inventory Manager` permissions
- **When** I attempt to update the default locations for Site "WH-1"
- **Then** the system returns a `403 Forbidden` error.

### AC5: Validate Storage Location Belongs to Site
- **Given** I am an authenticated `Inventory Manager`
- **And** Site "WH-1" exists
- **And** Storage Location "STAGING-X" belongs to Site "WH-2" (different site)
- **When** I submit a request to set "STAGING-X" as the default staging location for "WH-1"
- **Then** the system returns a `400 Bad Request` or `422 Unprocessable Entity` error
- **And** the error message indicates the storage location does not belong to the specified site.

## Audit & Observability

- **Event Emission:** A `SiteDefaultsUpdated` event MUST be emitted to a message bus (e.g., Kafka, RabbitMQ) upon any successful change.

- **Event Payload:** The event should include:
  - `siteId`
  - `updatedByUserId`
  - `timestamp`
  - Previous values: `previousDefaultStagingLocationId`, `previousDefaultQuarantineLocationId`
  - New values: `newDefaultStagingLocationId`, `newDefaultQuarantineLocationId`

- **Logging:** A structured log entry at the `INFO` level should be created, capturing the user, site, and changes made for traceability.

## Related Stories

### Dependency (This Story Must Be Completed First)
This story is a prerequisite for:

- **[NEW STORY]**: "[BACKEND] [STORY] Receiving: Use Site-Default Staging Location"
  - Domain: `domain:workexec`
  - Description: Receiving workflow consumes the site-default staging and quarantine locations configured in this story.

## Original Story (Unmodified ‚Äì For Traceability)

# Issue #38 ‚Äî [BACKEND] [STORY] Topology: Define Default Staging and Quarantine Locations for Receiving

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Topology: Define Default Staging and Quarantine Locations for Receiving

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As an **Inventory Manager**, I want default receiving staging and quarantine locations so that receiving workflows are consistent.

## Details
- Each site can define staging and quarantine locations.
- Quarantine requires approval to move into available stock.

## Acceptance Criteria
- Staging/quarantine configured per location.
- Receiving uses staging by default.
- Quarantine moves require permission.

## Integrations
- Distributor receiving may land in staging; quality hold uses quarantine.

## Data / Entities
- ReceivingPolicy, StorageLocationRef, PermissionCheck

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #37: [BACKEND] [STORY] Ledger: Record Stock Movements in Inventory Ledger
LABELS: type:story,domain:inventory,status:ready-for-dev,agent:story-authoring,agent:inventory
BODY:
---
**Rewrite Variant:** inventory-flexible
**Clarification Applied:** #234 (permissions model for ADJUST)
---

## Story Intent
**As an** Inventory Manager,  
**I want** all stock movements to be recorded as immutable transactions in an inventory ledger,  
**so that** on-hand quantity for any product is fully auditable, traceable, and explainable.

## Actors & Stakeholders
- **Inventory Manager (User Persona):** Primary user who needs to trust and audit inventory levels.
- **System (Actor):** Automated processes (Receiving, Work Execution, etc.) that trigger stock movements.
- **Service Advisor / Parts Counter Staff (User Persona):** Indirect users who consume inventory data and may initiate movements.
- **Auditor (Stakeholder):** Relies on ledger integrity for audits.
- **Work Execution System (Consumer):** Queries movement history for work order lines.

## Preconditions
1. A `Product` master record exists in Product Catalog.
2. Storage locations (bins, shelves, virtual locations) are defined in Location service.
3. The actor (user or system) initiating the movement is authenticated and identifiable.

## Functional Behavior

### 1. Ledger Entry Creation on Stock Movement
When any recognized stock movement event occurs, the system MUST create a new, immutable entry in the `InventoryLedger`. This action is append-only.

The following events MUST generate a ledger entry:
- **Receive:** Supplier receipt increases on-hand at a receiving location.
- **PutAway:** Move from receiving to final storage.
- **Pick:** Move from storage to staging/work-order location.
- **Issue/Consume:** Issue to work order / sale decreases on-hand.
- **Return:** Return increases on-hand at a returns location.
- **Transfer:** Move between two internal storage locations.
- **Adjust (posted):** A manual correction is posted to the ledger (up or down) after required authorization.

### 2. Adjustment (ADJUST) Authorization Flow (Resolved)
Adjustments are handled as a **two-step capability**:
1. **Create adjustment request** (draft/pending): requires permission `INVENTORY_ADJUST_CREATE`.
2. **Approve and post adjustment** (creates the ledger entry): requires permission `INVENTORY_ADJUST_APPROVE`.

Optional simplification (if the service chooses not to separate approve vs post): `INVENTORY_ADJUST_POST` may be used to collapse approve+post into a single step.

Permissions MUST be **scope-aware** (typical: location-scoped; optionally global).

## Alternate / Error Flows
1. **Invalid Product:** Reject with `PRODUCT_NOT_FOUND`; no ledger entry created.
2. **Invalid Location:** Reject with `LOCATION_NOT_FOUND`.
3. **Insufficient Quantity:** For decreasing movements (Pick, Issue, Transfer, negative Adjust), reject with `INSUFFICIENT_STOCK`.
4. **Permission Denied (Adjustment):**
   - Creating an adjustment request without `INVENTORY_ADJUST_CREATE` -> reject `PERMISSION_DENIED`.
   - Approving/posting without `INVENTORY_ADJUST_APPROVE` -> reject `PERMISSION_DENIED`.
5. **Missing Reason for Adjustment:** If an adjustment is created without `reasonCode`, reject with `REASON_CODE_REQUIRED`.

## Business Rules
1. **Immutability:** Ledger entries cannot be modified or deleted. Corrections are made via a new counteracting adjustment.
2. **Atomicity:** Stock movement and corresponding ledger entry creation MUST be atomic.
3. **On-Hand Calculation:** On-hand is computed by summing all `quantityChange` values for a product-location pair.
4. **Adjustment Policy:** Adjustments MUST include `reasonCode` (enum) and audit fields.
5. **Adjustment Authorization (Resolved):** Authorization is **permission-based**, not a single hard-coded role check.

## Data Requirements

### `InventoryLedgerEntry`
| Field | Type | Description | Constraints | Example |
| :--- | :--- | :--- | :--- | :--- |
| `ledgerEntryId` | UUID | Unique identifier for the ledger entry. | PK, Not Null | `a1b2c3d4-e5f6-7890-1234-567890abcdef` |
| `productId` | UUID | Foreign key to Product Catalog. | Not Null | `prod-98765` |
| `timestamp` | Timestamp UTC | When movement occurred. | Not Null, Indexed | `2024-05-21T14:30:00Z` |
| `movementType` | Enum | Stock movement type. | Not Null | `RECEIVE` |
| `quantityChange` | Decimal | Quantity moved. Positive=increase; negative=decrease. | Not Null | `10.00` |
| `unitOfMeasure` | String | UOM for `quantityChange`. | Not Null | `EA` |
| `fromLocationId` | String | Source location. | Nullable | `RECEIVING-DOCK-A` |
| `toLocationId` | String | Destination location. | Nullable | `BIN-A1-03` |
| `actorId` | String | User/system initiating the movement. | Not Null | `user-jane-doe` / `system-wms` |
| `reasonCode` | Enum | Required for adjustment requests and posted adjustments. | Nullable for non-adjust | `CYCLE_COUNT_CORRECTION` |
| `sourceTransactionId` | String | Link to source transaction (PO/WO/etc). | Nullable | `PO-12345` |

### Supporting Enums
- **`MovementType`**: `RECEIVE`, `PUT_AWAY`, `PICK`, `ISSUE`, `RETURN`, `TRANSFER`, `ADJUST`
- **`ReasonCode`** (non-exhaustive): `CYCLE_COUNT_CORRECTION`, `DAMAGED_GOODS`, `STOCK_FOUND`, `THEFT`

### Authorization Model (Resolved)
- Use **granular permissions** bundled into roles (do not hard-code a single "Inventory Manager" role check).
- Minimum v1 permissions:
  - `INVENTORY_ADJUST_CREATE`
  - `INVENTORY_ADJUST_APPROVE`
  - (`INVENTORY_ADJUST_POST` optional if approve+post are collapsed)
- Scope: `LOCATION` scope is typical; allow `GLOBAL` where applicable.

## Acceptance Criteria

**Scenario 1: Receiving New Stock**
- **Given** Product `SKU-123` exists
- **And** location `RCV-01` exists
- **When** the System processes a `RECEIVE` event for 50 units of `SKU-123` to location `RCV-01` from Purchase Order `PO-555`
- **Then** an `InventoryLedgerEntry` is created with:
  - `productId` = `SKU-123`
  - `movementType` = `RECEIVE`
  - `quantityChange` = `+50`
  - `toLocationId` = `RCV-01`
  - `fromLocationId` = `null`
  - `sourceTransactionId` = `PO-555`

**Scenario 2: Transferring Stock Internally**
- **Given** Product `SKU-123` has on-hand 50 at location `RCV-01`
- **And** location `BIN-C4` exists
- **When** an authorized user initiates a `TRANSFER` of 20 units of `SKU-123` from `RCV-01` to `BIN-C4`
- **Then** an `InventoryLedgerEntry` is created with:
  - `movementType` = `TRANSFER`
  - `quantityChange` reflecting the movement (implementation may model as one entry with both locations or two entries)
  - `fromLocationId` = `RCV-01`
  - `toLocationId` = `BIN-C4`

**Scenario 3: Creating an Adjustment Request (Authorized)**
- **Given** a user with permission `INVENTORY_ADJUST_CREATE` is logged in
- **When** they create an adjustment request for product `SKU-456` at location `SHELF-B2` to decrease stock by 2 units with reason `DAMAGED_GOODS`
- **Then** the request is accepted
- **And** `reasonCode` is required and stored

**Scenario 4: Approving/Posting an Adjustment (Authorized)**
- **Given** a pending adjustment request exists
- **And** a user with permission `INVENTORY_ADJUST_APPROVE` is logged in
- **When** they approve and post the adjustment
- **Then** an `InventoryLedgerEntry` is created with:
  - `movementType` = `ADJUST`
  - `quantityChange` = `-2`
  - `fromLocationId` = `SHELF-B2`
  - `toLocationId` = `null`
  - `reasonCode` = `DAMAGED_GOODS`

**Scenario 5: Unauthorized Adjustment Attempt**
- **Given** a user without `INVENTORY_ADJUST_CREATE` is logged in
- **When** they attempt to create an adjustment request
- **Then** the system rejects with `PERMISSION_DENIED`
- **And** no ledger entry is created.

**Scenario 6: Reconstructing On-Hand Quantity**
- **Given** ledger entries exist for product `SKU-789` at location `BIN-A1`:
  - `RECEIVE`, `+100`
  - `PICK`, `-10`
  - `ADJUST`, `+1` (reason `STOCK_FOUND`)
- **When** the system queries on-hand for `SKU-789` at `BIN-A1`
- **Then** the calculated on-hand MUST be `91`.

## Audit & Observability
- **Audit Trail:** Every `InventoryLedgerEntry` is an audit record.
- **Logging:**
  - Successful ledger entry creation: `INFO` with `ledgerEntryId`.
  - Failed attempts (insufficient stock, invalid data, permissions): `WARN` including actor, product, locations, reason.
- **Metrics:** Count ledger entries created per `movementType`.
- **Adjustment audit fields (required):** `requestedBy`, `approvedBy`, timestamps, and `policyVersion`.

## Open Questions
None.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #37 ‚Äî [BACKEND] [STORY] Ledger: Record Stock Movements in Inventory Ledger

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Ledger: Record Stock Movements in Inventory Ledger

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As an **Inventory Manager**, I want all stock movements recorded in a ledger so that on-hand is auditable and explainable.

## Details
- Movement types: Receive, PutAway, Pick, Issue/Consume, Return, Transfer, Adjust.
- Capture productId, qty, UOM, from/to storage, actor, timestamp, reason.

## Acceptance Criteria
- Every movement creates a ledger entry.
- Ledger is append-only.
- Can reconstruct on-hand by replay.
- Adjustments require reason and permission.

## Integrations
- Workexec can query movement history for a workorder line.

## Data / Entities
- InventoryLedgerEntry, MovementType, ReasonCode, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #36: [BACKEND] [STORY] Ledger: Compute On-hand and Available-to-Promise by Location/Storage
LABELS: type:story,domain:inventory,status:ready-for-dev,agent:story-authoring,agent:inventory
BODY:
---
**Rewrite Variant:** inventory-flexible
**Clarification Applied:** #233 (ATP formula, UOM scope, SLA, definitive ledger event types)
---

## Story Intent
**As a** Service Advisor,  
**I need to** know the real-time on-hand and available-to-promise (ATP) quantities for a specific part at a given location,  
**so that I can** provide accurate quotes and schedule customer work with confidence.

## Actors & Stakeholders
- **Primary Actor**: Service Advisor
- **System Actors**:
  - Inventory Service (computes and serves availability)
  - POS UI (consumes availability)
- **Stakeholders**:
  - Work Execution (confirms parts availability for scheduled jobs)
  - Pricing (may use ATP as an input)
  - Inventory Manager (operational planning and stock control)

## Preconditions
- An immutable inventory ledger exists and records stock movements with product, location, movement type, and quantity.
- A system for recording stock allocations (soft reservations for specific work orders/sales) exists and is accessible.
- Products (SKU + base UOM) are defined in Product domain.
- A location hierarchy exists (parent locations and optional storage/bin locations).

## Functional Behavior
The Inventory Service exposes an API endpoint providing on-hand and ATP for a specified product.

1. **Trigger**: Request for availability.
2. **Input**: `productSku`, `locationId`, optional `storageLocationId`.
3. **Processing**:
   - Compute `onHandQuantity` from the inventory ledger (net sum of physical stock movements; see Business Rules).
   - Query allocation system for `allocatedQuantity` for the same scope.
   - Compute `availableToPromiseQuantity` using the defined formula.
   - If only `locationId` is provided, aggregate across all child storage locations.
   - If `storageLocationId` is provided, scope is narrowed to that storage location.
4. **Output**: Return an `AvailabilityView` including `onHandQuantity`, `allocatedQuantity`, `availableToPromiseQuantity`, and `unitOfMeasure`.

## Alternate / Error Flows
- **Product Not Found**: If `productSku` is not found, return `404 Not Found`.
- **Location Not Found**: If `locationId` / `storageLocationId` is not found, return `404 Not Found`.
- **No Inventory History**: If product has no ledger entries for the scope, return success with quantities = 0.

## Business Rules

### On-Hand Calculation (Resolved)
On-hand is the net sum of **physical stock movements** (inbound/outbound) plus count variances. Allocations/reservations are **not** part of on-hand.

**Include in On-Hand (add/subtract by direction)**
- Inbound (positive):
  - `GOODS_RECEIPT`
  - `TRANSFER_IN`
  - `RETURN_TO_STOCK`
  - `ADJUSTMENT_IN`
  - `COUNT_VARIANCE_IN`
- Outbound (negative):
  - `GOODS_ISSUE`
  - `TRANSFER_OUT`
  - `SCRAP_OUT`
  - `ADJUSTMENT_OUT`
  - `COUNT_VARIANCE_OUT`

**Explicitly excluded from On-Hand**
- `RESERVATION_CREATED`, `RESERVATION_RELEASED`
- `ALLOCATION_CREATED`, `ALLOCATION_RELEASED`
- `BACKORDER_CREATED`, `BACKORDER_RESOLVED`
- `PICK_TASK_CREATED`, `PICK_TASK_COMPLETED` (unless these post one of the physical movement events above)

### ATP Calculation Formula (Resolved)
**ATP v1:** $\text{ATP} = \text{OnHand} - \text{Allocations}$  
**Expected receipts are out of scope** for this story.

Optional forward-compatibility: the API may return `expectedReceiptsQty` as nullable, but it MUST NOT be included in ATP.

### Allocation Definition
An allocation is a soft reservation for a specific purpose (e.g., scheduled work order) that has not yet been physically picked/issued.

### Unit of Measure (UOM) Consistency (Resolved)
All internal calculations and API responses are in the product‚Äôs **base UOM**.

Out of scope: request/response UOM conversions (e.g., case vs each).

### Location Aggregation
Querying a parent location aggregates all stock within the location across child storage locations.

## Data Requirements

### API Request
- `productSku` (string, required)
- `locationId` (UUID, required)
- `storageLocationId` (UUID, optional)

### API Response (`AvailabilityView`)
- `productSku` (string)
- `locationId` (UUID)
- `storageLocationId` (UUID, nullable)
- `onHandQuantity` (decimal, base UOM)
- `allocatedQuantity` (decimal, base UOM)
- `availableToPromiseQuantity` (decimal, base UOM)
- `unitOfMeasure` (string; product base UOM)

## Acceptance Criteria

**Scenario 1: Simple On-Hand Calculation**
- **Given** product `SKU-123` has ledger history at `LOC-A`: `GOODS_RECEIPT +10` and `GOODS_ISSUE -2`
- **When** availability is requested for `SKU-123` at `LOC-A`
- **Then** `onHandQuantity = 8`.

**Scenario 2: ATP Calculation with Allocations**
- **Given** `onHandQuantity = 8` for `SKU-123` at `LOC-A`
- **And** `allocatedQuantity = 3` at `LOC-A`
- **When** availability is requested for `SKU-123` at `LOC-A`
- **Then** `availableToPromiseQuantity = 5`.

**Scenario 3: Aggregate Calculation by Parent Location**
- **Given** `LOC-WAREHOUSE` contains `BIN-1` and `BIN-2`
- **And** ledger shows 5 units of `SKU-ABC` in `BIN-1` and 3 units in `BIN-2`
- **When** availability is requested for `SKU-ABC` at `LOC-WAREHOUSE` (no `storageLocationId`)
- **Then** `onHandQuantity = 8`.

**Scenario 4: Request for a Non-Existent Product**
- **Given** product catalog does not contain `SKU-DOES-NOT-EXIST`
- **When** availability is requested
- **Then** return `404 Not Found`.

**Scenario 5: Request for a Valid Product with No Inventory**
- **Given** `SKU-456` exists but has no ledger entries at `LOC-A`
- **When** availability is requested
- **Then** return success with `onHandQuantity = 0`, `allocatedQuantity = 0`, `availableToPromiseQuantity = 0`.

## Audit & Observability
- **Logging**: Log each availability request (`productSku`, `locationId`, optional `storageLocationId`) and resulting quantities. Log lookup/summation errors.
- **Metrics**:
  - Timer for endpoint latency.
  - Counters for success and error responses (4xx/5xx).
- **Tracing**: Distributed tracing from API gateway through Inventory Service to data stores.

## Performance Requirements (Resolved)
- Core endpoint (single product, single location, warm cache):
  - **P95 < 200ms**
  - P50 < 80ms
  - P99 < 400ms
- Measurement is at the service boundary, excluding caller network latency.

## Open Questions
None.

## Original Story (Unmodified ‚Äì For Traceability)
## Backend Implementation for Story

**Original Story**: [STORY] Ledger: Compute On-hand and Available-to-Promise by Location/Storage

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Service Advisor**, I want on-hand/ATP so that we can quote and schedule realistically.

## Details
- On-hand computed from ledger; ATP = on-hand - allocations + expected receipts (optional).
- Provide per location and optionally per storage location.

## Acceptance Criteria
- Availability query returns on-hand and ATP.
- Consistent UOM handling.
- SLA suitable for estimate UI.

## Integrations
- Product/workexec query availability; product may surface ATP to pricing.

## Data / Entities
- AvailabilityView, AllocationSummary, ExpectedReceiptSummary

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #35: [BACKEND] [STORY] Receiving: Create Receiving Session from PO/ASN
LABELS: type:story,domain:inventory,status:needs-review
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:inventory
- status:needs-review

### Recommended
- agent:inventory
- agent:story-authoring

---
**Rewrite Variant:** inventory-flexible
---

## Story Intent

**As a** Receiver,
**I want to** initiate a new receiving session by referencing an existing Purchase Order (PO) or Advanced Shipping Notice (ASN),
**so that** the system can pre-populate the expected items and quantities, streamlining the check-in process and ensuring accuracy.

## Actors & Stakeholders

- **Actors:**
  - `Receiver`: The primary user performing the physical and systemic receipt of goods.
  - `System`: The POS/Inventory management system facilitating the process.
- **Stakeholders:**
  - `Inventory Manager`: Responsible for the overall accuracy and efficiency of inventory operations.
  - `Purchasing Manager`: Responsible for the procurement lifecycle, including PO creation and fulfillment.
  - `System (Positivity)`: An external system that may provide the ASN data.

## Preconditions

1. The `Receiver` is authenticated and has the necessary permissions to perform receiving functions.
2. The Purchase Order or ASN to be received against exists in the system and is in an `Open` or `Partially Received` state.
3. Product master data for all items listed on the source PO/ASN is available in the system.

## Functional Behavior

1. The `Receiver` navigates to the receiving module and initiates the "Create New Session" flow.
2. The `System` prompts the `Receiver` to provide an identifier for the source document (e.g., PO Number, ASN ID). The identifier can be provided via:
    - **Manual text entry** into an input field, or
    - **Barcode scan** (which populates the same input field automatically)
3. The `Receiver` provides the identifier using one of the supported methods.
4. The `System` validates the identifier against existing, receivable POs and ASNs using an exact match.
5. Upon successful validation, the `System` creates a new `ReceivingSession` entity with a default status of `Open`.
6. The `System` populates the new session with key information from the source document, including:
    - Supplier/Distributor reference.
    - Shipment reference number (if available, e.g., from an ASN).
    - A list of expected `ReceivingLine` items, copying the Product ID and expected quantity for each line from the source document.
7. The `System` records metadata about how the identifier was provided (`MANUAL` or `SCAN`).
8. The `System` then presents the newly created session to the `Receiver`, ready for the item check-in and quantity confirmation phase to begin (which is handled in a subsequent story).

## Alternate / Error Flows

- **Source Document Not Found:** If the `Receiver` provides an identifier that does not correspond to a known PO or ASN, the `System` must display a clear error message (e.g., "PO/ASN [Identifier] not found") and prevent session creation.
- **Source Document Already Received:** If the identifier corresponds to a PO or ASN that is already in a `Closed` or `Fully Received` state, the `System` must display an informative error message (e.g., "PO [Identifier] has already been fully received") and block session creation.
- **Blind Receiving Not Supported:** If the physical shipment arrives without a scannable or enterable PO/ASN reference, the `System` must not allow receiving session creation. A clear blocking message must be displayed: "Receiving requires a valid PO or ASN. Blind receiving is not supported." (Note: Blind receiving may be introduced in a future story as a separate workflow with a separate permission `ALLOW_BLIND_RECEIVING`.)
- **User Cancellation:** The `Receiver` can cancel the creation process at any point before the session is finalized, returning them to the main receiving screen without creating any new data.

## Business Rules

- A `ReceivingSession` must be tied to exactly one source document (either a PO or an ASN).
- The initial status of a newly created `ReceivingSession` must be `Open`.
- All `ReceivingLine` items created within the session must have their `receivedQuantity` initialized to zero.
- The system must support partial receipts. A PO/ASN can have multiple `ReceivingSession`s created against it over time, until its total expected quantities are fulfilled.
- **Blind receiving is explicitly not supported in this story.** A valid PO or ASN identifier is required to create a receiving session.
- This story covers the *creation* of the session only. The subsequent actions of counting items, matching them to lines, and capturing variances are explicitly out of scope and will be handled in a separate, subsequent user story (e.g., *Receiving: Perform Count and Capture Variances*).

## Data Requirements

- **`ReceivingSession`**
  - `sessionID`: (UUID, System-generated) - PK
  - `sourceDocumentID`: (String) - The identifier of the source PO or ASN (e.g., "PO-12345").
  - `sourceDocumentType`: (Enum: `PO`, `ASN`)
  - `supplierID`: (FK) - Reference to the Supplier entity.
  - `shipmentReference`: (String, Nullable)
  - `status`: (Enum: `Open`, `InProgress`, `Completed`, `Cancelled`)
  - `entryMethod`: (Enum: `MANUAL`, `SCAN`) - How the identifier was provided
  - `createdAt`: (Timestamp)
  - `createdByUserID`: (FK)
- **`ReceivingLine`**
  - `lineID`: (UUID, System-generated) - PK
  - `sessionID`: (FK) - Reference to `ReceivingSession`.
  - `productID`: (FK) - Reference to the Product Master.
  - `expectedQuantity`: (Decimal)
  - `receivedQuantity`: (Decimal, Default: 0)

## Acceptance Criteria

### AC1: Successful Session Creation from a Purchase Order via Manual Entry
- **Given** a `Receiver` is logged into the system with receiving permissions,
- **And** a Purchase Order with ID `PO-123` exists in an `Open` state, containing two item lines.
- **When** the `Receiver` initiates a new receiving session and manually enters the identifier `PO-123`.
- **Then** a new `ReceivingSession` is created with a `status` of `Open`.
- **And** the session is linked to the source document `PO-123`.
- **And** the session contains two `ReceivingLine` items that correspond to the items and expected quantities on `PO-123`.
- **And** the `entryMethod` is recorded as `MANUAL`.

### AC2: Successful Session Creation from an ASN via Barcode Scan
- **Given** a `Receiver` is logged into the system with receiving permissions,
- **And** an ASN with ID `ASN-ABC-789` exists in an `Open` state.
- **When** the `Receiver` initiates a new receiving session and scans the barcode for `ASN-ABC-789`.
- **Then** a new `ReceivingSession` is created with a `status` of `Open`.
- **And** the session is linked to the source document `ASN-ABC-789`.
- **And** the session's lines are pre-populated from the ASN data.
- **And** the `entryMethod` is recorded as `SCAN`.

### AC3: Failure When Source Document is Not Found
- **Given** a `Receiver` is on the "Create New Session" screen.
- **When** the `Receiver` enters an identifier `PO-999` which does not exist in the system.
- **Then** the system must display an actionable error message, such as "Source document PO-999 not found."
- **And** no `ReceivingSession` is created.

### AC4: Failure When Source Document is Already Closed
- **Given** a `Receiver` is on the "Create New Session" screen,
- **And** a Purchase Order `PO-456` exists but has a status of `Closed` or `Fully Received`.
- **When** the `Receiver` enters the identifier `PO-456`.
- **Then** the system must display an actionable error message, such as "PO-456 has already been fully received."
- **And** no `ReceivingSession` is created.

### AC5: Failure When Attempting Blind Receiving
- **Given** a `Receiver` is on the "Create New Session" screen.
- **When** the `Receiver` attempts to create a session without providing a valid PO or ASN identifier.
- **Then** the system must display a clear blocking message: "Receiving requires a valid PO or ASN. Blind receiving is not supported."
- **And** no `ReceivingSession` is created.

## Audit & Observability

- **Audit Trail:** An immutable audit event must be logged upon the successful creation of a `ReceivingSession`. The event payload must include `sessionID`, `creatorUserID`, `creationTimestamp`, `sourceDocumentID`, `sourceDocumentType`, and `entryMethod`.
- **Logging:**
  - `INFO`: Log successful session creation events with entry method details.
  - `WARN`: Log failed attempts to create a session due to business rule violations (e.g., PO not found, PO already closed, blind receiving attempt) for monitoring potential process or data integrity issues.

## Clarifications (Resolved)

The following questions were raised during story authoring and have been resolved via [clarification issue #232](https://github.com/louisburroughs/durion-positivity-backend/issues/232):

### Question 1: Identifier Method
**Decision:** The primary methods for providing the PO/ASN identifier are:
- **Manual text entry** into an input field
- **Barcode scan** (which populates the same input field)
- **Searchable list is explicitly out of scope** for this story and may be a follow-up enhancement.

**Enforcement:** Input must be an exact match against an existing PO or ASN. Validation occurs before session creation. The system records:
- `identifierType` (PO or ASN)
- `identifierValue` (the actual identifier)
- `entryMethod` (MANUAL or SCAN)

### Question 2: "Blind" Receiving
**Decision:** **Blocked** for this story.

If no scannable or enterable PO/ASN is available:
- The system must **not allow** receiving session creation
- Display blocking message: "Receiving requires a valid PO or ASN. Blind receiving is not supported."

**Future extensibility (explicitly out of scope):** Blind receiving may be introduced later as a separate workflow with a separate permission (`ALLOW_BLIND_RECEIVING`).

### Question 3: Scope of "Matching and Variances"
**Decision:** **Confirmed out of scope** for this story.

This story includes only:
- Identification of PO/ASN
- Validation of existence and eligibility  
- Creation of a Receiving Session shell with:
  - `receivingSessionId`
  - `sourceDocumentId`
  - `status = CREATED`

**Explicitly excluded (next story):**
- Counting physical items
- Line-by-line matching
- Recording over/under/incorrect items
- Variance approval workflows

These will be handled in a subsequent story (e.g., *Receiving: Perform Count and Capture Variances*).

---

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #35 ‚Äî [BACKEND] [STORY] Receiving: Create Receiving Session from PO/ASN

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Receiving: Create Receiving Session from PO/ASN

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Receiver**, I want to create a receiving session from a PO/ASN so that inbound items can be checked in.

## Details
- Session includes supplier/distributor, shipment ref, expected lines.
- Support scanning barcodes and capturing lot/serial (optional v1).

## Acceptance Criteria
- Receiving session created.
- Lines can be matched and variances captured.
- Session auditable.

## Integrations
- Positivity may provide ASN; product master maps items.

## Data / Entities
- ReceivingSession, ReceivingLine, SupplierRef, VarianceRecord

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #33: [BACKEND] [STORY] Receiving: Direct-to-Workorder Receiving (Cross-dock) from Distributor
LABELS: type:story,domain:inventory,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:inventory
- status:ready-for-dev

### Recommended
- agent:inventory
- agent:story-authoring

---
**Rewrite Variant:** inventory-flexible
---

## Story Intent

**As an** Inventory Manager,
**I want to** receive parts from a supplier shipment and immediately issue them to a specific, pre-existing workorder,
**so that** urgent jobs can be fulfilled without the delay of the standard put-away and picking process.

This process, known as "cross-docking," ensures that high-priority parts are directly routed to the point of need, increasing workshop throughput.

## Actors & Stakeholders

- **Primary Actor:**
  - **Inventory Manager:** The user responsible for physically and systemically receiving goods from suppliers.

- **System Actors:**
  - **POS System:** The system of record for inventory movements (receiving, issuing).

- **Stakeholders:**
  - **Work Execution System (Workexec):** The system that manages workorders and is the consumer of the issued parts. It needs to be notified of the fulfillment.
  - **Service Advisor:** Needs visibility into the workorder status to manage customer expectations.
  - **Mechanic / Technician:** The end user of the part who is waiting for it to begin or complete a job.

## Preconditions

1.  A valid Workorder exists in the Workexec system with at least one line item demanding a specific part.
2.  A Purchase Order for the corresponding part exists and is linked to the supplier's shipment.
3.  The Inventory Manager is authenticated and has the necessary permissions to perform receiving functions (including `ISSUE_PARTS` permission for confirmation).
4.  The system has a mechanism to associate an incoming receiving line with a specific `workorderId` and `workorderLineId`.

## Functional Behavior

1.  The Inventory Manager initiates the receiving process for an incoming supplier shipment.
2.  For a specific line item on the shipment, the user flags it for "Direct-to-Workorder" (cross-dock) receiving.
3.  The system prompts the user to link the receiving line to an existing workorder line.
4.  The system validates that the part number on the receiving line matches the part number demanded by the selected workorder line (see Business Rule #5 for mismatch handling).
5.  Upon the user confirming the received quantity, the system behavior depends on the configured policy:
    
    **Default Behavior (Manual Confirmation):**
    - The system presents a final confirmation screen: "You are about to issue 2 √ó P-ABC to Work Order WO-123. Confirm?"
    - The Inventory Manager with `ISSUE_PARTS` permission must explicitly confirm.
    - Upon confirmation, the system executes the inventory movements.
    
    **Optional Auto-Issue Behavior (Policy-Controlled):**
    - Auto-issue is allowed ONLY when ALL of the following conditions are met:
      - Exact SKU match to the workorder line
      - Quantity received ‚â§ quantity remaining on the workorder
      - No lot/serial/expiry exceptions
      - User/location policy enables auto-issue
    - Auto-issue must be clearly indicated in the UI and fully audited
    
6.  The system executes the following inventory movements as a single, atomic transaction:
    a. Creates an `INVENTORY_RECEIVE` ledger entry, increasing the quantity-on-hand. The source reference will be the supplier shipment and Purchase Order.
    b. Immediately creates an `INVENTORY_ISSUE` ledger entry for the same quantity, decreasing the quantity-on-hand. The destination reference will be the `workorderId`.
    - Both ledger entries must record `issueMode` (either `MANUAL_CONFIRM` or `AUTO_ON_RECEIPT`) and `confirmedBy` (user ID or SYSTEM).
7.  The net effect on 'available' stock for general sale is zero. The part's lifecycle is tracked from receipt to immediate issue.
8.  The system emits an asynchronous `InventoryIssuedToWorkOrder` event (topic: `inventory.issue.completed.v1`) to notify the downstream Work Execution system that the part is now physically available for the job. This is a non-blocking operation from the POS system's perspective.

## Alternate / Error Flows

- **Error: Mismatched Part Number:**
  - **Default Behavior:** If the user attempts to link a receiving line to a workorder line with a different part number, the system will block the action and display an error message: `PART_MISMATCH_WITH_WORKORDER`.
  - **Override (Exceptional):** Users with `OVERRIDE_PART_MATCH` permission may override this block by:
    - Providing an explicit reason code (e.g., `APPROVED_SUBSTITUTE`, `VENDOR_SUBSTITUTION`)
    - Selecting/confirming the substitute mapping
    - All override actions are fully audited
  - **Important:** Overrides MUST NOT auto-issue; they always require manual confirmation.
  - The workorder line must be updated to reflect the substitute (with traceability), or the issuance must be explicitly marked as a substitute against the original line.

- **Error: Closed/Cancelled Workorder:**
  - If the target workorder is no longer in an 'Open' or 'In-Progress' state, the system will prevent the linkage and inform the user.

- **Error: Notification Failure:**
  - If the notification event to the Workexec system fails to send, the action will be added to a retry queue. A critical alert will be logged for monitoring if retries are exhausted. The inventory transactions themselves are not rolled back.

## Business Rules

1.  Items received via the cross-dock process must not be made available to any other source of demand (e.g., other workorders, counter sales).
2.  The inventory ledger must clearly distinguish between a standard receipt (to stock) and a cross-dock receipt-and-issue.
3.  The cost of the received item must be correctly applied to the workorder as part of the issue transaction.
4.  This flow explicitly bypasses the standard 'put-away' process and bin location assignment. The temporary location is effectively the destination workorder/bay.
5.  **Confirmation Policy (Resolved):**
    - **Default:** Manual confirmation is required before issuing parts to a workorder.
    - **Auto-Issue:** May be enabled when all safety conditions are met (exact match, quantity valid, no exceptions, policy enabled).
    - All issue operations must record `issueMode` and `confirmedBy` for audit purposes.
6.  **Part Mismatch Policy (Resolved):**
    - **Default:** Strictly block issuance if part numbers do not match.
    - **Override:** Allowed only with `OVERRIDE_PART_MATCH` permission, explicit reason code, and full audit trail.
    - Overrides always require manual confirmation (never auto-issue).
7.  **Notification Policy (Resolved):**
    - Notifications to Workexec are asynchronous and non-blocking.
    - The authoritative record is the event published to `inventory.issue.completed.v1` topic.
    - Optional synchronous REST calls for UI feedback are best-effort and must not block the issue transaction.

## Data Requirements

- **Entity: `ReceivingLine`**
  - Must be extended to include optional nullable fields: `workorderId` and `workorderLineId`.
  
- **Entity: `InventoryLedgerEntry`**
  - Must include a `transactionType` (e.g., `CROSS_DOCK_RECEIVE`, `CROSS_DOCK_ISSUE` or use existing types with a new context field).
  - Must include a `sourceDocumentReference` to store the supplier shipment ID or PO number.
  - Must include a `destinationDocumentReference` to store the `workorderId`.
  - **New Fields (Resolved):**
    - `issueMode` (Enum: `MANUAL_CONFIRM`, `AUTO_ON_RECEIPT`)
    - `confirmedBy` (FK to User or SYSTEM identifier)
  
- **Permissions:**
  - `ISSUE_PARTS` - Required to confirm manual issuance
  - `OVERRIDE_PART_MATCH` - Required to override part mismatch validation
  
- **Configuration:**
  - User/location-level policy flag for enabling auto-issue
  - Reason codes for part substitutions (e.g., `APPROVED_SUBSTITUTE`, `VENDOR_SUBSTITUTION`)

- **Integration Event: `InventoryIssuedToWorkOrder`**
  - **Topic:** `inventory.issue.completed.v1`
  - **Event Envelope (Required):**
    - `eventId` (UUIDv7)
    - `eventType` ("InventoryIssuedToWorkOrder")
    - `schemaVersion` ("1")
    - `occurredAt` (ISO 8601 timestamp)
    - `producer` ("pos-inventory")
  - **Payload:**
    - `workOrderId` (UUIDv7)
    - `workOrderLineId` (UUIDv7)
    - `receiptId` (UUIDv7)
    - `productId` (UUIDv7)
    - `quantityIssued` (Number)
    - `uom` (String, e.g., "EA")
    - `lotId` (UUIDv7, optional)
    - `sourceLocationId` (UUIDv7)
    - `issueMode` (String: "MANUAL_CONFIRM" or "AUTO_ON_RECEIPT")
    - `reference` (Object):
      - `receivingLineId` (UUIDv7)

## Acceptance Criteria

### AC-1: Successful Full Quantity Cross-Dock with Manual Confirmation

- **Given** an open Workorder `WO-123` demands 2 units of part `P-ABC`.
- **And** a supplier shipment arrives containing 2 units of part `P-ABC`.
- **And** manual confirmation is required (default policy).
- **When** the Inventory Manager receives the 2 units and links them to `WO-123`.
- **Then** the system displays a confirmation screen: "You are about to issue 2 √ó P-ABC to Work Order WO-123. Confirm?"
- **When** the Inventory Manager confirms.
- **Then** the system creates one `INVENTORY_RECEIVE` ledger entry for 2 units of `P-ABC`.
- **And** the system creates one `INVENTORY_ISSUE` ledger entry for 2 units of `P-ABC` against `WO-123`.
- **And** both entries record `issueMode = MANUAL_CONFIRM` and `confirmedBy = <userId>`.
- **And** the quantity-on-hand for `P-ABC` is unchanged by the net transaction.
- **And** an `InventoryIssuedToWorkOrder` event is published to `inventory.issue.completed.v1` topic for `WO-123`.

### AC-2: Successful Partial Quantity Cross-Dock

- **Given** an open Workorder `WO-123` demands 2 units of part `P-ABC`.
- **And** a supplier shipment arrives containing 1 unit of part `P-ABC`.
- **When** the Inventory Manager receives the 1 unit and links it to `WO-123`.
- **And** confirms the issuance.
- **Then** the system records the receipt and issue of 1 unit in the inventory ledger.
- **And** the Workexec system is notified via event that 1 of 2 units has been issued to `WO-123`.

### AC-3: Auto-Issue When Policy Conditions Are Met

- **Given** an open Workorder `WO-789` demands 1 unit of part `P-XYZ`.
- **And** auto-issue policy is enabled for the user/location.
- **And** a supplier shipment arrives containing 1 unit of part `P-XYZ` (exact match, no exceptions).
- **When** the Inventory Manager receives the 1 unit and links it to `WO-789`.
- **Then** the system automatically issues the part without requiring manual confirmation.
- **And** both ledger entries record `issueMode = AUTO_ON_RECEIPT` and `confirmedBy = SYSTEM`.
- **And** the UI clearly indicates that auto-issue occurred.

### AC-4: Attempt to Link to a Closed Workorder

- **Given** a Workorder `WO-456` exists with a status of 'Closed'.
- **And** a supplier shipment arrives containing a part demanded by the original `WO-456`.
- **When** the Inventory Manager attempts to link the received part to `WO-456`.
- **Then** the system displays an error message stating, "Cannot issue parts to a closed workorder."
- **And** no inventory transactions are created.

### AC-5: Mismatched Part with Override

- **Given** an open Workorder `WO-555` demands part `P-AAA`.
- **And** a supplier shipment arrives containing part `P-BBB` (different part).
- **When** the Inventory Manager attempts to link `P-BBB` to `WO-555`.
- **Then** the system displays an error: `PART_MISMATCH_WITH_WORKORDER`.
- **When** a user with `OVERRIDE_PART_MATCH` permission selects "Override" and provides reason code `APPROVED_SUBSTITUTE`.
- **And** confirms the substitute mapping.
- **Then** the system presents the manual confirmation screen (override never auto-issues).
- **When** the user confirms.
- **Then** the system records the issue with full audit trail including the reason code and override permission.

## Audit & Observability

- **Audit Trail:** Every cross-dock operation must create an immutable audit log entry containing: `timestamp`, `userId`, `partNumber`, `quantity`, `supplierShipmentId`, `workorderId`, `issueMode`, and `confirmedBy`.
- **Metrics:** The system should expose metrics for:
  - `crossdock_operations_total` (counter, labeled by `issueMode`)
  - `crossdock_notification_failures_total` (counter)
  - `crossdock_override_total` (counter, labeled by `reasonCode`)
- **Logging:** Structured logs should be generated for the start and end of the cross-dock transaction, including the success or failure of the notification to Workexec.

## Resolved Questions

All open questions have been answered and incorporated into the story above:

1.  **Confirmation Policy (RESOLVED):** Two-step with configurable auto-issue, defaulting to manual confirmation. See Business Rule #5 and Functional Behavior step 5.
2.  **Notification Contract (RESOLVED):** Asynchronous, non-blocking event via message queue topic `inventory.issue.completed.v1`. See Business Rule #7 and Data Requirements.
3.  **Mismatched Part Handling (RESOLVED):** Strict block by default, with override allowed via `OVERRIDE_PART_MATCH` permission and reason code. See Business Rule #6 and Alternate Flows.

**Clarification Issue:** #231 (Resolved 2026-01-12)

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #33 ‚Äî [BACKEND] [STORY] Receiving: Direct-to-Workorder Receiving (Cross-dock) from Distributor

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Receiving: Direct-to-Workorder Receiving (Cross-dock) from Distributor

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As an **Inventory Manager**, I want to receive items directly against a workorder so that urgent jobs can be fulfilled without normal put-away.

## Details
- Receiving lines can be linked to workorderId and workorderLineId.
- Items received can be immediately allocated/issued to that workorder.
- Optionally bypass storage and go straight to issue.

## Acceptance Criteria
- Receipt linked to workorder.
- Allocation/issue auto or confirm.
- Workexec notified.
- Audit includes supplier shipment ref.

## Integrations
- Workexec sends demand; Positivity provides shipment status; inventory posts receive+issue.

## Data / Entities
- WorkorderReceiptLink, ReceivingLine, InventoryLedgerEntry(Receive/Issue)

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #32: [BACKEND] [STORY] Putaway: Generate Put-away Tasks from Staging
LABELS: type:story,domain:inventory,status:ready-for-dev,agent:story-authoring,agent:inventory
BODY:
---
**Rewrite Variant:** inventory-flexible
**Clarification Applied:** #230 (rule precedence, task granularity, assignment model, destination fallback)
---

## Story Intent
**As a** Warehouse Manager,  
**I want** the system to automatically generate put-away tasks for all items on a completed goods receipt,  
**so that** stock clerks can efficiently move items from staging to correct, system-suggested storage locations with strong auditability.

## Actors & Stakeholders
- **Primary Actor (System):** Inventory service (generates tasks).
- **Users:** Stock Clerk (claims/executes tasks), Warehouse Manager (supervises), Inventory Controller (audit/accuracy).

## Preconditions
1. A `GoodsReceipt` is successfully processed and transitions to `COMPLETED`.
2. Received items are represented as being in a known staging location.
3. Storage locations (bins/shelves/zones) exist in the storage topology.
4. Put-away rules are configured (product/category/etc) and validated at configuration time.

## Functional Behavior

### Trigger
- Automatically triggered when `GoodsReceipt` transitions to `COMPLETED`.

### System Process
1. Identify receipt line items currently in staging.
2. For each receipt line item, resolve a suggested destination storage location using put-away rules (see Business Rules).
3. Generate a `PutawayTask` for each receipt line item (default behavior) with:
   - product, quantity
   - source location (staging)
   - suggested destination location
   - reference to the source `GoodsReceipt`
   - status initialized per assignment rules
4. Publish tasks to a shared task pool for claiming/assignment.

### Assignment and Execution Model (Resolved)
- Tasks are created as **UNASSIGNED**.
- Users with permission `CLAIM_PUTAWAY_TASK` can claim and execute tasks.
- Users with `ASSIGN_PUTAWAY_TASK` can assign/reassign tasks and override claims.

### Destination Availability Handling (Resolved)
At task generation time, if the rule-suggested destination is full/unavailable/invalid:
1. Automatically find the **next-best valid location** consistent with rule precedence and compatibility constraints.
2. Record:
   - `originalSuggestedLocationId`
   - `finalSuggestedLocationId`
   - `fallbackReason` = `DESTINATION_FULL` or `UNAVAILABLE`

If **no valid location exists** that satisfies rules/constraints:
- Create the task with status `REQUIRES_LOCATION_SELECTION`
- Require a user with permission `SELECT_PUTAWAY_LOCATION` to select a destination before execution.

## Alternate / Error Flows
- **Invalid Receipt State:** Must not trigger for non-`COMPLETED` receipts.
- **Rule Conflicts:** Conflicts at the same precedence level are configuration errors and must be rejected at setup time.
- **No Matching Rule:** Use lower-precedence defaults and ultimately a system fallback location policy (‚Äúany valid location‚Äù) rather than producing a null destination.

## Business Rules

### Rule Precedence (Resolved)
Use a strict most-specific-wins hierarchy (highest ‚Üí lowest):
1. Product-specific rule
2. Category-level rule
3. Supplier / receipt-type rule
4. Location default rule
5. System fallback (‚Äúany valid location‚Äù; last resort)

Higher-precedence rules override lower-precedence ones.

### Task Granularity (Resolved)
- **Default:** One receipt line item ‚Üí one putaway task.
- **Optional controlled consolidation:** allowed only when all are true:
  - same `productId`
  - same `suggestedDestinationLocationId`
  - same receipt/session
  - same handling constraints (e.g., lot/expiry/serial constraints)

Explicitly disallowed:
- merging different SKUs
- merging items with different lot/expiry constraints

### Task Atomicity
Task generation for a single receipt is atomic: if any task fails to be created, roll back all tasks for that receipt.

## Data Requirements

### `PutawayTask`
- `taskId` (UUID, PK)
- `sourceReceiptId` (UUID, FK)
- `productId` (UUID, FK)
- `quantity` (Decimal)
- `sourceLocationId` (UUID, FK)
- `suggestedDestinationLocationId` (UUID, FK, nullable only when `status = REQUIRES_LOCATION_SELECTION`)
- `originalSuggestedLocationId` (UUID, FK, nullable)
- `finalSuggestedLocationId` (UUID, FK, nullable)
- `actualDestinationLocationId` (UUID, FK, nullable)
- `fallbackReason` (Enum, nullable): `DESTINATION_FULL`, `UNAVAILABLE`
- `status` (Enum): `UNASSIGNED`, `ASSIGNED`, `IN_PROGRESS`, `COMPLETED`, `CANCELLED`, `REQUIRES_LOCATION_SELECTION`
- `assigneeId` (UUID, nullable)
- `createdAt`, `updatedAt` (timestamps)

### `PutawayRule`
- `ruleId` (UUID, PK)
- `priority` (Integer; lower evaluated first within same precedence tier)
- `criteria` (JSON)
- `destinationLocationId` (UUID)
- `isEnabled` (Boolean)

## Acceptance Criteria

### AC1: Successful Task Generation with Product/Category Rule
- **Given** a category rule routes Category ‚ÄúElectronics‚Äù to `BIN-A1`
- **And** a goods receipt line for 10 units of Product-X (Category ‚ÄúElectronics‚Äù) completes into staging
- **When** put-away tasks are generated
- **Then** a `PutawayTask` is created with `suggestedDestinationLocationId = BIN-A1` and `status = UNASSIGNED`.

### AC2: No Matching Specific Rule Uses Defaults/Fallback
- **Given** no product-specific or category rule matches Product-Y
- **And** a goods receipt for Product-Y completes into staging
- **When** put-away tasks are generated
- **Then** a `PutawayTask` is created with a non-null `suggestedDestinationLocationId` resolved via lower-precedence defaults/system fallback.

### AC3: Destination Unavailable Triggers Auto-Fallback
- **Given** a rule suggests destination `BIN-1`
- **And** `BIN-1` is full/unavailable at generation time
- **When** tasks are generated
- **Then** the task records `originalSuggestedLocationId = BIN-1`
- **And** assigns `finalSuggestedLocationId` to the next-best valid location
- **And** sets `fallbackReason` to `DESTINATION_FULL` or `UNAVAILABLE`.

### AC4: No Valid Location Requires Manual Selection
- **Given** no valid storage location satisfies applicable rules/constraints
- **When** tasks are generated
- **Then** the task is created with `status = REQUIRES_LOCATION_SELECTION`
- **And** a user with permission `SELECT_PUTAWAY_LOCATION` is required to resolve a destination.

### AC5: Shared Pool Self-Claim
- **Given** a task is `UNASSIGNED`
- **When** a Stock Clerk with permission `CLAIM_PUTAWAY_TASK` views available tasks
- **Then** the task is visible and can be claimed.

## Audit & Observability
- **Audit Log:** Create an immutable audit entry for every generated task linking `taskId` to `sourceReceiptId` and the applied rule (if any).
- **Logging:**
  - `INFO`: successful creation of putaway tasks for a receipt.
  - `WARN`: fallback used, manual selection required, or configuration errors.
- **Metrics:**
  - `putaway_tasks_created_total` tagged by outcome (success, fallback, requires_location_selection)
  - `putaway_generation_duration_seconds`

## Open Questions
None.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #32 ‚Äî [BACKEND] [STORY] Putaway: Generate Put-away Tasks from Staging

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Putaway: Generate Put-away Tasks from Staging

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Stock Clerk**, I want put-away tasks generated so that received items are placed into proper storage locations.

## Details
- Rules: default bin by product category, manual destination.
- Tasks list product, qty, from staging, suggested destination.

## Acceptance Criteria
- Put-away tasks created after receipt.
- Suggested destinations provided.
- Tasks assignable.

## Integrations
- Uses storage topology and optional replenishment rules.

## Data / Entities
- PutawayTask, PutawayRule, StorageLocationRef

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #31: [BACKEND] [STORY] Putaway: Execute Put-away Move (Staging ‚Üí Storage)
LABELS: type:story,domain:inventory,status:ready-for-dev,agent:story-authoring,agent:inventory
BODY:
---
**Rewrite Variant:** inventory-flexible
**Clarification Applied:** #229 (handling invalid/full destinations; handling zero on-hand at source)
---

## Story Intent
As a Stock Clerk, I need to execute a confirmed put-away move from a staging area to a final storage location, so that inventory location and on-hand are updated atomically and become available for downstream processes like picking.

## Actors & Stakeholders
- **Stock Clerk (Primary Actor):** Uses mobile scanning to move inventory and record the transaction.
- **Inventory Service (System Actor):** Validates, posts ledger movement, updates task state, and audits.
- **Work Execution (Downstream Stakeholder):** Consumes updated location/on-hand for picking tasks.

## Preconditions
- Stock Clerk is authenticated.
- An active `PutawayTask` exists with status `IN_PROGRESS` or `PENDING_EXECUTION`.
- Physical inventory is present at the staging source location.
- Source and destination locations are scannable and known to the system.

## Functional Behavior

### Happy Path
1. Clerk starts ‚ÄúExecute Put-away Move‚Äù for an active `PutawayTask`.
2. Clerk scans source (staging) location.
3. System validates scanned source matches task source.
4. Clerk scans item/pallet identifier.
5. System validates scanned item matches task.
6. Clerk scans destination storage location.
7. System validates destination type is `STORAGE` and passes SKU compatibility rules.
8. Clerk confirms move summary.
9. System commits an atomic transaction:
   - decrement on-hand at source
   - increment on-hand at destination
   - create immutable ledger entry with transaction type `PUTAWAY`
   - mark `PutawayTask` as `COMPLETED`
   - emit audit entry
10. Clerk sees success.

## Alternate / Error Flows (Resolved)

### A) Destination scanned but invalid for SKU
Examples: zone restriction, hazardous mismatch, temperature class mismatch, unauthorized bin.

**Default behavior (mandatory):**
- Block the putaway transaction.
- Return/display error `LOCATION_NOT_VALID_FOR_SKU`.
- Clerk must choose a different valid location.

**Override (optional, disabled by default):**
- Allowed only with permission `OVERRIDE_LOCATION_COMPATIBILITY`.
- Requires mandatory reason code + free-text justification.
- Emits audit event `PutawayOverrideLocationRule`.

### B) Destination scanned but at full capacity
**Default behavior:**
- Block the putaway to that location.
- Prompt clerk to choose a different valid location or split quantity across multiple locations.

**Optional override:**
- Allowed only if permission `OVERRIDE_LOCATION_CAPACITY` is present.
- Must be within configured overfill tolerance (e.g., 5‚Äì10%).
- Must capture justification.

**Audit requirements if overridden:**
- `previousCapacity`, `newCapacity`, `overrideReasonCode = CAPACITY_OVERRIDE`, `approvedBy`.

### C) Source scanned but system shows zero on-hand
This indicates a data consistency error.

**Default behavior (mandatory):**
- Block the putaway transaction.
- Return/display error `NO_ON_HAND_AT_SOURCE_LOCATION`.
- System must not proceed or silently create inventory.

**Recovery / reconciliation flow (permission-gated):**
1. Initiate cycle count/recount:
   - Permission `INITIATE_CYCLE_COUNT`
   - Creates reconciliation task for the source location.
2. Inventory adjustment (exceptional):
   - Permission `ADJUST_INVENTORY`
   - Requires explicit reason code (e.g., `MISPLACED_STOCK`, `UNRECORDED_RECEIPT`)
   - Requires manager approval if above threshold
   - Adjustment must be completed before putaway proceeds.

Explicitly disallowed:
- proceeding without correcting inventory records
- ‚Äúassume quantity exists‚Äù behavior

## Business Rules
- Put-away moves originate from `STAGING` and end in `STORAGE`.
- On-hand cannot become negative.
- Every inventory movement is recorded in the immutable `InventoryLedger`.
- `PutawayTask` can be `COMPLETED` only after successful ledger commit.

## Data Requirements
- **Ledger entry (create):** transactionId, SKU/productId, quantity, fromLocationId, toLocationId, `transactionType = PUTAWAY`, actorId, timestamp.
- **On-hand update:** decrement `(SKU, fromLocationId)`, increment `(SKU, toLocationId)`.
- **PutawayTask update:** status transitions to `COMPLETED` on success.
- **Override auditing (if enabled):** include override permission used, reason codes, justification, approver.

## Acceptance Criteria

**AC1: Successful Put-away**
- Given a `PutawayTask` is `IN_PROGRESS` for 10 units of `ABC-123` from `STAGING-01` to `A-01-B-03`
- When the clerk scans source, item, destination and confirms
- Then the ledger entry `PUTAWAY` is created and on-hand updates are applied atomically
- And the task is marked `COMPLETED` and audited.

**AC2: Invalid Destination for SKU Blocks Move**
- When destination is not valid for the SKU
- Then the system blocks with `LOCATION_NOT_VALID_FOR_SKU`
- And no ledger/on-hand changes occur.

**AC3: Destination Full Blocks Move (Default)**
- When destination is full
- Then the system blocks and prompts for alternate location or split quantity
- And no ledger/on-hand changes occur.

**AC4: Source Has Zero On-hand Blocks Move**
- When source shows zero on-hand for the item
- Then the system blocks with `NO_ON_HAND_AT_SOURCE_LOCATION`
- And user must initiate reconciliation or approved adjustment before retrying.

## Audit & Observability
- Audit every successful putaway: transactionId, actorId, timestamp, SKU, qty, from/to.
- Log failed validation at `WARN`; transaction failures at `ERROR` with correlation id.
- Metrics for successful putaways and failed attempts.

## Open Questions
None.

## Original Story (Unmodified ‚Äì For Traceability)
## Backend Implementation for Story

**Original Story**: [STORY] Putaway: Execute Put-away Move (Staging ‚Üí Storage)

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Stock Clerk**, I want to execute put-away moves so that inventory becomes available for picking.

## Details
- Scan from/to locations.
- Update ledger with movement PutAway.

## Acceptance Criteria
- Ledger entry created.
- On-hand updated per destination.
- Task marked complete.
- Audited.

## Integrations
- Workexec sees accurate pick locations.

## Data / Entities
- InventoryLedgerEntry(PutAway), PutawayTaskState, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #30: [BACKEND] [STORY] Putaway: Replenish Pick Faces from Backstock (Optional)
LABELS: type:story,domain:inventory,status:needs-review
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:inventory
- status:needs-review

### Recommended
- agent:inventory
- agent:story-authoring

---
**Rewrite Variant:** inventory-flexible
---

## Story Intent
**As an** Inventory Manager,
**I want** the system to automatically generate replenishment tasks for primary picking locations when their stock levels fall below a defined minimum,
**so that** we can proactively move inventory from backstock to ensure parts are always available for mechanics, minimizing order fulfillment delays and preventing stockouts at the point of work.

## Actors & Stakeholders
- **Primary Actor:**
  - **Inventory Service (System):** The automated process responsible for monitoring stock levels and creating replenishment tasks.
- **Key Stakeholders:**
  - **Inventory Manager:** Oversees inventory health and relies on this process to maintain optimal stock levels in picking locations.
  - **Warehouse Associate:** Executes the replenishment tasks generated by the system.
  - **Mechanic / Service Technician:** The end consumer who benefits from consistently stocked pick faces, enabling faster job completion.

## Preconditions
1.  A clear distinction between "Pick Face" (primary picking) and "Backstock" (overflow/storage) location types exists within the system.
2.  `ReplenishmentPolicy` records exist and are associated with specific Item-Location pairs, defining their `minimumQuantity` and `maximumQuantity` thresholds.
3.  The inventory system has real-time, accurate quantity-on-hand data for all items in all defined locations.
4.  The functionality to create and persist a `ReplenishmentPolicy` is already implemented or will be completed as a prerequisite.
5.  An `InventoryDecremented` event is published whenever inventory is reduced in any location.

## Functional Behavior
The system shall provide an automated mechanism to generate inventory replenishment tasks using a hybrid triggering approach.

### Trigger Mechanism (Hybrid Model)

**Primary Trigger: Event-Driven**
- **Trigger:** An `InventoryDecremented` event is received.
- **Conditions:** The replenishment check is triggered **only when**:
  1. The decrement occurs in a **Pick Face** location (`isPickFace = true`), **AND**
  2. The resulting on-hand quantity falls **at or below** the `minimumQuantity` threshold (`onHandQty <= minQty`)
- **Debouncing:** To control system load, implement per-tuple debouncing: `(productId, pickFaceLocationId)` ‚Äì maximum once every 60 seconds.
- **Purpose:** Provides responsive, near-real-time replenishment for active picking operations.

**Secondary Trigger: Scheduled Batch Job**
- **Schedule:** Runs every 5-15 minutes.
- **Purpose:** Acts as a safety net to:
  - Catch missed events
  - Recover from transient failures
  - Reconcile inventory after bulk adjustments
  - Scan all pick faces systematically
- **Process:** Scans all Pick Face locations and evaluates their current inventory against their `ReplenishmentPolicy`.

### Replenishment Process
1.  The system identifies an item in a Pick Face location where the `currentQuantityOnHand` has dropped at or below the `minimumQuantity` specified in its `ReplenishmentPolicy`.
2.  Upon detection, the system calculates the required replenishment quantity: `quantityToMove = maximumQuantity - currentQuantityOnHand`.
3.  The system queries for available stock of the same item in "Backstock" locations using the **deterministic sourcing hierarchy** (see Backstock Sourcing Logic below).
4.  If sufficient backstock is found, the system creates a `ReplenishmentTask` with a `PENDING` status.
5.  The task must contain all necessary information for a warehouse associate to execute the move:
    -   `itemSKU`
    -   `quantityToMove`
    -   `sourceLocationId` (the identified backstock location)
    -   `destinationLocationId` (the pick face location needing replenishment)
    -   `triggerType` (EVENT or BATCH)
    -   `decisionReason` (BELOW_MIN or SAFETY_SCAN)

### Backstock Sourcing Logic (Deterministic Hierarchy)

When selecting which backstock location to source from, the system shall apply the following prioritized rules:

1. **FEFO/FIFO Compliance (if applicable)**
   - If the item is lot-controlled or has expiry tracking:
     - Choose backstock with the **earliest expiry date** (FEFO)
     - If no expiry, use earliest receipt date (FIFO)

2. **Sufficient Quantity**
   - Prefer a **single backstock location** that can fully satisfy the `quantityToMove`

3. **Location Proximity (if topology data exists)**
   - Use lowest layout order: Zone ‚Üí Aisle ‚Üí Rack ‚Üí Bin
   - Prioritize locations physically closer to the destination pick face

4. **Highest On-Hand Quantity**
   - Final deterministic tie-breaker
   - Select the location with the most stock

**Note:** "Any location with sufficient quantity" is used **only** as a last-resort tie-breaker when no other differentiating factors exist. This ensures deterministic, auditable, and repeatable behavior.

## Alternate / Error Flows
- **Insufficient Backstock (Partial Replenishment):** If no single backstock location has sufficient quantity to fully satisfy `quantityToMove`, the system shall:
  - Create **multiple ReplenishmentTasks**, one for each source location
  - Each task follows the same sourcing hierarchy rules
  - Tasks are ordered by priority (FEFO/FIFO first)
  - The sum of all task quantities should equal the required `quantityToMove` (or less if insufficient total backstock)

- **No Backstock:** If there is zero available quantity of the item in any backstock location:
  - No `ReplenishmentTask` is created
  - Log as a `BACKSTOCK_UNAVAILABLE` event
  - Increment metric: `replenishment_backstock.unavailable.count`

- **Existing Open Task:** If a `PENDING` or `IN_PROGRESS` `ReplenishmentTask` already exists for the same item and destination location:
  - The system shall **not** create a duplicate task
  - Log as duplicate prevention event

- **Invalid Policy:** If a `ReplenishmentPolicy` is found where `minimumQuantity >= maximumQuantity`:
  - The system shall log a `POLICY_CONFIGURATION_ERROR`
  - Ignore that policy during evaluation
  - Alert inventory management team

- **Event Processing Failure:** If event-driven trigger fails:
  - The batch job safety net will catch and recover within 5-15 minutes
  - Log the failure for monitoring

## Business Rules
- A replenishment task is only triggered when `currentQuantityOnHand <= minimumQuantity` (at or below threshold).
- The target fill quantity for a replenishment is always the `maximumQuantity` defined in the policy.
- The system must prevent the creation of duplicate, open replenishment tasks for the same item-location pair using idempotency checks.
- Replenishment task creation must be idempotent per `(productId, pickFaceLocationId, thresholdCrossing)`.
- Event-driven triggers are debounced to once per 60 seconds per `(productId, pickFaceLocationId)` tuple.
- Backstock sourcing follows the deterministic hierarchy; random selection is not permitted.

## Data Requirements
### `ReplenishmentTask` (Entity)
| Field | Type | Description | Example |
|---|---|---|---|
| `taskId` | UUID | Unique identifier for the task. | `f47ac10b-58cc-4372-a567-0e02b2c3d479` |
| `itemSKU` | String | The unique identifier of the item to be moved. | `OIL-FILTER-001` |
| `quantity` | Integer | The number of units to move. | `10` |
| `sourceLocationId` | UUID | The ID of the backstock location to pick from. | `loc-bkstk-b2-s3` |
| `destinationLocationId`| UUID | The ID of the pick face location to replenish. | `loc-pick-a1-r2` |
| `status` | Enum | The current state of the task. | `PENDING`, `IN_PROGRESS`, `COMPLETED`, `CANCELLED` |
| `triggerType` | Enum | How this task was triggered. **[CLARIFIED]** | `EVENT`, `BATCH` |
| `decisionReason` | Enum | Why replenishment was needed. **[CLARIFIED]** | `BELOW_MIN`, `SAFETY_SCAN` |
| `sourcingReason` | String | The rule that selected this source location. **[CLARIFIED]** | `FEFO`, `FIFO`, `SUFFICIENT_QTY`, `PROXIMITY`, `HIGHEST_STOCK` |
| `createdAt` | Timestamp | Timestamp of task creation. | `2023-10-27T10:00:00Z` |
| `assignedTo` | UUID | (Optional) The user ID of the assigned associate. | `user-1234` |

### `ReplenishmentPolicy` (Reference Entity)
- `policyId` (UUID)
- `locationId` (UUID) - The ID of the Pick Face location this policy applies to.
- `itemSKU` (String)
- `minimumQuantity` (Integer)
- `maximumQuantity` (Integer)

## Acceptance Criteria
```gherkin
Scenario: Event-driven replenishment task is created when stock drops below minimum
  Given a "Pick Face" location "A1" has a Replenishment Policy for item "SKU-123" with min 5 and max 20
  And the current quantity of "SKU-123" in location "A1" is 6
  And a "Backstock" location "B2" has 50 units of "SKU-123"
  When an InventoryDecremented event reduces the quantity in "A1" to 4
  Then a new ReplenishmentTask must be created within 1 minute
  And the task's quantity must be 16 (20 - 4)
  And the task's source location must be "B2"
  And the task's destination location must be "A1"
  And the task's status must be "PENDING"
  And the task's triggerType must be "EVENT"
  And the task's decisionReason must be "BELOW_MIN"

Scenario: Batch job creates replenishment task during scheduled scan
  Given a "Pick Face" location "A1" has a Replenishment Policy for item "SKU-123" with min 5 and max 20
  And the current quantity of "SKU-123" in location "A1" is 3
  And a "Backstock" location "B2" has 50 units of "SKU-123"
  And the event-driven trigger was missed or failed
  When the scheduled batch replenishment job runs
  Then a new ReplenishmentTask must be created
  And the task's triggerType must be "BATCH"
  And the task's decisionReason must be "SAFETY_SCAN"

Scenario: FEFO backstock sourcing selects earliest expiry
  Given a "Pick Face" location "A1" needs replenishment for item "SKU-123" (expiry-controlled)
  And "Backstock" location "B2" has 30 units with expiry date 2024-06-30
  And "Backstock" location "B3" has 40 units with expiry date 2024-03-15
  When the replenishment evaluation process runs
  Then the task's source location must be "B3" (earliest expiry)
  And the task's sourcingReason must be "FEFO"

Scenario: Sufficient quantity rule prefers single-location fulfillment
  Given a "Pick Face" location "A1" needs 20 units of "SKU-456"
  And "Backstock" location "B2" has 10 units
  And "Backstock" location "B3" has 25 units
  And no expiry/lot control applies
  When the replenishment evaluation process runs
  Then the task's source location must be "B3"
  And the task's sourcingReason must be "SUFFICIENT_QTY"

Scenario: Multiple tasks created for partial replenishment
  Given a "Pick Face" location "A1" has a Replenishment Policy for item "SKU-123" with min 5 and max 20
  And the current quantity of "SKU-123" in location "A1" is 4
  And "Backstock" location "B2" has 10 units of "SKU-123"
  And "Backstock" location "B3" has 8 units of "SKU-123"
  When the replenishment evaluation process runs
  Then 2 ReplenishmentTasks must be created
  And the first task's quantity must be 10 from "B2"
  And the second task's quantity must be 6 from "B3"
  And the total quantity across tasks must be 16

Scenario: No replenishment task when stock is at minimum threshold
  Given a "Pick Face" location "A1" has a Replenishment Policy for item "SKU-123" with min 5 and max 20
  And the current quantity of "SKU-123" in location "A1" is 5
  When the replenishment evaluation process runs
  Then no new ReplenishmentTask should be created for "SKU-123" at location "A1"

Scenario: Event debouncing prevents duplicate tasks
  Given a "Pick Face" location "A1" needs replenishment for "SKU-123"
  When an InventoryDecremented event triggers replenishment at time T
  And another InventoryDecremented event occurs at time T+30 seconds
  Then only 1 ReplenishmentTask is created
  And the second event is debounced

Scenario: No duplicate task created when open task already exists
  Given a "Pick Face" location "A1" has a Replenishment Policy for item "SKU-123" with min 5 and max 20
  And the current quantity of "SKU-123" in location "A1" is 3
  And a "PENDING" ReplenishmentTask already exists for "SKU-123" to location "A1"
  When the replenishment evaluation process runs
  Then no new ReplenishmentTask should be created for "SKU-123" at location "A1"

Scenario: No task created when no backstock is available
  Given a "Pick Face" location "A1" has a Replenishment Policy for item "SKU-123" with min 5 and max 20
  And the current quantity of "SKU-123" in location "A1" is 3
  And there is 0 quantity of "SKU-123" in all backstock locations
  When the replenishment evaluation process runs
  Then no ReplenishmentTask is created
  And a BACKSTOCK_UNAVAILABLE event is logged
  And the metric replenishment_backstock.unavailable.count is incremented
```

## Audit & Observability
- **Audit Log:** The creation of every `ReplenishmentTask` must be recorded in an immutable audit log, including:
  - State of inventory and policy that triggered it
  - `triggerType` (EVENT or BATCH)
  - `decisionReason` (BELOW_MIN or SAFETY_SCAN)
  - `sourcingReason` (which hierarchy rule selected the source location)
  - `occurredAt` timestamp
  - Source backstock location(s) evaluated and selected

- **Events:** A `ReplenishmentTaskCreated` event must be published to a message bus (e.g., Kafka, RabbitMQ) upon successful task creation. The event payload should contain all task details including trigger metadata.

- **Metrics:** The Inventory service should expose metrics for monitoring:
  - `replenishment_tasks.created.count` (counter, tagged by location/item/triggerType)
  - `replenishment_evaluation.duration.ms` (timer, separate tags for event-driven vs batch)
  - `replenishment_backstock.unavailable.count` (counter for when no backstock is found)
  - `replenishment_event.debounced.count` (counter for debounced events)
  - `replenishment_tasks.partial.count` (counter for partial replenishment requiring multiple tasks)
  - `replenishment_sourcing.fefo.count` (counter for FEFO-based selections)
  - `replenishment_sourcing.fifo.count` (counter for FIFO-based selections)
  - `replenishment_batch.scan.duration.ms` (timer for batch job execution)

## Clarification Resolution

**Decision from Issue #228:**

### 1. Triggering Mechanism: **Hybrid Model**

**Primary Trigger:** Event-driven on `InventoryDecremented` events
- Only triggers when:
  - Decrement occurs in a Pick Face location, AND
  - Resulting on-hand ‚â§ minimum threshold
- Debounced to once per 60 seconds per `(productId, pickFaceLocationId)`
- Provides responsive, near-real-time replenishment

**Secondary Trigger:** Scheduled batch job every 5-15 minutes
- Acts as safety net for:
  - Missed events
  - Transient failures
  - Bulk adjustments
  - System reconciliation

**Why Hybrid:**
- Event-driven alone risks missed replenishment due to failures
- Batch alone introduces unacceptable latency
- Hybrid is industry standard for inventory correctness

### 2. Backstock Sourcing Logic: **Deterministic Hierarchy**

The system uses a **prioritized, deterministic hierarchy** (not "any location"):

1. **FEFO/FIFO Compliance** (if item is lot/expiry-controlled)
   - Earliest expiry date (FEFO)
   - Earliest receipt date (FIFO)

2. **Sufficient Quantity**
   - Prefer single backstock location that can fully satisfy the requirement

3. **Location Proximity** (if topology data exists)
   - Lowest layout order (Zone ‚Üí Aisle ‚Üí Rack ‚Üí Bin)

4. **Highest On-Hand Quantity**
   - Final deterministic tie-breaker

**Clarification on "Any Location":**
- "Any location with sufficient quantity" is only used as a **last-resort tie-breaker**
- NOT the primary rule
- Ensures deterministic, auditable, repeatable behavior
- Prevents FEFO/FIFO violations

### 3. Additional Required Behaviors

**Partial Replenishment:**
- If no single location has sufficient quantity, create **multiple tasks**
- Ordered by same sourcing hierarchy

**Idempotency:**
- Tasks are idempotent per `(productId, pickFaceLocationId, thresholdCrossing)`

**Audit Requirements:**
- Record `triggerType`, `sourceBackstockLocationId(s)`, `decisionReason`, `occurredAt`

---

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #30 ‚Äî [BACKEND] [STORY] Putaway: Replenish Pick Faces from Backstock (Optional)

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Putaway: Replenish Pick Faces from Backstock (Optional)

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As an **Inventory Manager**, I want replenishment moves so that pick locations stay stocked.

## Details
- Define min/max for pick bins.
- Create replenishment tasks when below min.

## Acceptance Criteria
- Replenishment tasks created.
- Moves recorded.
- Audited.

## Integrations
- Improves mechanic pick speed; reduces stockouts.

## Data / Entities
- ReplenishmentPolicy, ReplenishmentTask, InventoryLedgerEntry(Transfer)

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #29: [BACKEND] [STORY] Fulfillment: Reserve/Allocate Stock to Workorder Lines
LABELS: type:story,domain:inventory,status:needs-review
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:inventory
- status:needs-review

### Recommended
- agent:inventory
- agent:story-authoring

---
**Rewrite Variant:** inventory-flexible
---

## Story Intent
**Goal:** To ensure parts required for a specific job are available when needed by creating durable reservations for stock items against work order lines.
**Purpose:** This mechanism prevents parts from being sold or used for other jobs, improving service predictability and reducing delays caused by stock unavailability. It formally links inventory state to the work execution lifecycle.

## Actors & Stakeholders
- **System (Primary Actor):** The `Work Execution System`, which initiates reservation requests on behalf of a user action (e.g., approving a work order).
- **System (Owner):** The `Inventory Management System`, which is the system of record for all stock levels, reservations, and allocations. It owns the business logic for this story.
- **Service Advisor (Stakeholder):** Needs visibility into whether parts for a job are secured to communicate confidently with the customer.
- **Parts Manager (Stakeholder):** Manages inventory levels and needs to understand demand from reserved stock to inform purchasing decisions.

## Preconditions
1. A valid, non-cancelled `Work Order` and `Work Order Line` must exist in the Work Execution system.
2. The part number (SKU) referenced by the work order line must exist in the Product/Parts catalog.
3. The `Inventory Management System` is available and can be reached by the `Work Execution System`.

## Functional Behavior

### 1. Create/Update Stock Reservation
- **Trigger:** The `Work Execution System` sends an `UpsertReservationRequest` to the `Inventory Management System`. This request is idempotent, identified by the `WorkOrderLineID`.
- **Process:**
    1. The `Inventory Management System` receives the request, containing the `WorkOrderLineID`, `SKU`, and `RequiredQuantity`.
    2. It validates the request against preconditions.
    3. It checks for an existing `Reservation` for the given `WorkOrderLineID`.
        - If none exists, it creates a new `Reservation` record in a `PENDING` state.
        - If one exists, it proceeds to update the existing reservation.
    4. The system creates `Allocation` records in **SOFT** state by default. SOFT allocations represent intent to use inventory but do **not** reduce ATP and may be reallocated by the system.
    5. The `Reservation` status is updated based on the outcome (e.g., `FULFILLED`, `PARTIALLY_FULFILLED`, `BACKORDERED`).
- **Outcome:** The `Inventory Management System` returns a `ReservationConfirmation` response, detailing the `ReservationID`, status, quantity requested, quantity allocated (SOFT), and quantity backordered.

### 2. Promote Allocation from SOFT to HARD
- **Trigger:** An explicit system or user action occurs:
    1. **Picking/Issuing begins** (e.g., Pick Task started or Parts Issued)
    2. **Workorder status transitions to irreversible execution state** (e.g., `IN_PROGRESS`)
    3. **Explicit user action** with permission (e.g., "Reserve Parts Now")
- **Process:**
    1. The system locates the `Allocation` records associated with the `Reservation`.
    2. It changes the `Allocation` status from `SOFT` to `HARD`.
    3. The system decrements the `ATP` quantity for the SKU by the allocated amount.
    4. An audit event (`AllocationHardened`) is created with reference to the triggering cause.
- **Outcome:** The allocation is now a HARD reservation, protected from reallocation, and ATP is reduced.
- **Permissions:** Converting SOFT ‚Üí HARD requires the `inventory.reserve.hard` permission.

### 3. Cancel Stock Reservation
- **Trigger:** The `Work Execution System` sends a `CancelReservationRequest` when a work order line is cancelled or removed.
- **Process:**
    1. The system locates the `Reservation` associated with the `WorkOrderLineID`.
    2. It changes the `Reservation` status to `CANCELLED`.
    3. It deletes any associated `Allocation` records.
    4. If allocations were in HARD state, the system increments the `ATP` for the SKU by the previously allocated amount.
- **Outcome:** The system confirms the cancellation. The previously reserved stock (if HARD) is now available for other requests.

## Alternate / Error Flows
- **Invalid SKU:** If the SKU in the request does not exist, the system rejects the request with a `SKU_NOT_FOUND` error.
- **Invalid WorkOrderLineID:** If the `WorkOrderLineID` is malformed or invalid, the system rejects the request with an `INVALID_REQUEST` error.
- **Zero or Negative Quantity:** If the `RequiredQuantity` is ‚â§ 0, the system treats it as a cancellation request if a reservation exists, or rejects it as an `INVALID_QUANTITY` error if one does not.
- **Insufficient Stock (SOFT):** If no stock is available when creating SOFT allocations, a `Reservation` is still created but is immediately placed in a `BACKORDERED` state with zero allocations.
- **Insufficient ATP (HARD Promotion):** If attempting to promote to HARD and ATP is insufficient, the promotion fails with an `INSUFFICIENT_ATP` error.

## Business Rules
1. **System of Record:** The `Inventory Management System` is the single source of truth for `ATP`, reservations, and allocations.
2. **Idempotency:** All reservation creation and update operations (upserts) against a `WorkOrderLineID` MUST be idempotent. Sending the same request multiple times must not create duplicate reservations or over-allocate stock.
3. **ATP Calculation:** `ATP` = `Quantity-On-Hand` - `Quantity-Allocated-HARD` (SOFT allocations do NOT reduce ATP).
4. **Allocation States:**
    - **SOFT:** Intent to use inventory. Does NOT reduce ATP. Eligible for reallocation.
    - **HARD:** Committed inventory. REDUCES ATP. Protected from reallocation.
5. **SOFT ‚Üí HARD Transition:** Only occurs via explicit trigger (picking, work start, or user action). Never automatic or time-based.
6. **No Implicit Promotion:** Time-based auto-promotion and implicit promotion based on workorder type are explicitly NOT allowed.
7. **Backorders:** A reservation is considered backordered (or partially backordered) if the allocated quantity is less than the required quantity. This status should be clearly queryable.

## Data Requirements

### Reservation (Entity)
- `ReservationID` (Primary Key, UUID)
- `WorkOrderLineID` (Foreign Key / Reference, Unique)
- `SKU` (string)
- `RequiredQuantity` (integer)
- `AllocatedQuantity` (integer, calculated from Allocations)
- `Status` (enum: `PENDING`, `PARTIALLY_FULFILLED`, `FULFILLED`, `BACKORDERED`, `CANCELLED`)
- `CreatedAt`, `UpdatedAt` (timestamps)

### Allocation (Entity)
- `AllocationID` (Primary Key, UUID)
- `ReservationID` (Foreign Key)
- `LocationID` (Identifier for warehouse/bin where stock resides)
- `AllocatedQuantity` (integer)
- `AllocationState` (enum: `SOFT`, `HARD`) **[CLARIFIED]**
- `Status` (enum: `ALLOCATED`, `PICKED`, `RELEASED`)
- `HardenedAt` (timestamp, nullable - set when promoted to HARD)
- `HardenedBy` (string, nullable - user or system that triggered promotion)
- `HardenedReason` (string, nullable - reason for promotion: PICKING, WORK_START, USER_ACTION)

## Acceptance Criteria

**Scenario 1: Sufficient stock is available for a new SOFT reservation**
- **Given** a work order line requires 5 units of SKU "FLTR-01".
- **And** the `On-Hand` quantity for "FLTR-01" is 10 units.
- **When** the `Work Execution System` requests a reservation for 5 units against the work order line.
- **Then** a new `Reservation` record is created with `Status: FULFILLED`.
- **And** the `AllocatedQuantity` on the reservation is 5.
- **And** `Allocation` records are created with `AllocationState: SOFT`.
- **And** the system's `ATP` for "FLTR-01" remains 10 (SOFT allocations do NOT reduce ATP).
- **And** a confirmation is sent back to the `Work Execution System`.

**Scenario 2: SOFT allocation is promoted to HARD when picking begins**
- **Given** an existing SOFT reservation for 5 units of SKU "FLTR-01".
- **And** the `ATP` for "FLTR-01" is 10 units.
- **When** a Pick Task is started for this work order line.
- **Then** the `Allocation` records are updated with `AllocationState: HARD`.
- **And** the system's `ATP` for "FLTR-01" is reduced to 5.
- **And** an audit event `AllocationHardened` is created with reason "PICKING".

**Scenario 3: HARD promotion fails due to insufficient ATP**
- **Given** an existing SOFT reservation for 5 units of SKU "FLTR-01".
- **And** the `ATP` for "FLTR-01" is only 2 units (other HARD reservations consumed 8 units).
- **When** an attempt is made to promote the allocation to HARD.
- **Then** the promotion fails with error `INSUFFICIENT_ATP`.
- **And** the allocation remains in SOFT state.
- **And** an error is returned to the requesting system.

**Scenario 4: A reservation request is updated with a different quantity**
- **Given** an existing `FULFILLED` SOFT reservation exists for 5 units of SKU "FLTR-01" for a specific work order line.
- **When** the `Work Execution System` sends an update request for the same work order line, now requiring 7 units.
- **Then** the existing `Reservation` is updated.
- **And** its `RequiredQuantity` is updated to 7.
- **And** the `AllocatedQuantity` becomes 7 (if sufficient On-Hand exists).
- **And** the allocations remain SOFT (no ATP impact).

**Scenario 5: An idempotent request is received**
- **Given** a reservation for 5 units of SKU "FLTR-01" has already been successfully created.
- **When** the exact same reservation request is received a second time.
- **Then** no new `Reservation` or `Allocation` records are created.
- **And** the system's `ATP` for "FLTR-01" is not changed.
- **And** the system returns the same successful `ReservationConfirmation` as the first request.

**Scenario 6: A SOFT reservation is cancelled**
- **Given** an existing SOFT reservation for 5 units of SKU "FLTR-01".
- **When** the `Work Execution System` sends a request to cancel the reservation for that work order line.
- **Then** the `Reservation` status is updated to `CANCELLED`.
- **And** the system's `ATP` for "FLTR-01" is unchanged (SOFT allocations don't affect ATP).

**Scenario 7: A HARD reservation is cancelled**
- **Given** an existing HARD reservation for 5 units of SKU "FLTR-01".
- **And** the `ATP` for "FLTR-01" is 10 (reduced from 15 by the HARD allocation).
- **When** the `Work Execution System` sends a request to cancel the reservation for that work order line.
- **Then** the `Reservation` status is updated to `CANCELLED`.
- **And** the system's `ATP` for "FLTR-01" is increased to 15.

## Audit & Observability
- **Audit Trail:** Every state change to a `Reservation` or `Allocation` entity must be recorded in an audit log. This includes creation, status changes (e.g., `PENDING` -> `FULFILLED`), quantity changes, SOFT -> HARD promotion, and cancellations. The log must include the timestamp, the responsible system or user, triggering cause, and the before/after values.
- **Logging:** All incoming API requests and outgoing responses for reservation operations must be logged with correlation IDs for traceability.
- **Metrics:** The system should expose metrics for:
    - Number of active SOFT reservations.
    - Number of active HARD reservations.
    - Total quantity of items on SOFT reservation (by SKU).
    - Total quantity of items on HARD reservation (by SKU).
    - Number of backordered line items.
    - Latency of reservation API endpoints.
    - Number of failed HARD promotions due to insufficient ATP.

## Clarification Resolution

**Decision from Issue #227:**

All allocations are created as **SOFT** by default. A **HARD reservation is created only via an explicit system action** when operational commitment is reached. This explicitly uses **Option C (Manual Promotion)** with the following rules:

- **SOFT allocations** do NOT reduce ATP and may be reallocated
- **HARD reservations** reduce ATP and are protected from reallocation
- **Transition to HARD** occurs only when:
  1. Picking/Issuing begins (Pick Task started or Parts Issued)
  2. Workorder status transitions to irreversible execution state (e.g., `IN_PROGRESS`)
  3. Explicit user action with `inventory.reserve.hard` permission

**What is explicitly NOT allowed:**
- ‚ùå Time-based auto-promotion
- ‚ùå Implicit promotion based on workorder type
- ‚ùå Silent ATP reduction without an event or user/system action

This decision is deterministic, operationally safe, auditable, and extensible for future policy additions.

---

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #29 ‚Äî [BACKEND] [STORY] Fulfillment: Reserve/Allocate Stock to Workorder Lines

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Fulfillment: Reserve/Allocate Stock to Workorder Lines

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **System**, I want to reserve stock for workorder lines so that parts are held for the job.

## Details
- Soft allocation vs hard reservation.
- Handle partial reservations and backorders.

## Acceptance Criteria
- Reservation created/updated.
- ATP reflects allocations.
- Idempotent updates.
- Audited.

## Integrations
- Workexec requests reservation; inventory responds with allocations and pick tasks.

## Data / Entities
- Reservation, Allocation, WorkorderLineRef

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #28: [BACKEND] [STORY] Fulfillment: Create Pick List / Pick Tasks for Workorder
LABELS: type:story,domain:inventory,status:ready-for-dev,agent:story-authoring,agent:inventory
BODY:
**Rewrite Variant:** inventory-flexible

## Story Intent
**As a** Dispatcher,
**I want** the system to automatically generate a deterministic pick list when parts for a work order are confirmed/reserved,
**so that** Mechanics have a clear, efficient, and ordered set of tasks for gathering the correct parts, minimizing errors and accelerating vehicle service preparation.

## Actors & Stakeholders
- **Dispatcher (Primary Actor):** Oversees allocation of work and parts.
- **Mechanic (End User):** Executes the pick tasks.
- **System (Inventory Domain):** System of record for inventory locations, on-hand, and pick list generation.
- **System (Work Execution Domain):** System of record for work order scheduling and SLA/urgency inputs.

## Preconditions
1. A Work Order exists in Work Execution.
2. The Inventory system has reservations for the Work Order‚Äôs required products/quantities.
3. Inventory storage locations have an assigned layout ordering (Zone ‚Üí Aisle ‚Üí Rack ‚Üí Bin).

## Functional Behavior

### Trigger
The process starts when Inventory receives a `WorkOrderPartsReservationConfirmed` event from Work Execution.

**Required trigger inputs** (either on the event or retrievable by Inventory via WorkExec query):
- `workOrderId`
- Reserved line items: `productId`, `quantityRequired`
- Work order SLA/urgency inputs: `workOrderPriority` and one of:
  - `scheduledStartAt` (preferred) and/or
  - `dueAt`

### Happy Path (Success Flow)
1. Inventory validates the trigger payload.
2. Inventory creates a `PickList` associated to `workOrderId`.
3. For each reserved product requirement, Inventory generates **one or more** `PickTask`s (a task is always **one product from one location**):
   - Select the **primary suggested pick location** using the deterministic decision hierarchy in ‚ÄúLocation Suggestion‚Äù.
   - If the primary location cannot fulfill the full `quantityRequired`, create additional `PickTask`s for the remaining quantity using the same deterministic location selection rules.
   - Populate each task with `productId`, `quantityRequired` (for that task), and `suggestedLocationId`.
4. Inventory assigns each `PickTask`:
   - `priority` using ‚ÄúPriority Determination‚Äù
   - `dueAt` using ‚ÄúDue Time Determination‚Äù
5. Inventory assigns `sortOrder` to tasks using the deterministic ‚ÄúSorting Logic‚Äù.
6. Inventory finalizes the `PickList` with status `ReadyToPick`.
7. Inventory publishes `PickListCreated` containing `pickListId` and `workOrderId`.

## Alternate / Error Flows
- **Reserved item has no actionable storage location:**
  - If a reserved product has no eligible location (or location data is incomplete), Inventory creates the corresponding task(s) with `status = NeedsReview`.
  - The `PickList` remains in `Draft` until all tasks are actionable.
  - Emit an operational alert/metric for manual intervention.

- **Invalid trigger event:**
  - If `workOrderId` or reserved lines are missing/invalid, reject the event and route it to a DLQ.
  - Log the validation failure with correlation IDs.

## Business Rules

### Priority Determination (Deterministic)
- **Authority:** Base urgency comes from Work Execution; Inventory may apply **bounded adjustments**.

1. Start with `basePriority = workOrderPriority`.
2. Apply inventory-specific modifiers (each adds **+1** if applicable):
   - **Stock risk:** low on-hand for the product/location selection.
   - **Backorder resolution:** this pick unblocks waiting work.
   - **Critical part type:** safety/immobilizing component.
3. Cap at `MAX_PRIORITY` (configurable) to prevent runaway escalation.

$$
EffectivePriority = \min(basePriority + modifiers,\ MAX\_PRIORITY)
$$

### Due Time Determination (Deterministic)
- Default: `pickDueAt = scheduledStartAt ‚àí pickLeadTimeBuffer`
- Default `pickLeadTimeBuffer`: **30 minutes** (configurable)
- If no `scheduledStartAt`, inherit `pickDueAt = workOrder.dueAt`.
- Inventory must not set a pick due time later than the work order‚Äôs SLA-driven due time.

### Sorting Logic (Route / Location)
- **Decision:** Use a deterministic, layout-aware sort (no route optimization).

Warehouse layout order is:

```
Zone ‚Üí Aisle ‚Üí Rack ‚Üí Bin
```

Each storage location must provide:
- `zoneOrder` (int)
- `aisleOrder` (int or normalized string)
- `rackOrder` (int)
- `binOrder` (int)
- `locationCode` (string)

Stable sorting keys (in order):
1. `zoneOrder ASC`
2. `aisleOrder ASC`
3. `rackOrder ASC`
4. `binOrder ASC`
5. `locationCode ASC` (tie-breaker)

Non-goals (v1): shortest-path optimization, picker-specific routing, dynamic reordering mid-pick.

### Location Suggestion (Single Primary Suggested Location)
When a product exists in multiple locations, select the **primary suggested location** using this strict hierarchy:

1. **Dedicated Pick Zone**
   - If any location has `isPickZone = true` and sufficient on-hand, select it.
2. **FEFO / FIFO compliance**
   - If lot/expiry controlled, select earliest expiry (or earliest receipt date).
3. **Single-location sufficiency**
   - Prefer a single location that can fulfill the full required quantity.
4. **Proximity in layout**
   - Lowest `(zoneOrder, aisleOrder, rackOrder, binOrder)`.
5. **Highest on-hand quantity**
   - Final tie-breaker.

**Partial fulfillment rule:**
- If no single location can fulfill the entire quantity:
  - Suggest the best primary location using the hierarchy above,
  - Create additional `PickTask`s for remaining quantity using the same hierarchy.

Explicit exclusions:
- Do not split picks unnecessarily.
- Do not pick from reserve/bulk locations unless no pick-zone stock exists.

## Data Requirements

### `PickList`
| Field | Type | Description |
|---|---|---|
| `pickListId` | UUID | Primary key |
| `workOrderId` | UUID | Work order reference |
| `status` | Enum | `Draft`, `ReadyToPick`, `InProgress`, ... |
| `createdAt` | Timestamp | Server-generated |

### `PickTask`
| Field | Type | Description |
|---|---|---|
| `pickTaskId` | UUID | Primary key |
| `pickListId` | UUID | Parent pick list |
| `productId` | UUID | Product |
| `quantityRequired` | Integer/Decimal | Quantity for this task |
| `suggestedLocationId` | UUID | Suggested storage location |
| `sortOrder` | Integer | Deterministic order within list |
| `priority` | Integer | Derived priority |
| `dueAt` | Timestamp | Derived due time |
| `status` | Enum | `Pending`, `NeedsReview`, `Picked`, ... |

### `StorageLocation` (required fields for v1)
| Field | Type | Description |
|---|---|---|
| `locationId` | UUID | Primary key |
| `locationCode` | String | Human-readable code |
| `zoneOrder` | Integer | Route sort key |
| `aisleOrder` | String/Integer | Route sort key |
| `rackOrder` | Integer | Route sort key |
| `binOrder` | Integer | Route sort key |
| `isPickZone` | Boolean | Dedicated pick-zone indicator |

## Acceptance Criteria

**Scenario 1: Successful Pick List Generation (single location per product)**
- **Given** a `WorkOrderPartsReservationConfirmed` trigger for a work order with three reserved products.
- **And** each product has at least one eligible location with sufficient on-hand.
- **When** Inventory processes the trigger.
- **Then** a `PickList` is created with status `ReadyToPick`.
- **And** the list contains pick tasks that cover exactly the reserved quantities.
- **And** each task has `priority` and `dueAt` derived from the work order SLA inputs.
- **And** tasks are ordered by the deterministic layout sort.
- **And** a `PickListCreated` event is published.

**Scenario 2: Priority is inherited and modifiers are bounded**
- **Given** a work order with `workOrderPriority = P`.
- **And** a reserved product qualifies for exactly one modifier (e.g., stock risk).
- **When** tasks are created.
- **Then** the task `priority = min(P + 1, MAX_PRIORITY)`.

**Scenario 3: Due time derived from scheduled start**
- **Given** a work order with `scheduledStartAt = T`.
- **When** tasks are created.
- **Then** each task `dueAt = T ‚àí pickLeadTimeBuffer`.

**Scenario 4: Location suggestion prefers pick zone**
- **Given** a product is available in two locations.
- **And** one location is `isPickZone = true` with sufficient quantity.
- **When** selecting the primary suggested location.
- **Then** the pick-zone location is selected.

**Scenario 5: Partial fulfillment creates multiple tasks**
- **Given** a product requires quantity 10.
- **And** no single location has 10 on-hand.
- **When** Inventory generates tasks.
- **Then** Inventory creates multiple `PickTask`s that sum to 10.
- **And** the first task uses the primary suggested location per the deterministic hierarchy.

**Scenario 6: Missing location data triggers NeedsReview**
- **Given** a reserved product has no eligible/actionable location.
- **When** Inventory generates tasks.
- **Then** the task is created with `status = NeedsReview`.
- **And** the `PickList` remains in `Draft`.

## Audit & Observability
- **Audit trail:** Log `PickList` creation and state changes with `workOrderId`, `pickListId`, timestamps, and correlation IDs.
- **Metrics:**
  - `picklists_created_total`
  - `pick_tasks_created_total`
  - `picklist_generation_duration_seconds`
  - `pick_tasks_needs_review_total`
- **Events:** Publish `PickListCreated` when a list is finalized to `ReadyToPick`.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #28 ‚Äî [BACKEND] [STORY] Fulfillment: Create Pick List / Pick Tasks for Workorder

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Fulfillment: Create Pick List / Pick Tasks for Workorder

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Dispatcher**, I want a pick list so that mechanics know what to pull for a workorder.

## Details
- Pick tasks include product, qty, suggested storage locations, priority, and due time.

## Acceptance Criteria
- Pick tasks generated when reservation confirmed.
- Sorted by route/location.
- Printable or mobile view.

## Integrations
- Workexec provides workorder context; shopmgr may surface to mechanics.

## Data / Entities
- PickTask, PickList, RouteHint

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #27: [BACKEND] [STORY] Counts: Execute Cycle Count and Record Variances
LABELS: type:story,domain:inventory,status:ready-for-dev,agent:story-authoring,agent:inventory
BODY:
**Rewrite Variant:** inventory-flexible

## Story Intent
**As an** Auditor,
**I want** to record a blind physical count for a cycle count task and (when needed) perform bounded recounts,
**so that** the system can compute variances against expected quantities with a complete, immutable audit trail and escalate unresolved discrepancies for investigation.

## Actors & Stakeholders
- **Auditor (Primary Actor):** Performs the physical count and submits results.
- **Inventory Manager (Stakeholder):** Reviews variances, triggers recounts beyond the auditor‚Äôs allowance, approves exceptions, and oversees investigations.
- **System (Inventory Domain):** Owns tasks, expected quantity, variance calculation, recount workflow state, and audit trail.
- **Accounting (Downstream Consumer, future):** May consume variance/adjustment signals.

## Preconditions
1. An active `CycleCountTask` exists for a specific product and storage location/bin.
2. The system has an `expectedQuantity` for that product at that location (not shown to the auditor during counting).
3. The Auditor is authenticated and authorized to execute cycle count tasks.

## Functional Behavior

### Happy Path (Initial Count)
1. Auditor selects an active `CycleCountTask` from their assigned list.
2. System displays task details (location/bin, product/SKU, description) but **does not** display `expectedQuantity` (blind count).
3. Auditor counts physical items in the specified bin.
4. Auditor submits `actualQuantity`.
5. System validates `actualQuantity` (non-negative numeric; precision consistent with the item‚Äôs UOM rules).
6. System creates an immutable `CountEntry` (sequence 1).
7. System calculates `variance = actualQuantity - expectedQuantity`.
8. System updates `CycleCountTask` status to `COUNTED_PENDING_REVIEW` (or equivalent) and references the latest `CountEntry`.

### Recount Flow (Bounded)
Recounts are supported for auditability and error correction.

#### Recount persistence rules (mandatory)
- Every recount creates a **new** immutable `CountEntry`.
- Recount entries must reference the prior count via:
  - `recountOfCountEntryId`
  - `recountSequenceNumber` (1, 2, 3‚Ä¶)
- Overwriting or updating prior entries is not allowed.

#### Who can trigger recounts
- **Auditor** may trigger **one immediate recount**:
  - only before manager approval/finalization,
  - intended to correct obvious mistakes.
- **Inventory Manager (or higher)** may trigger recounts:
  - after review,
  - after variance threshold breach,
  - as part of approval workflow.

#### Recount limits
- Hard cap per `CycleCountTask`: **3 total counts** (original count + up to **2 recounts**).
- When the cap is reached, the system blocks further recounts and routes the task to investigation.

## Alternate / Error Flows
- **Invalid quantity submitted:** reject and return a validation error (e.g., ‚ÄúQuantity must be zero or a positive number‚Äù).
- **Unauthorized recount attempt:** reject with access denied (auditor attempting a second recount; non-manager attempting manager-level recount).
- **Recount cap exceeded:**
  - System blocks further recounts.
  - System sets task status to `REQUIRES_INVESTIGATION`.
  - System requires manager sign-off and a required ‚Äúroot cause note‚Äù (e.g., damage, theft, system error, supplier issue) before proceeding to any adjustment flow.

## Business Rules
- `variance = actualQuantity - expectedQuantity`.
- Positive variance = surplus; negative variance = shortage; zero = match.
- All `CountEntry` records are immutable.
- Blind count: `expectedQuantity` is never shown during count entry.

### Permissions (as decided)
- `TRIGGER_RECOUNT_SELF` ‚Äî Auditor (limited to one immediate recount).
- `TRIGGER_RECOUNT_ANY` ‚Äî Inventory Manager+.

## Data Requirements

### `CountEntry` (new entity)
| Field | Type | Description |
|---|---|---|
| `countEntryId` | UUID | Primary key |
| `cycleCountTaskId` | UUID | Parent task |
| `auditorId` | UUID | Who performed the count |
| `actualQuantity` | Integer/Decimal | Non-negative |
| `expectedQuantity` | Integer/Decimal | Stored for audit (not displayed during entry) |
| `variance` | Integer/Decimal | `actual - expected` |
| `countedAt` | Timestamp | Server-generated |
| `recountSequenceNumber` | Integer | 1 for initial count, increments per recount |
| `recountOfCountEntryId` | UUID (nullable) | Prior count entry reference |

### `CycleCountTask` (state + pointers)
| Field | Type | Description |
|---|---|---|
| `status` | Enum | Must include `COUNTED_PENDING_REVIEW` and `REQUIRES_INVESTIGATION` |
| `latestCountEntryId` | UUID | Pointer to latest count entry |
| `totalCountEntries` | Integer | Used to enforce cap |

## Acceptance Criteria

**AC1: Initial count creates immutable entry and computes variance**
- Given a `CycleCountTask` with `expectedQuantity = 100`
- When Auditor submits `actualQuantity = 102`
- Then system creates a new `CountEntry` (sequence 1) and stores `variance = +2`
- And task status becomes `COUNTED_PENDING_REVIEW`.

**AC2: Recount creates a new entry referencing prior**
- Given a task has an initial `CountEntry`
- When a recount is triggered and submitted
- Then system creates a new `CountEntry` with `recountOfCountEntryId` pointing to the prior entry
- And increments `recountSequenceNumber`.

**AC3: Auditor may trigger only one immediate recount**
- Given an auditor has already triggered one recount for a task
- When the auditor attempts to trigger a second recount
- Then the system rejects the request as unauthorized.

**AC4: Manager can trigger recounts beyond auditor allowance (until cap)**
- Given a task has an initial count and one auditor recount
- When a manager triggers another recount
- Then the system allows it (subject to cap) and records a new `CountEntry`.

**AC5: Cap enforcement and investigation escalation**
- Given a task already has 3 total `CountEntry` records
- When any user attempts to trigger another recount
- Then the system blocks the recount
- And sets task status to `REQUIRES_INVESTIGATION`.

**AC6: Invalid input rejected**
- Given an auditor is counting
- When they submit a negative quantity
- Then the system rejects with a validation error.

## Audit & Observability
- **Audit trail:** Every `CountEntry` creation must be logged immutably with `countEntryId`, `cycleCountTaskId`, `auditorId`, `actualQuantity`, `expectedQuantity`, `variance`, `recountSequenceNumber`, `recountOfCountEntryId`, and timestamp.
- **Metrics:**
  - `cycle_counts_submitted_total`
  - `cycle_counts_recounts_total`
  - `cycle_counts_requires_investigation_total`
  - `cycle_count_submission_duration_seconds`
- **Event publishing (future-safe design):** For non-zero variance, design to emit `InventoryVarianceDetected` including item/product ID, location, variance quantity, and reference to `CountEntry`.

## Original Story (Unmodified ‚Äì For Traceability)
## Backend Implementation for Story

**Original Story**: [STORY] Counts: Execute Cycle Count and Record Variances

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As an **Auditor**, I want to record counted quantities so that variances can be reviewed and corrected.

## Details
- Count tasks per bin.
- Record counts; optional recount.
- Variance report generated.

## Acceptance Criteria
- Counts recorded.
- Variance computed.
- Recount supported (basic).
- Audited.

## Integrations
- May later emit accounting adjustment events.

## Data / Entities
- CycleCountTask, CountEntry, VarianceReport, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #26: [BACKEND] [STORY] Counts: Approve and Post Adjustments from Cycle Count
LABELS: type:story,domain:inventory,status:ready-for-dev,agent:story-authoring,agent:inventory
BODY:
**Rewrite Variant:** inventory-flexible

## Story Intent
**As an** Inventory Manager,
**I want** a policy-driven approval workflow for inventory adjustments produced by cycle counts,
**so that** material inventory changes are reviewed and authorized while low-risk variances can be posted quickly, with full auditability and accounting visibility.

## Actors & Stakeholders
- **Inventory Manager:** Reviews/approves/rejects adjustments in approval tiers.
- **Director / Inventory Controller (Tier-2 Approver):** Approves high-risk adjustments.
- **System (Inventory Domain):** Evaluates policy thresholds, routes approvals, posts ledger entries, and updates on-hand.
- **Accounting (Downstream Consumer, future):** Consumes adjustment signals for shrink/gain reporting.

## Preconditions
1. A cycle count is completed and variance(s) are computed (see story #27).
2. An `InventoryAdjustment` is created for each variance (proposed adjustment).
3. Approver roles/permissions and threshold policies are configured.
4. User is authenticated.

## Functional Behavior

### Adjustment evaluation (policy-driven)
When an `InventoryAdjustment` is created, the system computes:
- `unitVariance = |varianceQty|`
- `valueVariance = |varianceQty √ó unitCost|`
- `percentVariance = |varianceQty| / max(onHandQty, 1)`

Then evaluates whether approval is required:

```
approvalRequired =
  unitVariance >= unitThreshold
  OR valueVariance >= valueThreshold
  OR percentVariance >= percentThreshold
```

### Below-threshold behavior (auto-approve)
- If `approvalRequired = false`:
  1. System sets adjustment status to `AUTO_APPROVED`.
  2. System immediately posts the adjustment:
     - creates an immutable `InventoryLedgerEntry` with type `ADJUST_CYCLE_COUNT`
     - updates `quantityOnHand`
  3. System emits `InventoryAdjustmentAutoApproved` (and/or `InventoryAdjustmentPosted`) via outbox.
- Auto-approval must still be fully auditable (actor, timestamps, values, policy version).

### Above-threshold behavior (manual approval)
- If `approvalRequired = true`:
  1. System sets adjustment status to `PENDING_APPROVAL`.
  2. System determines the required approval tier based on configured policy.
  3. System places the adjustment into the approval queue for authorized approvers.

### Approval tiers (two-tier launch model)
**Tier 1 ‚Äì Manager**
- Approves adjustments above auto-approval threshold up to the Tier-2 threshold.

**Tier 2 ‚Äì Director / Inventory Controller**
- Required for high-risk adjustments (e.g., `valueVariance > $1,000` or `percentVariance > 25%`, per policy).

Tiers and thresholds are configurable (policy-driven; not hard-coded).

### Approval actions
- **Approve** (authorized approver):
  - set status `POSTED`
  - create immutable `InventoryLedgerEntry (ADJUST_CYCLE_COUNT)`
  - update `quantityOnHand`
  - emit `InventoryAdjustmentPosted`
- **Reject** (authorized approver):
  - set status `REJECTED`
  - require `rejectionReason`
  - do not change on-hand; do not create ledger entry

## Alternate / Error Flows
- **Unauthorized approval attempt:** reject with access denied; status unchanged.
- **Stock item not found / inactive at posting:** fail posting, set status `FAILED`, record error details.
- **Concurrent modification:** posting must be transactional; ledger entry creation + on-hand update succeed or fail together.

## Business Rules
- Composite approval thresholds are evaluated as: **units OR value OR percent**.
- Below-threshold adjustments are auto-approved and posted.
- Above-threshold adjustments require manual approval with the correct tier.
- Posted/rejected adjustments are immutable; corrections occur via a new adjustment.
- All state transitions must be auditable.

## Notification Mechanism
**Required (v1):**
- In-app notification center badge/count for pending approvals.
- Approval dashboard/queue widget (filterable by location, SKU, variance, aging).

**Optional (configurable):**
- Email digest/escalation if pending longer than X minutes (e.g., 30‚Äì60 minutes), to avoid per-item spam.

## Data Requirements

### `InventoryAdjustment`
| Field | Type | Description |
|---|---|---|
| `adjustmentId` | UUID | Primary key |
| `stockItemId` | UUID | Stock item |
| `reasonCodeId` | UUID | Reason code (cycle count shrink/gain) |
| `varianceQty` | Integer/Decimal | Quantity variance (positive/negative) |
| `unitCost` | Money/Decimal | Cost at time of adjustment |
| `onHandQtyAtProposal` | Integer/Decimal | Used for percent variance |
| `unitVariance` | Integer/Decimal | Derived |
| `valueVariance` | Money/Decimal | Derived |
| `percentVariance` | Decimal | Derived |
| `status` | Enum | `PENDING_APPROVAL`, `AUTO_APPROVED`, `POSTED`, `REJECTED`, `FAILED` |
| `requiredApprovalTier` | Enum | `TIER_1_MANAGER`, `TIER_2_DIRECTOR` |
| `policyVersion` | String | Threshold policy version applied |
| `createdByUserId` | UUID | Who initiated |
| `approvedByUserId` | UUID (nullable) | Approver identity |
| `rejectionReason` | String (nullable) | Required on reject |
| `createdAt`, `updatedAt` | Timestamp | Server-generated |

### `InventoryLedgerEntry`
| Field | Type | Description |
|---|---|---|
| `ledgerEntryId` | UUID | Primary key |
| `stockItemId` | UUID | Stock item |
| `adjustmentId` | UUID | Source adjustment |
| `type` | Enum | `ADJUST_CYCLE_COUNT` |
| `changeInQuantity` | Integer/Decimal | Posted change |
| `quantityAfter` | Integer/Decimal | New on-hand |
| `postedAt` | Timestamp | Post timestamp |

## Acceptance Criteria

**AC1: Composite threshold triggers approval**
- Given thresholds configured for units, value, and percent
- When an adjustment is proposed
- Then `approvalRequired` is true if any threshold is exceeded.

**AC2: Below-threshold auto-approves and posts**
- Given an adjustment that does not exceed any threshold
- When it is evaluated
- Then status becomes `AUTO_APPROVED`
- And a ledger entry is created and on-hand is updated
- And `InventoryAdjustmentAutoApproved` is emitted.

**AC3: Above-threshold routes to correct tier**
- Given an adjustment above auto-approval threshold
- When it is evaluated
- Then status becomes `PENDING_APPROVAL`
- And `requiredApprovalTier` is set according to policy
- And the adjustment appears in the approval queue.

**AC4: Tiered approval posts adjustment**
- Given an adjustment is `PENDING_APPROVAL`
- And an authorized approver for the required tier approves
- Then status becomes `POSTED`
- And a ledger entry is created and on-hand is updated
- And `InventoryAdjustmentPosted` is emitted.

**AC5: Rejection requires reason and does not post**
- Given an adjustment is `PENDING_APPROVAL`
- When an authorized approver rejects with a reason
- Then status becomes `REJECTED`
- And no ledger entry is created and on-hand is unchanged.

**AC6: Notifications appear for pending approvals**
- Given an adjustment enters `PENDING_APPROVAL`
- Then in-app notification and dashboard queue reflect the pending item.

## Audit & Observability
- Audit all state transitions (created, auto-approved, approved, rejected, posted, failed) with actor, timestamps, values, and policy version.
- Metrics:
  - `inventory_adjustments_pending_approval_count`
  - `inventory_adjustments_posted_total` (tagged by reason + direction)
  - `inventory_adjustments_auto_approved_total`
  - `inventory_adjustments_requires_tier2_total`

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #26 ‚Äî [BACKEND] [STORY] Counts: Approve and Post Adjustments from Cycle Count

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Counts: Approve and Post Adjustments from Cycle Count

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As an **Inventory Manager**, I want approvals before posting adjustments so that shrink and corrections are controlled.

## Details
- Approval required above thresholds.
- Posting creates Adjust ledger entries and updates on-hand.

## Acceptance Criteria
- Adjustments require permission.
- Ledger entries posted.
- Thresholds enforced.
- Full audit trail.

## Integrations
- Optional accounting events for shrink/adjustment.

## Data / Entities
- InventoryLedgerEntry(Adjust), ApprovalRecord, ReasonCode, EventOutbox

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #25: [BACKEND] [STORY] Allocations: Handle Shortages with Backorder or Substitution Suggestion
LABELS: type:story,domain:inventory,status:ready-for-dev
BODY:
## Story Intent
**As a** Service Advisor,
**I want** the system to automatically present actionable solutions like backorders, approved substitutions, or external availability when a requested part is out of stock,
**so that** I can make an immediate, informed decision to prevent work stoppage and keep the customer informed.

## Actors & Stakeholders
- **Service Advisor (User):** The primary actor who receives shortage information and makes a decision on how to proceed.
- **System (Inventory Service):** The automated actor responsible for detecting shortages, querying other domains for solutions, and presenting them.
- **Stakeholders:**
    - **Product Domain:** Provides the rules and data for part substitutions.
    - **Positivity Domain:** Provides data on external part availability.
    - **Work Execution Domain:** Consumes the outcome of the decision to update the work order and estimate.
    - **Auditing System:** Records the decision for traceability.

## Preconditions
1.  A Service Advisor is attempting to allocate a specific part (by SKU/Part Number) to a work order.
2.  The Inventory system has been configured with location-specific stock levels.
3.  The system has determined that the Available-to-Promise (ATP) quantity for the requested part at the primary location is less than the requested quantity.

## Functional Behavior
1.  **Trigger:** An allocation request is made for a part where `requested_quantity > atp_quantity`.
2.  The system flags an internal **Shortage Event** for the requested part and quantity.
3.  Upon detecting the shortage, the system orchestrates the following lookups in parallel:
    a. **Internal Backorder Option:** The system calculates its own internal backorder feasibility (this is the default fallback option).
    b. **Substitution Lookup:** The system sends a request to the **Product Domain** service with the original part SKU to retrieve a list of approved substitute parts.
    c. **External Availability Lookup:** The system sends a request to the **Positivity Domain** service with the original part SKU to check for availability from external suppliers.
4.  The system aggregates the responses from all lookups.
5.  The system returns a structured response to the Point of Sale (POS) client containing all available options, presented in the following **deterministic order**:
    - **Option 1: Substitute parts** (if available)
    - **Option 2: External availability** (if available)
    - **Option 3: Backorder** the original part (always available as fallback)
6.  The Service Advisor selects one of the presented options.
7.  The system captures the Service Advisor's decision, linking it to the original allocation request and work order.
8.  The system emits an event (e.g., `PartShortageResolvedEvent`) containing the original request, the decision made, and the resulting action (e.g., create backorder, update work order with new part SKU).

## Alternate / Error Flows
- **No Substitutes or External Availability:** If both the Product and Positivity services return no viable options, the system's response will only contain the "Backorder" option.
- **Integration Partner Timeout/Error:** 
  - If a request to the **Product Domain** exceeds **800 ms**, the system will proceed without substitute data.
  - If a request to the **Positivity Domain** exceeds **1200 ms**, the system will proceed without external availability data.
  - The system shall **not** fail the entire operation due to dependent service failures.
  - Timeouts and failures will be logged, and the user will be presented with the remaining valid options.
  - A banner message shall be displayed: _"Some availability options could not be retrieved at this time."_
- **User Cancels/Aborts:** If the Service Advisor cancels the operation without making a choice, the part allocation on the work order remains in a "pending allocation" or "shortage" state. No decision is recorded.

## Business Rules
- A part is considered in shortage if the quantity requested for immediate allocation exceeds the current Available-to-Promise (ATP) quantity.
- All substitute parts suggested MUST be from the authoritative list provided by the Product Domain. This system does not define its own substitution rules.
- The default action if no other option is available or chosen is to place the original part on backorder.
- **Decision Hierarchy (Option Presentation Order):**
  - Shortage resolution options are presented in this deterministic order:
    1. **Substitute parts** (preserves service continuity with minimal delay)
    2. **External availability** (maintains original spec but may add logistics cost)
    3. **Backorder** (least desirable operationally, always shown as fallback)
  - Within each option category, options are ranked by:
    1. **Availability / Lead Time ASC** (fastest first)
    2. **Total Cost Impact ASC** (price difference + handling)
    3. **Quality Tier DESC** (OEM > Equivalent > Aftermarket)
    4. **Brand Preference** (customer or shop preference, optional)
  - Configuration: `shortageDecisionOrder = [SUBSTITUTE, EXTERNAL, BACKORDER]` (default), with per-location override allowed.
- **Error Handling Policy:**
  - Product Domain timeout threshold: **800 ms**
  - Positivity Domain timeout threshold: **1200 ms**
  - No synchronous retries; background refresh allowed for UI updates.
  - Degradation: Omit failed option category, present remaining options with informational banner.
- **Backorder Lead Time Sourcing:**
  - Use tiered fallback model for `estimatedLeadTimeDays`:
    1. **Purchasing / Supplier domain** (if integrated) ‚Äî authoritative
    2. **Inventory domain replenishment estimate** ‚Äî preferred default
    3. **Product catalog static lead-time hint** ‚Äî last resort
  - Lead time must always include `source` and `confidence` fields.
  - If no source exists, omit the backorder option rather than fabricating a lead time.

## Data Requirements

### API Response Structure
The API response for a shortage event must be a structured object containing a list of `ResolutionOption`.

```json
{
  "originalRequest": {
    "partSku": "OEM-12345",
    "requestedQuantity": 2,
    "workOrderId": "WO-9876"
  },
  "shortageDetails": {
    "shortfallQuantity": 2
  },
  "resolutionOptions": [
    {
      "type": "SUBSTITUTE",
      "partSku": "SUB-67890",
      "partName": "Premium Alternative Filter",
      "availableQuantity": 5,
      "substituteInfo": {
        "substituteProductId": "UUID-v7",
        "qualityTier": "OEM",
        "brand": "ACDelco",
        "fitmentConfidence": "HIGH",
        "priceDifference": {
          "amount": 5.00,
          "currency": "USD"
        },
        "notes": "Recommended OEM equivalent"
      }
    },
    {
      "type": "EXTERNAL_PURCHASE",
      "partSku": "OEM-12345",
      "externalInfo": {
        "sourceId": "supplier-partscorp-001",
        "sourceType": "SUPPLIER",
        "availableQuantity": 4,
        "estimatedLeadTimeDays": 1,
        "additionalCost": {
          "amount": 35.00,
          "currency": "USD"
        },
        "confidence": "HIGH"
      }
    },
    {
      "type": "BACKORDER",
      "partSku": "OEM-12345",
      "backorderInfo": {
        "estimatedLeadTimeDays": 5,
        "source": "PURCHASING",
        "confidence": "MEDIUM"
      }
    }
  ]
}
```

### Product Domain Integration (Substitutes)

**Endpoint:** `POST /product/v1/substitutes:resolve`

**Request Schema:**
```json
{
  "items": [
    {
      "productId": "UUIDv7",
      "quantity": 2,
      "context": {
        "vehicleAttributes": {
          "make": "Ford",
          "model": "F-150",
          "year": 2022
        },
        "locationId": "UUIDv7"
      }
    }
  ],
  "includePricing": true
}
```

**Response Schema:**
```json
{
  "results": [
    {
      "productId": "UUIDv7",
      "substitutes": [
        {
          "substituteProductId": "UUIDv7",
          "qualityTier": "OEM | EQUIVALENT | AFTERMARKET",
          "brand": "string",
          "fitmentConfidence": "HIGH | MEDIUM | LOW",
          "priceDifference": {
            "amount": 12.50,
            "currency": "USD"
          },
          "notes": "string"
        }
      ]
    }
  ]
}
```

**Guarantees:**
- Product domain does **not** guarantee availability.
- Fitment confidence must be explicit.
- Supports batch requests.

### Positivity Domain Integration (External Availability)

**Endpoint:** `POST /positivity/v1/availability/external`

**Request Schema:**
```json
{
  "items": [
    {
      "productId": "UUIDv7",
      "quantity": 2,
      "deliveryLocationId": "UUIDv7"
    }
  ]
}
```

**Response Schema:**
```json
{
  "results": [
    {
      "productId": "UUIDv7",
      "sources": [
        {
          "sourceId": "string",
          "sourceType": "SUPPLIER | PARTNER_SHOP",
          "availableQuantity": 4,
          "estimatedLeadTimeDays": 1,
          "additionalCost": {
            "amount": 35.00,
            "currency": "USD"
          },
          "confidence": "HIGH | MEDIUM | LOW"
        }
      ]
    }
  ]
}
```

**Definition of External Availability:**
An option is considered externally available if it includes:
- A third-party source identifier
- Non-zero available quantity
- A lead-time estimate

**Guarantees:**
- Supports batch requests.

## Acceptance Criteria
**Scenario 1: Shortage with both Substitute and External options available**
- **Given** a part with SKU "ABC-101" has an ATP of 0
- **And** a Service Advisor requests to allocate a quantity of 1 of "ABC-101"
- **And** the Product domain has an approved substitute "XYZ-202"
- **And** the Positivity domain indicates "ABC-101" is available from an external supplier
- **When** the system processes the allocation request
- **Then** it must return a response containing three options in this order:
    1. Substitution with "XYZ-202"
    2. External purchase of "ABC-101"
    3. Backorder for "ABC-101"

**Scenario 2: Shortage with only a Substitute option available**
- **Given** a part with SKU "DEF-303" has an ATP of 1
- **And** a Service Advisor requests to allocate a quantity of 2 of "DEF-303"
- **And** the Product domain has an approved substitute "UVW-404"
- **And** the Positivity domain indicates no external availability
- **When** the system processes the allocation request
- **Then** it must return a response containing two options in this order:
    1. Substitution with "UVW-404"
    2. Backorder for "DEF-303"

**Scenario 3: Shortage with no alternative options**
- **Given** a part with SKU "GHI-505" has an ATP of 0
- **And** a Service Advisor requests to allocate a quantity of 1 of "GHI-505"
- **And** the Product domain has no approved substitutes
- **And** the Positivity domain indicates no external availability
- **When** the system processes the allocation request
- **Then** it must return a response containing only the "Backorder for GHI-505" option.

**Scenario 4: Integration Partner Fails**
- **Given** a part with SKU "JKL-606" has an ATP of 0
- **And** a Service Advisor requests to allocate a quantity of 1 of "JKL-606"
- **And** the request to the Product domain service times out (exceeds 800ms)
- **And** the Positivity domain responds with external availability
- **When** the system processes the allocation request
- **Then** it must log the timeout error for the Product service
- **And** it must display the banner: "Some availability options could not be retrieved at this time."
- **And** it must return a response containing two options in this order:
    1. External purchase of "JKL-606"
    2. Backorder for "JKL-606"

**Scenario 5: Option Ranking within Category**
- **Given** a part with SKU "MNO-707" has an ATP of 0
- **And** the Product domain returns three substitute options with varying lead times and costs
- **When** the system processes the allocation request
- **Then** substitutes must be sorted by:
    1. Lead time (ascending)
    2. Total cost impact (ascending)
    3. Quality tier (descending: OEM > EQUIVALENT > AFTERMARKET)

**Scenario 6: Backorder with Lead Time Source**
- **Given** a part with SKU "PQR-808" has an ATP of 0
- **And** no substitutes or external options are available
- **When** the system presents the backorder option
- **Then** the response must include `estimatedLeadTimeDays`, `source`, and `confidence` fields
- **And** if no lead time source exists, the backorder option must be omitted (no fabricated lead time)

## Audit & Observability
- **Audit Log:** Every decision made by the Service Advisor (Backorder, Substitute, External Purchase) must be logged as an immutable audit event. The event must include:
    - `workOrderId`
    - `originalPartSku`
    - `decisionType` (e.g., `SUBSTITUTE`)
    - `resultingPartSku` (if different)
    - `userId` of the Service Advisor
    - `timestamp`
- **Metrics:** The system should expose metrics for:
    - Number of shortage events triggered.
    - Latency of dependent service calls (Product, Positivity).
    - Count of each resolution type chosen by users.
    - Timeout/failure rate for dependent services.
- **Logging:** Log errors and timeouts for all external API calls to dependent domains.

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #25 ‚Äî [BACKEND] [STORY] Allocations: Handle Shortages with Backorder or Substitution Suggestion

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Allocations: Handle Shortages with Backorder or Substitution Suggestion

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Service Advisor**, I want shortage handling so that work proceeds with backorders or approved substitutes.

## Details
- If ATP insufficient: propose external availability or substitute options.
- Link to product substitution rules.

## Acceptance Criteria
- Shortage flagged.
- Suggested actions returned.
- Decision captured and auditable.

## Integrations
- Product provides substitution/pricing; Positivity provides external availability; workexec updates estimate/WO.

## Data / Entities
- ShortageFlag, SubstituteSuggestion, ExternalAvailabilityRef

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #24: [BACKEND] [STORY] Allocations: Reallocate Reserved Stock When Schedule Changes
LABELS: type:story,domain:inventory,status:ready-for-dev,agent:story-authoring,agent:inventory
BODY:
**Rewrite Variant:** inventory-flexible

## Story Intent
**As a** Dispatcher,
**I want** the system to deterministically re-evaluate and reassign reserved stock when a work order‚Äôs schedule, priority, or ‚Äúwaiting on inventory‚Äù status changes,
**so that** limited inventory is allocated fairly to urgent jobs without starving lower-priority work, and allocations remain auditable and explainable.

## Actors & Stakeholders
- **Dispatcher:** Relies on accurate reservations aligned to priority and schedule.
- **System (Inventory Domain):** Owns reservations/allocations and executes reallocation.
- **System (Work Execution):** Source of base priority and lifecycle changes (e.g., completed/cancelled).
- **System (Shop Management):** Source of scheduling/due-time updates.

## Preconditions
1. Work orders exist with base priority and schedule fields.
2. One or more work orders require the same finite-stock item.
3. Inventory has existing `Allocation` records reserving quantities against work orders.
4. Work orders may be blocked waiting on inventory (`waitingSince` semantics).

## Functional Behavior

### Reallocation triggers
Reallocation is triggered when Inventory receives any of the following signals:
- **Schedule Change** (from Shop Management): due time and/or schedule start time changes.
- **Priority Change** (from Work Execution): base priority changes.
- **Work Order Lifecycle Change** (from Work Execution): cancelled/completed.
- **Inventory Availability Change** (from Inventory): replenishment/shortage detected for the stock item.
- **Manual Override** (from a user action, audited).

For each trigger, Inventory identifies the affected work order(s) and stock item(s), then re-runs deterministic allocation for each impacted stock item.

### Deterministic reallocation algorithm (per stock item)
1. Gather all work orders that currently have allocations for this stock item **plus** any work orders requiring this item that are currently unallocated.
2. For each work order, compute:
   - `basePriority` (from Work Execution)
   - `effectivePriority` (Inventory-computed; includes aging)
   - `dueDateTime` (from Shop Management)
   - `scheduleStartTime` (from Shop Management)
   - `waitingSince` (when the work became blocked on inventory)
3. Sort work orders using the stable multi-key sort in ‚ÄúSorting Logic‚Äù.
4. Allocate available quantity in order, applying ‚ÄúFull Allocation Only‚Äù rule.
5. Persist updated allocations and emit audit records for each change.
6. Recompute ATP (`onHand - totalAllocated`) for the stock item.

## Business Rules

### Starvation Prevention (mandatory)
Inventory must implement deterministic **priority aging** while a work order is blocked waiting on inventory.

Default policy values (configurable):
- `agingGracePeriod = 24h`
- `agingInterval = 24h`
- `agingStep = +1 priority level`
- `maxEffectivePriority = CRITICAL`

Formula:

```
effectivePriority =
  min(
    basePriority + floor((now - waitingSince - agingGracePeriod) / agingInterval),
    maxEffectivePriority
  )
```

Constraints:
- Aging applies only while blocked on inventory.
- Aging resets when stock is successfully allocated.
- Manual priority override is allowed but must be audited.

### Sorting Logic (stable, deterministic)
Work orders must be sorted for allocation as follows:
1. `effectivePriority DESC`
2. `dueDateTime ASC`
3. `waitingSince ASC`
4. `scheduleStartTime ASC`
5. `workOrderCreatedAt ASC` (final tie-breaker)

### Full Allocation Only
A work order must receive its full required quantity for the stock item to get an allocation. Partial allocations are not supported.

## Data Requirements

### `Allocation`
| Field | Type | Description |
|---|---|---|
| `allocationId` | UUID | Primary key |
| `workOrderId` | UUID | Work order |
| `stockItemId` | UUID | Stock item |
| `quantityReserved` | Integer/Decimal | Reserved quantity |
| `createdAt`, `updatedAt` | Timestamp | Server-generated |

### Work order fields required for reallocation
- `basePriority`
- `dueDateTime`
- `scheduleStartTime`
- `waitingSince` (nullable)
- `workOrderCreatedAt`

### Audit record requirements
Each allocation change must create an audit record containing:
- `reasonCode` (enum)
- `previousAllocationState`
- `newAllocationState`
- `triggeredBy` (`USER` | `SYSTEM`)
- `triggerReferenceId` (scheduleId, userId, eventId, etc.)
- `occurredAt`

### Audit Reason Codes (required enum v1)
- `SCHEDULE_CHANGE`
- `PRIORITY_CHANGE`
- `PRIORITY_AGED`
- `MANUAL_OVERRIDE`
- `STOCK_SHORTAGE`
- `STOCK_REPLENISHED`
- `LOCATION_CHANGE`
- `WORK_ORDER_CANCELLED`
- `WORK_ORDER_COMPLETED`
- `SYSTEM_REBALANCE`

## Acceptance Criteria

**AC1: Deterministic reallocation on priority change**
- Given a stock item with limited on-hand
- And two work orders competing for the same item
- When WorkExec publishes a priority change
- Then Inventory recomputes allocations using the stable sort
- And the same inputs always yield the same allocation outcome
- And an audit record is written with reason `PRIORITY_CHANGE`.

**AC2: Starvation prevention via priority aging**
- Given a work order is blocked on inventory with `waitingSince = T0`
- And `now - T0` exceeds `agingGracePeriod`
- When Inventory recomputes allocations
- Then the work order‚Äôs `effectivePriority` increases deterministically (capped)
- And an audit record is written with reason `PRIORITY_AGED` when aging changes allocation outcome.

**AC3: Sorting includes fairness tie-breakers**
- Given multiple work orders share the same effective priority and due time
- When Inventory sorts for allocation
- Then the order is determined by `waitingSince`, then `scheduleStartTime`, then `createdAt`.

**AC4: Full allocation only**
- Given remaining available quantity is insufficient to fulfill a work order‚Äôs full requirement
- When Inventory allocates
- Then that work order receives no allocation for that item.

**AC5: ATP remains consistent**
- Given on-hand is constant and allocations are moved between work orders
- When reallocation occurs
- Then total allocated quantity remains constant
- And ATP (`onHand - totalAllocated`) remains constant.

## Audit & Observability
- Audit every allocation change with reason code and before/after state.
- Metrics:
  - `allocations_reallocated_total` (tagged by reasonCode)
  - `allocations_starvation_aged_total`
  - `allocation_recompute_duration_seconds`
- Logs: include correlation IDs for triggering events.

## Original Story (Unmodified ‚Äì For Traceability)
## Backend Implementation for Story

**Original Story**: [STORY] Allocations: Reallocate Reserved Stock When Schedule Changes

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Dispatcher**, I want reallocations so that reservations reflect updated schedule and priorities.

## Details
- Reallocation by priority and due time.
- Rules prevent starvation (optional).

## Acceptance Criteria
- Allocations updated deterministically.
- Audit includes reason.
- ATP updated.

## Integrations
- Workexec triggers priority changes; shopmgr schedule updates due times.

## Data / Entities
- Allocation, PriorityPolicy, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #23: [BACKEND] [STORY] Security: Define Inventory Roles and Permission Matrix
LABELS: type:story,domain:inventory,status:ready-for-dev,agent:story-authoring,agent:inventory,agent:security
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:inventory
- status:ready-for-dev

### Recommended
- agent:inventory
- agent:security
- agent:story-authoring

### Blocking / Risk
- none

**Rewrite Variant:** inventory-enforcement

---

## Story Intent
As a System Administrator,
I want Inventory-specific roles and a permission matrix (namespaced as `inventory:*`) that are enforced on inventory operations,
so that only authorized users can view/receive/count/adjust/approve inventory activities using least-privilege and auditable controls.

This story is **Inventory-owned** and depends on a **Security-owned RBAC framework** (see Dependencies).

## Actors & Stakeholders
- **System Administrator (Primary Actor):** Configures Inventory roles and assignments using Security RBAC admin tooling.
- **Inventory Manager / Controller:** Approves cycle counts and reviews privileged actions.
- **Receiver:** Receives inventory and posts receipts.
- **Stock Clerk:** Initiates and submits cycle counts.
- **Mechanic Picker:** Views parts availability and requests/consumes parts (read-only permissions in this story).
- **Security Service / API Gateway (System Actors):** Enforce permission checks and produce audit events.
- **Audit & Compliance:** Reviews audit trails for privileged actions.

## Preconditions
- A Security-owned RBAC framework exists and is usable by domain services (example: issue #42).
- Requests are authenticated via an external IdP (OIDC) and include a stable principal identifier (JWT `sub`).
- Inventory operations are exposed as discrete API actions that can be protected with permission checks.

## Dependencies
- Security RBAC framework story: https://github.com/louisburroughs/durion-positivity-backend/issues/42

## Functional Behavior

### 1) Canonical Inventory permission list
Inventory defines (and Security enforces) a canonical permission list using `domain:resource:action` style keys, namespaced to `inventory:*`.

The initial permission set to implement and enforce is:

**Catalog / Items**
- `inventory:item:view`
- `inventory:item:create`
- `inventory:item:update`
- `inventory:item:archive`

**Stock / Levels**
- `inventory:stock:view`
- `inventory:stock:adjust`
- `inventory:stock:transfer`

**Counts / Cycle Counts**
- `inventory:count:view`
- `inventory:count:initiate`
- `inventory:count:submit`
- `inventory:count:approve`

**Receiving / Putaway**
- `inventory:receiving:view`
- `inventory:receiving:receive`
- `inventory:receiving:reverse`

**Locations / Warehouses**
- `inventory:location:view`
- `inventory:location:create`
- `inventory:location:update`
- `inventory:location:archive`

**Reporting / Export**
- `inventory:report:view`
- `inventory:report:export`

### 2) Inventory roles and default mapping (seed)
The system provides a default, seedable role ‚Üí permission mapping for Inventory:

- **Inventory Viewer**
	- All `inventory:*:view`, plus `inventory:report:view`
- **Inventory Clerk**
	- Viewer + `inventory:count:initiate`, `inventory:count:submit`, `inventory:receiving:receive`
- **Inventory Manager**
	- Clerk + `inventory:item:create`, `inventory:item:update`, `inventory:item:archive`, `inventory:stock:transfer`, `inventory:report:export`
- **Inventory Controller / Approver**
	- Viewer + `inventory:count:approve`, `inventory:stock:adjust`, `inventory:receiving:reverse`
- **Inventory Admin (optional, use sparingly)**
	- All `inventory:*`

### 3) Enforcement on Inventory operations
- Inventory APIs MUST be protected server-side (deny-by-default).
- Each protected endpoint/workflow MUST require one or more explicit permissions from the list above.
- The authorization decision MUST be enforced consistently (e.g., via Security Service decision API, shared middleware, gateway enforcement, or Spring Security method guards), but the outcome is the same: allow only when permission is granted.

### 4) Identity integration contract (non-blocking)
- The source of truth for identity is an external IdP (OIDC).
- The backend maps JWT `sub` (and optionally tenant) to an internal user profile record.
- RBAC roles/permissions are managed within this system (not IdP groups) unless added via a follow-up story.

## Alternate / Error Flows
- **Access denied:** If the principal lacks required permission, the API MUST return `403 Forbidden` and the operation MUST NOT execute.
- **Role/permission misconfiguration:** If a referenced permission is not registered/recognized, the system MUST fail safe (deny) and emit an actionable error/audit signal.

## Business Rules
- **Least privilege / deny-by-default.** Users have no Inventory permissions until roles are assigned.
- **Separation of duties (recommended, implement in defaults):** `inventory:count:approve` and `inventory:stock:adjust` are privileged permissions and should not be granted broadly.
- **Server-side enforcement required.** UI-only enforcement is not sufficient.

## Data Requirements
- Inventory maintains a permission manifest (code constants or config) sufficient to:
	- register permissions with the Security RBAC registry (idempotently), and
	- reference the permission keys when protecting endpoints.

Role/permission assignment data is owned by the Security RBAC system.

## Acceptance Criteria
```gherkin
Scenario: Allow authorized stock adjustment
	Given the permission "inventory:stock:adjust" exists in the Security RBAC registry
	And a role "Inventory Controller" is granted "inventory:stock:adjust"
	And user "Alice" is assigned role "Inventory Controller"
	When "Alice" calls the protected inventory endpoint to adjust stock
	Then the system MUST allow the action to proceed.

Scenario: Deny unauthorized cycle count approval
	Given the permission "inventory:count:approve" exists in the Security RBAC registry
	And user "Bob" is not assigned any role granting "inventory:count:approve"
	When "Bob" calls the protected inventory endpoint to approve a cycle count
	Then the system MUST deny the action
	And the system MUST return HTTP 403.

Scenario: Audit privileged inventory actions
	Given user "Alice" is authorized to adjust stock
	When "Alice" performs a stock adjustment
	Then the system MUST emit an audit event that includes actor identity, permission key, target identifiers, and outcome.
```

## Audit & Observability
- Emit audit events for privileged actions:
	- `inventory.stock.adjusted`
	- `inventory.count.approved`
	- `inventory.receiving.reversed`
- Emit access denial events for Inventory permissions:
	- `inventory.access.denied` (include permission key)
- Track metrics:
	- authorization allow/deny counts by permission
	- 95p authorization check latency

## Open Questions
None.

## Original Story (Unmodified ‚Äì For Traceability)

# Issue #23 ‚Äî [BACKEND] [STORY] Security: Define Inventory Roles and Permission Matrix

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Security: Define Inventory Roles and Permission Matrix

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As an **Admin**, I want roles/permissions so that only authorized users can adjust stock or approve counts.

## Details
- Roles: InventoryManager, Receiver, StockClerk, MechanicPicker, Auditor.
- Least privilege defaults.

## Acceptance Criteria
- Permissions enforced.
- Role changes audited.

## Integrations
- Integrates with HR/security identity and role assignment.

## Data / Entities
- Role, Permission, RolePermission, UserRole, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #17: [BACKEND] [STORY] Catalog: Search Catalog by Keyword/SKU and Filter
LABELS: type:story,domain:inventory,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:inventory
- status:ready-for-dev

### Recommended
- agent:inventory
- agent:story-authoring

---
**Rewrite Variant:** inventory-flexible
---

## Story Intent
As a **POS Clerk**, I need a fast and flexible catalog search capability to efficiently find products and services by various attributes (keyword, SKU, category, etc.) and add them to a customer's work order.

## Actors & Stakeholders
- **Primary Actor**: `POS Clerk` ‚Äî The user performing the search via the POS terminal.
- **System Actors**: 
    - `POS Terminal` ‚Äî The client application initiating the search request.
    - `Inventory Service` ‚Äî The backend service responsible for executing the search against the product catalog.
- **Stakeholders**:
    - `Work Execution Domain` ‚Äî Consumes the search results to build a work order/ticket.
    - `Product Domain` ‚Äî The system of record for product definitions, specifications, and categories.

## Preconditions
- The POS Clerk is authenticated and has an active session on the POS Terminal.
- The POS Terminal is in a state that permits adding items to a work order or sale.
- The Inventory Service is available and reachable by the POS Terminal.

## Functional Behavior
1.  **Trigger:** The POS Clerk enters search criteria (e.g., keyword, SKU) and/or applies filters in the POS application's catalog search interface and initiates the search.
2.  The POS Terminal constructs and sends a search request to the Inventory Service API. The request includes the search terms, selected filters, and pagination parameters.
3.  The Inventory Service validates the search request.
4.  The service executes the query against the product catalog data, applying all specified criteria and filters.
5.  The service returns a paginated list of `ProductSummary` objects that match the query. The response includes metadata such as total item count, current page, and pagination cursor.
6.  The POS Terminal receives the response and displays the formatted results to the POS Clerk.

## Alternate / Error Flows
- **No Results Found:** If the query yields no matching items, the service returns an empty result list. The POS Terminal should display a "No results found" message to the Clerk.
- **Invalid Search Parameters:** If the search request is malformed or contains invalid data (e.g., negative price range), the service must reject it with a `400 Bad Request` status and a descriptive error message.
- **Service Unavailability:** If the Inventory Service is down or fails to respond, the POS Terminal must handle the error gracefully, displaying an appropriate message to the Clerk (e.g., "Catalog search is temporarily unavailable").

## Business Rules

### Identifier Precedence
- Searches for an exact SKU or Manufacturer Part Number (MPN) must be prioritized and return the specific item as the top result if a match exists.

### Keyword Matching
- Keyword searches must be case-insensitive.
- Keyword searches match against the following fields, in priority order:
  1. **SKU / Product Code** (exact + prefix matching)
  2. **Product Name** (tokenized contains)
  3. **Manufacturer Part Number (MPN)** (exact + prefix + tokenized)
  4. **Manufacturer / Brand Name** (tokenized)
  5. **Tags / Categories** (tokenized)
  6. **Short Description** (tokenized, lower weight)
- **Exclusions:** Long Description and free-form notes are excluded from keyword search.
- **Normalization:** Lowercase, strip punctuation, collapse whitespace.
- **Ranking:** Exact matches > prefix matches > token contains.
- **Weighting:** Identifiers (SKU/MPN) have highest weight; descriptions have lowest weight.

### Filter Logic
- All applied filters (e.g., manufacturer, price range, tire size) are to be combined using a logical `AND` operation.

### Price Range
- The price range filter (`minPrice`, `maxPrice`) is inclusive of the boundary values.

### Pagination Policy
- **Default page size:** 25 items per page
- **Maximum page size:** 100 items per page (hard cap)
- **Mechanism:** Cursor-based pagination for stability and performance
  - Request parameters: `cursor` (optional), `pageSize` (optional, default=25, max=100)
  - Response includes: `nextCursor` (null if no more pages)
- **Offset-based pagination:** May be supported separately for specific UI requirements, but cursor-based is the primary API mechanism.

### Performance Requirements
- **P95 response time:** < 500ms for search-only (catalog) operations
- **P99 response time:** < 1000ms for search-only operations
- **P50 response time:** < 200ms for search-only operations
- **Note:** If the endpoint performs dependency fan-out (pricing/inventory enrichment), separate SLOs apply:
  - **Search + enrichment P95:** < 900ms with graceful degradation when dependencies time out
- **Assumptions:** Targets assume indexed search (database indexes or search engine) and warm caches.

## Data Requirements

### Search Request (`SearchQuery`)
- `query_term` (string, optional): A keyword, SKU, or MPN.
- `category_id` (string, optional): The unique identifier for a product category.
- `filters` (object, optional):
    - `manufacturer` (string, optional)
    - `price_range` (object, optional): `{ min: decimal, max: decimal }`
    - `tire_specs` (object, optional): `{ width: int, aspect_ratio: int, diameter: int, ... }`
- `pagination` (object, optional): 
    - `cursor` (string, optional): Pagination cursor from previous response
    - `page_size` (integer, optional): Number of results (default=25, max=100)

### Search Response (`SearchResult`)
- `metadata`: 
    - `total_items` (integer): Total number of matching items
    - `page_size` (integer): Number of items in current page
    - `next_cursor` (string, nullable): Cursor for next page (null if last page)
- `items`: An array of `ProductSummary` objects.

### Product Summary (`ProductSummary`)
- `product_id` (string, UUID): Unique identifier for the product.
- `sku` (string): The Stock Keeping Unit.
- `mpn` (string, optional): The Manufacturer Part Number.
- `name` (string): The display name of the product.
- `description_short` (string): A brief product description.
- `list_price` (decimal): The standard retail price.
- `manufacturer` (string): The name of the manufacturer.
- `availability_hint` (enum): A high-level indicator of stock (e.g., `IN_STOCK`, `LOW_STOCK`, `OUT_OF_STOCK`, `ON_ORDER`).

## Acceptance Criteria

### Keyword Search
- **Given** a POS Clerk is viewing the catalog search screen
  **When** they enter a keyword that exists in a product's name or short description
  **Then** the search results must contain that product.

### SKU Priority
- **Given** a POS Clerk is viewing the catalog search screen
  **When** they enter an exact SKU for an existing product
  **Then** that product must be returned as the first result.

### Manufacturer Filter
- **Given** a search has returned a list of products from multiple manufacturers
  **When** the Clerk applies a filter for a single manufacturer
  **Then** the updated result list must only contain products from that specific manufacturer.

### Pagination Default
- **Given** a search query matches more than 25 products
  **When** the search is executed without specifying a page size
  **Then** the response must contain exactly 25 results (the default page size) and include a `next_cursor` in the metadata indicating more pages are available.

### Pagination Maximum
- **Given** a POS Clerk requests a page size of 150
  **When** the search is executed
  **Then** the service must return at most 100 results (the maximum page size) and not fail.

### No Results
- **Given** a POS Clerk is viewing the catalog search screen
  **When** they enter a search term that does not match any product
  **Then** the system must return an empty result set with `total_items: 0` and display a "No results found" message.

### Performance Target
- **Given** a valid search request is submitted to the Inventory Service
  **When** the service processes the request (search-only, no enrichment)
  **Then** the P95 response time must be under 500ms and the P99 response time must be under 1000ms.

### Keyword Field Matching
- **Given** a product exists with the name "Michelin Pilot Sport 4S"
  **When** a Clerk searches for "pilot sport"
  **Then** that product must appear in the search results (tokenized matching on Product Name).

### Exclusion of Long Description
- **Given** a product exists with a short description "Premium tire" and a long description containing the word "experimental"
  **When** a Clerk searches for "experimental"
  **Then** that product must NOT appear in the results (Long Description is excluded from search).

## Audit & Observability

### Logging
- All search API requests must be logged with their parameters (excluding any PII).
- API responses, especially errors (`4xx`, `5xx`), must be logged.
- The identity of the requesting user/clerk should be included in logs for audit purposes.

### Metrics
- `search_requests_total`: A counter for the number of search requests, partitioned by result type (success, no_results, error).
- `search_request_latency_seconds`: A histogram measuring the duration of search requests.
- `search_error_rate`: The percentage of requests that result in a `5xx` server error.
- `search_results_count`: A histogram of the number of results returned per search.

---

## Clarification History

**Clarification Issue:** [#219](https://github.com/louisburroughs/durion-positivity-backend/issues/219)

**Questions Resolved:**
1. **Performance:** P95 < 500ms, P99 < 1000ms, P50 < 200ms (search-only mode)
2. **Search Fields:** SKU, Product Name, MPN, Manufacturer/Brand, Tags/Categories, Short Description (exclude Long Description)
3. **Pagination:** Default 25, max 100, cursor-based with nextCursor

**Answered By:** @louisburroughs on 2026-01-12

---

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #17 ‚Äî [BACKEND] [STORY] Catalog: Search Catalog by Keyword/SKU and Filter

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Catalog: Search Catalog by Keyword/SKU and Filter

**Domain**: user

### Story Description

/kiro
# User Story

## Narrative
As a **POS Clerk**, I want to search the catalog quickly so that I can find the right items during checkout.

## Details
- Search by keyword, SKU/MPN, category.
- Filters: tire size/spec, manufacturer, price range (basic).

## Acceptance Criteria
- Search returns results within target latency.
- Filters apply correctly.
- Pagination supported.

## Integrations
- Product domain provides definitions; inventory provides availability hints.

## Data / Entities
- SearchQuery, SearchResult, ProductSummary

## Classification (confirm labels)
- Type: Story
- Layer: Experience
- domain :  Point of Sale

### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*



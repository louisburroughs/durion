‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #373: [BACKEND] [STORY] Receiving: Use Site-Default Staging Location
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
# [BACKEND] [STORY] Receiving: Use Site-Default Staging Location

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- status:draft
- domain:workexec
- depends-on:issue-38

### Recommended
- agent:story-authoring

---

## Story Intent

As a **Receiving Associate**, I want the receiving workflow to automatically use the site's configured default staging location when I receive inventory, so that the process is standardized and I don't have to manually select a location each time.

## Actors & Stakeholders

- **Primary Actor:**
  - **Receiving Associate:** The warehouse worker performing receiving operations.

- **Secondary Actors & Stakeholders:**
  - **Inventory Manager:** Configured the default locations (in Issue #38).
  - **System:** The POS/WMS receiving workflow that consumes the configuration.
  - **`domain:location` / `domain:inventory`:** Provides the configured default locations.
  - **`domain:audit`:** Requires events to be published when inventory is moved to staging or quarantine.

## Preconditions

1. **Issue #38 must be completed**: The system can retrieve default staging and quarantine locations for a site.
2. A receiving session has been created (e.g., from a PO or ASN).
3. The receiving associate is authenticated and authorized to perform receiving operations.
4. The site has configured default staging and quarantine locations.

## Functional Behavior

### 1. Receiving to Default Staging Location

1. **Trigger:** A Receiving Associate confirms receipt of items in a receiving session.

2. **Behavior:**
   - The system retrieves the site's `defaultStagingLocationId` from the site configuration (configured in Issue #38).
   - The system creates an inventory movement record:
     - **Source**: `RECEIVING` (or null, depending on inventory model)
     - **Destination**: The site's default staging location
     - **Quantity**: As confirmed by the receiving associate
     - **Product/SKU**: From the receiving session
   - The system updates the inventory ledger with the movement.

3. **Outcome:**
   - The received inventory is recorded at the default staging location.
   - An `InventoryReceived` event is emitted with the location details.

### 2. Receiving to Default Quarantine Location (Optional Flow)

1. **Trigger:** A Receiving Associate marks items for quarantine during receiving (e.g., due to damage or quality concerns).

2. **Behavior:**
   - The system retrieves the site's `defaultQuarantineLocationId` from the site configuration.
   - The system creates an inventory movement record to the default quarantine location.
   - The system marks the inventory with a `QUARANTINE` status.

3. **Outcome:**
   - The received inventory is recorded at the default quarantine location with quarantine status.
   - An `InventoryQuarantined` event is emitted.

## Alternate / Error Flows

1. **Default Location Not Configured:** If the site does not have a configured default staging location, the system:
   - Prompts the Receiving Associate to manually select a staging location.
   - Logs a warning that the site configuration is incomplete.

2. **Default Location Not Available:** If the configured default staging location is:
   - Disabled, deleted, or marked as unavailable
   - The system prompts the associate to select an alternative location
   - Logs an error for the Inventory Manager to review the site configuration.

3. **Configuration Retrieval Failure:** If the system cannot retrieve the site configuration (e.g., due to a service outage):
   - The system should fail gracefully with a clear error message.
   - The receiving operation is blocked until configuration can be retrieved.

## Business Rules

1. The receiving workflow SHALL use the site's default staging location unless the associate explicitly overrides it.

2. If the associate selects the quarantine option during receiving, the system SHALL use the site's default quarantine location.

3. The system SHALL NOT allow inventory to be received to a quarantine location without explicit user action (e.g., selecting "Quarantine" option).

4. Permission enforcement for moving items **out of** quarantine is handled by separate inventory movement stories (out of scope for this story).

## Data Requirements

- **API Dependency:** The receiving workflow must call the Site Configuration API to retrieve default locations:
  - **Example:** `GET /api/v1/sites/{siteId}/default-locations`
  - **Expected Response:**
    ```json
    {
      "siteId": "site-123",
      "defaultStagingLocationId": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
      "defaultQuarantineLocationId": "6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b"
    }
    ```

- **Inventory Movement Record:**
  - `movementId`: UUID
  - `siteId`: UUID
  - `productId`: UUID
  - `fromLocationId`: UUID or null (RECEIVING)
  - `toLocationId`: UUID (default staging or quarantine location)
  - `quantity`: Decimal
  - `unitOfMeasure`: String
  - `movedAt`: Timestamp
  - `movedByUserId`: UUID
  - `movementType`: Enum (`RECEIVING_TO_STAGING`, `RECEIVING_TO_QUARANTINE`)

## Acceptance Criteria

### AC1: Receive Items to Default Staging Location
- **Given** Site "WH-1" has a configured default staging location "STAGING-A"
- **And** I am a Receiving Associate at Site "WH-1"
- **And** I have an active receiving session for PO "PO-123"
- **When** I confirm receipt of 10 units of product "P-ABC"
- **Then** the system creates an inventory movement to location "STAGING-A"
- **And** the inventory ledger shows 10 units of "P-ABC" at "STAGING-A"
- **And** an `InventoryReceived` event is emitted with the location details.

### AC2: Receive Items to Default Quarantine Location
- **Given** Site "WH-1" has a configured default quarantine location "QUARANTINE-B"
- **And** I am a Receiving Associate at Site "WH-1"
- **And** I have an active receiving session
- **When** I mark 5 units of product "P-XYZ" for quarantine (e.g., due to damage)
- **Then** the system creates an inventory movement to location "QUARANTINE-B"
- **And** the inventory status is marked as `QUARANTINE`
- **And** an `InventoryQuarantined` event is emitted.

### AC3: Fallback When Default Location Not Configured
- **Given** Site "WH-2" does NOT have a configured default staging location
- **And** I am a Receiving Associate at Site "WH-2"
- **And** I have an active receiving session
- **When** I attempt to confirm receipt of items
- **Then** the system prompts me to manually select a staging location
- **And** a warning is logged indicating the site configuration is incomplete.

### AC4: Handle Default Location Unavailable
- **Given** Site "WH-1" has a configured default staging location "STAGING-A"
- **And** "STAGING-A" has been disabled or deleted
- **When** I attempt to confirm receipt of items at Site "WH-1"
- **Then** the system displays an error message indicating the default location is unavailable
- **And** the system prompts me to select an alternative staging location
- **And** an error is logged for the Inventory Manager to review.

## Audit & Observability

- **Event Emission:**
  - `InventoryReceived`: Emitted when items are received to the default staging location.
    - Payload: `movementId`, `siteId`, `productId`, `locationId`, `quantity`, `receivedByUserId`, `timestamp`
  - `InventoryQuarantined`: Emitted when items are received to the default quarantine location.
    - Payload: `movementId`, `siteId`, `productId`, `locationId`, `quantity`, `reason`, `quarantinedByUserId`, `timestamp`

- **Logging:**
  - `INFO`: Log each successful receiving operation with location details.
  - `WARN`: Log when a site's default location is not configured.
  - `ERROR`: Log when a configured default location is unavailable.

## Dependencies

### Blocking Dependency
- **Issue #38**: "[BACKEND] [STORY] Configuration: Define Default Staging and Quarantine Storage Locations for a Site"
  - This story MUST be completed first.
  - The receiving workflow depends on the ability to retrieve configured default locations.

## Related Stories

- **Future Story**: "Inventory: Move Items Out of Quarantine with Permission Check"
  - Will handle the permission enforcement for moving items from quarantine to available stock.
  - Domain: `domain:inventory`, `domain:security`

## Technical Notes

- The receiving workflow should cache the site configuration for a reasonable TTL (e.g., 5 minutes) to reduce API calls.
- If the Site Configuration API is unavailable, the system should fail gracefully rather than using a potentially stale default.
- Consider implementing a circuit breaker pattern for the configuration API call.

---

## Original Context (From Issue #38 Split)

This story represents the **execution** portion of the original Issue #38, which combined both configuration and execution concerns. The original story has been split to maintain clean domain boundaries:

- **Configuration** (Issue #38): Defining and managing default locations.
- **Execution** (This story): Using those configured defaults in the receiving workflow.


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #207: [BACKEND] [STORY] Approval: Capture Digital Customer Approval
LABELS: type:story,layer:functional,kiro,domain:workexec,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:workexec
- status:ready-for-dev

### Recommended
- agent:workexec
- agent:story-authoring

### Blocking / Risk
- none

---
**Rewrite Variant:** workexec-structured
---
## Story Intent
**As a** Service Advisor,
**I want to** capture and persist a customer's digital approval for a work order or estimate,
**so that** I have a non-repudiable, auditable record that authorizes work to begin and ensures compliance with business policies.

## Actors & Stakeholders
- **Service Advisor (User):** The primary user initiating the approval process on behalf of the customer, or guiding the customer through it.
- **Customer (External Actor):** The individual providing the approval for the specified work and costs.
- **System (Internal Actor):** The POS backend system responsible for processing the approval, updating state, and storing the record.
- **Stakeholders:**
    - **Billing Domain:** Is notified of the approval to enable invoicing once work is complete.
    - **Audit Domain:** Requires a durable, immutable record of the approval event for compliance and dispute resolution.

## Preconditions
- A `Work Order` or `Estimate` exists within the system.
- The target entity is in a state that requires customer approval (e.g., `Pending Customer Approval`).
- The user (Service Advisor or an authenticated system process) has the necessary permissions to record an approval.

## Functional Behavior
This story describes the backend API functionality for capturing a digital approval.

### Entity Scope
- Approvals can be captured for both **Estimates** and **Work Orders**
- The endpoint should support both entity types

### Approval Flow
1.  **Trigger**: The system receives a `POST` request to a secure endpoint, such as:
    - `/api/v1/estimates/{estimateId}/approvals`
    - `/api/v1/work-orders/{workOrderId}/approvals`
2.  **Input Validation**: The system validates that the entity ID corresponds to an existing Estimate or Work Order and that the request payload contains all required approval data.
3.  **State Verification**: The system verifies that the target entity is currently in the `Pending Customer Approval` state. If not, the request is rejected.
4.  **Signature Capture**:
    - The system captures signature data in **JSON + PNG** format
    - **Stroke vectors** (x/y coordinates + timestamps) are captured alongside the rendered **PNG image**
    - The signature is bound to an **ApprovalPayload** containing:
      - `originType` / `originId` (estimate/workorder)
      - `originVersion` or `documentDigest`
      - `amount`, `currency`, key line items summary
      - `signerUserId`
      - `timestamp`
    - A `payloadHash` (SHA-256) is computed for tamper-evidence
5.  **Persistence**:
    - The system creates a new, immutable `Approval` record
    - This record contains the approval details (signature data, timestamp, IP address, user agent, payload hash, etc.)
    - The `Approval` record is atomically associated with the entity
6.  **State Transition**: The system transitions the status from `Pending Customer Approval` to `Approved`.
7.  **PDF Signing** (if applicable):
    - If the approval generates or attaches to a PDF (estimate/invoice/workorder), apply cryptographic PDF signature using Apache PDFBox or EU DSS
    - Include visible appearance with captured signature image
8.  **Event Emission**: The system publishes a `workexec.EntityApproved` domain event containing the entity ID, type, and approval ID.
9.  **Response**: The system returns a `201 Created` HTTP response, including the unique identifier of the newly created `Approval` record.

## Alternate / Error Flows
- **Error - Entity Not Found**: If the provided entity ID does not exist, the system returns a `404 Not Found` error.
- **Error - Invalid State**: If the entity is not in the `Pending Customer Approval` state (e.g., it is already `Approved`, `In Progress`, `Denied`, `On Hold`, or `Transferred`), the system returns a `409 Conflict` error with a message indicating the invalid state.
- **Error - Invalid Payload**: If the request payload is missing required fields (e.g., `customerSignatureData`, `approvalPayload`), the system returns a `400 Bad Request` error with details about the validation failure.
- **Error - Authorization Failure**: If the authenticated principal does not have permission to perform this action, the system returns a `403 Forbidden` error.
- **Error - Signature Integrity**: If the payload hash does not match the signed content, the system returns a `400 Bad Request` error indicating tampering.

## Business Rules

### State Machine
The approval process follows these state transitions:
- **Pre-approval state**: `Pending Customer Approval`
- **Post-approval state**: `Approved`
- **Other relevant states**: `Denied` (must have cause), `In process`, `On Hold`, `Transferred`

### Versioning & Mutability
- Estimates are **editable until `Approved`**
- Changes to an estimate in the `Approved` state **require a new version** of the estimate
- If a new version of the estimate is created, any work orders connected to the old version must be put into a `Transferred` status, with a reference to the new estimate
- A digital approval can only be captured once for a specific version of an entity
- The captured approval record is considered legally binding and must be stored immutably

### Retention Policy
**Retention varies by transaction type:**
- **B2B transactions**: Approval records are kept through invoicing and payment (for the lifetime of the invoice)
- **B2C transactions**: Signatures are archived for the entire lifecycle of the invoice

### Tamper-Evidence
- The system must capture sufficient metadata (timestamp, IP, payload hash, etc.) to support the validity of the digital approval
- Anti-replay protection: `intentId` is single-use and expires quickly

## Data Requirements

### Approval Entity
An `Approval` entity will be created with the following attributes:
- `approvalId`: UUID, Primary Key
- `entityType`: Enum (`Estimate`, `WorkOrder`) - identifies what is being approved
- `entityId`: UUID, Foreign Key to the Estimate or Work Order
- `entityVersion`: String (optional) - captures version if versioning is enabled
- `approvalTimestamp`: ISO 8601 UTC string, timestamp of when the approval was submitted
- `customerSignatureData`: JSON object containing:
  - `signatureImage`: Base64-encoded PNG of rendered signature
  - `signatureStrokes`: Array of stroke vectors (x/y coordinates + timestamps) - optional for forensics
- `approvalPayload`: JSON object containing the approval intent (see Functional Behavior)
- `payloadHash`: String (SHA-256 hash of approvalPayload)
- `approverIpAddress`: String, IP address of the device used for approval
- `approverUserAgent`: String, User-Agent string of the browser/client used for approval
- `pdfSignatureReference`: String (optional), reference to signed PDF document
- `createdAt`: ISO 8601 UTC string, system timestamp
- `retentionCategory`: Enum (`B2B`, `B2C`) - determines retention policy

## Acceptance Criteria

**AC1: Successful Capture of Digital Approval for Work Order**
- **Given** a Work Order exists with ID `WO-123` and its status is `Pending Customer Approval`.
- **When** a valid POST request is made to `/api/v1/work-orders/WO-123/approvals` with all required signature data and approval payload.
- **Then** the system returns a `201 Created` response.
- **And** a new `Approval` record is created with entityType=`WorkOrder` and entityId=`WO-123`.
- **And** the status of Work Order `WO-123` is updated to `Approved`.
- **And** the `payloadHash` is computed and stored.
- **And** a `workexec.EntityApproved` event is emitted.

**AC2: Successful Capture of Digital Approval for Estimate**
- **Given** an Estimate exists with ID `EST-456` and its status is `Pending Customer Approval`.
- **When** a valid POST request is made to `/api/v1/estimates/EST-456/approvals` with all required data.
- **Then** the system returns a `201 Created` response.
- **And** a new `Approval` record is created with entityType=`Estimate` and entityId=`EST-456`.
- **And** the status of Estimate `EST-456` is updated to `Approved`.

**AC3: Attempt to Approve an Already Approved Entity**
- **Given** a Work Order exists with ID `WO-456` and its status is `Approved`.
- **When** a POST request is made to `/api/v1/work-orders/WO-456/approvals`.
- **Then** the system returns a `409 Conflict` error.
- **And** the state of Work Order `WO-456` remains `Approved`.

**AC4: Attempt to Approve an Entity in Invalid State**
- **Given** a Work Order exists with ID `WO-789` and its status is `In Progress`.
- **When** a POST request is made to `/api/v1/work-orders/WO-789/approvals`.
- **Then** the system returns a `409 Conflict` error.
- **And** the state of Work Order `WO-789` remains `In Progress`.

**AC5: Attempt to Approve with Incomplete Payload**
- **Given** a Work Order exists with ID `WO-123` in a `Pending Customer Approval` state.
- **When** a POST request is made to `/api/v1/work-orders/WO-123/approvals` but the `customerSignatureData` field is missing.
- **Then** the system returns a `400 Bad Request` error with a descriptive message.
- **And** the state of Work Order `WO-123` remains `Pending Customer Approval`.

**AC6: Versioning - New Estimate Version After Approval**
- **Given** an Estimate exists with ID `EST-100` in `Approved` state.
- **And** a Work Order `WO-200` is connected to `EST-100`.
- **When** a new version `EST-100-v2` of the estimate is created.
- **Then** Work Order `WO-200` transitions to `Transferred` status.
- **And** Work Order `WO-200` contains a reference to the new estimate `EST-100-v2`.

**AC7: Signature Integrity - Payload Hash Validation**
- **Given** a Work Order exists with ID `WO-999` in `Pending Customer Approval` state.
- **When** a POST request is made with signature data and approval payload.
- **Then** the system computes SHA-256 hash of the `approvalPayload`.
- **And** the hash is stored in the `Approval` record.
- **And** any tampering with the payload can be detected by hash mismatch.

## Audit & Observability
- **Logging:**
    - `INFO`: Log the successful creation of an approval record, including `approvalId`, `entityType`, `entityId`, and `payloadHash`.
    - `WARN`: Log failed approval attempts due to business rule violations (e.g., invalid state), including the reason for failure.
    - `ERROR`: Log any unexpected system errors during the approval process.
- **Metrics:**
    - Counter for `approvals.success` (tagged by entityType).
    - Counter for `approvals.failure` (tagged by reason, e.g., `invalid_state`, `not_found`, `integrity_error`).
- **Events:**
    - A domain event `workexec.EntityApproved` must be published to the message bus upon successful approval. The event payload should contain `entityType`, `entityId`, `approvalId`, `payloadHash`, and `timestamp`.
- **Retention:**
    - Approval records must be retained according to `retentionCategory` (B2B: invoice lifetime, B2C: full archive).

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #207 ‚Äî [BACKEND] [STORY] Approval: Capture Digital Customer Approval

## Current Labels
- backend
- story-implementation
- type:story
- layer:functional
- kiro

## Current Body
## ü§ñ Implementation Issue - Created by Durion Workspace Agent

### Original Story
**Story**: #20 - Approval: Capture Digital Customer Approval
**URL**: https://github.com/louisburroughs/durion/issues/20
**Domain**: general

### Implementation Requirements
This issue was automatically created by the Missing Issues Audit System to address a gap in the automated story processing workflow.

The original story processing may have failed due to:
- Rate limiting during automated processing
- Network connectivity issues
- Temporary GitHub API unavailability
- Processing system interruption

### Implementation Notes
- Review the original story requirements at the URL above
- Ensure implementation aligns with the story acceptance criteria
- Follow established patterns for backend development
- Coordinate with corresponding frontend implementation if needed

### Technical Requirements
**Backend Implementation Requirements:**
- Use Spring Boot with Java 21
- Implement RESTful API endpoints following established patterns
- Include proper request/response validation
- Implement business logic with appropriate error handling
- Ensure database operations are transactional where needed
- Include comprehensive logging for debugging
- Follow security best practices for authentication/authorization


### Notes for Agents
- This issue was created automatically by the Missing Issues Audit System
- Original story processing may have failed due to rate limits or network issues
- Ensure this implementation aligns with the original story requirements
- Backend agents: Focus on Spring Boot microservices, Java 21, REST APIs, PostgreSQL. Ensure API contracts align with frontend requirements.

### Labels Applied
- `type:story` - Indicates this is a story implementation
- `layer:functional` - Functional layer implementation
- `kiro` - Created by Kiro automation
- `domain:general` - Business domain classification
- `story-implementation` - Implementation of a story issue
- `backend` - Implementation type

---
*Generated by Missing Issues Audit System - 2025-12-26T17:39:18.912027327*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #206: [BACKEND] [STORY] Approval: Capture In-Person Customer Approval
LABELS: type:story,layer:functional,kiro,domain:workexec,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:workexec
- status:ready-for-dev

### Recommended
- agent:workexec
- agent:story-authoring

---
**Rewrite Variant:** workexec-structured
---

## Story Intent
**As a** Service Advisor,
**I want to** capture a customer's in-person approval for a work estimate directly in the POS system,
**so that** I have an official, timestamped record of their consent and the associated work can proceed to the next stage.

## Actors & Stakeholders
- **Service Advisor (Primary Actor)**: The system user who interacts with the customer and records their approval in the system.
- **Customer (External Actor)**: The individual providing verbal or physical consent for the work.
- **System**: The POS application that orchestrates the state change and creates the audit trail.
- **Mechanic/Technician (Stakeholder)**: Is notified or can see that work is approved and can be started.
- **Billing Department (Stakeholder)**: Is interested in the approval as a prerequisite for future invoicing.
- **Auditor (Stakeholder)**: Requires a clear and immutable record of customer approvals for compliance and dispute resolution.

## Preconditions
- The Service Advisor is authenticated and has the necessary permissions to manage Work Orders.
- A Work Order (or a similar entity like an Estimate) exists in the system.
- The Work Order is in a state that requires customer approval (e.g., `Pending Approval`).
- The customer is physically present with the Service Advisor.

## Functional Behavior
1.  **Trigger**: The Service Advisor navigates to the relevant Work Order screen within the POS application.
2.  **Action**: The Service Advisor selects an action to "Capture In-Person Approval".
3.  **Confirmation**: The system presents a confirmation dialog to the Service Advisor (e.g., "Confirm that the customer has approved all work items and the total amount?").
4.  **Approval Granularity**: The approval is for the entire work order/estimate. However, the Service Advisor (as editor) can mark certain line items as declined before the approval is completed.
5.  **Approval Capture**: The system executes the approval logic:
    - It validates that the Work Order is in a valid state for approval.
    - It updates the Work Order's status to `Approved`.
    - It records the current timestamp, the ID of the Service Advisor who performed the action, and the approval method.
    - **Approval Method**: Configurable by location and customer. Default behavior is click-to-confirm (Service Advisor click on confirmation button).
6.  **Feedback**: The system displays a success message confirming the approval has been recorded and the Work Order status has been updated.
7.  **Side-Effects**: The system generates an immutable audit event for the approval.

## Alternate / Error Flows
- **Invalid State**: If the Work Order is not in a `Pending Approval` state (e.g., it is already `Approved`, `In Progress`, or `Canceled`), the "Capture In-Person Approval" action shall be disabled or, if triggered via API, return an error. The system will display a message like, "This Work Order is not in a state that can be approved."
- **Concurrent Modification**: If another user modifies the Work Order while the approval is being processed, the system should detect the conflict and return an error, preventing the state change.
- **System Failure**: If the database or a downstream service is unavailable during the save operation, the entire transaction must be rolled back. The Work Order's state will remain `Pending Approval`, and the system will display an appropriate error message to the Service Advisor.

## Business Rules

### Approval States
The work order follows this state machine progression:
- **Approved**: Estimate is approved by the customer. The estimate has been accepted but may not yet be scheduled for work.
- **Ready for Work**: Approved estimate with parts, mechanic, and location available or scheduled. All prerequisites for work execution are in place.
- **Scheduled**: Parts, mechanic, and location are confirmed as available or scheduled. (Note: This state may apply to individual tasks or the overall work order depending on domain definition.)

### Decline Workflow
Decline behavior is scoped as follows:
- A "Declined" estimate never becomes a work order.
- A "Declined" estimate can be changed to "Approved" within X days (where X is configurable).
- Decline behavior for a work order that was already approved is separate and out of scope for this story.
- Full decline workflow details are covered in a separate story.

### Approval Record Rules
- A Work Order can only be moved to an `Approved` state from a pre-defined set of preceding states (e.g., `Pending Approval`).
- The approval record is immutable once created. It must be permanently associated with the Work Order.
- The identity of the employee recording the approval (`approvingUserId`) and the exact UTC timestamp (`approvalTimestamp`) are non-nullable and mandatory fields.
- The type of approval method (`approvalType`) must be recorded as `InPerson`.

## Data Requirements
The following data attributes need to be captured or updated on the `WorkOrder` entity:
- `status`: (State Machine) Transition from `Pending Approval` to `Approved`.
- `approvalTimestamp`: `datetime` (UTC) - The exact moment the approval was confirmed in the system.
- `approvingUserId`: `UUID` - The unique identifier of the Service Advisor user who recorded the approval.
- `approvalType`: `enum` - Set to `InPerson`.
- `approvalMethod`: `enum` (configurable by location/customer) - Captures the method used (e.g., `ClickToConfirm`, `SignatureCapture`). Default: `ClickToConfirm`.
- `approvalNotes`: `text` (optional) - A field for the Service Advisor to add relevant notes about the interaction.

## Acceptance Criteria
**AC1: Successful In-Person Approval of a Work Order**
- **Given** a Work Order exists with a status of `Pending Approval`.
- **And** a Service Advisor is logged into the system.
- **When** the Service Advisor initiates and confirms the "Capture In-Person Approval" action for that Work Order.
- **Then** the system updates the Work Order's status to `Approved`.
- **And** the `approvalTimestamp` is set to the current UTC time.
- **And** the `approvingUserId` is set to the ID of the logged-in Service Advisor.
- **And** the `approvalType` is set to `InPerson`.
- **And** the `approvalMethod` is set according to the configured default (or customer/location override).
- **And** an audit event `workorder.approved` is published.

**AC2: Attempt to Approve an Already Approved Work Order**
- **Given** a Work Order exists with a status of `Approved`.
- **When** the Service Advisor attempts to use the "Capture In-Person Approval" action.
- **Then** the system prevents the action and displays an error message: "This Work Order has already been approved."
- **And** the Work Order's status and approval data remain unchanged.

**AC3: Attempt to Approve a Work Order in an Invalid State**
- **Given** a Work Order exists with a status of `Completed`.
- **When** the Service Advisor attempts to use the "Capture In-Person Approval" action.
- **Then** the system prevents the action and displays an error message: "This Work Order cannot be approved in its current state."
- **And** the Work Order's status remains `Completed`.

**AC4: Decline Individual Line Items Before Approval**
- **Given** a Work Order with multiple line items exists in `Pending Approval` status.
- **And** the Service Advisor has permission to edit the estimate.
- **When** the Service Advisor marks one or more line items as declined before confirming approval.
- **Then** the approval captures the final approved set of line items.
- **And** the Work Order transitions to `Approved` with only the approved items included.
- **And** the approval record reflects the final state of line items.

## Audit & Observability
- **Audit Event**: A `workorder.approved` event must be emitted to the audit stream upon successful completion.
- **Event Payload**: The event must contain `workOrderId`, `customerId`, `previousStatus`, `newStatus: 'Approved'`, `approvalType: 'InPerson'`, `approvalMethod`, `approvingUserId`, and `timestamp`.
- **Logging**:
    - INFO: Log the initiation and successful completion of the approval process, including `workOrderId` and `approvingUserId`.
    - ERROR: Log any failures during the approval process, including the error details, `workOrderId`, and a request correlation ID.

---
## Original Story (Unmodified ‚Äì For Traceability)
## ü§ñ Implementation Issue - Created by Durion Workspace Agent

### Original Story
**Story**: #21 - Approval: Capture In-Person Customer Approval
**URL**: https://github.com/louisburroughs/durion/issues/21
**Domain**: general

### Implementation Requirements
This issue was automatically created by the Missing Issues Audit System to address a gap in the automated story processing workflow.

The original story processing may have failed due to:
- Rate limiting during automated processing
- Network connectivity issues
- Temporary GitHub API unavailability
- Processing system interruption

### Implementation Notes
- Review the original story requirements at the URL above
- Ensure implementation aligns with the story acceptance criteria
- Follow established patterns for backend development
- Coordinate with corresponding frontend implementation if needed

### Technical Requirements
**Backend Implementation Requirements:**
- Use Spring Boot with Java 21
- Implement RESTful API endpoints following established patterns
- Include proper request/response validation
- Implement business logic with appropriate error handling
- Ensure database operations are transactional where needed
- Include comprehensive logging for debugging
- Follow security best practices for authentication/authorization

### Notes for Agents
- This issue was created automatically by the Missing Issues Audit System
- Original story processing may have failed due to rate limits or network issues
- Ensure this implementation aligns with the original story requirements
- Backend agents: Focus on Spring Boot microservices, Java 21, REST APIs, PostgreSQL. Ensure API contracts align with frontend requirements.

### Labels Applied
- `type:story` - Indicates this is a story implementation
- `layer:functional` - Functional layer implementation
- `kiro` - Created by Kiro automation
- `domain:general` - Business domain classification
- `story-implementation` - Implementation of a story issue
- `backend` - Implementation type

---
*Generated by Missing Issues Audit System - 2025-12-26T17:39:15.989974434*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #205: [BACKEND] [STORY] Approval: Record Partial Approval
LABELS: type:story,layer:functional,kiro,domain:workexec,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:workexec
- status:ready-for-dev

### Recommended
- agent:workexec
- agent:story-authoring

### Blocking / Risk
- none

---
**Rewrite Variant:** workexec-structured
---

## Story Intent
As a Service Advisor, I need to record a customer's partial approval on a Work Order so that I can proceed with the authorized work while maintaining a clear record of the declined items for future reference and reporting.

## Actors & Stakeholders
- **Service Advisor**: The primary user who interacts with the customer and records their approval decision in the system.
- **Customer**: The individual who owns the vehicle/asset and provides approval for the work.
- **Technician / Mechanic**: Consumes the output of this process to understand which specific tasks are authorized to be performed.
- **System**: The POS application responsible for persisting the state of the Work Order and its line items.

## Preconditions
1.  A Work Order (or Estimate) exists in the system.
2.  The Work Order has a status of `AwaitingApproval`.
3.  The Work Order contains at least two line items (e.g., services, parts) that require individual approval.
4.  The Service Advisor is authenticated and has the necessary permissions to modify Work Orders.

## Functional Behavior
1.  **Trigger**: The Service Advisor initiates the "Record Approval" action for a Work Order that is in the `AwaitingApproval` state.
2.  The system presents a view of all line items associated with the Work Order.
3.  For each line item, the Service Advisor can independently set an approval status, typically `Approved` or `Declined`, based on the customer's feedback.
4.  **Approval Method Capture**:
    - The system determines the approval method based on configuration:
      - **Store-level default**: Default approval method for the location
      - **Customer-level override**: Customer-specific approval requirements
      - **Precedence rule**: Customer requirements take precedence over store requirements
    - Approval methods: **Digital Signature** or **Electronic Approval by Service Advisor**
    - The selected method identifier must be stored with the approval record
5.  The Service Advisor confirms the set of approvals and declinations for the entire Work Order.
6.  Upon confirmation, the system performs the following actions atomically:
    a.  Persists the `approvalStatus` (`Approved`/`Declined`) for each line item.
    b.  Stores the approval method identifier and proof (signature data or Service Advisor confirmation).
    c.  Recalculates the `totalApprovedAmount` for the Work Order based on the sum of `Approved` line items.
    d.  Updates the overall Work Order status from `AwaitingApproval` to `ApprovedForWork` if at least one item was approved.
    e.  If all items are declined, the system transitions the Work Order to terminal `Declined` state.

## Alternate / Error Flows
- **Flow 1: Attempt to approve a Work Order in an invalid state**
    - **Given** a Work Order has a status of `InProgress`.
    - **When** the Service Advisor attempts to record an approval.
    - **Then** the system must reject the action and display an error message: "Approval can only be recorded for Work Orders awaiting approval."

- **Flow 2: User cancels the operation**
    - **Given** the Service Advisor is in the process of marking line items as `Approved` or `Declined`.
    - **When** the Service Advisor cancels the operation before final confirmation.
    - **Then** the system must discard all changes, and the Work Order and its line items must remain in their original state.

- **Flow 3: System error during confirmation**
    - **Given** the Service Advisor has confirmed the partial approval.
    - **When** a system or network error prevents the successful saving of all changes.
    - **Then** the entire transaction must be rolled back, and the system must inform the user of the failure, allowing them to retry the operation.

- **Flow 4: Re-Approval within Approval Window**
    - **Given** a line item has been marked as `Declined`.
    - **And** the estimate is still within its **Approval Window** (configurable time period).
    - **When** the customer changes their mind and wants to approve the previously declined item.
    - **Then** the Service Advisor can change the item status from `Declined` to `Approved`.
    - **And** the Work Order schedule must be amended to ensure location and mechanic availability for the new work item.

## Business Rules

### State Transitions
- A Work Order's line items can only have their approval status modified when the parent Work Order is in the `AwaitingApproval` state.
- Once a Work Order moves to `ApprovedForWork` or a subsequent state, this approval flow cannot be used again. Any changes would require a new, distinct business process (e.g., "Amend Approved Work Order").
- **Terminal Status**: When all line items are declined, the Work Order transitions to `Declined` state (confirmed as correct).

### Approval Window & Re-Approval
- A `Declined` item may be changed to `Approved` as long as the change occurs within the estimate's **Approval Window** (configurable time period).
- When a declined item is re-approved, the Work Order schedule **must be amended** to ensure:
  - Location availability
  - Mechanic availability
  - Resource allocation for the newly approved work item

### Financial Calculations
- `Declined` line items must be excluded from all financial calculations related to the authorized work total.
- The `totalApprovedAmount` on the Work Order must always equal the sum of the prices of its `Approved` line items.

### Approval Method Configuration
- Approval method is configurable at two levels:
  1. **Store-level**: Default approval method for all customers at that location
  2. **Customer-level**: Customer-specific approval requirements
- **Precedence**: Customer requirements take precedence over store requirements
- **Methods**: Digital Signature OR Service Advisor Electronic Approval

## Data Requirements
This story will modify the following domain entities:

- **WorkOrder**
    - `workOrderId` (UUID, PK)
    - `status` (Enum: `Draft`, `AwaitingApproval`, `ApprovedForWork`, `InProgress`, `Declined`, `Completed`)
    - `totalApprovedAmount` (Money/Decimal)
    - `approvalWindowEnd` (DateTime) - Configurable deadline for re-approval changes
    - `approvalMethodConfig` (String) - Reference to store/customer approval method configuration

- **LineItem**
    - `lineItemId` (UUID, PK)
    - `workOrderId` (UUID, FK)
    - `description` (String)
    - `price` (Money/Decimal)
    - `approvalStatus` (Enum: `PendingApproval`, `Approved`, `Declined`)
    - `approvalTimestamp` (DateTime) - When approval status was set
    - `approvalMethodUsed` (Enum: `DigitalSignature`, `ServiceAdvisorElectronic`)
    - `approvalProofId` (UUID, nullable) - Reference to signature data or confirmation record

- **ApprovalConfiguration**
    - `configId` (UUID, PK)
    - `entityType` (Enum: `Store`, `Customer`)
    - `entityId` (UUID) - Store or Customer ID
    - `approvalMethod` (Enum: `DigitalSignature`, `ServiceAdvisorElectronic`)
    - `approvalWindowDuration` (Integer) - Duration in hours/days for re-approval eligibility

## Acceptance Criteria
**AC1: Successful Partial Approval**
- **Given** a Work Order is `AwaitingApproval` and contains three line items, each `PendingApproval`.
- **When** the Service Advisor marks Line Item 1 and Line Item 2 as `Approved`, and Line Item 3 as `Declined`, and confirms the changes.
- **Then** the system must:
    - Update Line Item 1 and 2 `approvalStatus` to `Approved`.
    - Update Line Item 3 `approvalStatus` to `Declined`.
    - Store the approval method used for each line item.
    - Update the Work Order `status` to `ApprovedForWork`.
    - Update the Work Order `totalApprovedAmount` to be the sum of the prices of Line Item 1 and 2.

**AC2: All Line Items Are Declined**
- **Given** a Work Order is `AwaitingApproval` and contains two line items.
- **When** the Service Advisor marks both line items as `Declined` and confirms.
- **Then** the system must:
    - Update both line items' `approvalStatus` to `Declined`.
    - Update the Work Order `status` to `Declined` (terminal state).
    - Update the Work Order `totalApprovedAmount` to zero.

**AC3: Action on Work Order in Invalid State**
- **Given** a Work Order exists with a status of `InProgress`.
- **When** a user attempts to access the "Record Approval" function for that Work Order.
- **Then** the system must prevent the action and display an informative error.

**AC4: Approval Method Configuration - Customer Precedence**
- **Given** a Store has a default approval method of `ServiceAdvisorElectronic`.
- **And** a Customer has an override approval method of `DigitalSignature`.
- **When** recording approval for that customer's Work Order.
- **Then** the system must use `DigitalSignature` method (customer takes precedence).

**AC5: Re-Approval Within Approval Window**
- **Given** a Work Order with Line Item A marked as `Declined` at time T.
- **And** the estimate's Approval Window is 48 hours.
- **And** current time is T+24 hours (within window).
- **When** the Service Advisor changes Line Item A from `Declined` to `Approved`.
- **Then** the system must:
    - Update Line Item A `approvalStatus` to `Approved`.
    - Trigger schedule amendment workflow to verify location and mechanic availability.
    - Recalculate `totalApprovedAmount` to include Line Item A.

**AC6: Re-Approval Outside Approval Window**
- **Given** a Work Order with Line Item B marked as `Declined` at time T.
- **And** the estimate's Approval Window is 48 hours.
- **And** current time is T+72 hours (outside window).
- **When** the Service Advisor attempts to change Line Item B from `Declined` to `Approved`.
- **Then** the system must reject the change and display an error: "Approval Window has expired. A new estimate/work order is required."

## Audit & Observability
- **Audit Log**: An immutable audit event must be generated upon successful confirmation of an approval decision. The event must contain:
    - `eventId`, `timestamp`, `eventType` (`WorkOrderApprovalRecorded`)
    - `workOrderId`
    - `userId` (of the Service Advisor)
    - `approvalMethod` (DigitalSignature or ServiceAdvisorElectronic)
    - `approvalProofId` (if applicable)
    - `correlationId`
    - A snapshot of the changes, including the previous and new `approvalStatus` for each affected line item.
    - For re-approvals: include `previousApprovalTimestamp` and `approvalWindowRemaining`
- **Metrics**: The system should emit metrics to track:
    - Rate of approved vs. declined line items
    - Re-approval rate within approval window
    - Approval method usage (signature vs. electronic)
    - Schedule amendment triggers from re-approvals

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #205 ‚Äî [BACKEND] [STORY] Approval: Record Partial Approval

## Current Labels
- backend
- story-implementation
- type:story
- layer:functional
- kiro

## Current Body
## ü§ñ Implementation Issue - Created by Durion Workspace Agent

### Original Story
**Story**: #22 - Approval: Record Partial Approval
**URL**: https://github.com/louisburroughs/durion/issues/22
**Domain**: general

### Implementation Requirements
This issue was automatically created by the Missing Issues Audit System to address a gap in the automated story processing workflow.

The original story processing may have failed due to:
- Rate limiting during automated processing
- Network connectivity issues
- Temporary GitHub API unavailability
- Processing system interruption

### Implementation Notes
- Review the original story requirements at the URL above
- Ensure implementation aligns with the story acceptance criteria
- Follow established patterns for backend development
- Coordinate with corresponding frontend implementation if needed

### Technical Requirements
**Backend Implementation Requirements:**
- Use Spring Boot with Java 21
- Implement RESTful API endpoints following established patterns
- Include proper request/response validation
- Implement business logic with appropriate error handling
- Ensure database operations are transactional where needed
- Include comprehensive logging for debugging
- Follow security best practices for authentication/authorization


### Notes for Agents
- This issue was created automatically by the Missing Issues Audit System
- Original story processing may have failed due to rate limits or network issues
- Ensure this implementation aligns with the original story requirements
- Backend agents: Focus on Spring Boot microservices, Java 21, REST APIs, PostgreSQL. Ensure API contracts align with frontend requirements.

### Labels Applied
- `type:story` - Indicates this is a story implementation
- `layer:functional` - Functional layer implementation
- `kiro` - Created by Kiro automation
- `domain:general` - Business domain classification
- `story-implementation` - Implementation of a story issue
- `backend` - Implementation type

---
*Generated by Missing Issues Audit System - 2025-12-26T17:39:13.309796384*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #204: [BACKEND] [STORY] Approval: Handle Approval Expiration
LABELS: type:story,layer:functional,kiro,domain:workexec,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:workexec
- status:ready-for-dev

### Recommended
- agent:workexec
- agent:story-authoring

### Blocking / Risk
- none

---

**Rewrite Variant:** workexec-structured

---

## Story Intent
As a System Administrator, I want the system to automatically transition pending approvals to a cancelled state after a defined period, so that work orders do not remain indefinitely blocked waiting for a decision, ensuring process continuity and timely workflow progression. Additionally, I want to configure optional alerts for estimates approaching expiration to proactively notify stakeholders.

## Actors & Stakeholders
- **Primary Actor:** `System (Scheduled Job Processor)`: A non-human, automated process responsible for identifying and processing expired approvals.
- **Affected Actor:** `Service Advisor`: The user role that may have created the approval request, which is now considered expired.
- **Stakeholder:** `Shop Manager`: Interested in workflow efficiency and ensuring work is not stalled due to inaction on approvals.
- **Stakeholder:** `Alert Configuration Administrator`: Manages alert recipients and thresholds for expiration notifications.

## Preconditions
- An `Estimate` entity exists in the system.
- The `Estimate` entity has a `status` field in `AwaitingApproval` state.
- The `Estimate` entity has a non-null `approvalExpirationTimestamp` field, populated with a UTC timestamp.
- A scheduled job is configured to run at a regular interval (e.g., every 5 minutes for expiration processing, every 1 hour for alert generation).
- Optional: `ApprovalAlertConfiguration` records exist for generating proactive notifications.

## Functional Behavior

### Flow 1: Automatic Expiration of Pending Approvals
1. **Trigger:** The `ApprovalExpirationJob` is initiated by the system scheduler.
2. **Query:** The job queries the database for all `Estimate` records where `status` is `AwaitingApproval` and the `approvalExpirationTimestamp` is less than or equal to the current UTC time.
3. **Process:** For each `Estimate` record returned by the query:
   - a. The system initiates a transaction for the specific `Estimate`.
   - b. The status of the `Estimate` is updated to `CANCELLED` with a reason field set to `'expired'`.
   - c. An audit event is generated to record the state transition, capturing the reason (`APPROVAL_EXPIRED`), the old state (`AwaitingApproval`), and the new state (`CANCELLED`).
4. **Completion:** The job completes its run. If any records were processed, it logs a summary (e.g., "Processed 5 expired estimates"). If no records were found, it logs that no action was taken.

### Flow 2: No Work Order Until Approved
1. **Prerequisite:** An `Estimate` exists in `AwaitingApproval` status.
2. **Expiration Occurs:** The `ApprovalExpirationJob` runs and transitions the `Estimate` to `CANCELLED` with reason `'expired'`.
3. **Work Order State:** No `WorkOrder` is created from this `Estimate`.
4. **Authority:** The `Estimate` is the system of record for approval status. A `WorkOrder` is never created until the `Estimate` is explicitly approved and its status transitions to `APPROVED`.

### Flow 3: Configurable Expiration Alerts
1. **Alert Generation Trigger:** An `ApprovalAlertJob` runs periodically (e.g., every 1 hour).
2. **Query:** The job queries for `Estimate` records where:
   - `status` is `AwaitingApproval`
   - `approvalExpirationTimestamp - now()` is less than or equal to a configurable threshold (e.g., 24 hours remaining)
3. **Configuration Lookup:** For each `Estimate`, the system:
   - a. Checks for a customer-level `ApprovalAlertConfiguration` (takes precedence).
   - b. Falls back to a store-level `ApprovalAlertConfiguration` if no customer override exists.
4. **Alert Generation:** If an `ApprovalAlertConfiguration` is found and alerts are enabled:
   - a. An internal alert event is published (e.g., `APPROVAL_EXPIRING_SOON`) with details:
      - `estimateId`, `expirationTimestamp`, `recipientList`, `timeRemainingHours`
   - b. The alert is NOT directly sent via email/SMS by this system.
5. **Notification System Integration:** A separate external notification system subscribes to the alert event and handles:
   - Sending notifications to configured recipients (email, SMS, in-app, etc.).
   - Honoring recipient preferences and do-not-disturb settings.
   - Retry and failure handling.

## Alternate / Error Flows

- **No Expired Approvals:** If the job runs and finds no `Estimate` records meeting the expiration criteria, it finishes successfully without making any state changes. This is the expected "happy path" for most runs.
- **No Estimates Approaching Expiration (Alert Job):** The alert job runs but finds no `Estimate` records within the alert threshold. The job completes without publishing any events.
- **Database Transaction Failure (Expiration):** If the system fails to update an `Estimate`'s status or create an audit log within the transaction, the entire transaction for that record must be rolled back. The `Estimate` will remain in the `AwaitingApproval` state, and an error will be logged with high severity. The job will continue to process any other identified records.
- **No Alert Configuration Found (Alert Job):** If an `Estimate` is approaching expiration but no store or customer-level `ApprovalAlertConfiguration` exists, no alert is published and the estimate is silently monitored.
- **External Notification System Unavailable:** If the notification system is not listening to alert events, alerts are published but not delivered. This is acceptable as the system operates independently; the external system is responsible for availability.

## Business Rules

- An approval is considered expired if `now() >= approvalExpirationTimestamp`. All time comparisons must be performed in UTC.
- A cancelled approval (due to expiration) is a terminal state. Once an `Estimate` is in `CANCELLED` (reason: `'expired'`) state, it cannot be subsequently approved or declined.
- The expiration check process must only consider `Estimate` records in the `AwaitingApproval` state. It must not affect `Estimate`s in `APPROVED`, `DECLINED`, `CANCELLED`, or other terminal states.
- **Work Order Creation Authority:** A `WorkOrder` is only created when an `Estimate` transitions to `APPROVED` status. Expiration of an `Estimate` in `AwaitingApproval` prevents `WorkOrder` creation.
- **Alert Configuration Precedence:** Customer-level `ApprovalAlertConfiguration` takes precedence over store-level defaults. If a customer configuration disables alerts, no alert event is published, even if the store has alerts enabled.
- **Alert Threshold:** The alert threshold is configurable per store and per customer. Different stakeholders can have different alert advance-notice periods (e.g., 24 hours, 48 hours, 7 days).

## Data Requirements

- The `Estimate` entity must contain, at a minimum:
  - `estimateId` (UUID, Primary Key)
  - `customerId` (UUID, Foreign Key to Customer)
  - `locationId` (UUID, Foreign Key to Location)
  - `status` (Enum: `DRAFT`, `AwaitingApproval`, `APPROVED`, `DECLINED`, `CANCELLED`)
  - `statusReason` (String, optional): For `CANCELLED` status, the reason (e.g., `'expired'`, `'customer-requested'`)
  - `approvalExpirationTimestamp` (DATETIME, UTC, nullable)
  - `createdAt` (DATETIME, UTC)
  - `updatedAt` (DATETIME, UTC)

- The `AuditLog` entity must support recording approval expiration events, capturing:
  - `entityType`: `'Estimate'`
  - `entityId`: `estimateId`
  - `eventType`: `'STATE_TRANSITION'`
  - `details`: `{ fromStatus: 'AwaitingApproval', toStatus: 'CANCELLED', reason: 'APPROVAL_EXPIRED', expirationTimestamp: <UTC timestamp> }`
  - `createdBy`: `'SYSTEM_APPROVAL_JOB'`
  - `createdAt`: (DATETIME, UTC)

- **New Entity: `ApprovalAlertConfiguration`**
  - `configId` (UUID, Primary Key)
  - `entityType` (Enum: `'STORE'`, `'CUSTOMER'`)
  - `entityId` (UUID: storeId or customerId depending on entityType)
  - `alertsEnabled` (Boolean, default: true)
  - `expirationThresholdHours` (Integer, default: 24): How many hours before expiration to trigger an alert
  - `recipientRoles` (List of Strings): Roles to notify (e.g., `['SERVICE_ADVISOR', 'SHOP_MANAGER', 'CUSTOMER']`)
  - `createdAt` (DATETIME, UTC)
  - `updatedAt` (DATETIME, UTC)

- **Alert Event Structure** (published to internal event bus):
  - `eventId` (UUID)
  - `eventType`: `'APPROVAL_EXPIRING_SOON'`
  - `estimateId` (UUID)
  - `customerId` (UUID)
  - `locationId` (UUID)
  - `expirationTimestamp` (DATETIME, UTC)
  - `timeRemainingHours` (Integer)
  - `recipientRoles` (List of Strings, from configuration)
  - `publishedAt` (DATETIME, UTC)

## Acceptance Criteria

### AC1: Pending estimate transitions to cancelled (expired) state after expiration time
**Given** an `Estimate` record exists with `status: 'AwaitingApproval'`  
**And** its `approvalExpirationTimestamp` is set to a time in the past  
**When** the `ApprovalExpirationJob` is executed  
**Then** the `Estimate` record's `status` is updated to `'CANCELLED'`  
**And** its `statusReason` is set to `'expired'`  
**And** an audit event is created documenting the change from `AwaitingApproval` to `CANCELLED`  

### AC2: Pending estimate is not affected before expiration time
**Given** an `Estimate` record exists with `status: 'AwaitingApproval'`  
**And** its `approvalExpirationTimestamp` is set to a time in the future  
**When** the `ApprovalExpirationJob` is executed  
**Then** the `Estimate` record's `status` remains `'AwaitingApproval'`  
**And** no audit event for expiration is created for this record  

### AC3: Non-pending estimates are ignored by the expiration process
**Given** an `Estimate` record exists with a status of `'APPROVED'`  
**And** its `approvalExpirationTimestamp` is in the past  
**When** the `ApprovalExpirationJob` is executed  
**Then** the `Estimate` record's `status` remains `'APPROVED'`  

### AC4: Job handles an empty set of pending estimates gracefully
**Given** there are no `Estimate` records with `status: 'AwaitingApproval'`  
**When** the `ApprovalExpirationJob` is executed  
**Then** the job completes successfully  
**And** no database writes or errors occur  

### AC5: No work order is created when estimate expires without approval
**Given** an `Estimate` exists in `AwaitingApproval` status  
**And** no `WorkOrder` has been created from this estimate  
**When** the `ApprovalExpirationJob` runs and transitions the estimate to `CANCELLED` (reason: `'expired'`)  
**Then** no `WorkOrder` is ever created from this estimate  
**And** the `Estimate` is now in a terminal state with clear audit trail  

### AC6: Alert generated for estimate approaching expiration (customer config)
**Given** an `Estimate` exists with `status: 'AwaitingApproval'`  
**And** a customer-level `ApprovalAlertConfiguration` exists with `alertsEnabled: true` and `expirationThresholdHours: 24`  
**And** the `approvalExpirationTimestamp` is 20 hours in the future  
**When** the `ApprovalAlertJob` runs  
**Then** an `APPROVAL_EXPIRING_SOON` event is published  
**And** the event includes `timeRemainingHours: 20` and recipient roles from the configuration  

### AC7: Store-level alert configuration used when no customer override exists
**Given** an `Estimate` exists for a customer with no customer-level `ApprovalAlertConfiguration`  
**And** a store-level `ApprovalAlertConfiguration` exists with `alertsEnabled: true` and `expirationThresholdHours: 48`  
**And** the `approvalExpirationTimestamp` is 30 hours in the future  
**When** the `ApprovalAlertJob` runs  
**Then** an `APPROVAL_EXPIRING_SOON` event is published (using store threshold)  

### AC8: No alert generated when alerts are disabled
**Given** an `Estimate` exists  
**And** an `ApprovalAlertConfiguration` (customer or store) exists with `alertsEnabled: false`  
**And** the estimate is approaching its expiration threshold  
**When** the `ApprovalAlertJob` runs  
**Then** no `APPROVAL_EXPIRING_SOON` event is published  
**And** the system continues monitoring the estimate silently  

## Audit & Observability

- **Audit Event (Expiration):** A structured audit event MUST be generated for every `Estimate` that is automatically expired. The event must include the `estimateId`, `customerId`, `locationId`, the previous status (`AwaitingApproval`), the new status (`CANCELLED`), the reason (`'expired'`), and the `expirationTimestamp`.
- **Audit Event (Alert Published):** When an alert event is published, it should be logged with: `eventId`, `estimateId`, `expirationTimestamp`, `timeRemainingHours`, `recipientRoles`, and `publishedAt`.
- **Logging:**
  - The `ApprovalExpirationJob` should log its start and end time.
  - It should log a summary count of how many estimates were processed (e.g., `Expired 7 estimates`).
  - Any errors encountered during processing must be logged with a high severity level, including the `estimateId` that failed.
  - The `ApprovalAlertJob` should log the number of alerts published (e.g., `Published 12 expiration alerts`).
- **Metrics:** 
  - A metric should be emitted for the number of estimates expired per job run: `approval.expirations.count`.
  - A metric should be emitted for the number of alerts published: `approval.alerts.published`.
  - A metric should be emitted for alert configuration cache hits/misses: `approval.alert.config.cache.*`.

## Original Story (Unmodified ‚Äì For Traceability)

STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:workexec
- status:draft

### Recommended
- agent:workexec
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---

**Rewrite Variant:** workexec-structured

---

## Story Intent
As a System Administrator, I want the system to automatically transition pending approvals to an expired state after a defined period, so that work orders do not remain indefinitely blocked waiting for a decision, ensuring process continuity and timely workflow progression.

## Actors & Stakeholders
- **Primary Actor:** `System (Scheduled Job Processor)`: A non-human, automated process responsible for identifying and processing expired approvals.
- **Affected Actor:** `Service Advisor`: The user role that may have created the work order or the approval request, which is now considered expired.
- **Stakeholder:** `Shop Manager`: Interested in workflow efficiency and ensuring work is not stalled due to inaction on approvals.

## Preconditions
- A `WorkApproval` entity exists in the system.
- The `WorkApproval` entity is in a `PENDING` state.
- The `WorkApproval` entity has a non-null `expirationTimestamp` field, populated with a UTC timestamp.
- A scheduled job is configured to run at a regular interval (e.g., every 5 minutes).

## Functional Behavior
1. **Trigger:** The `ApprovalExpirationJob` is initiated by the system scheduler.
2. **Query:** The job queries the database for all `WorkApproval` records where `status` is `PENDING` and the `expirationTimestamp` is less than or equal to the current UTC time.
3. **Process:** For each `WorkApproval` record returned by the query:
   - a. The system initiates a transaction for the specific `WorkApproval`.
   - b. The status of the `WorkApproval` is updated to the designated terminal state for expired items (e.g., `EXPIRED`).
   - c. An audit event is generated to record the state transition, capturing the reason (`EXPIRED_AUTOMATICALLY`), the old state (`PENDING`), and the new state.
4. **Completion:** The job completes its run. If any records were processed, it logs a summary (e.g., "Processed 5 expired approvals"). If no records were found, it logs that no action was taken.

## Alternate / Error Flows
- **No Expired Approvals:** If the job runs and finds no `WorkApproval` records meeting the expiration criteria, it finishes successfully without making any state changes. This is the expected "happy path" for most runs.
- **Database Transaction Failure:** If the system fails to update a `WorkApproval`'s status or create an audit log within the transaction, the entire transaction for that record must be rolled back. The `WorkApproval` will remain in the `PENDING` state, and an error will be logged. The job will continue to process any other identified records.

## Business Rules
- An approval is considered expired if `now() >= expirationTimestamp`. All time comparisons must be performed in UTC.
- An expired approval is a terminal state. Once an approval is in an `EXPIRED` state, it cannot be subsequently approved or declined.
- The expiration check process must only consider approvals in the `PENDING` state. It must not affect approvals in `APPROVED`, `DECLINED`, or other terminal states.

## Data Requirements
- The `WorkApproval` entity must contain, at a minimum:
   - `approvalId` (UUID, Primary Key)
   - `workOrderId` (UUID, Foreign Key)
   - `status` (Enum: `PENDING`, `APPROVED`, `DECLINED`, `EXPIRED`, `CANCELLED`)
   - `expirationTimestamp` (DATETIME, UTC)
   - `createdAt` (DATETIME, UTC)
   - `updatedAt` (DATETIME, UTC)

- The `AuditLog` entity must support recording this event, capturing:
   - `entityType`: 'WorkApproval'
   - `entityId`: `approvalId`
   - `eventType`: 'STATE_TRANSITION'
   - `details`: { `fromStatus`: 'PENDING', `toStatus`: 'EXPIRED', `reason`: 'AUTOMATED_EXPIRATION' }

## Acceptance Criteria

### AC1: Pending approval transitions to expired state after expiration time
**Given** a `WorkApproval` record exists with `status: 'PENDING'`  
**And** its `expirationTimestamp` is set to a time in the past  
**When** the `ApprovalExpirationJob` is executed  
**Then** the `WorkApproval` record's `status` is updated to `'EXPIRED'`  
**And** an audit event is created documenting the change from `PENDING` to `EXPIRED`.

### AC2: Pending approval is not affected before expiration time
**Given** a `WorkApproval` record exists with `status: 'PENDING'`  
**And** its `expirationTimestamp` is set to a time in the future  
**When** the `ApprovalExpirationJob` is executed  
**Then** the `WorkApproval` record's `status` remains `'PENDING'`  
**And** no audit event for expiration is created for this record.

### AC3: Non-pending approvals are ignored by the expiration process
**Given** a `WorkApproval` record exists with a status of `'APPROVED'`  
**And** its `expirationTimestamp` is in the past  
**When** the `ApprovalExpirationJob` is executed  
**Then** the `WorkApproval` record's `status` remains `'APPROVED'`.

### AC4: Job handles an empty set of pending approvals gracefully
**Given** there are no `WorkApproval` records with `status: 'PENDING'`  
**When** the `ApprovalExpirationJob` is executed  
**Then** the job completes successfully  
**And** no database writes or errors occur.

## Audit & Observability
- **Audit Event:** A structured audit event MUST be generated for every approval that is automatically expired. The event must include the `approvalId`, `workOrderId`, the previous status (`PENDING`), the new status (`EXPIRED`), and the reason for the change.
- **Logging:**
   - The `ApprovalExpirationJob` should log its start and end time.
   - It should log a summary count of how many approvals were processed (e.g., `Expired 7 approvals`).
   - Any errors encountered during processing must be logged with a high severity level, including the `approvalId` that failed.
- **Metrics:** A metric should be emitted for the number of approvals expired per job run.

## Open Questions
1. **Target State:** What is the authoritative, final status for an expired approval? The story assumes `EXPIRED`, but it could also be `DECLINED` or `CANCELLED`. This needs to be confirmed.
2. **Work Order Impact:** Does the expiration of a `WorkApproval` trigger a state change on the parent `WorkOrder`? For example, should the `WorkOrder` revert to a `NEEDS_REVIEW` state?
3. **Notifications:** Should any notifications be sent when an approval expires? If so, who are the recipients (e.g., the original requestor, the intended approver), and what is the required message content/format?


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #179: [BACKEND] [STORY] Fulfillment: Mechanic Executes Picking (Scan + Confirm)
LABELS: type:story,domain:workexec,status:needs-review,agent:story-authoring,agent:workexec
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:workexec
- status:needs-review

### Recommended
- agent:workexec
- agent:story-authoring

---\n**Rewrite Variant:** workexec-structured\n---\n\n## Story Intent\nAs a Mechanic, I need to scan and confirm the parts from a picking list for a specific work order, so that the parts are accurately tracked, inventory is updated in real-time, and the items are officially assigned to the job before I begin work.\n\n## Actors & Stakeholders\n- **Mechanic (Primary Actor):** The user performing the physical and digital picking process.\n- **System (System Actor):** The Workshop/POS system that facilitates the picking workflow, validates scans, and updates records.\n- **Inventory Manager (Stakeholder):** Relies on accurate, real-time stock level updates resulting from the picking process.\n- **Service Advisor (Stakeholder):** Monitors the work order's progress, which includes the completion of the parts picking stage.\n\n## Preconditions\n1.  The Mechanic is authenticated and has the appropriate permissions to execute work order tasks.\n2.  A `Work Order` exists and is in a state that permits parts picking (e.g., `WORK_AUTHORIZED`).\n3.  A `Picking List` has been generated for the `Work Order` and is in a `PENDING_PICK` state.\n4.  The items on the `Picking List` have a corresponding inventory status of `ALLOCATED` to this `Work Order`.\n\n## Functional Behavior\n1.  **Trigger:** The Mechanic initiates the \"Pick Parts\" action for a specific `Work Order` within the system (e.g., on a mobile terminal or workstation).\n2.  The System displays the `Picking List` associated with the `Work Order`, showing the required items and quantities.\n3.  The Mechanic physically gathers the parts and scans the barcode or QR code of the first item.\n4.  The System receives the scanned identifier and validates it against the `Picking List`.\n5.  **On successful validation:**\n    - The System updates the UI to indicate the item has been successfully scanned.\n    - The system increments the `pickedQuantity` for that `PickingListItem`.\n6.  The Mechanic continues this process until all items and their required quantities are scanned.\n7.  The mechanic can choose to save the current picking session and continue later.\n8.  Once all items are scanned, the Mechanic uses a \"Confirm Pick\" action in the system.\n9.  **On confirmation:**\n    - The System performs a final validation to ensure all required items/quantities are accounted for.\n    - The System transitions the `Picking List` status from `PENDING_PICK` to `COMPLETED`.\n    - The System triggers updates to the `Inventory` service to transition the status of the picked items from `ALLOCATED` to `DISBURSED_TO_WORK_ORDER` and then to `PICKED_TO_WORK_ORDER`.\n    - The System may update the parent `Work Order` status (e.g., to `READY_FOR_WORK`).\n\n## Alternate / Error Flows\n- **Error: Scanned Item Not on Picking List**\n  - **Trigger:** Mechanic scans an item barcode that is not associated with any item on the current `Picking List`.\n  - **System Response:** The System rejects the scan and displays an audible and/or visual error message: \"Invalid Item: This item is not on the picking list.\" The state of the picking list remains unchanged.\n\n- **Error: Quantity Exceeded**\n  - **Trigger:** Mechanic scans an item for which the `pickedQuantity` already equals the `requiredQuantity`.\n  - **System Response:** The System rejects the scan and displays an error: \"Quantity Met: The required quantity for this item has already been picked.\"\n\n- **Error: Attempt to Confirm Incomplete Pick**\n  - **Trigger:** Mechanic selects \"Confirm Pick\" before all required items on the list have been scanned.\n  - **System Response:** The System rejects the confirmation and displays a message indicating which items are still pending: \"Confirmation Failed: Please pick all required items before confirming.\"\n\n- **Error: Item Not Found**\n  - **Trigger:** Mechanic cannot find a part on the shelf that is listed as `ALLOCATED`.\n  - **System Response:** The Mechanic can flag the item as `NOT_FOUND` from the UI. The system will record this exception and notify the Inventory Manager. The `PickingListItem` will be marked as `NOT_FOUND`.\n\n- **User Action: Cancel Picking Process**\n  - **Trigger:** Mechanic cancels the picking session before confirming.\n  - **System Response:** The System discards the current session's progress (i.e., resets any temporarily stored `pickedQuantity` counts) and reverts the `Picking List` to its previous state (`PENDING_PICK`). No inventory changes are committed.\n\n## Business Rules\n- A `Picking List` can be partially picked. The mechanic can save the current progress and continue picking later. Each picking session will be tracked, and the inventory will be updated accordingly.\n- Upon successful confirmation of a `Picking List`, the corresponding inventory records for the picked items must be transactionally updated to reflect their new state.\n- A unique, auditable event must be recorded for every completed picking confirmation.\n- The system must prevent the same physical item from being picked for two different work orders simultaneously.\n\n## Data Requirements\n- **`PickingList`**\n  - `pickingListId` (PK)\n  - `workOrderId` (FK)\n  - `status` (Enum: `PENDING_PICK`, `PARTIALLY_PICKED`, `COMPLETED`, `CANCELLED`)\n  - `assigneeId` (FK to User/Mechanic, optional)\n- **`PickingListItem`**\n  - `pickingListItemId` (PK)\n  - `pickingListId` (FK)\n  - `itemId` (FK)\n  - `requiredQuantity` (Integer)\n  - `pickedQuantity` (Integer)\n  - `status` (Enum: `PENDING`, `PICKED`, `NOT_FOUND`)\n- **Required Input for Endpoint (e.g., `POST /picking-lists/{id}/confirm`)**\n  - `pickingListId`\n  - A collection of picked items with identifiers (e.g., `scannedBarcode`) and quantities.\n\n## Acceptance Criteria\n**AC1: Successful Full Pick and Confirmation**\n- **Given** a `Work Order` with a `Picking List` in `PENDING_PICK` state, requiring 2 units of Item A and 1 unit of Item B.\n- **And** the corresponding inventory for these items is `ALLOCATED`.\n- **When** the Mechanic scans two units of Item A and one unit of Item B.\n- **And** the Mechanic confirms the completed pick.\n- **Then** the System successfully validates the pick.\n- **And** the `Picking List` status transitions to `COMPLETED`.\n- **And** the inventory status for the 3 items transitions from `ALLOCATED` to `DISBURSED_TO_WORK_ORDER` and then to `PICKED_TO_WORK_ORDER`.\n- **And** an audit event for the completed pick is created.\n\n**AC2: Scan of an Item Not on the List**\n- **Given** a `Picking List` that does not include Item C.\n- **When** the Mechanic scans the barcode for Item C.\n- **Then** the System displays an \"Invalid Item\" error message.\n- **And** the state of the `Picking List` and its items remains unchanged.\n\n**AC3: Attempt to Over-Pick an Item**\n- **Given** a `Picking List` requires 1 unit of Item A, and it has already been scanned.\n- **When** the Mechanic scans Item A again.\n- **Then** the System displays a \"Quantity Met\" error message.\n- **And** the `pickedQuantity` for Item A remains 1.\n\n**AC4: Attempt to Confirm an Incomplete Pick**\n- **Given** a `Picking List` requires 2 units of Item A, but only 1 unit has been scanned.\n- **When** the Mechanic attempts to confirm the pick.\n- **Then** the System displays an \"Incomplete Pick\" error message, highlighting that Item A is still pending.\n- **And** the `Picking List` status remains `PENDING_PICK`.\n\n**AC5: Partial Pick and Save**\n- **Given** a `Work Order` with a `Picking List` in `PENDING_PICK` state, requiring 2 units of Item A and 1 unit of Item B.\n- **When** the Mechanic scans one unit of Item A.\n- **And** the Mechanic chooses to save the session.\n- **Then** the `Picking List` status transitions to `PARTIALLY_PICKED`.\n- **And** the `pickedQuantity` for Item A is 1.\n- **And** the inventory status for the picked item is updated.\n\n**AC6: Item Not Found**\n- **Given** a `Picking List` requires 1 unit of Item D.\n- **When** the Mechanic cannot find the item and flags it as `NOT_FOUND`.\n- **Then** the `PickingListItem` for Item D is marked as `NOT_FOUND`.\n- **And** a notification is sent to the Inventory Manager.\n\n## Audit & Observability\n- **Audit Trail:** An immutable audit log entry must be created upon every successful `Picking List` confirmation. The entry must include:\n  - `eventId`\n  - `timestamp`\n  - `eventType`: `PICKING_LIST_CONFIRMED`\n  - `userId` (Mechanic who performed the action)\n  - `workOrderId`\n  - `pickingListId`\n  - `payload`: A list of all `itemId` and `quantity` that were picked.\n- **Logging:** Structured logs (e.g., JSON) should be generated for key steps: `picking_session_started`, `item_scan_validated`, `item_scan_failed`, `picking_confirmation_attempted`, `picking_confirmation_succeeded`, `picking_session_saved`.\n- **Metrics:**\n  - `picking_lists_completed_total`: A counter for successfully completed picking lists.\n  - `picking_lists_partial_total`: A counter for partially picked lists.\n  - `picking_scan_errors_total`: A counter for failed scans, tagged by error type (e.g., `invalid_item`, `quantity_exceeded`).\n  - `picking_item_not_found_total`: A counter for items flagged as not found.\n  - `picking_confirmation_duration_seconds`: A histogram measuring the time from initiation to confirmation.\n- **Events:** A domain event `workexec.PickingListCompleted` should be published to a message bus upon successful completion for consumption by other domains like Inventory and Billing. A `workexec.PickingListPartial` event should be published when a partial pick is saved.

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #173: [BACKEND] [STORY] Estimate: Add Parts to Estimate
LABELS: type:story,domain:workexec,status:needs-review
BODY:
STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:workexec
- status:draft

### Recommended
- agent:workexec
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** workexec-structured
---

## Story Intent

**As a** Service Advisor,
**I want to** add parts from the catalog or as non-catalog items to a work estimate,
**so that** I can provide a customer with an accurate and complete quote for the parts required for a service.

## Actors & Stakeholders

- **Primary Actor**:
  - `Service Advisor`: The user directly interacting with the POS to build and manage the estimate.
- **System Actors**:
  - `Work Execution Service`: Owns the lifecycle and state of the `Estimate`.
  - `Inventory Service`: Provides the product catalog for lookups.
  - `Pricing Service`: Provides list prices, discounts, and markups for catalog items.
- **Stakeholders**:
  - `Customer`: The recipient of the estimate.
  - `Service Manager`: Responsible for operational efficiency and profitability, and sets policies for price overrides.
  - `Parts Manager`: Responsible for the accuracy of the parts catalog and pricing.
  - `Auditor`: Requires a clear trail of all financial changes made to an estimate.

## Preconditions

1. A valid `Estimate` exists in a modifiable state (e.g., `DRAFT`).
2. The `Service Advisor` is authenticated and possesses the necessary permissions to modify the specified `Estimate`.
3. The system has access to the `Inventory Service` to search the parts catalog.
4. The system has access to the `Pricing Service` to retrieve default pricing information.

## Functional Behavior

### Scenario 1: Add a Catalog Part to an Estimate

- **Trigger**: The Service Advisor initiates the "Add Part" action on a `DRAFT` estimate.
- **Steps**:
  1. The system presents an interface to search the product catalog.
  2. The Service Advisor searches for a part by `partNumber`, `description`, or `category`.
  3. A list of matching parts is returned from the `Inventory Service`.
  4. The Service Advisor selects a part from the results and specifies a `quantity` (must be > 0).
  5. The `Work Execution Service` requests the default price for the selected part and quantity from the `Pricing Service`.
  6. The `Pricing Service` returns the `unitPrice`, including any applicable standard discounts or markups.
  7. The `Work Execution Service` creates a new `EstimateItem` of type `PART` and links it to the `Estimate`.
  8. The system recalculates all estimate totals (`subtotal`, `tax`, `grandTotal`) transactionally.
- **Outcome**: A new part line item is successfully added to the estimate, and all totals are updated.

### Scenario 2: Add a Part with an Overridden Price

- **Trigger**: The Service Advisor adds a part but needs to adjust the system-calculated price.
- **Steps**:
  1. Following the steps in Scenario 1, a part is selected and added.
  2. The Service Advisor initiates a price override action on the newly added line item.
  3. The system verifies if the Service Advisor has the `PRICE_OVERRIDE` permission.
  4. If permitted, the system allows the `unitPrice` field to be edited.
  5. The Service Advisor enters the new `unitPrice`.
  6. If the business policy requires a reason for overrides, the system prompts for an `overrideReasonCode` from a pre-configured list.
  7. The Service Advisor selects a valid reason.
  8. The system updates the `EstimateItem` with the new price and reason, and recalculates all estimate totals.
- **Outcome**: The part's price is updated, the reason is recorded, and estimate totals are recalculated.

### Scenario 3: Add a Non-Catalog Part

- **Trigger**: A required part is not found in the catalog search.
- **Steps**:
  1. The system detects a "part not found" condition during the search.
  2. The system checks if the `ALLOW_NON_CATALOG_PARTS` policy is enabled.
  3. If enabled, the system presents an interface for manual entry.
  4. The Service Advisor must provide a `description` and `unitPrice`. A `partNumber` may be entered but is not validated against the catalog.
  5. The Service Advisor enters a `quantity` (> 0).
  6. The system creates a new `EstimateItem` with the `isNonCatalog` flag set to `true`.
  7. The system recalculates all estimate totals.
- **Outcome**: A non-catalog part line item is added to the estimate with manually entered details, and totals are updated.

## Alternate / Error Flows

- **Part Not Found**:
  - **Condition**: A search yields no results.
  - **System Response**: If non-catalog entry is disabled, display a "Part not found" message. If enabled, provide the option to add a non-catalog part (see Scenario 3).
- **Invalid Quantity**:
  - **Condition**: User enters a quantity that is less than or equal to zero, or non-numeric.
  - **System Response**: Reject the input, display a validation error message (e.g., "Quantity must be a number greater than 0"), and prevent the item from being added.
- **Price Override Not Permitted**:
  - **Condition**: Service Advisor attempts to override a price without the required `PRICE_OVERRIDE` permission.
  - **System Response**: Block the action and display an informative message (e.g., "You do not have permission to override prices.").
- **Price Override Reason Required**:
  - **Condition**: User performs a permitted price override but fails to provide a reason code when one is required by policy.
  - **System Response**: Reject the change, display a validation error message (e.g., "A reason code is required for all price overrides."), and keep the original price.
- **Estimate Not in Modifiable State**:
  - **Condition**: User attempts to add a part to an estimate that is not in `DRAFT` status (e.g., it is `APPROVED` or `INVOICED`).
  - **System Response**: Block the action and display an error message (e.g., "This estimate cannot be modified as it has already been approved.").

## Business Rules

- **BR-1 (State Gate)**: Parts can only be added, edited, or removed while the `Estimate` is in the `DRAFT` state.
- **BR-2 (Transactional Totals)**: All estimate-level totals (`subtotal`, `tax`, `grandTotal`) must be recalculated within the same transaction as any line item addition, modification, or deletion. The estimate must remain consistent at all times.
- **BR-3 (Pricing Authority)**: The `Pricing Service` is the authority for the initial `unitPrice` of catalog items. Any deviation must be explicitly stored as an `overridePrice`.
- **BR-4 (Configurable Policies)**: The following behaviors must be controlled by configurable business policies:
  - `ALLOW_NON_CATALOG_PARTS` (Boolean)
  - `REQUIRE_REASON_FOR_OVERRIDE` (Boolean)
- **BR-5 (Permissions)**: Modifying an estimate item's price requires a specific, checkable user permission (e.g., `workexec.estimate.overridePrice`).
- **BR-6 (Non-Catalog Identifier)**: Non-catalog items must have a stable, system-generated internal identifier for traceability, even without a `productId`. The `isNonCatalog` flag must be set to `true`.

## Data Requirements

### `WorkExecution.EstimateItem` Entity

| Field Name | Type | Constraints | Description |
|---|---|---|---|
| `estimateItemId` | UUID | Primary Key, Not Null | Unique identifier for the estimate line item. |
| `estimateId` | UUID | Foreign Key, Not Null | Links to the parent `Estimate`. |
| `itemSeqId` | Integer | Not Null | Display order of the item within the estimate. |
| `itemType` | Enum | Not Null, Default: `PART` | Type of line item (e.g., 'PART', 'LABOR'). |
| `productId` | UUID | Nullable | FK to the `Inventory.Product` entity. Null for non-catalog items. |
| `description` | String | Not Null | Product description. Copied from catalog or manually entered. |
| `partNumber` | String | Nullable | Part number. Copied from catalog or manually entered. |
| `quantity` | Decimal | Not Null, > 0 | Quantity of the part being quoted. |
| `unitPrice` | Money | Not Null | The unit price fetched from the Pricing Service. |
| `overrideUnitPrice` | Money | Nullable | The manually overridden price, if applicable. |
| `overrideReasonCode` | String | Nullable | The reason code for the price override. |
| `isNonCatalog` | Boolean | Not Null, Default: `false` | Flag indicating if the part is from the catalog. |
| `taxCodeSnapshot` | String | Not Null | The tax code applicable at the time of addition. |

### Data Read from Other Domains
- **`Inventory.Product`**: `productId`, `partNumber`, `description`.
- **`Pricing.Price`**: `unitPrice`, `applicableDiscounts`.

## Acceptance Criteria

- **AC-1: Add a standard catalog part**
  - **Given** I am viewing an estimate in `DRAFT` status
  - **When** I search for a valid catalog part, select it, and specify a quantity of 2
  - **Then** a new line item for that part is added to the estimate
  - **And** the `unitPrice` is populated from the Pricing Service
  - **And** the estimate's `subtotal` and `grandTotal` are correctly recalculated.

- **AC-2: Override a part's price with permission and a reason code**
  - **Given** I am a Service Advisor with `PRICE_OVERRIDE` permission
  - **And** I have added a part to a `DRAFT` estimate
  - **And** the system policy requires a reason code for overrides
  - **When** I change the `unitPrice` of the part and select a valid `overrideReasonCode`
  - **Then** the `overrideUnitPrice` is saved with the new price
  - **And** the `overrideReasonCode` is recorded
  - **And** the estimate totals are recalculated based on the new price.

- **AC-3: Add a non-catalog part**
  - **Given** the `ALLOW_NON_CATALOG_PARTS` policy is enabled
  - **And** I am viewing an estimate in `DRAFT` status
  - **When** I choose to add a non-catalog part and provide a description, a quantity of 1, and a unit price
  - **Then** a new line item is added to the estimate with `isNonCatalog` set to `true`
  - **And** the estimate totals are recalculated.

- **AC-4: Fail to add a part with invalid quantity**
  - **Given** I am viewing an estimate in `DRAFT` status
  - **When** I attempt to add a part with a quantity of 0
  - **Then** the system prevents the line item from being added
  - **And** a validation message "Quantity must be a number greater than 0" is displayed.

- **AC-5: Fail to override a price without permission**
  - **Given** I am a Service Advisor without `PRICE_OVERRIDE` permission
  - **And** I have added a part to a `DRAFT` estimate
  - **When** I attempt to change the `unitPrice` of the part
  - **Then** the action is blocked
  - **And** a message "You do not have permission to override prices" is displayed.

## Audit & Observability

- **Audit Logs**:
  - An immutable audit event **MUST** be created for:
    - `ESTIMATE_ITEM_CREATED`: On successful addition of any part. Log `estimateId`, `estimateItemId`, `productId` (if any), `quantity`, `unitPrice`.
    - `ESTIMATE_ITEM_MODIFIED`: On any change to a line item. Log `estimateItemId` and a `changeset` containing the field name, previous value, and new value (e.g., for `quantity`, `overrideUnitPrice`).
  - All audit events must include the `userId` of the performing `Service Advisor`, a `timestamp`, and the `source` service (`work-execution-service`).
- **Metrics**:
  - `estimate.parts.added.count`: Counter for parts added (can be tagged by `catalog` vs `non_catalog`).
  - `estimate.price_overrides.count`: Counter for every price override event.
- **Logging**:
  - `INFO` level logs for successful addition/modification of parts.
  - `WARN` level logs for failed attempts due to business rule violations (e.g., invalid quantity, permission denied).

## Open Questions

1.  **Price Override Permissions**: What is the specific mechanism for granting `PRICE_OVERRIDE` permission? Is it role-based (e.g., "Service Manager" role) or a direct permission assignment?
2.  **Override Reason Codes**: What is the definitive list of valid `overrideReasonCode` values (e.g., `PRICE_MATCH`, `CUSTOMER_GOODWILL`, `DAMAGED_ITEM`)? Is this list configurable?
3.  **Non-Catalog Policy Scope**: Is the `ALLOW_NON_CATALOG_PARTS` policy a system-wide setting, or can it be configured per location/dealership?
4.  **Tax Code Source**: The original story mentions a `taxCode` field. What is the source of truth for this value? Does it come from the `Product` entity, the `Customer` record, or a location-based tax rule engine? This needs to be defined before implementation.

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #173 ‚Äî [BACKEND] [STORY] Estimate: Add Parts to Estimate

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Estimate: Add Parts to Estimate

**Domain**: user

### Story Description

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
Service Advisor

## Trigger
A Draft estimate exists and parts need to be quoted.

## Main Flow
1. User searches parts catalog by part number, description, or category.
2. User selects a part and specifies quantity.
3. System defaults unit price from configured price list and applies discounts/markups as configured.
4. User optionally overrides price if permitted and provides a reason code if required.
5. System adds the part line item and recalculates totals.

## Alternate / Error Flows
- Part not found ‚Üí allow controlled non-catalog part entry (if enabled) with mandatory description.
- Quantity invalid (<=0) ‚Üí block and prompt correction.
- Price override not permitted ‚Üí block and show policy message.

## Business Rules
- Each part line item references a part number (or controlled non-catalog identifier).
- Totals must be recalculated on line change.
- Price overrides require permission and may require reason codes.

## Data Requirements
- Entities: Estimate, EstimateItem, Product, PriceList, DiscountRule, AuditEvent
- Fields: itemSeqId, productId, partNumber, quantity, unitPrice, discountAmount, taxCode, isNonCatalog, overrideReason

## Acceptance Criteria
- [ ] User can add a catalog part line item to a Draft estimate.
- [ ] Totals update immediately after adding or editing part items.
- [ ] Audit records who changed quantity/price.

## Notes for Agents
Model part items so later promotion preserves stable identifiers and tax snapshots.


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #172: [BACKEND] [STORY] Estimate: Add Labor to Estimate
LABELS: type:story,domain:workexec,status:needs-review
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:workexec
- status:draft

### Recommended
- agent:workexec
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** workexec-structured
---
## Story Intent
As a Service Advisor, I want to add standardized or custom labor items to a draft estimate so that I can accurately quote the cost of services for a customer.

## Actors & Stakeholders
- **Primary Actor:** Service Advisor (The user performing the action).
- **System Actor:** Point of Sale (POS) System.
- **Beneficiary:** Customer (Receives the accurate estimate).
- **Stakeholder:** Pricing Domain (Provides the business rules and data for labor rate determination).
- **Stakeholder:** Audit & Compliance (Requires traceability of all financial changes to an estimate).

## Preconditions
1.  The user is authenticated as a Service Advisor with permissions to create and modify estimates.
2.  An `Estimate` entity exists with `status: Draft`.
3.  The Service Catalog is available and accessible to the system.
4.  Configured labor rate rules are available from the Pricing domain.

## Functional Behavior
### Main Success Scenario: Adding a Standard Labor Item
1.  **Trigger:** The Service Advisor initiates the "Add Labor" action on a `Draft` estimate.
2.  The system presents an interface to search the `ServiceCatalog`.
3.  The Service Advisor searches for a labor service by its service code or description.
4.  The Service Advisor selects a matching service from the results.
5.  If the service is time-based, the Service Advisor enters the number of labor units (e.g., hours).
6.  If the service is flat-rate, the units and price are pre-defined.
7.  The system requests the default labor rate from the Pricing service/module, providing context (e.g., `shopId`, `serviceCode`, `technicianClass`).
8.  The system creates a new `EstimateItem` of `type: LABOR`, linking it to the `Estimate`.
9.  The system populates the `EstimateItem` with the `serviceCode`, `description`, `laborUnits`, `laborRate`, and any applicable tax codes.
10. The system recalculates the `Estimate` sub-totals and grand total.
11. The Service Advisor can optionally add notes specific to this labor item.
12. **Outcome:** A new labor line item is successfully added to the estimate, and all totals are updated in real-time.

## Alternate / Error Flows
### Flow 1: Service Not Found (With Custom Entry Allowed)
1.  The Service Advisor searches for a service that does not exist in the `ServiceCatalog`.
2.  The system returns no results.
3.  The system presents an option to "Add Custom Labor" (contingent on business rule `BR-4`).
4.  The Service Advisor enters a mandatory `description`, `laborUnits`, and a `laborRate`.
5.  The system proceeds from step 8 of the Main Success Scenario, marking the `EstimateItem` with a specific source flag (e.g., `source: CUSTOM`).

### Flow 2: Invalid Labor Units
1.  The Service Advisor enters a non-positive value (e.g., `0` or `-1`) for `laborUnits`.
2.  The system rejects the input and displays a validation error message: "Labor units must be a positive number."
3.  The system blocks the addition of the line item until the error is corrected.

### Flow 3: Labor Rate Not Found
1.  The system requests a default labor rate from the Pricing service/module, but no matching rule is found for the given context.
2.  **[OPEN QUESTION]** The system's behavior is currently undefined. See Open Questions. The system should either block the addition with an error or allow a manual rate override, pending clarification.

## Business Rules
- **BR-1:** Labor items can only be added, edited, or removed while the `Estimate` is in `status: Draft`.
- **BR-2:** Each labor `EstimateItem` must be associated with a unique, system-generated `itemSeqId` within the context of its `Estimate`.
- **BR-3:** The determination of the default `laborRate` must be deterministic and based on a clearly defined hierarchy of rules managed by the Pricing domain.
- **BR-4:** The ability to add custom (non-catalog) labor items is controlled by a system-level configuration setting. If disabled, Flow 1 is not possible.
- **BR-5:** Any change to a labor line item (addition, update, removal) must trigger a full recalculation of the `Estimate` totals (subtotal, tax, grand total).
- **BR-6:** A custom labor item must have a non-empty `description`.

## Data Requirements
| Entity | Attribute | Type | Notes |
| :--- | :--- | :--- | :--- |
| `Estimate` | `estimateId` | UUID | Primary Key |
| | `status` | Enum | e.g., `Draft`, `Presented`, `Approved` |
| | `subTotal` | Money | Sum of all line item extended prices. |
| | `totalTax` | Money | Sum of all taxes. |
| | `grandTotal` | Money | `subTotal` + `totalTax`. |
| `EstimateItem` | `estimateItemId` | UUID | Primary Key |
| | `estimateId` | UUID | Foreign Key to `Estimate`. |
| | `itemSeqId` | Integer | Sequential identifier within the estimate. |
| | `itemType` | Enum | `LABOR` |
| | `serviceCode` | String | Foreign Key to `ServiceCatalog` or a controlled code for custom items. |
| | `description` | String | Populated from catalog or user-entered for custom. |
| | `laborUnits` | Decimal(10,2) | e.g., hours. Must be > 0. |
| | `unitPrice` | Money | The labor rate applied. |
| | `extendedPrice`| Money | `laborUnits` * `unitPrice`. |
| | `isFlatRate` | Boolean | Flag indicating if this is a flat-rate item. |
| | `source` | Enum | `CATALOG` or `CUSTOM`. |
| | `notes` | Text | Optional notes for the technician. |

## Acceptance Criteria
### Scenario 1: Add a Standard Time-Based Labor Item
- **Given** I am a Service Advisor viewing an estimate in "Draft" status.
- **When** I search for and select a time-based labor service with code "SVC-OIL-CHG".
- **And** I enter `1.5` for the labor units.
- **Then** a new labor line item for "SVC-OIL-CHG" is added to the estimate.
- **And** the line item shows `1.5` units and the correctly defaulted labor rate.
- **And** the estimate's subtotal and grand total are recalculated and displayed correctly.

### Scenario 2: Add a Custom Labor Item
- **Given** I am a Service Advisor viewing an estimate in "Draft" status.
- **And** the system is configured to allow custom labor entry.
- **When** I choose to add a custom labor item.
- **And** I enter the description "Diagnose engine noise", `2.0` labor units, and a manual rate of `$150.00`.
- **Then** a new labor line item is added to the estimate with the specified description and values.
- **And** the estimate's totals are correctly updated.

### Scenario 3: Attempt to Add Labor with Invalid Units
- **Given** I am a Service Advisor viewing an estimate in "Draft" status.
- **When** I select a labor service and enter `-1` for the labor units.
- **Then** the system displays an error message "Labor units must be a positive number."
- **And** the labor item is not added to the estimate.
- **And** the estimate's totals remain unchanged.

## Audit & Observability
- **Audit Log:** An immutable audit event `EstimateLaborItemAdded` must be recorded when a labor item is successfully added. The event payload must contain `estimateId`, `estimateItemId`, `serviceCode`, `laborUnits`, `laborRate`, and the `userId` of the Service Advisor.
- **Metrics:**
    - `estimate.labor_item.add.success`: Counter for successful additions.
    - `estimate.labor_item.add.failure`: Counter for failed attempts (e.g., validation errors).
    - `estimate.labor_item.add.latency`: Histogram measuring the duration of the end-to-end add operation.

## Open Questions
1.  **Labor Rate Precedence:** What is the precise hierarchy and fallback logic for determining the default labor rate? (e.g., Does a customer-specific rate override a shop-level rate? What happens if no rate rule matches at all? Should it fail, or prompt for manual entry?)
2.  **Flat-Rate Behavior:** For flat-rate labor items selected from the catalog, are the `laborUnits` and `laborRate` fields editable, or are they locked to the catalog definition?

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #172 ‚Äî [BACKEND] [STORY] Estimate: Add Labor to Estimate

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Estimate: Add Labor to Estimate

**Domain**: user

### Story Description

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
Service Advisor

## Trigger
A Draft estimate exists and labor/services need to be quoted.

## Main Flow
1. User searches service catalog by service code or description.
2. User selects a service and specifies hours/units or selects a flat-rate option.
3. System defaults labor rate based on shop, role/class, and pricing rules.
4. System adds the labor line item and recalculates totals.
5. User adds notes/instructions if required for execution.

## Alternate / Error Flows
- Service not found ‚Üí allow controlled custom service entry (if enabled) with required description and labor units.
- Labor units invalid (<=0) ‚Üí block and prompt correction.

## Business Rules
- Each labor line item references a service code (or controlled custom code).
- Labor rate defaulting must be deterministic (policy-driven).
- Totals must be recalculated on labor line changes.

## Data Requirements
- Entities: Estimate, EstimateItem, ServiceCatalog, LaborRateRule, AuditEvent
- Fields: itemSeqId, serviceCode, laborUnits, laborRate, flatRateFlag, notes, taxCode

## Acceptance Criteria
- [ ] User can add labor/service line items to a Draft estimate.
- [ ] Labor pricing defaults correctly per configured rules.
- [ ] Totals update immediately after adding/editing labor items.

## Notes for Agents
Keep labor structure compatible with time-based and flat-rate models.


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #170: [BACKEND] [STORY] Estimate: Revise Estimate Prior to Approval
LABELS: type:story,domain:workexec,status:needs-review
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:workexec
- status:draft

### Recommended
- agent:workexec
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** workexec-structured
---

## Story Intent
As a Service Advisor, I want to revise a draft or pending estimate, so that I can correct errors or update the scope before it becomes a committed work order, while maintaining a clear audit trail of all changes.

## Actors & Stakeholders
- **Primary Actor**: Service Advisor - The user performing the revision of the estimate.
- **System Actors**:
    - POS System: Facilitates the estimate lifecycle, including versioning and state transitions.
    - Audit Subsystem: Records all revision events for traceability.
- **Stakeholders**:
    - Customer: Receives the accurate and updated estimate for approval.
    - Shop Manager: Relies on accurate estimates for resource planning and financial forecasting.
    - Auditor: Reviews the estimate history to ensure compliance and track changes.

## Preconditions
- An estimate exists in the system with a unique identifier.
- The estimate is in a state that permits revision, such as `Draft` or `PendingApproval`.
- The Service Advisor is authenticated and has the necessary permissions to create and modify estimates.

## Functional Behavior
### Trigger
The Service Advisor selects the "Revise" action on an estimate that is in a `Draft` or `PendingApproval` state.

### Main Success Scenario
1.  The system validates that the estimate's current state (`Draft` or `PendingApproval`) allows revision.
2.  The system creates a new version of the estimate. This new version becomes the active, editable record.
3.  The system links the new version to the previous one, preserving the chronological revision history (e.g., `v2` points to `v1` as its predecessor).
4.  The previous version's state is transitioned to `Archived` and it becomes immutable.
5.  The new, active version's state is set to `Draft`.
6.  If the previous state was `PendingApproval`, the system invalidates any associated approval requests or signatures.
7.  The Service Advisor modifies the estimate's details (e.g., adds/removes line items, changes quantities, updates pricing, adds notes).
8.  With each modification, the system automatically recalculates all dependent totals (e.g., subtotal, taxes, grand total).
9.  Upon saving, the system persists the revised estimate and records an audit event for the revision action, capturing the user, timestamp, and a summary of the change.

## Alternate / Error Flows
- **Attempt to Revise a Non-Revisable Estimate**:
    - **Trigger**: The Service Advisor attempts to revise an estimate in a terminal state (e.g., `ConvertedToWorkOrder`, `Rejected`, `Closed`).
    - **Outcome**: The system blocks the action and displays a clear error message explaining why the estimate cannot be revised (e.g., "This estimate has already been converted to a work order and cannot be revised. Please create a change order instead."). This behavior is subject to the decision in OQ1.
- **Insufficient Permissions**:
    - **Trigger**: An authenticated user without `estimate:revise` permission attempts the action.
    - **Outcome**: The system denies the request, displays an "Access Denied" message, and logs a security warning event.
- **User Abandons Revision**:
    - **Trigger**: The Service Advisor initiates a revision but navigates away or cancels the action before saving.
    - **Outcome**: The newly created draft version is discarded. The original, pre-revision version remains the active version of the estimate with its state unchanged.

## Business Rules
- An estimate can only be revised if its status is `Draft` or `PendingApproval`.
- Each revision must create a new, distinct version of the estimate. The prior version must be preserved as an immutable historical record.
- The system must maintain a sequential version number for each revision (e.g., 1, 2, 3...).
- The most recent version is always considered the "active" or "current" version of the estimate.
- Revising an estimate that is in a `PendingApproval` state MUST invalidate any outstanding approval requests and revert the estimate's status to `Draft`.

## Data Requirements
- **`Estimate` Entity**: Represents the lifecycle container for a single estimate.
    - `estimateId`: (PK) Unique identifier for the estimate.
    - `customerId`: (FK) Reference to the customer.
    - `vehicleId`: (FK) Reference to the vehicle.
    - `activeVersionId`: (FK) Reference to the current `EstimateVersion`.
- **`EstimateVersion` Entity**: Represents a specific, point-in-time version of an estimate.
    - `estimateVersionId`: (PK) Unique identifier for this specific version.
    - `estimateId`: (FK) Parent `Estimate`.
    - `versionNumber`: (Integer) Sequential version number (e.g., 1, 2, 3).
    - `status`: (String Enum) e.g., `Draft`, `PendingApproval`, `Approved`, `Rejected`, `ConvertedToWorkOrder`, `Archived`.
    - `lineItems`: (JSON/Collection) The detailed list of parts and labor.
    - `totals`: (Object) Calculated totals including subtotal, taxes, and grand total.
    - `notes`: (Text) Any notes for this version.
    - `priorVersionId`: (FK to `EstimateVersion`) Self-referencing link to the previous version, null for v1.
    - `createdBy`: (String) User ID of the creator.
    - `createdAt`: (Timestamp) Creation timestamp of this version.

## Acceptance Criteria
- **AC1: Successful Revision of a Draft Estimate**
    - **Given** an estimate exists at version 1 with a status of `Draft`.
    - **When** the Service Advisor revises the estimate by adding a new line item and saves.
    - **Then** the system creates a new `EstimateVersion` record (version 2) with the updated line item.
    - **And** the original version 1 record is updated to a status of `Archived`.
    - **And** the new version 2 record has a status of `Draft` and becomes the active version for the estimate.
- **AC2: Revision of a "Pending Approval" Estimate Invalidates Approval**
    - **Given** an estimate exists at version 1 with a status of `PendingApproval`.
    - **When** the Service Advisor initiates a revision.
    - **Then** a new `EstimateVersion` (version 2) is created with a status of `Draft`.
    - **And** any outstanding approval requests associated with version 1 are marked as `Invalidated`.
    - **And** version 1 is marked as `Archived`.
- **AC3: Attempt to Revise a Converted Estimate is Blocked**
    - **Given** an estimate has a status of `ConvertedToWorkOrder`.
    - **When** the Service Advisor attempts to revise it.
    - **Then** the system prevents the action and displays an informative error message.
- **AC4: Revision History is Preserved and Accessible**
    - **Given** an estimate has been revised three times and is currently on version 4.
    - **When** a user with appropriate permissions views the estimate's history.
    - **Then** the system can retrieve and display read-only views of versions 1, 2, and 3.

## Audit & Observability
- **Audit Events to be Logged**:
    - `estimate.revision.initiated`: Fired when a revision process begins.
    - `estimate.revision.completed`: Fired when a revision is successfully saved.
    - `estimate.approval.invalidated`: Fired when a revision causes a pending approval to be cancelled.
- **Key Fields for Audit Logs**:
    - `traceId`, `timestamp`, `eventType`
    - `userId`: The ID of the Service Advisor performing the action.
    - `estimateId`, `priorVersionNumber`, `newVersionNumber`
    - `sourceIpAddress`
- **Metrics to be Emitted**:
    - `pos.estimate.revisions.count`: (Counter) Incremented for each successful revision.
    - `pos.estimate.revisions.error.count`: (Counter) Incremented for failed revision attempts, tagged by reason (e.g., `permission_denied`, `invalid_state`).

## Open Questions
- **OQ1: Revision Policy for Converted Estimates**
    - What is the definitive business policy for handling revision attempts on an estimate that has already been `Approved` and `ConvertedToWorkOrder`?
    - **Option A**: Strictly disallow revision. The user must initiate a separate "Change Order" process for the associated Work Order.
    - **Option B**: Automatically trigger a "Change Order" workflow from this action.
    - **Decision Needed**: This decision impacts the behavior defined in Alternate Flow #1 and AC3. Option A is the safer default assumption, but this must be confirmed.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #170 ‚Äî [BACKEND] [STORY] Estimate: Revise Estimate Prior to Approval

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Estimate: Revise Estimate Prior to Approval

**Domain**: user

### Story Description

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
Service Advisor

## Trigger
A Draft or PendingApproval estimate requires changes (scope, price, quantities, fees, or notes).

## Main Flow
1. User opens the estimate and selects 'Revise'.
2. System creates a new estimate version (or revision record) linked to the prior version.
3. User edits line items and/or terms.
4. System recalculates totals and updates revision metadata.
5. System invalidates any prior approvals and sets state back to Draft (or Revision state) per policy.

## Alternate / Error Flows
- Estimate is already promoted to workorder ‚Üí disallow revision or create a change request workflow (policy).
- User lacks permission to revise after approval submission ‚Üí block and log.

## Business Rules
- Revision must preserve history and allow comparing versions.
- Any revision after approval invalidates approval.
- Revision increments version and records who/when/why.

## Data Requirements
- Entities: Estimate, EstimateRevision, ApprovalRecord, AuditEvent
- Fields: estimateId, version, status, revisionReason, revisedBy, revisedDate, priorVersionRef

## Acceptance Criteria
- [ ] System preserves revision history and allows retrieving prior versions.
- [ ] Any existing approval is invalidated on revision and recorded.
- [ ] Revised estimate totals are recalculated and stored.

## Notes for Agents
Revision history is a core audit artifact‚Äîdo not overwrite approved snapshots.


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #169: [BACKEND] [STORY] Estimate: Present Estimate Summary for Review
LABELS: type:story,domain:workexec,status:needs-review
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:workexec
- status:needs-review

### Recommended
- agent:workexec
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** workexec-structured
---

## Story Intent
As a Service Advisor, I need to generate a clean, customer-facing summary of a Draft Estimate so that I can review the proposed scope of work, pricing, and terms with the customer before they provide their approval.

## Actors & Stakeholders
- **Primary Actor:** `Service Advisor` - The user who prepares estimates and interacts with the customer.
- **Secondary Actors:**
    - `System` - The POS system responsible for generating the summary and enforcing business rules.
- **Stakeholders:**
    - `Customer` - The recipient of the estimate summary who uses it to make an approval decision.
    - `Compliance Officer` - Concerned that all required legal terms, disclaimers, and expiration dates are presented accurately.
    - `Finance Team` - Concerned that the financial figures presented to the customer are consistent with the internal estimate record.

## Preconditions
1. An `Estimate` exists with the `status` of `Draft`.
2. The `Estimate` contains at least one `EstimateItem` with defined quantities and pricing.
3. The requesting user (Service Advisor) is authenticated and has the necessary permissions to access the specified `Estimate`.
4. The system has a defined visibility policy for the `Service Advisor` role.

## Functional Behavior

### Trigger
The Service Advisor initiates an action to generate a customer-facing summary for a specific `Draft` Estimate.

### Process
1.  The System receives a request to generate a summary for a given `estimateId`.
2.  The System validates that the `Estimate` exists, is in `Draft` status, and the user is authorized.
3.  The System retrieves the complete `Estimate` record, including all associated line items, calculated totals (subtotal, taxes, fees, grand total), and metadata (e.g., `expirationDate`).
4.  The System fetches the role-based visibility policy applicable to the Service Advisor.
5.  The System constructs a data payload for the summary, explicitly excluding any fields marked as internal-only by the visibility policy (e.g., `itemCost`, `profitMargin`).
6.  The System retrieves the currently active, configured legal terms and conditions and any required disclaimers.
7.  The System renders a customer-facing document (e.g., PDF or HTML view) using the filtered data payload and the retrieved legal text.

### Outcome
- **Success:** The System presents the generated summary document to the Service Advisor for review or sharing with the customer.
- **Failure:** The System returns a structured error message indicating the reason for failure (e.g., invalid status, missing configuration).

## Alternate / Error Flows
- **Estimate Not Found:** If the `estimateId` does not correspond to an existing record, the system returns a `404 Not Found` error.
- **Invalid Estimate Status:** If the `Estimate` is not in `Draft` status (e.g., it is `Approved` or `Declined`), the system returns a `409 Conflict` error with a message "Summary can only be generated for Draft estimates."
- **Authorization Failure:** If the user lacks permission to view the estimate, the system returns a `403 Forbidden` error.
- **Missing Configuration:** If required legal terms or disclaimers are not configured in the system, the system returns a `500 Internal Server Error` (or a `409 Conflict`) with a clear error code like `CONFIGURATION_ERROR_TERMS_MISSING`.

## Business Rules
- The summary is a read-only representation of the `Estimate` at the time of generation. It does not modify the `Estimate`'s state.
- All monetary values displayed on the summary (line totals, subtotal, taxes, grand total) MUST be identical to the values stored on the `Estimate` record.
- The visibility of internal financial data (e.g., part cost, labor cost, margin) is strictly controlled by a non-negotiable, role-based security policy.
- The generation of a summary MUST be blocked if mandatory legal text (terms, disclaimers) is not configured, to prevent the creation of non-compliant documents.
- If the `Estimate` has an `expirationDate`, it MUST be clearly displayed on the summary.
**BR-SNAPSHOT-1: Immutable Snapshot Requirement**
- When an estimate summary is generated for review, the system SHALL create an immutable snapshot of:
  - All estimate line items and pricing
  - Customer information
  - Vehicle information
  - Legal terms and disclaimers (if configured)
  - Configuration state and policy settings
  - Generation timestamp and generating user
- The snapshot SHALL NOT be modified after creation
- The snapshot SHALL be used as the authoritative source for the presented estimate

**BR-LEGAL-1: Legal Terms Policy Configuration**
- The system SHALL support a configurable policy for handling missing legal terms
- Available policy options:
  - `FAIL`: Prevent estimate summary generation if legal terms are not configured (safe default)
  - `USE_DEFAULTS`: Generate estimate summary with system-configured default legal terms
- The policy SHALL be configurable per shop location or globally
- The active policy SHALL be captured in the estimate snapshot for audit purposes

**BR-LEGAL-2: Missing Legal Terms Handling**
- When policy is `FAIL` and legal terms are not configured:
  - System SHALL return error: "Cannot generate estimate summary: Legal terms and conditions not configured"
  - System SHALL log the configuration error
  - System SHALL NOT create an estimate snapshot
- When policy is `USE_DEFAULTS` and legal terms are not configured:
  - System SHALL use the system default legal terms
  - System SHALL log a warning indicating default terms were used
  - System SHALL include policy decision in snapshot metadata
- When legal terms are configured:
  - System SHALL use the configured legal terms regardless of policy
  - System SHALL include the source and version of legal terms in the snapshot

## Data Requirements
- **`Estimate` Entity:**
    - `estimateId` (PK)
    - `status` (String, Enum: 'Draft', 'Approved', etc.)
    - `subtotal` (Money)
    - `taxTotal` (Money)
    - `grandTotal` (Money)
    - `expirationDate` (Date, Nullable)
- **`EstimateItem` Entity:**
    - `description` (String)
    - `quantity` (Decimal)
    - `unitPrice` (Money)
    - `lineTotal` (Money)
    - `itemCost` (Money, Internal-Only)
- **`SystemConfiguration` Entity/Service:**
    - `customerFacingTerms` (Text)
    - `estimateDisclaimer` (Text)
- **`RoleVisibilityPolicy` Entity/Service:**
    - Defines field-level visibility rules per user role (e.g., 'Service Advisor' cannot view 'itemCost').
**EstimateSummarySnapshot**
- `snapshotId` (UUID, PK, not null) - Unique identifier for the snapshot
- `estimateId` (UUID, FK to Estimate, not null) - Reference to source estimate
- `snapshotTimestamp` (TIMESTAMP, not null) - When snapshot was created
- `snapshotData` (JSONB, not null) - Complete estimate data including line items, pricing, customer, vehicle
- `legalTermsSource` (VARCHAR(50), nullable) - Source of legal terms: 'CONFIGURED', 'DEFAULT', or null if missing
- `legalTermsVersion` (VARCHAR(50), nullable) - Version identifier of legal terms used
- `legalTermsText` (TEXT, nullable) - Full text of legal terms included in summary
- `policyMode` (VARCHAR(20), not null) - Active policy: 'FAIL' or 'USE_DEFAULTS'
- `createdBy` (UUID, FK to User, not null) - User who generated the summary
- `auditMetadata` (JSONB, not null) - Additional audit data (IP, user agent, shop location, etc.)

**LegalTermsConfiguration**
- `configId` (UUID, PK, not null) - Unique identifier
- `shopLocationId` (UUID, FK to Location, nullable) - Specific shop location (null = global)
- `termsText` (TEXT, not null) - Legal terms and disclaimers content
- `termsVersion` (VARCHAR(50), not null) - Version identifier
- `effectiveDate` (DATE, not null) - When these terms become effective
- `expirationDate` (DATE, nullable) - When these terms expire (null = no expiration)
- `isDefault` (BOOLEAN, not null, default false) - Whether this is the system default
- `createdAt` (TIMESTAMP, not null) - Creation timestamp
- `createdBy` (UUID, FK to User, not null) - User who created the configuration

**MissingLegalTermsPolicy**
- `policyId` (UUID, PK, not null) - Unique identifier
- `shopLocationId` (UUID, FK to Location, nullable) - Specific shop location (null = global)
- `policyMode` (VARCHAR(20), not null) - 'FAIL' or 'USE_DEFAULTS'
- `effectiveDate` (DATE, not null) - When this policy becomes effective
- `updatedAt` (TIMESTAMP, not null) - Last update timestamp
- `updatedBy` (UUID, FK to User, not null) - User who last updated the policy

## Acceptance Criteria
**Scenario: Successful generation of an estimate summary**
  Given an Estimate exists with the status "Draft"
  And the Estimate has a grand total of "$550.00"
  And the system is configured with standard "Terms and Conditions"
  When the Service Advisor requests a customer summary for that Estimate
  Then the system should generate a summary document
  And the document's grand total must be "$550.00"
  And the document must contain the standard "Terms and Conditions"

**Scenario: Internal cost fields are excluded from the summary**
  Given an Estimate exists with an item that has an internal "itemCost" of "$100.00"
  And the Service Advisor role is configured to hide the "itemCost" field
  When the Service Advisor requests a customer summary for that Estimate
  Then the system should generate a summary document
  And the document's content must not contain the "itemCost" field or its value

**Scenario: Attempting to generate a summary for an approved estimate**
  Given an Estimate exists with the status "Approved"
  When the Service Advisor requests a customer summary for that Estimate
  Then the system must return a "409 Conflict" error
  And provide a message indicating the action is invalid for the current status

**Scenario: Summary generation fails when legal terms are not configured**
  Given an Estimate exists with the status "Draft"
  And the system's standard "Terms and Conditions" are not configured
  When the Service Advisor requests a customer summary for that Estimate
  Then the system must return an error
  And the error must indicate that a system configuration is missing

**AC-SNAPSHOT-1: Immutable Snapshot Created**
- Given an estimate is ready for customer review
- When the service advisor generates an estimate summary
- Then the system SHALL create an immutable snapshot containing all estimate data
- And the snapshot SHALL include a unique snapshotId and timestamp
- And the snapshot SHALL be stored before presenting to the customer

**AC-LEGAL-1: Legal Terms Included When Configured**
- Given legal terms are configured for the shop location
- When an estimate summary is generated
- Then the system SHALL include the configured legal terms in the snapshot
- And the snapshot SHALL record legalTermsSource as 'CONFIGURED'
- And the snapshot SHALL include the termsVersion identifier

**AC-LEGAL-2: Policy Mode - FAIL (Safe Default)**
- Given the missing legal terms policy is set to 'FAIL'
- And legal terms are NOT configured for the shop location
- When an estimate summary generation is attempted
- Then the system SHALL prevent the generation
- And return error message: "Cannot generate estimate summary: Legal terms and conditions not configured"
- And log a configuration error event
- And NOT create an estimate snapshot

**AC-LEGAL-3: Policy Mode - USE_DEFAULTS**
- Given the missing legal terms policy is set to 'USE_DEFAULTS'
- And legal terms are NOT configured for the shop location
- When an estimate summary is generated
- Then the system SHALL use the system default legal terms
- And the snapshot SHALL record legalTermsSource as 'DEFAULT'
- And log a warning: "Estimate summary generated with default legal terms"
- And include the policy decision in snapshot metadata

**AC-LEGAL-4: Policy Configuration**
- Given an administrator is configuring missing legal terms policy
- When they set the policy mode for a shop location
- Then the system SHALL validate the mode is either 'FAIL' or 'USE_DEFAULTS'
- And store the policy with effectiveDate and updatedBy
- And the new policy SHALL be used for all subsequent estimate summaries at that location

**AC-LEGAL-5: Audit Trail Captured**
- Given any estimate summary is generated
- When the snapshot is created
- Then the system SHALL capture in auditMetadata:
  - Active policy mode
  - Legal terms source and version
  - Generating user, timestamp, and shop location
  - IP address and user agent (if available)
- And this metadata SHALL be immutable after snapshot creation

## Audit & Observability
- **Audit Log:** An immutable audit event MUST be created upon every successful generation of an estimate summary. The event must record:
    - `eventType`: `ESTIMATE_SUMMARY_GENERATED`
    - `timestamp`
    - `userId` (of the requesting Service Advisor)
    - `estimateId`
    - `traceId`
- **Monitoring:**
    - Track the latency of the summary generation endpoint (`estimate.summary.generation.latency`).
    - Increment a counter for successful generations (`estimate.summary.generation.success`).
    - Increment a counter for failed generations, tagged by error type (`estimate.summary.generation.failure{reason="invalid_status"}`).
- **Logging:** Log detailed error information for failed generation attempts, including the `estimateId` and the specific validation or configuration rule that failed.

## Answered Questions
### Question 1: Missing Terms & Conditions Policy
**Question:** If required legal terms and disclaimers are not configured in the system, should the summary generation fail with an error (as assumed in this story), or should it proceed with a warning/default text?

**Decision:** Use immutable snapshots; if legal terms are missing, handle gracefully per policy (fail or use defaults) with clear documentation.

**Interpretation:**
- The system SHALL use immutable snapshots of estimate data when generating summaries
- Legal terms and disclaimers SHALL be captured as part of the snapshot
- The handling of missing legal terms SHALL be configurable per business policy
- Policy options include:
  - **Fail** (safe default): Prevent summary generation if legal terms are not configured
  - **Use defaults**: Generate summary with system-configured default legal terms
- The chosen policy MUST be clearly documented and configurable
- All snapshots MUST include timestamp and configuration state for audit purposes

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #169 ‚Äî [BACKEND] [STORY] Estimate: Present Estimate Summary for Review

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Estimate: Present Estimate Summary for Review

**Domain**: user

### Story Description

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
Service Advisor

## Trigger
A Draft estimate is ready to be reviewed with the customer before approval submission.

## Main Flow
1. User requests a customer-facing summary view/printout.
2. System generates a summary that includes scope, quantities, pricing, taxes, fees, and totals.
3. System excludes restricted internal fields (cost, margin) based on role/policy.
4. System includes configured terms, disclaimers, and expiration date.
5. User shares summary with customer and optionally proceeds to submit for approval.

## Alternate / Error Flows
- Terms/disclaimers not configured ‚Üí use defaults or block submission depending on compliance settings.

## Business Rules
- Customer summary must be consistent with the estimate snapshot.
- Visibility rules must be enforced for internal-only fields.
- Expiration must be clearly shown if configured.

## Data Requirements
- Entities: Estimate, EstimateItem, DocumentTemplate, VisibilityPolicy
- Fields: displayPrice, taxTotal, grandTotal, termsText, expirationDate, hiddenCostFields

## Acceptance Criteria
- [ ] Customer-facing summary is generated and matches estimate totals.
- [ ] Restricted fields are not displayed to unauthorized roles.
- [ ] Summary includes terms and expiration where configured.

## Notes for Agents
This output becomes the basis for consent text during approval‚Äîkeep it deterministic.


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #168: [BACKEND] [STORY] Approval: Submit Estimate for Customer Approval
LABELS: type:story,domain:workexec,status:needs-review
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:workexec
- status:draft

### Recommended
- agent:workexec
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** workexec-structured
---

## Story Intent
**As a** Service Advisor,
**I want to** submit a completed work estimate for customer approval,
**so that** I can formalize the proposed scope of work and pricing, and trigger the customer consent process.

## Actors & Stakeholders
- **Service Advisor (Primary Actor)**: The user who prepares the estimate and initiates the submission process.
- **System (Actor)**: The POS backend system that validates the estimate, manages state transitions, creates immutable records, and logs audit events.
- **Customer (Stakeholder)**: The external party whose approval is being requested. Their information is used to generate the approval request.
- **Auditor (Stakeholder)**: Requires a verifiable and immutable record of when an estimate was submitted for approval and by whom.

## Preconditions
- The Service Advisor is authenticated and has the necessary permissions to create and submit estimates.
- An `Estimate` entity exists and is in the `Draft` state.
- The `Estimate` is associated with a valid `Customer` record.

## Functional Behavior
1.  **Trigger**: The Service Advisor initiates the "Submit for Approval" action for an estimate in the `Draft` state.
2.  **Validation**: The system performs a "completeness check" on the estimate. This validation is defined by `BR-1`.
3.  **State Transition**: Upon successful validation, the system transitions the `Estimate` status from `Draft` to `PendingApproval`.
4.  **Snapshot Creation**: The system creates an immutable `EstimateSnapshot` record. This snapshot captures the exact state of the estimate at the moment of submission (including all line items, pricing, taxes, terms, and totals). The new snapshot is versioned and linked to the `Estimate`.
5.  **Payload Generation**: The system generates an `ApprovalRequest` payload. This payload contains all necessary information for a downstream notification service to contact the customer, such as a unique approval token/link, customer contact details, and consent language.
6.  **Auditing**: The system logs a structured `EstimateSubmittedForApproval` event, capturing the details of the action as defined in the **Audit & Observability** section.

## Alternate / Error Flows
- **Flow 1: Validation Failure**
    - **Trigger**: The estimate fails the completeness check (`BR-1`).
    - **Outcome**: The system rejects the submission. The `Estimate` remains in the `Draft` state.
    - **System Feedback**: The system returns an error response detailing the specific validation rule(s) that failed (e.g., "Estimate must contain at least one line item," "Customer contact information is missing").

- **Flow 2: Invalid State**
    - **Trigger**: The user attempts to submit an estimate that is not in the `Draft` state (e.g., it is already `PendingApproval` or `Approved`).
    - **Outcome**: The system rejects the submission.
    - **System Feedback**: The system returns an error response indicating the action is invalid for the current state (e.g., "Estimate is already pending approval and cannot be submitted again").

## Business Rules
- **BR-1 (Estimate Completeness)**: An estimate can only be submitted for approval if it meets all completeness criteria. The exact criteria are pending clarification (see `OQ-1`).
- **BR-2 (State Immutability)**: Only an estimate in the `Draft` state can be transitioned to `PendingApproval` via this action.
- **BR-3 (Snapshot Immutability)**: The `EstimateSnapshot` created upon submission is immutable. Any changes to the estimate after submission require retracting the current approval request and creating a new estimate version, which then requires a new submission and snapshot.
- **BR-4 (Audit Trail)**: Every submission attempt, whether successful or failed, must be auditable. Successful submissions must generate a formal audit event.

## Data Requirements
- **Estimate**:
    - `estimateId`: Unique identifier.
    - `status`: State field, transitions from `Draft` -> `PendingApproval`.
    - `version`: Integer, incremented for each new revision.
    - `customerId`: Foreign key to the Customer entity.
- **EstimateSnapshot**:
    - `snapshotId`: Unique identifier.
    - `estimateId`: Foreign key to the parent Estimate.
    - `snapshotVersion`: Integer, corresponds to the estimate version at time of creation.
    - `snapshotData`: A structured, immutable representation (e.g., JSONB) of the complete estimate details.
    - `createdAt`: Timestamp of creation.
    - `submittedByUserId`: Identifier of the user who submitted the estimate.
- **ApprovalRequest**:
    - `approvalRequestId`: Unique identifier.
    - `estimateId`: Foreign key.
    - `snapshotId`: Foreign key to the specific snapshot being approved.
    - `approvalToken`: A unique, secure token for the customer to use for approval.
    - `status`: `Issued`, `Viewed`, `Responded`, etc.
    - `consentText`: The specific legal/consent text shown to the customer.

## Acceptance Criteria
**Scenario 1: Successful Submission of a Valid Estimate**
- **Given** an estimate is in the `Draft` state
- **And** it meets all completeness validation criteria
- **When** the Service Advisor submits the estimate for approval
- **Then** the system transitions the estimate's status to `PendingApproval`
- **And** the system creates a new, immutable `EstimateSnapshot` linked to the estimate
- **And** the system generates a corresponding `ApprovalRequest` payload
- **And** the system logs an `EstimateSubmittedForApproval` audit event.

**Scenario 2: Submission of an Incomplete Estimate**
- **Given** an estimate is in the `Draft` state
- **But** it is missing a required field (e.g., has no line items)
- **When** the Service Advisor attempts to submit the estimate for approval
- **Then** the system rejects the request
- **And** the estimate's status remains `Draft`
- **And** the system returns an error message specifying the validation failure.

**Scenario 3: Attempt to Re-submit an Estimate Already Pending Approval**
- **Given** an estimate is already in the `PendingApproval` state
- **When** the Service Advisor attempts to submit it for approval again
- **Then** the system rejects the request
- **And** the estimate's status remains `PendingApproval`
- **And** the system returns an error message indicating it is already pending approval.

## Audit & Observability
- **Event**: `EstimateSubmittedForApproval`
- **Trigger**: Successful submission of an estimate.
- **Required Log Fields**:
    - `timestamp`: ISO 8601 timestamp of the event.
    - `eventType`: `EstimateSubmittedForApproval`.
    - `eventSource`: The service name (e.g., `workexec-service`).
    - `actorId`: The unique identifier of the Service Advisor who performed the action.
    - `entityId`: `estimateId` of the submitted estimate.
    - `entityVersion`: The version number of the estimate that was submitted.
    - `details`:
        - `snapshotId`: The ID of the newly created immutable snapshot.
        - `approvalRequestId`: The ID of the generated approval request.

## Open Questions
- **OQ-1**: What are the specific, non-negotiable fields and conditions that define a "complete" estimate ready for submission? Please provide a checklist.
    - _Example considerations: Must have at least one line item? Must have non-zero total? Must have taxes calculated and present? Must customer contact information (email/phone) be present? Are terms and conditions required?_

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #168 ‚Äî [BACKEND] [STORY] Approval: Submit Estimate for Customer Approval

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Approval: Submit Estimate for Customer Approval

**Domain**: user

### Story Description

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
Service Advisor

## Trigger
A Draft estimate is complete and ready for customer consent.

## Main Flow
1. User selects 'Submit for Approval'.
2. System validates estimate completeness (required fields, items, taxes, totals, terms).
3. System transitions estimate to PendingApproval and freezes an approval snapshot.
4. System generates an approval request payload (method, link/token, consent text).
5. System logs the submission event for audit.

## Alternate / Error Flows
- Validation fails (missing taxes, missing items) ‚Üí block and show actionable errors.
- Estimate already pending approval ‚Üí prevent duplicate submissions and show status.

## Business Rules
- Only submit-ready estimates may enter PendingApproval.
- Submission creates an immutable approval snapshot version.
- Submission must be auditable (who/when).

## Data Requirements
- Entities: Estimate, ApprovalRequest, ApprovalSnapshot, AuditEvent
- Fields: status, approvalRequestId, snapshotVersion, consentText, submittedBy, submittedDate, approvalMethod

## Acceptance Criteria
- [ ] System blocks submission when required completeness checks fail.
- [ ] PendingApproval state is set and visible.
- [ ] An approval snapshot is created and referenced by the request.

## Notes for Agents
Approval snapshot must remain immutable; later revisions require resubmission.


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #166: [BACKEND] [STORY] Promotion: Create Workorder from Approved Estimate
LABELS: order,type:story,domain:workexec,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:workexec
- status:ready-for-dev

### Recommended
- agent:workexec
- agent:story-authoring

### Blocking / Risk
- none

---
**Rewrite Variant:** workexec-structured
---

## Story Intent
As a Service Advisor, I want to create a formal Workorder from an approved Estimate so that I can schedule, assign, and track the execution of authorized customer work.

## Actors & Stakeholders
- **Service Advisor (Primary Actor):** Initiates the promotion of an approved Estimate to a Workorder.
- **System (Executing Actor):** Performs the creation, linking, and state transition of the Workorder.
- **Mechanic / Technician:** Consumes the created Workorder to perform the required tasks.
- **Back Office / Shop Manager:** Audits and reports on work execution based on created Workorders.

## Preconditions
1. An `Estimate` must exist and be in the `Approved` state.
2. The approved estimate content must be captured as an immutable snapshot at approval time.
3. The initiating user (Service Advisor) must have the `workorder:create` permission for the associated shop.

## Functional Behavior
### Happy Path: Promoting an Approved Estimate
1. **Trigger:** A Service Advisor initiates the "Promote to Workorder" action on an `Approved` `Estimate`.
2. **Workorder Creation:** The System creates a new `Workorder` header record.
3. **Source Linking:** The System creates an immutable link from the `Workorder` to:
   - The `Estimate` (`sourceEstimateId`)
   - The audit event ID that recorded the approval (`sourceApprovalEventId`)
4. **Task Population:** The System creates line item records for each item on the approved estimate:
   - Service lines ‚Üí `WorkOrderService` records with `sourceEstimateLineItemId`
   - Part lines ‚Üí `WorkOrderPart` records with `sourceEstimateLineItemId`
5. **Data Snapshotting:** The System captures customer and vehicle data in a `WorkOrderSnapshot` record with type `PROMOTION`, containing:
   - Customer snapshot: name, billing address, primary contact info, account type
   - Vehicle snapshot: VIN, year/make/model, mileage at promotion
   - Promotion metadata: workorderId, estimateId, sourceApprovalEventId, promotingUserId, shopId, timestamp
6. **State Initialization:** The System sets the initial status of the new `Workorder` to `APPROVED`.
7. **Confirmation:** The System returns a success confirmation with the new `Workorder ID` to the user.

## Alternate / Error Flows
- **Estimate Not in Approved State:**
  - If the "Promote to Workorder" action is attempted on an `Estimate` that is not in the `Approved` state, the System MUST reject the request with an error message (e.g., "Estimate must be approved before creating a workorder."). The operation MUST be rolled back, and no `Workorder` should be created.

- **Idempotent Promotion:**
  - If the action is triggered a second time for an `Estimate` that has already been successfully promoted, the System MUST NOT create a duplicate `Workorder`. The system should check for an existing active workorder via `findByEstimateId` repository method and return a reference to the existing `Workorder` with a notification that the workorder already exists. Note: Cancelled workorders still count for idempotency; re-promotion requires a new estimate.

- **System Configuration Error:**
  - If any system configuration required for workorder creation is missing or invalid, the transaction MUST fail and be completely rolled back. An error MUST be logged for system administrators with high severity.

## Business Rules
- A single `Approved Estimate` can be promoted to exactly one active `Workorder`.
- The `Workorder` must maintain an immutable reference to the `Estimate` and the approval audit event ID.
- Customer and Vehicle data are captured in a `WorkOrderSnapshot` at the time of promotion and MUST NOT be updated if the master `Customer` or `Vehicle` records change later.
- The initial status of a new `Workorder` is `APPROVED`.
- Idempotency is enforced at the service layer. One active workorder per estimate; cancelled workorders count for idempotency.
- Role-based access controls (RBAC) for viewing workorder data are **out of scope** for this story and will be addressed in a separate security/RBAC story.

## Data Requirements
- **`Workorder` Entity (existing):**
  - `workorderId` (PK)
  - `status` (set to `APPROVED` initially)
  - `shopId` (FK)
  - `sourceEstimateId` (FK, immutable) - direct link to Estimate
  - `sourceApprovalEventId` (FK, immutable) - audit event ID that recorded the approval
  - `createdTimestamp`
  - `createdByUserId`
  
- **`WorkOrderService` Entity (existing):**
  - Add field: `sourceEstimateLineItemId` (FK, immutable) - links to service line on estimate
  - Existing fields: `workorderId`, `description`, `notes`, etc.
  
- **`WorkOrderPart` Entity (existing):**
  - Add field: `sourceEstimateLineItemId` (FK, immutable) - links to part line on estimate
  - Existing fields: `workorderId`, `description`, `notes`, etc.
  
- **`WorkOrderSnapshot` Entity (existing, enhanced):**
  - `snapshotId` (PK)
  - `workorderId` (FK)
  - `snapshotType` (e.g., `PROMOTION`)
  - `snapshotData` (JSON/TEXT) containing:
    - Customer snapshot: name, billing address, primary contact info, account type
    - Vehicle snapshot: VIN, year, make, model, mileage at promotion
    - Promotion metadata: estimateId, sourceApprovalEventId, promotingUserId, shopId
  - `timestamp`

## Acceptance Criteria
- **AC-1: Successful Workorder Creation from Approved Estimate**
  - **Given** an `Estimate` is in the `Approved` state
  - **And** the system is configured to create workorders with initial status `APPROVED`
  - **When** a Service Advisor promotes the estimate to a Workorder
  - **Then** a new `Workorder` record is created in the database
  - **And** the `Workorder` status is `APPROVED`
  - **And** the `Workorder` is linked to the `Estimate` via `sourceEstimateId`
  - **And** the `Workorder` is linked to the approval audit event via `sourceApprovalEventId`
  - **And** a `WorkOrderSnapshot` record with type `PROMOTION` is created containing customer and vehicle snapshots and promotion metadata.

- **AC-2: Line Items Mapped Correctly**
  - **Given** an approved estimate has 2 service lines and 3 part lines
  - **When** the estimate is promoted to a workorder
  - **Then** 2 `WorkOrderService` records are created with `sourceEstimateLineItemId` linking back to the estimate service lines
  - **And** 3 `WorkOrderPart` records are created with `sourceEstimateLineItemId` linking back to the estimate part lines.

- **AC-3: Idempotency of Promotion Action**
  - **Given** an `Approved Estimate` has already been promoted to `Workorder-123`
  - **When** a user attempts to promote the same `Approved Estimate` again
  - **Then** the system does not create a new `Workorder`
  - **And** the system returns a response indicating `Workorder-123` already exists for this estimate.

- **AC-4: Promotion is Rejected for Non-Approved Estimate**
  - **Given** an `Estimate` exists in a `Draft` state
  - **When** a user attempts to promote this estimate to a Workorder
  - **Then** the system rejects the operation
  - **And** no `Workorder` is created
  - **And** an error message is returned to the user.

- **AC-5: Customer and Vehicle Data is Snapshotted Correctly**
  - **Given** an approved estimate for "John Doe" at "123 Main St" is promoted to `Workorder-456`
  - **And** the promotion creates a `WorkOrderSnapshot` with customer address "123 Main St"
  - **When** the master `Customer` record for "John Doe" is updated to "456 Oak Ave"
  - **Then** the customer address stored in the `WorkOrderSnapshot` for `Workorder-456` remains "123 Main St".

## Audit & Observability
- **Snapshot Record:** A `WorkOrderSnapshot` record with type `PROMOTION` must be created upon successful promotion.
- **Snapshot Payload:** The snapshot must contain:
  - Customer snapshot: name, billing address, primary contact info, account type
  - Vehicle snapshot: VIN, year, make, model, mileage at promotion
  - Promotion metadata: workorderId, estimateId, sourceApprovalEventId, promotingUserId, shopId, timestamp
- **Metrics:**
  - A counter metric `workorder_creation_total` should be incremented.
  - The metric should be tagged with `source:estimate` and `shopId`.
- **Logging:** Log an error with high severity if the promotion fails due to a system misconfiguration or validation error.

## Out of Scope
- **Role-Based Access Controls (RBAC):** Filtering workorder data visibility based on user roles (e.g., hiding prices from mechanics) is explicitly **out of scope** for this story. This will be addressed in a separate security/RBAC story.

## Implementation Notes
- Use existing `WorkOrder`, `WorkOrderService`, `WorkOrderPart`, and `WorkOrderSnapshot` entities.
- Add `sourceEstimateLineItemId` field to `WorkOrderService` and `WorkOrderPart` entities.
- Add `sourceEstimateId` and `sourceApprovalEventId` fields to `WorkOrder` entity.
- Implement service-layer idempotency check using `findByEstimateId` repository method.
- Initial workorder status is hard-coded to `APPROVED` for this flow in v1.
- Promotion snapshot type is `PROMOTION`.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #166 ‚Äî [BACKEND] [STORY] Promotion: Create Workorder from Approved Estimate

## Current Labels
- backend
- story-implementation
- order

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Promotion: Create Workorder from Approved Estimate

**Domain**: order

### Story Description

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
Service Advisor / Back Office

## Trigger
Promotion preconditions are satisfied for an approved estimate.

## Main Flow
1. System creates a Workorder header using customer and vehicle context from the estimate snapshot.
2. System links workorder to estimate version and approval record.
3. System sets workorder initial state (e.g., Ready or Scheduled) per configuration.
4. System applies role-based visibility rules (e.g., hide prices for mechanics).
5. System records the promotion event for audit.

## Alternate / Error Flows
- Workorder creation fails due to validation/config error ‚Üí rollback and report error.
- Promotion retried after partial failure ‚Üí idempotent recovery.

## Business Rules
- Workorder must reference estimate snapshot and approval record.
- Initial state is policy-driven.
- Promotion must be auditable.

## Data Requirements
- Entities: Workorder, Estimate, ApprovalRecord, AuditEvent
- Fields: workorderId, status, estimateId, estimateVersion, approvalId, shopId, createdBy, createdDate

## Acceptance Criteria
- [ ] A workorder is created and linked to the approved estimate snapshot.
- [ ] Initial workorder state matches configuration.
- [ ] Audit trail shows who promoted and when.

## Notes for Agents
Keep promotion atomic: either you have a valid workorder, or you have nothing.


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #162: [BACKEND] [STORY] Promotion: Record Promotion Audit Trail
LABELS: type:story,domain:workexec,status:needs-review
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:workexec
- status:ready-for-dev

### Recommended
- agent:workexec
- agent:story-authoring

---

**Rewrite Variant:** workexec-structured

## Story Intent
As a Shop Manager or Auditor, I need a non-repudiable audit trail created whenever a service estimate is promoted to a work order, so that I can trace the exact state of what was approved, who approved it, and when it was converted into executable work, ensuring accountability and resolving potential customer disputes.

## Actors & Stakeholders
- **Primary Actor:**
  - **System:** The automated process responsible for creating and persisting the audit record upon a successful promotion event.
- **Stakeholders:**
  - **Service Advisor:** The user role that typically initiates the promotion of an estimate to a work order.
  - **Shop Manager / Auditor:** The user roles that review and rely on the audit trail for operational oversight, quality control, and dispute resolution.
  - **Customer:** The indirect beneficiary who is assured that work is performed based on an agreed-upon and versioned estimate.

## Preconditions
- A valid \`Estimate\` exists in a promotable state (e.g., \`APPROVED\`).
- An \`ApprovalRecord\` associated with the \`Estimate\` exists, capturing customer consent.
- The user initiating the promotion is authenticated and has the necessary permissions (e.g., \`WORKORDER_CREATE\`).
- The system has successfully validated that the \`Estimate\` can be converted into a \`WorkOrder\`.

## Functional Behavior
### Trigger
The \`EstimatePromotedToWorkOrder\` business event is successfully completed within the Work Execution domain.

### Main Success Scenario
1.  Upon successful creation of a \`WorkOrder\` from an \`Estimate\`, the system initiates the audit trail creation process within the same transaction.
2.  The system creates a new, immutable \`PromotionAuditEvent\` record.
3.  The system populates the audit record with the following information:
    - A unique identifier for the audit event (\`auditEventId\`).
    - The identifier of the user who initiated the promotion (\`promotingUserId\`).
    - A precise, server-generated timestamp (\`eventTimestamp\`).
    - A reference to the newly created \`WorkOrder\` (\`workorderId\`).
    - A reference to the source \`Estimate\` (\`estimateId\`).
    - A **critical** reference to the specific, versioned snapshot of the estimate that was promoted (\`estimateSnapshotId\`). This ensures the audit trail points to the exact state of the estimate at the moment of promotion.
    - A reference to the \`ApprovalRecord\` that authorized the work (\`approvalId\`).
4.  The system calculates and stores a summary of the promoted items (e.g., \`{"total_cost": 1250.75, "labor_items": 3, "part_items": 5}\`) within the audit record for efficient retrieval and display.
5.  The system transactionally commits the new \`WorkOrder\`, its related state changes, and the \`PromotionAuditEvent\` record together.

## Alternate / Error Flows
- **Audit Record Creation Fails:**
  - If, for any reason (e.g., database connection issue, constraint violation), the \`PromotionAuditEvent\` record cannot be persisted, the entire parent transaction for the work order promotion **MUST** be rolled back.
  - No new \`WorkOrder\` will be created, and the source \`Estimate\` will revert to its pre-promotion state.
  - The system will log a \`CRITICAL\` error detailing the failure to create the audit record, as this represents a failed business-critical transaction.

## Business Rules
- **Atomicity of Promotion:** The creation of a \`WorkOrder\` from an \`Estimate\` and the creation of its corresponding \`PromotionAuditEvent\` are an atomic, all-or-nothing operation.
- **Immutability:** Once created, a \`PromotionAuditEvent\` record is immutable and cannot be altered or deleted through standard application workflows.
- **Traceability Mandate:** The audit trail must always link to a versioned, point-in-time snapshot of the estimate, not a live or mutable version.
- **Access Control:** The visibility of promotion audit records in the UI or via APIs is restricted to authorized roles (e.g., \`SHOP_MANAGER\`, \`SYSTEM_AUDITOR\`).

## Data Requirements
- **Entity:** \`PromotionAuditEvent\`
- **Fields:**
  - \`auditEventId\`: (PK) Unique identifier for the audit record.
  - \`workorderId\`: (FK, Indexed) Reference to the \`WorkOrder\` entity.
  - \`estimateId\`: (FK, Indexed) Reference to the source \`Estimate\` entity.
  - \`estimateSnapshotId\`: (FK, Indexed) **Non-negotiable** reference to the immutable version of the estimate.
  - \`approvalId\`: (FK) Reference to the \`ApprovalRecord\` entity.
  - \`promotingUserId\`: (FK, Indexed) Reference to the \`User\` who initiated the event.
  - \`eventTimestamp\`: (TimestampTZ) High-precision timestamp of the event.
  - \`eventType\`: (Text) A constant value, e.g., \`ESTIMATE_PROMOTED_TO_WORK_ORDER\`.
  - \`promotionSummary\`: (JSONB) A structured object containing key metrics like total cost, item counts, etc., for performance reasons.

## Acceptance Criteria
### Scenario 1: Successful Promotion and Audit Trail Creation
- **Given** an \`Estimate\` with ID \`E-101\` and snapshot ID \`ES-v3\` is in an \`APPROVED\` state
- **And** a user with sufficient permissions is logged in
- **When** the user successfully promotes \`Estimate\` \`E-101\` to a new \`WorkOrder\` \`WO-552\`
- **Then** the system MUST create a \`PromotionAuditEvent\` record
- **And** the audit record MUST reference \`workorderId: WO-552\`
- **And** the audit record MUST reference \`estimateSnapshotId: ES-v3\`
- **And** the audit record MUST contain the ID of the logged-in user
- **And** the \`promotionSummary\` field in the audit record must accurately reflect the totals from \`Estimate\` snapshot \`ES-v3\`.

### Scenario 2: Promotion Fails if Audit Record Cannot Be Saved
- **Given** a user is promoting an \`APPROVED\` \`Estimate\` \`E-102\`
- **And** the system successfully creates a \`WorkOrder\` in-memory
- **When** the system attempts to save the \`PromotionAuditEvent\` but encounters a database write error
- **Then** the entire promotion transaction MUST be rolled back
- **And** no new \`WorkOrder\` corresponding to \`E-102\` will exist in the database
- **And** the \`Estimate\` \`E-102\` MUST remain in the \`APPROVED\` state
- **And** a critical error MUST be logged indicating the audit failure.

## Audit & Observability
- **Logging:**
  - \`INFO\`: Log the successful creation of a \`PromotionAuditEvent\` including the \`auditEventId\`, \`workorderId\`, and \`promotingUserId\`.
  - \`ERROR\` / \`CRITICAL\`: Log any failure to create a \`PromotionAuditEvent\`, as this indicates a failed core business transaction. Include the stack trace and relevant context (e.g., \`estimateId\`).
- **Metrics:**
  - \`promotions.success.count\`: (Counter) Increment on every successful promotion and audit record creation.
  - \`promotions.failure.audit.count\`: (Counter) Increment when a promotion is rolled back due to an audit write failure.
- **Alerting:**
  - Configure a high-priority alert if the \`promotions.failure.audit.count\` metric increments, as this may signal a systemic issue with the database or audit subsystem.

## Domain Conflict Resolution

**Decision: Confirmed ‚Äî \`domain:workexec\` is the single, authoritative domain.**

**Rationale:**
The promotion audit trail records a **state transition within the estimate ‚Üí work order lifecycle**, which is owned by **Workorder Execution**. The \`domain:user\` reference found in the original story metadata was a classification error. While user context (actor identity) is captured as an attribute of the audit record, this does not make it the owning domain. The business process of promoting an estimate to a work order is fundamentally a work execution lifecycle operation.

**Classification Correction:**
- **Primary Domain:** \`domain:workexec\` ‚úÖ
- **Incorrect Reference:** \`domain:user\` (removed) ‚ùå
- **No Story Split Required:** This is a single, cohesive story. The conflict was purely a metadata classification error, not a functional ambiguity.

**Status:** Unblocked and ready for implementation.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #162 ‚Äî [BACKEND] [STORY] Promotion: Record Promotion Audit Trail

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Promotion: Record Promotion Audit Trail

**Domain**: user

### Story Description

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
System

## Trigger
A promotion event completes successfully.

## Main Flow
1. System records an audit event including who initiated promotion and when.
2. System records the estimate snapshot version and approval reference used.
3. System stores a summary of items promoted (counts, totals) for quick review.
4. System links audit record to the workorder and estimate.
5. System exposes audit record in UI for authorized roles.

## Alternate / Error Flows
- Audit write fails ‚Üí fail promotion or retry per strictness policy (recommended: fail).

## Business Rules
- Promotion must be auditable and traceable.
- Audit must reference the exact snapshot promoted.

## Data Requirements
- Entities: AuditEvent, Workorder, Estimate, ApprovalRecord
- Fields: eventType, actorUserId, timestamp, estimateId, snapshotVersion, approvalId, workorderId, summaryTotals

## Acceptance Criteria
- [ ] Promotion event is stored and retrievable.
- [ ] Audit record references estimate snapshot and approval.
- [ ] Audit record shows summary totals and item counts.

## Notes for Agents
Audit isn't optional‚Äîthis protects you in customer disputes.


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #161: [BACKEND] [STORY] Execution: Assign Technician to Workorder
LABELS: type:story,domain:workexec,status:needs-review
BODY:
STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:workexec
- status:draft

### Recommended
- agent:workexec
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** workexec-structured
---

## Story Intent
**As a** Shop Manager or Dispatcher,
**I want to** assign a specific Technician to a Workorder that is ready for execution,
**so that** accountability for the work is established, the Technician is enabled to perform the work, and the assignment is tracked for operational reporting.

## Actors & Stakeholders
- **Primary Actor:** `Shop Manager` / `Dispatcher` - The user responsible for assigning work.
- **Secondary Actor:** `Technician` - The user who is assigned the work and requires visibility into the Workorder.
- **System Actor:** `POS System` - The system of record that processes the assignment, enforces rules, and records audit trails.
- **Stakeholders:**
    - `Service Advisor`: Needs to know which Technician is responsible for a customer's Workorder.
    - `Operations Manager`: Reviews assignment history and metrics for shop performance.

## Preconditions
- A Workorder exists with a status that permits assignment (e.g., `SCHEDULED`, `READY_FOR_WORK`).
- A list of eligible `Technician` users exists in the system.
- The `Shop Manager` is authenticated and possesses the `WORKORDER_ASSIGN` permission.

## Functional Behavior

### 4.1. Happy Path: Assigning a Technician
1.  **Trigger:** The `Shop Manager` selects a Workorder in an assignable state and initiates the "Assign Technician" action.
2.  The system presents a list of available Technicians.
3.  The `Shop Manager` selects a Technician from the list.
4.  The system validates that the selected Technician is eligible for assignment.
5.  The system creates a new `TechnicianAssignment` record, linking the `Workorder`, the `Technician`, and the `Shop Manager` (`assignedByUserId`). The record is marked as `isActive=true` and `assignedAt` is set to the current timestamp.
6.  If a previous active assignment exists for this Workorder, the system deactivates it by setting `isActive=false` and populating `unassignedAt`.
7.  The system updates the `Workorder`'s status to `ASSIGNED`.
8.  The system grants the assigned `Technician` the necessary visibility/permissions to view and interact with the Workorder.
9.  The system emits a `WorkorderTechnicianAssigned` event for downstream consumers (e.g., auditing, notifications).

## Alternate / Error Flows
- **Flow 5.1: Unauthorized Assignment Attempt**
    1. A user without the `WORKORDER_ASSIGN` permission attempts to assign a Technician.
    2. The system rejects the request with a `403 Forbidden` error and logs the security violation.
- **Flow 5.2: Assignment to a Workorder in a Non-Assignable State**
    1. A `Shop Manager` attempts to assign a Technician to a Workorder with a status of `COMPLETED` or `CANCELED`.
    2. The system rejects the request with a `409 Conflict` or `400 Bad Request` error, indicating the Workorder is not in a valid state for assignment.
- **Flow 5.3: Assignment of an Ineligible User**
    1. A `Shop Manager` attempts to assign a user who is not a `Technician` (e.g., a `Service Advisor`).
    2. The system rejects the request with a `400 Bad Request` error.
- **Flow 5.4: Technician is Unavailable (Requires Clarification)**
    1. See Open Questions. The system behavior (warn vs. block) for assigning a Technician who is unavailable (e.g., on leave, already over-allocated) is undefined.

## Business Rules
- **Rule 6.1 (Single Primary Assignment):** A Workorder can have only one `isActive=true` `TechnicianAssignment` at any given time.
- **Rule 6.2 (Immutable History):** `TechnicianAssignment` records are immutable. A reassignment deactivates the existing record and creates a new one; records are never deleted.
- **Rule 6.3 (Role-Based Access):** Only users with the `WORKORDER_ASSIGN` permission can create or modify assignments.
- **Rule 6.4 (Visibility Control):** A Technician can only view the details of a Workorder if they have an active assignment to it (or possess higher-level permissions).

## Data Requirements
- **Entity: `TechnicianAssignment`**
    - `assignmentId` (UUID, PK): Unique identifier for the assignment record.
    - `workorderId` (UUID, FK): Foreign key to the `Workorder` entity.
    - `technicianId` (UUID, FK): Foreign key to the `User` entity representing the technician.
    - `assignedByUserId` (UUID, FK): Foreign key to the `User` entity who performed the assignment.
    - `assignedAt` (TimestampTZ): The exact time the assignment was made.
    - `unassignedAt` (TimestampTZ, Nullable): The time the assignment was superseded.
    - `isActive` (Boolean): Flag indicating if this is the current, active assignment.

## Acceptance Criteria

### AC 8.1: Successful Technician Assignment
- **Given** a `Workorder` exists with status `SCHEDULED`.
- **And** the `Shop Manager` has the `WORKORDER_ASSIGN` permission.
- **When** the `Shop Manager` assigns `Technician A` to the `Workorder`.
- **Then** the system creates a new `TechnicianAssignment` record with `workorderId`, `technicianId` for `Technician A`, and `isActive=true`.
- **And** the `Workorder` status transitions to `ASSIGNED`.
- **And** `Technician A` can now view the details of that `Workorder`.

### AC 8.2: Reassignment Creates History
- **Given** `Technician A` is actively assigned to a `Workorder`.
- **When** the `Shop Manager` reassigns the `Workorder` to `Technician B`.
- **Then** the original `TechnicianAssignment` record for `Technician A` is updated to `isActive=false` and `unassignedAt` is populated.
- **And** a new `TechnicianAssignment` record is created for `Technician B` with `isActive=true`.
- **And** the `Workorder` status remains `ASSIGNED`.
- **And** `Technician A` loses default access to the Workorder, while `Technician B` gains it.

### AC 8.3: Unauthorized User Cannot Assign
- **Given** a `Workorder` exists with status `SCHEDULED`.
- **And** a user with the `SERVICE_ADVISOR` role (lacking `WORKORDER_ASSIGN` permission) is logged in.
- **When** the user attempts to assign a Technician to the `Workorder`.
- **Then** the system must reject the operation with a `403 Forbidden` status.
- **And** no `TechnicianAssignment` record is created or modified.

## Audit & Observability
- **Event Logging:**
    - An event `WorkorderTechnicianAssigned` MUST be published on successful assignment. Event payload should include `workorderId`, `technicianId`, `assignedByUserId`, and `assignedAt`.
    - An event `WorkorderTechnicianUnassigned` MUST be published upon reassignment for the previous technician. Payload should include `workorderId`, `technicianId`, and `unassignedAt`.
- **Application Logging:**
    - Log successful assignment actions at `INFO` level, including relevant IDs.
    - Log failed assignment attempts (e.g., permission denied, invalid state) at `WARN` level.
    - Log unexpected system errors during assignment at `ERROR` level.

## Open Questions
1.  **Technician Availability Policy:** The original story mentions "Technician unavailable ‚Üí system prevents assignment or warns based on schedule policy."
    - **Question:** What is the authoritative source for technician availability/schedule? Is it a separate `Schedules` domain?
    - **Question:** What is the precise business rule? Should the system hard-block an assignment or show a soft warning that the manager can override?
2.  **Technician Notification:** The original story mentions "System optionally notifies technician."
    - **Question:** What channels are required for notification (e.g., in-app, SMS, email)?
    - **Question:** Who configures this "optional" behavior (e.g., system-wide, per-location, per-user)?
    - **Question:** What is the required content of the notification message?

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #161 ‚Äî [BACKEND] [STORY] Execution: Assign Technician to Workorder

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Execution: Assign Technician to Workorder

**Domain**: user

### Story Description

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
Shop Manager / Dispatcher

## Trigger
A workorder is Ready/Scheduled and needs assignment.

## Main Flow
1. User selects a workorder and opens assignment controls.
2. User assigns a primary technician or crew.
3. System records assignment timestamp and assigns visibility to the technician.
4. System optionally notifies technician.
5. System records assignment history on reassignment.

## Alternate / Error Flows
- Technician unavailable ‚Üí system prevents assignment or warns based on schedule policy.
- Unauthorized role tries assignment ‚Üí block.

## Business Rules
- Assignment history must be retained.
- Workorder visibility is role-based.

## Data Requirements
- Entities: Workorder, TechnicianAssignment, User, Notification
- Fields: workorderId, technicianId, assignedBy, assignedAt, unassignedAt, reason

## Acceptance Criteria
- [ ] Technician can be assigned and sees the workorder.
- [ ] Assignment changes are tracked with history.
- [ ] Unauthorized users cannot assign.

## Notes for Agents
Assignment data feeds execution metrics; keep it clean and auditable.


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #160: [BACKEND] [STORY] Execution: Start Workorder and Track Status
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:workexec
- status:ready-for-dev

### Recommended
- agent:workexec
- agent:story-authoring

---

**Rewrite Variant:** workexec-structured

## Story Intent
**As a** Technician or Shop Manager,
**I want to** formally start a work order and track its granular status changes,
**so that** the shop has an accurate, real-time view of work in progress and can measure operational efficiency.

## Actors & Stakeholders
- **Technician:** The primary actor who performs the work and updates the work order status.
- **Shop Manager:** A secondary actor who oversees shop operations, assigns work, and may also start work orders or track their status.
- **System:** The POS/Shop Management System responsible for enforcing state transitions, validating rules, and recording events.

## Preconditions
1. The user (Technician or Shop Manager) is authenticated and has the necessary permissions to view and modify the work order.
2. A `WorkOrder` entity exists with a unique identifier.
3. The `WorkOrder` is in one of the startable states: `APPROVED`, `ASSIGNED`, or `SCHEDULED`.
4. No active `ChangeRequest` with `status = PENDING_APPROVAL` and `requiresWorkHold = true` is blocking the work order.

## Functional Behavior

### Main Flow: Starting a Work Order

1. The user navigates to a specific, assigned `WorkOrder` that is in a startable state (`APPROVED`, `ASSIGNED`, or `SCHEDULED`).
2. The user initiates a "Start Work" action via `POST /workexec/v1/workorders/{id}:start`.
3. The System validates that:
   - The `WorkOrder` is in one of the three startable states.
   - No blocking `ChangeRequest` exists (see Business Rules below).
4. Upon successful validation, the System performs the following atomic operations:
   - Transitions the `WorkOrder` status to `WORK_IN_PROGRESS`.
   - Sets the `inProgressReason` to `ACTIVE_WORK` (default).
   - Records the current UTC timestamp as `workStartedAt`.
   - Creates an entry in the `WorkOrderStatusHistory` to log this transition.
5. The user can subsequently update the `WorkOrder`'s `inProgressReason` (sub-status) while remaining in `WORK_IN_PROGRESS` (e.g., `WAITING_PARTS`, `WAITING_CUSTOMER_APPROVAL`).
6. Each reason change is validated and recorded in the `WorkOrderStatusHistory`.

### Sub-Status (In-Progress Reason) Tracking

While a work order is in `WORK_IN_PROGRESS`, the system tracks the reason/sub-status via the `inProgressReason` enum field without transitioning the canonical status. Allowed values are:

- `ACTIVE_WORK` (default, work proceeding normally)
- `WAITING_PARTS` (awaiting parts arrival)
- `WAITING_CUSTOMER_APPROVAL` (awaiting customer decision)
- `WAITING_DIAGNOSIS` (awaiting diagnostic results)
- `WAITING_EXTERNAL_SERVICE` (e.g., sublet, vendor work)
- `PAUSED_BY_SHOP` (temporary operational pause)

**Audit Behavior:**
- Transitions into/out of `WORK_IN_PROGRESS` are audited as true status changes.
- Changes to `inProgressReason` are audited as reason changes (separate audit record type).

## Alternate / Error Flows

1. **Attempt to Start Non-Startable Work Order:**
   - **Trigger:** A user attempts to start a `WorkOrder` that is not in `APPROVED`, `ASSIGNED`, or `SCHEDULED` state.
   - **Outcome:** The System rejects the action with error message: "Work order cannot be started. It is currently in '[current_status]' status."

2. **Attempt to Start Work Order with Blocking Change Request:**
   - **Trigger:** A user attempts to start work, but the `WorkOrder` has an active `ChangeRequest` with `status = PENDING_APPROVAL` and `type` in `[SCOPE_CHANGE, PRICE_INCREASE, PART_SUBSTITUTION_REQUIRING_APPROVAL]`.
   - **Outcome:** The System blocks the "Start Work" action with message: "Cannot start work. A pending change request requires approval before proceeding."

3. **Change Reason Within WORK_IN_PROGRESS (Not a State Change):**
   - **Trigger:** Technician changes `inProgressReason` from `ACTIVE_WORK` to `WAITING_PARTS`.
   - **Outcome:** System updates the field without creating a status-change audit record; instead, a reason-change audit record is created.

## Business Rules

1. **Startable States (exhaustive, v1):**
   - A `WorkOrder` can transition to `WORK_IN_PROGRESS` **only** from: `APPROVED`, `ASSIGNED`, `SCHEDULED`.
   - All other states (`DRAFT`, `PENDING_APPROVAL`, `CANCELLED`, `CLOSED`, `INVOICED`, `VOIDED`, `ON_HOLD`, `COMPLETED`, `LOCKED_FOR_REVIEW`, `ARCHIVED`) are **not startable**.

2. **Status Irreversibility:**
   - Once a `WorkOrder` is in `WORK_IN_PROGRESS`, it cannot revert to a pre-work status like `APPROVED` or `ASSIGNED`.

3. **Blocking Change Requests:**
   - If a `ChangeRequest` linked to the `WorkOrder` exists where:
     - `status = PENDING_APPROVAL`
     - `type` is in `[SCOPE_CHANGE, PRICE_INCREASE, PART_SUBSTITUTION_REQUIRING_APPROVAL]` **or** `requiresWorkHold = true`
   - Then the work order **cannot be started** until the change request is resolved (approved or rejected).

4. **In-Progress Reason (Sub-Status):**
   - The `inProgressReason` field is **only valid** while `status = WORK_IN_PROGRESS`.
   - Changes to `inProgressReason` do not alter the canonical status; they are audited separately.

5. **Immutable History:**
   - All status transitions and reason changes must be recorded in an immutable `WorkOrderStatusHistory` log.

6. **Auto-Start is Out of Scope:**
   - This story implements **explicit start only** via API call.
   - Auto-start on first labor entry is a **separate follow-on story** and is not addressed here.

## Data Requirements

### WorkOrder Entity (additions)
- `id` (UUID, PK)
- `statusId` (ENUM/String, e.g., `WORK_IN_PROGRESS`)
- `inProgressReason` (ENUM, nullable, allowed values: `ACTIVE_WORK`, `WAITING_PARTS`, `WAITING_CUSTOMER_APPROVAL`, `WAITING_DIAGNOSIS`, `WAITING_EXTERNAL_SERVICE`, `PAUSED_BY_SHOP`)
- `workStartedAt` (TimestampZ, nullable)

### WorkOrderStatusHistory Entity
- `id` (UUID, PK)
- `workOrderId` (UUID, FK to `WorkOrder`, indexed)
- `fromStatusId` (ENUM/String, nullable for initial creation)
- `toStatusId` (ENUM/String, not null)
- `reason` (String, optional user-provided reason)
- `changedByUserId` (UUID, the user who initiated the change)
- `changedAtTimestamp` (TimestampZ, UTC)
- `changeType` (ENUM: `STATUS_CHANGE` or `REASON_CHANGE`, for audit distinction)

### ChangeRequest Entity (referenced)
- `id` (UUID, PK)
- `workOrderId` (UUID, FK to `WorkOrder`, indexed)
- `status` (ENUM, e.g., `PENDING_APPROVAL`, `APPROVED`, `REJECTED`)
- `type` (ENUM, e.g., `SCOPE_CHANGE`, `PRICE_INCREASE`, `PART_SUBSTITUTION_REQUIRING_APPROVAL`)
- `requiresWorkHold` (Boolean, derived from type or explicit flag)

## Acceptance Criteria

### AC1: Successfully Start a Work Order from APPROVED State
- **Given** a work order exists in an `APPROVED` state
- **And** I am an authenticated Technician
- **When** I trigger `POST /workexec/v1/workorders/{id}:start`
- **Then** the work order's status must transition to `WORK_IN_PROGRESS`
- **And** the `inProgressReason` must be set to `ACTIVE_WORK`
- **And** the `workStartedAt` field must be populated with the current UTC time
- **And** a new record must be created in `WorkOrderStatusHistory` with `changeType = STATUS_CHANGE`, documenting the change from `APPROVED` to `WORK_IN_PROGRESS`.

### AC2: Start from ASSIGNED State
- **Given** a work order exists in an `ASSIGNED` state
- **And** I am an authenticated Technician
- **When** I trigger the start action
- **Then** the transition succeeds with the same outcomes as AC1.

### AC3: Start from SCHEDULED State
- **Given** a work order exists in a `SCHEDULED` state
- **When** I trigger the start action
- **Then** the transition succeeds with the same outcomes as AC1.

### AC4: Reject Start from Non-Startable State
- **Given** a work order exists in a `COMPLETED` state
- **And** I am an authenticated Technician
- **When** I attempt to trigger the start action
- **Then** the system must reject the request with error message: "Work order cannot be started. It is currently in 'COMPLETED' status."
- **And** the work order's status must remain `COMPLETED`
- **And** no audit record is created.

### AC5: Block Start Due to Pending Change Request
- **Given** a work order exists in an `APPROVED` state
- **And** an active `ChangeRequest` exists where `status = PENDING_APPROVAL` and `type = SCOPE_CHANGE`
- **And** I am an authenticated Technician
- **When** I attempt to trigger the start action
- **Then** the system must reject the request with error message: "Cannot start work. A pending change request requires approval before proceeding."
- **And** the work order's status must remain `APPROVED`
- **And** no audit record is created.

### AC6: Change In-Progress Reason
- **Given** a work order is in `WORK_IN_PROGRESS` with `inProgressReason = ACTIVE_WORK`
- **When** I update the reason to `WAITING_PARTS`
- **Then** the `inProgressReason` field is updated
- **And** the canonical status remains `WORK_IN_PROGRESS`
- **And** a new record is created in `WorkOrderStatusHistory` with `changeType = REASON_CHANGE` documenting the reason change
- **And** no status-change audit record is created.

### AC7: Validate Allowed In-Progress Reasons
- **Given** a work order is in `WORK_IN_PROGRESS`
- **When** an attempt is made to set `inProgressReason` to an invalid value (not in the allowed enum)
- **Then** the system rejects the update with a validation error
- **And** the current `inProgressReason` is unchanged.

## Audit & Observability
- **Logging:**
  - `INFO`: Log successful work order start, including `workOrderId`, `workStartedAt`, and `changedByUserId`.
  - `INFO`: Log successful reason changes, including the old and new `inProgressReason`.
  - `WARN`: Log rejections due to non-startable state or blocking change request.
- **Metrics:**
  - `workexec.workorder.start.success.count`: Counter, incremented on successful start.
  - `workexec.workorder.start.failure.count`: Counter, incremented on start rejection (by reason: non_startable_state, blocking_change_request).
  - `workexec.workorder.reason_change.count`: Counter, incremented on each reason change.
- **Alerting:**
  - Monitor `workexec.workorder.start.failure.count` for systemic issues.

## Clarification Resolution

### 1. Auto-Start Behavior
**Decision:** **Out of scope for this story.** Treat "auto-start on first labor entry" as a **separate follow-on story**.

**Rationale:**
- Auto-start changes the trigger model (implicit vs. explicit) and introduces coupling with timekeeping/labor capture systems.
- It complicates auditability and operator intent (work order start becomes a side effect rather than an explicit action).

**This story's scope:** Explicit start via `POST /workexec/v1/workorders/{id}:start` only.

### 2. Startable States (Exhaustive List)
**Decision:** A work order is startable from exactly three states (v1):
- `APPROVED`
- `ASSIGNED`
- `SCHEDULED`

**Not startable:**
- `DRAFT`, `PENDING_APPROVAL`, `CANCELLED`, `CLOSED`, `INVOICED`, `VOIDED`, `ON_HOLD`, `COMPLETED`, `LOCKED_FOR_REVIEW`, `ARCHIVED`

**Rule:** Start transitions the work order to `WORK_IN_PROGRESS` and sets `workStartedAt` to the current UTC timestamp.

### 3. In-Progress Sub-Statuses
**Decision:** Use a **single primary status** `WORK_IN_PROGRESS` plus a constrained enum `inProgressReason` (sub-status) to avoid state explosion.

**Allowed `inProgressReason` values (v1):**
- `ACTIVE_WORK` (default)
- `WAITING_PARTS`
- `WAITING_CUSTOMER_APPROVAL`
- `WAITING_DIAGNOSIS`
- `WAITING_EXTERNAL_SERVICE` (e.g., sublet/vendor)
- `PAUSED_BY_SHOP` (temporary operational pause)

**Rules:**
- `WORK_IN_PROGRESS` remains the canonical status.
- `inProgressReason` may change without leaving WIP.
- Transitions into/out of `WORK_IN_PROGRESS` are audited as true status changes; changes to `inProgressReason` are audited separately as reason changes.

### 4. Pending Approval Change Request Identification
**Decision:** Yes‚Äîa **ChangeRequest entity linked to the WorkOrder** is used to evaluate this as a blocking condition.

**Relationship:**
- `WorkOrder (1) -> (0..*) ChangeRequest`
- Link: `changeRequest.workOrderId`

**Blocking Condition:**
Block start if there exists an active ChangeRequest where:
- `status = PENDING_APPROVAL`
- AND `type` is in the set that must be approved before work begins: `[SCOPE_CHANGE, PRICE_INCREASE, PART_SUBSTITUTION_REQUIRING_APPROVAL]`

**Query Logic (Deterministic):**
```
exists ChangeRequest where 
  workOrderId = :id 
  AND status = PENDING_APPROVAL 
  AND (type IN (...) OR requiresWorkHold = true)
```

**Status:** All clarifications resolved; story is unblocked and ready for implementation.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #160 ‚Äî [BACKEND] [STORY] Execution: Start Workorder and Track Status

## Current Labels
- backend
- blocked:clarification
- domain:workexec
- status:draft
- story-implementation
- type:story
- user

## Original Scope
This story defines the mechanism for formally starting a work order and tracking granular status changes during the work-in-progress phase, ensuring accurate operational visibility and audit compliance.


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #159: [BACKEND] [STORY] Execution: Record Labor Performed
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:workexec
- status:draft

### Recommended
- agent:workexec
- agent:story-authoring

### Blocking / Risk
- none

---
**Rewrite Variant:** workexec-structured
---
## Story Intent
- **As a:** Technician
- **I want to:** Accurately record the labor I perform on a specific service item of a work order, whether it's measured in hours or as a completed flat-rate task.
- **So that:** My work is correctly tracked, the work order status is updated, and the business has accurate data for job costing and future invoicing.

## Actors & Stakeholders
- **Technician (Primary Actor):** The user performing and recording the labor against an assigned work order item.
- **Service Advisor (Stakeholder):** Manages the work order and may need to review, edit, or approve labor entries.
- **Accounting System (Stakeholder):** A downstream system that consumes `LaborRecorded` events for Work-in-Progress (WIP) and job costing purposes.
- **System (Actor):** The POS/Workshop system responsible for validating and persisting labor entries and emitting events.

## Preconditions
- The Technician is authenticated and has the necessary permissions (`WORKORDER_LABOR_RECORD`) to record labor.
- A Work Order exists with a status that allows labor to be recorded (e.g., 'IN_PROGRESS').
- The Work Order contains one or more service line items that require labor.
- The Technician is assigned to the Work Order or the specific service item, as per system policy.

## Functional Behavior
### Trigger
The Technician initiates the action to record labor against a specific service line item on an active work order.

### Path 1: Record Time-Based Labor
1. The Technician selects a time-based service item from the work order.
2. The System presents an interface to record time (e.g., direct entry of hours).
3. The Technician enters the labor hours (e.g., `1.5`) and optionally adds notes about the work performed.
4. The Technician submits the labor entry.
5. The System validates and persists the entry, creating a `WorkorderLaborEntry` record.
6. The System updates the status of the work order item (e.g., `labor_in_progress`) and/or the parent work order.
7. The System emits a `LaborRecorded` event.

### Path 2: Record Flat-Rate Labor
1. The Technician selects a flat-rate service item from the work order.
2. The System presents an interface to mark the item as complete.
3. The Technician confirms completion and optionally adds notes.
4. The Technician submits the labor entry.
5. The System validates and persists the entry, creating a `WorkorderLaborEntry` record.
6. The System updates the status of the work order item to `labor_complete`.
7. The System emits a `LaborRecorded` event.

## Alternate / Error Flows
- **Error - Unassigned Technician:**
  - **Scenario:** A Technician attempts to record labor on a work order or item they are not assigned to.
  - **System Response:** The system rejects the entry and displays an error message: "You are not assigned to this work order/item. Please see the Service Advisor."

- **Error - Invalid Labor Hours:**
  - **Scenario:** A Technician enters a non-positive or excessively large value for hours on a time-based entry (e.g., `0`, `-5`, or `1000`).
  - **System Response:** The system rejects the entry with a validation error: "Please enter a valid, positive number for labor hours."

- **Error - Work Order in Invalid State:**
  - **Scenario:** A Technician attempts to record labor on a work order that is not in an active state (e.g., 'DRAFT', 'COMPLETED', 'CANCELED').
  - **System Response:** The system rejects the entry with an error message: "Labor cannot be recorded on a work order with status '[WorkOrderStatus]'."

## Business Rules
- `BR1`: All labor entries must be immutably associated with a specific `Workorder` and `WorkorderItem`.
- `BR2`: Each labor entry must be attributed to a single, identified `Technician`.
- `BR3`: The system must support two types of labor recording:
    - `BR3.1`: **Time-Based:** Recorded as a quantity of hours.
    - `BR3.2`: **Flat-Rate:** Recorded as a single completion event.
- `BR4`: Labor entries are immutable. Corrections must be made by creating a new, superseding entry (e.g., a reversal and a new correct entry), which requires specific permissions (`WORKORDER_LABOR_CORRECT`).
- `BR5`: A `LaborRecorded` event must be emitted upon the successful creation of a `WorkorderLaborEntry`. This event is for internal tracking (WIP/costing) and is explicitly non-posting from an Accounts Receivable (AR) perspective.
- `BR6`: The cost of labor is tracked for job costing purposes but is not recognized as revenue until the work order is invoiced.

## Data Requirements
- **Entity:** `WorkorderLaborEntry`
- **Attributes:**
    - `laborEntryId` (PK): Unique identifier for the labor record.
    - `workorderId` (FK): Reference to the parent `Workorder`.
    - `workorderItemSeqId` (FK): Reference to the specific `WorkorderItem`.
    - `technicianId` (FK): Reference to the `Technician` who performed the labor.
    - `laborType` (Enum: `TIME_BASED`, `FLAT_RATE`): The type of labor being recorded.
    - `laborHours` (Decimal): Hours recorded for `TIME_BASED` labor. Null for `FLAT_RATE`.
    - `isComplete` (Boolean): Flag indicating completion for `FLAT_RATE` labor.
    - `notes` (Text, Optional): Technician's notes.
    - `entryTimestamp` (Timestamp): When the record was created in the system.
    - `version` (Integer): For optimistic locking and idempotency key generation.

## Acceptance Criteria
- **AC1: Record Time-Based Labor Successfully**
  - **Given:** A Technician is assigned to a work order with a time-based service item.
  - **When:** The Technician records 2.5 hours of labor against that service item.
  - **Then:** The system creates a `WorkorderLaborEntry` with `laborType` = `TIME_BASED` and `laborHours` = 2.5.
  - **And:** The system emits a `LaborRecorded` event with the correct details.

- **AC2: Record Flat-Rate Labor Successfully**
  - **Given:** A Technician is assigned to a work order with a flat-rate service item.
  - **When:** The Technician marks the flat-rate item as complete.
  - **Then:** The system creates a `WorkorderLaborEntry` with `laborType` = `FLAT_RATE` and `isComplete` = true.
  - **And:** The system emits a `LaborRecorded` event with the corresponding details.

- **AC3: Verify Event is Non-Posting for Accounts Receivable**
  - **Given:** A `LaborRecorded` event is emitted.
  - **When:** The Accounting domain consumes and processes the event.
  - **Then:** No General Ledger entries for Accounts Receivable or Revenue are created.
  - **And:** The labor cost is correctly recorded in the Work-in-Progress (WIP) sub-ledger.

- **AC4: Reject Invalid (Negative) Labor Hours**
  - **Given:** A Technician is recording labor for a time-based service item.
  - **When:** The Technician attempts to submit an entry with -1.0 hours.
  - **Then:** The system rejects the submission and displays a user-facing validation error.
  - **And:** No `WorkorderLaborEntry` is created and no `LaborRecorded` event is emitted.

- **AC5: Ensure Idempotent Event Processing**
  - **Given:** A `WorkorderLaborEntry` has been successfully recorded and a `LaborRecorded` event was emitted.
  - **When:** The same `LaborRecorded` event (with the same idempotency key) is processed a second time by a downstream system.
  - **Then:** The system recognizes the event as a duplicate and does not create a duplicate labor cost entry in the WIP ledger.

- **AC6: Verify Labor Entry Auditability**
  - **Given:** A `WorkorderLaborEntry` is successfully created.
  - **When:** An auditor queries the system's audit logs.
  - **Then:** An immutable audit record exists that clearly identifies the `technicianId`, `workorderId`, `laborEntryId`, the data recorded, and the creation timestamp.

## Audit & Observability
- **Audit Log:** All CUD (Create, Update, Delete) operations on `WorkorderLaborEntry` must be logged in an immutable audit trail. The log must include the principal (Technician ID), timestamp, and a snapshot of the changed data.
- **Event Sourcing:** The `LaborRecorded` event must be published to a durable, ordered message topic (e.g., Kafka, Kinesis) for reliable consumption by other domains like Accounting.
- **Event Schema & Contract:** The event payload must be versioned and strictly conform to the `Durion_Accounting_Event_Contract_v1.pdf`.
- **Idempotency Key:** The emitted event must contain a unique and deterministic idempotency key, composed of `workorderId` + `laborEntryId` + `version`, to guarantee safe reprocessing by consumers.
- **Metrics:** The service must expose metrics for monitoring, including:
  - `labor_entries_created_total` (counter, with dimensions for `laborType`)
  - `labor_entry_errors_total` (counter, with dimensions for `errorType`)
  - `labor_entry_duration_seconds` (histogram)

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #159 ‚Äî [BACKEND] [STORY] Execution: Record Labor Performed

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Execution: Record Labor Performed

**Domain**: user

### Story Description

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24300002/Durion_Accounting_Event_Contract_v1.pdf)

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
Technician

## Trigger
Technician performs labor associated with a workorder service item.

## Main Flow
1. Technician selects a labor/service line item.
2. Technician records time (start/stop or hours) or marks a flat-rate completion.
3. Technician adds notes/results (optional).
4. System validates permissions and records labor entry.
5. System updates workorder progress and completion indicators.

## Alternate / Error Flows
- Labor entry attempted without assignment ‚Üí block or warn per policy.
- Negative or unrealistic hours ‚Üí block and require correction.

## Business Rules
- Labor entries must be attributable to a technician and time.
- Support both flat-rate and time-based labor.
- Entries must be auditable and reversible only with permissions.

## Data Requirements
- Entities: Workorder, WorkorderItem, LaborEntry, AuditEvent
- Fields: workorderId, itemSeqId, technicianId, hours, flatRateFlag, notes, createdAt

## Acceptance Criteria
- [ ] Technicians can record labor entries on assigned workorders.
- [ ] Labor entries are auditable and tied to service items.
- [ ] Progress updates reflect labor completion.
- [ ] Labor entries emit LaborRecorded events when saved
- [ ] Labor events do not create AR or revenue
- [ ] Labor cost is available for job costing or WIP reporting
- [ ] Updates to labor entries supersede prior events
- [ ] Duplicate events do not create duplicate labor cost

## Integrations

### Accounting
- Emits Event: LaborRecorded
- Event Type: Non-posting (job cost / WIP tracking)
- Source Domain: workexec
- Source Entity: WorkorderLaborEntry
- Trigger: Labor entry recorded or completed
- Idempotency Key: workorderId + laborEntryId + version


## Notes for Agents
Even if prices are hidden, labor quantities must remain accurate for invoicing.


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #158: [BACKEND] [STORY] Execution: Issue and Consume Parts
LABELS: type:story,domain:workexec,status:needs-review
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:workexec
- status:draft

### Recommended
- agent:workexec
- agent:story-authoring


---
**Rewrite Variant:** workexec-structured
---

## Story Intent
As a Technician or Parts Counter Staff, I need to record the issuance and consumption of parts for a specific work order, so that inventory levels are accurately updated, work progress is tracked, and financial records (WIP/COGS) are correctly impacted via downstream systems.

## Actors & Stakeholders
- **Primary Actors:**
  - `Technician`: Performs the work and installs the parts.
  - `Parts Counter Staff`: Gathers and issues parts from inventory for a specific job.
- **System Actors:**
  - `Work Execution Service`: Owns the state and lifecycle of the work order.
  - `Inventory Service`: A downstream consumer that adjusts on-hand inventory based on issuance events.
- **Stakeholders:**
  - `Accounting Department`: Consumes financial events (`InventoryIssued`) to correctly track Cost of Goods Sold (COGS) or Work-in-Progress (WIP) asset value.
  - `Service Advisor`: Monitors work order status, including delays due to parts availability.

## Preconditions
- A `Workorder` exists in a state that permits part allocation (e.g., `APPROVED`, `IN_PROGRESS`).
- The `Workorder` has one or more `WorkorderItem` line items that specify the required `productId` and an authorized `quantity`.
- The actor is authenticated and has the necessary permissions to modify the specified `Workorder`.
- The system has a defined inventory of parts that can be queried for availability.

## Functional Behavior
This story covers the linked actions of issuing (committing from stock) and consuming (installing on the job) a part.

1.  **Trigger:** The actor initiates the "Issue/Consume Parts" action for a specific `WorkorderItem` on a `Workorder`.
2.  The system validates that the `Workorder` is in a mutable state (e.g., not `COMPLETED` or `CANCELLED`).
3.  The actor specifies the `productId` and the `quantity` being issued and consumed.
4.  **Validation:**
    - The system verifies that the `quantity` does not exceed the remaining authorized quantity for that `WorkorderItem`.
    - The system checks for available on-hand inventory for the requested `quantity`.
5.  **State Change:**
    - Upon successful validation, the system creates an immutable `PartUsageEvent` with `eventType: ISSUED_AND_CONSUMED`.
    - The system updates the `WorkorderItem` to reflect the consumed quantity and may update its completion status (e.g., `PARTS_COMPLETE`).
6.  **Integration Event:**
    - The system constructs and emits an `InventoryIssued` event.
    - The event payload includes all data required by downstream systems, including the source `Workorder`, part details, quantity, and a hint for the accounting model (WIP vs. COGS).
    - The event must include a deterministic idempotency key to prevent duplicate processing by consumers.

## Alternate / Error Flows
- **Insufficient Inventory:**
  - If the requested `quantity` is greater than the available on-hand inventory, the transaction is blocked.
  - The system will flag the `Workorder` and/or `WorkorderItem` with a status of `WAITING_FOR_PARTS`.
  - A notification may be generated for the Parts Department or Service Advisor.
- **Consumption Exceeds Authorization:**
  - If the requested `quantity` exceeds the authorized quantity on the `WorkorderItem`, the transaction is blocked.
  - The system should direct the user to an approval workflow to increase the authorized quantity (Note: The approval workflow itself is out of scope for this story).
- **Invalid Work Order State:**
  - If the `Workorder` is in a terminal state (e.g., `COMPLETED`, `CANCELLED`), the system rejects the request with an error indicating the work order is locked.
- **Downstream Event Failure:**
  - If the `InventoryIssued` event fails to publish to the event bus, the core state change (creation of `PartUsageEvent`) must still be committed successfully.
  - The system must guarantee eventual delivery of the event using a mechanism like the transactional outbox pattern.

## Business Rules
- **BR1:** All part movements against a work order must generate an immutable `PartUsageEvent` record for audit and traceability.
- **BR2:** The total quantity issued/consumed for a part on a work order item cannot exceed the authorized quantity without a separate, explicit approval.
- **BR3:** An `InventoryIssued` event must be emitted for every `ISSUED_AND_CONSUMED` `PartUsageEvent`. This event is the source of truth for downstream inventory and accounting systems.
- **BR4:** The idempotency key for the `InventoryIssued` event must be unique and deterministic for each distinct issuance action, as specified in the Data Requirements.
#### BR-ATOMIC-1: Atomic Transaction Requirement
**Rule:** Part issue and consume operations MUST be executed within a single local database transaction that includes:
- Work order part consumption state update
- Inventory ledger entry creation
- Outbox record creation for event publishing

**Rationale:** Ensures data consistency by preventing partial updates. If any step fails, all changes are rolled back.

**Authority:** Workexec domain

#### BR-ASYNC-1: Asynchronous Event Publishing
**Rule:** Events (InventoryIssued, PartConsumed) MUST be published asynchronously after the local transaction commits successfully, using the transactional outbox pattern.

**Rationale:** Decouples event publishing from transaction processing, improving performance and reliability. The outbox pattern ensures guaranteed eventual delivery even if the message broker is temporarily unavailable.

**Authority:** Workexec domain

#### BR-IDEMPOTENCY-1: Idempotency Key Standard
**Rule:** All part consumption operations and events MUST use the idempotency key format: `{workorderId}-{workorderItemId}-{partUsageEventId}`. Consumers MUST handle retries idempotently using this key.

**Rationale:** Prevents duplicate processing in distributed systems, especially during retries or network failures.

**Authority:** Workexec domain (key format), Cross-cutting concern (idempotency handling)

#### BR-AUDIT-1: Audit Trail Requirements
**Rule:** All part consumption operations MUST capture:
- Actor identifier (who performed the action)
- Timestamp in UTC (when it occurred)
- Entity changes (what changed, original and new values)
- Idempotency key
- Request/event correlation identifiers

**Rationale:** Provides complete auditability and troubleshooting capability for compliance and operational needs.

**Authority:** Audit & Observability domain

#### BR-POLICY-1: WIP vs COGS Policy Configuration
**Rule:** The determination of whether inventory consumption impacts Work-In-Progress (WIP) or Cost of Goods Sold (COGS) accounts SHALL be configurable via policy. The policy configuration may be:
- System-wide default
- Per location override
- Per work order type
- Or other business-defined criteria

The workexec domain MUST evaluate the policy at consumption time and include the determination in the `InventoryIssued` event payload.

**Rationale:** Different business processes and locations may have different accounting treatment requirements. The policy provides flexibility while maintaining consistency within each configuration scope.

**Authority:** Accounting domain (policy definition), Workexec domain (policy evaluation and event payload)

## Data Requirements
- **Entity: `PartUsageEvent`**
  - `partUsageEventId`: (PK) Unique identifier for the event.
  - `workorderId`: (FK) The parent work order.
  - `workorderItemId`: (FK) The specific line item the part is for.
  - `productId`: (FK) The identifier of the part.
  - `quantity`: The amount issued and consumed.
  - `eventType`: `ISSUED_AND_CONSUMED`.
  - `eventTimestamp`: The UTC timestamp of the transaction.
  - `performedBy`: The ID of the user who performed the action.

- **Event DTO: `InventoryIssued`**
  - `eventId`: A unique ID for this event instance.
  - `idempotencyKey`: Composite key for consumer-side deduplication. Format: `{workorderId}-{workorderItemId}-{partUsageEventId}`.
  - `sourceDomain`: `workexec`.
  - `sourceEntityId`: The `partUsageEventId`.
  - `eventType`: `InventoryIssued`.
  - `eventVersion`: `1.0`.
  - `timestamp`: UTC timestamp of the event.
  - `payload`:
    - `workorderId`: ID of the source work order.
    - `productId`: ID of the part issued.
    - `quantityIssued`: The quantity.
    - `issuedBy`: User ID of the actor.
    - `accountingModel`: `WIP` or `COGS`, based on configuration.
#### PartUsageEvent
Represents a single part consumption event.

**Fields:**
- `partUsageEventId` (UUID, Primary Key): Unique identifier for this consumption event
- `workorderId` (UUID, Foreign Key): Work order being executed
- `workorderItemId` (UUID, Foreign Key): Specific line item on the work order
- `partId` (UUID, Foreign Key): Part/SKU being consumed
- `quantityConsumed` (Decimal): Quantity consumed in this event
- `unitCost` (Decimal): Cost per unit at time of consumption
- `totalCost` (Decimal): Total cost (quantityConsumed * unitCost)
- `actorId` (UUID): User who performed the consumption
- `consumedAtUtc` (Timestamp): When consumption occurred (UTC)
- `idempotencyKey` (String): Format: `{workorderId}-{workorderItemId}-{partUsageEventId}`
- `accountingPolicy` (String): WIP or COGS determination
- `auditMetadata` (JSONB): Additional audit context

#### OutboxEvent
Represents events to be published asynchronously.

**Fields:**
- `outboxEventId` (UUID, Primary Key): Unique identifier for this outbox entry
- `aggregateType` (String): Entity type (e.g., "WorkOrder")
- `aggregateId` (UUID): Entity instance identifier
- `eventType` (String): Event name (e.g., "InventoryIssued", "PartConsumed")
- `eventPayload` (JSONB): Complete event data
- `createdAtUtc` (Timestamp): When outbox record was created (UTC)
- `publishedAtUtc` (Timestamp, Nullable): When successfully published (NULL if pending)
- `publishAttempts` (Integer): Number of publish attempts
- `lastAttemptAtUtc` (Timestamp, Nullable): Last publish attempt timestamp
- `status` (String): PENDING, PUBLISHED, FAILED

#### AccountingPolicyConfiguration
Configures WIP vs COGS determination rules.

**Fields:**
- `policyConfigId` (UUID, Primary Key): Unique identifier
- `scope` (String): SYSTEM_DEFAULT, LOCATION, WORK_ORDER_TYPE
- `scopeValue` (String, Nullable): Location ID or work order type if scoped
- `policyDecision` (String): WIP or COGS
- `effectiveFromUtc` (Timestamp): When this policy becomes effective (UTC)
- `effectiveToUtc` (Timestamp, Nullable): When this policy expires (NULL if current)
- `createdBy` (UUID): User who created this policy
- `createdAtUtc` (Timestamp): When policy was created (UTC)
- `auditMetadata` (JSONB): Additional audit context

## Acceptance Criteria
- **AC1: Successful Part Consumption**
  - **Given** a `Workorder` is `IN_PROGRESS` with an item authorizing 2 units of `PART-123`.
  - **And** there are 10 units of `PART-123` in stock.
  - **When** a Technician records the consumption of 2 units of `PART-123` for that item.
  - **Then** the system creates a `PartUsageEvent` for 2 units.
  - **And** an `InventoryIssued` event is published with a quantity of 2.
  - **And** the `WorkorderItem` reflects that 2 units have been consumed.

- **AC2: Insufficient Inventory**
  - **Given** a `Workorder` is `IN_PROGRESS` with an item authorizing 2 units of `PART-123`.
  - **And** there is only 1 unit of `PART-123` in stock.
  - **When** a Technician attempts to record the consumption of 2 units of `PART-123`.
  - **Then** the system rejects the transaction with an "Insufficient Inventory" error.
  - **And** the `Workorder` status is updated to `WAITING_FOR_PARTS`.
  - **And** no `PartUsageEvent` is created and no `InventoryIssued` event is published.

- **AC3: Exceeding Authorized Quantity**
  - **Given** a `Workorder` is `IN_PROGRESS` with an item authorizing 2 units of `PART-123`.
  - **And** there are 10 units of `PART-123` in stock.
  - **When** a Technician attempts to record the consumption of 3 units of `PART-123`.
  - **Then** the system rejects the transaction with an "Exceeds Authorized Quantity" error.
  - **And** no `PartUsageEvent` is created and no `InventoryIssued` event is published.

- **AC4: Idempotent Event Processing**
  - **Given** an `InventoryIssued` event with idempotency key `WO-1-W-OI-2-PUE-3` has already been successfully processed by the Inventory service.
  - **When** the same event with key `WO-1-W-OI-2-PUE-3` is delivered again.
  - **Then** the Inventory service must recognize it as a duplicate and discard it without reducing inventory a second time.

## Audit & Observability
- **Audit Log:** Every `PartUsageEvent` creation must be logged with all its fields for a permanent audit trail.
- **Structured Logging:**
  - `INFO`: Log successful part consumption events, including `workorderId`, `productId`, and `quantity`.
  - `WARN`: Log business rule validation failures, such as attempts to exceed authorized quantity or consume out-of-stock parts.
  - `ERROR`: Log failures in publishing the `InventoryIssued` event to the message bus after retries are exhausted.
- **Metrics:**
  - `parts.consumed.count`: Counter for the number of parts consumed, tagged by `productId`.
  - `parts.consumption.failures`: Counter for failed consumption attempts, tagged by `reason` (e.g., `insufficient_inventory`, `unauthorized_quantity`).
  - `events.published.duration`: A timer measuring the latency to publish the `InventoryIssued` event.
#### AC-ATOMIC-1: Single Transaction Guarantees Atomicity
**Given** a request to issue and consume a part for a work order item
**When** the part consumption is processed
**Then** all database changes (state update, ledger entry, outbox record) MUST occur within a single local transaction
**And** if any step fails, all changes MUST be rolled back
**And** no partial state MUST be committed

#### AC-ASYNC-1: Events Published Asynchronously
**Given** a successful part consumption transaction has committed
**When** the outbox processor runs
**Then** the `InventoryIssued` and `PartConsumed` events MUST be published to the message broker
**And** if publishing fails, the events MUST remain in the outbox for retry
**And** the original transaction MUST NOT be affected by publishing failures

#### AC-IDEMPOTENCY-1: Idempotency Keys Prevent Duplicate Processing
**Given** a part consumption request with idempotency key `{workorderId}-{workorderItemId}-{partUsageEventId}`
**When** the same request is submitted multiple times (e.g., due to retry)
**Then** the system MUST detect the duplicate using the idempotency key
**And** subsequent requests MUST return the same result without reprocessing
**And** only one part consumption record MUST be created

#### AC-AUDIT-1: Complete Audit Trail Captured
**Given** any part consumption operation
**When** the operation is executed
**Then** the system MUST capture:
- Actor identifier (who)
- UTC timestamp (when)
- Entity changes (what, before and after values)
- Idempotency key
- Request correlation identifier
**And** this audit trail MUST be queryable for compliance and troubleshooting

#### AC-POLICY-1: WIP vs COGS Determined by Configured Policy
**Given** a part consumption request
**When** the system evaluates accounting policy
**Then** the policy configuration MUST be queried based on:
- System-wide default
- Location-specific override (if applicable)
- Work order type-specific override (if applicable)
**And** the policy decision (WIP or COGS) MUST be determined according to the most specific applicable configuration
**And** if no policy is configured, the system MUST use the system-wide default or fail with a clear error

#### AC-POLICY-2: Policy Decision Included in InventoryIssued Event
**Given** a part consumption has been successfully processed
**When** the `InventoryIssued` event is created
**Then** the event payload MUST include:
- `accountingPolicy` field with value "WIP" or "COGS"
- Policy configuration identifier used for the determination
- Timestamp of policy evaluation (UTC)
**And** the Accounting service MUST consume this event and apply the specified policy without recomputation

### Audit & Observability Section
#### Event: PartConsumptionRequested
**Logged When:** Part consumption operation is initiated
**Payload:**
- Request identifier
- Idempotency key
- Work order ID
- Work order item ID
- Part ID
- Quantity requested
- Actor ID
- Timestamp (UTC)

#### Event: PartConsumptionTransactionCommitted
**Logged When:** Local database transaction commits successfully
**Payload:**
- Transaction identifier
- Idempotency key
- Part usage event ID
- Duration (milliseconds)
- Timestamp (UTC)

#### Event: PartConsumptionEventPublished
**Logged When:** Event successfully published to message broker
**Payload:**
- Outbox event ID
- Event type
- Publish attempt number
- Duration (milliseconds)
- Timestamp (UTC)

#### Event: PartConsumptionEventPublishFailed
**Logged When:** Event publishing fails
**Payload:**
- Outbox event ID
- Event type
- Error message
- Publish attempt number
- Next retry scheduled time
- Timestamp (UTC)

#### Metric: part_consumption_transaction_duration_ms
**Description:** Duration of part consumption transaction processing
**Type:** Histogram
**Labels:** work_order_type, location_id, success/failure

#### Metric: part_consumption_event_publish_duration_ms
**Description:** Duration of event publishing to message broker
**Type:** Histogram
**Labels:** event_type, success/failure, attempt_number

#### Metric: part_consumption_idempotency_key_duplicates_total
**Description:** Count of duplicate requests detected via idempotency key
**Type:** Counter
**Labels:** work_order_type, location_id

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #158 ‚Äî [BACKEND] [STORY] Execution: Issue and Consume Parts

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Execution: Issue and Consume Parts

**Domain**: user

### Story Description

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24299981/Durion_Accounting_Event_Contract_v1.pdf)

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
Technician / Parts Counter

## Trigger
Parts are picked/issued for installation on a workorder.

## Main Flow
1. User selects a workorder part item.
2. User records parts issued (picked) and parts consumed (installed).
3. System validates quantities and updates on-hand commitments (if integrated).
4. System records consumption event with timestamp and user.
5. System updates item completion indicators where applicable.

## Alternate / Error Flows
- Insufficient inventory ‚Üí flag and move workorder to waiting parts status.
- Consumption exceeds authorized quantity ‚Üí block or require approval per policy.

## Business Rules
- Parts usage must be recorded as events (issue/consume/return).
- Consumption should not silently change authorized scope without approval.
- Traceability must be preserved.

## Data Requirements
- Entities: WorkorderItem, PartUsageEvent, InventoryReservation
- Fields: productId, quantityIssued, quantityConsumed, eventType, eventAt, performedBy, originEstimateItemId

## Acceptance Criteria
- [ ] Parts issued/consumed can be recorded and audited.
- [ ] System enforces quantity integrity and policy limits.
- [ ] Workorder status reflects parts availability issues.
- [ ] Each issued part emits exactly one InventoryIssued event
- [ ] Inventory on-hand quantity is reduced correctly
- [ ] COGS or WIP impact follows configured accounting model
- [ ] Issued quantities are traceable to workorder and technician
- [ ] Replayed events do not double-reduce inventory

## Integrations

### Accounting
- Emits Event: InventoryIssued
- Event Type: Non-posting or Posting (configurable: WIP vs immediate COGS)
- Source Domain: workexec
- Source Entity: WorkorderPartUsage
- Trigger: Part is issued/consumed for a workorder item
- Idempotency Key: workorderId + partId + usageSequence


## Notes for Agents
Keep parts usage consistent with promotion snapshot; changes route through approvals.


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #157: [BACKEND] [STORY] Execution: Handle Part Substitutions and Returns
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
## Story Intent
As a Technician or Parts Counter Staff, accurately record part substitutions and returns on a work order so inventory levels remain correct, billing is accurate, and a clear audit trail exists.

## Actors & Stakeholders
- **Technician / Parts Counter (Primary):** Performs substitutions/returns at point of work.
- **System (POS/Work Execution):** Processes changes, updates records, emits events.
- **Service Advisor:** Reviews and approves substitutions when they raise price; can also price match.
- **Inventory Manager:** Depends on accurate consumption data for reconciliation.
- **Customer:** Impacted by price changes from substitutions.
- **Accounting System (Downstream):** Consumes inventory adjustment events for COGS.

## Preconditions
1. Work Order exists and is `IN_PROGRESS`.
2. At least one part (`OriginalPart`) has been issued to the Work Order.
3. User is authenticated with permission to modify part usage on the Work Order.
4. The `SubstitutePart` exists in the product catalog.

## Functional Behavior
### Scenario 1: Part Substitution
1. Trigger: Technician selects an issued `OriginalPart` and chooses `Substitute Part`.
2. System prompts for `SubstitutePart` and quantity.
3. Technician selects and confirms.
4. System records substitution by:
   a. Decrementing `consumedQuantity` of `OriginalPart`.
   b. Creating a usage record for `SubstitutePart` with specified quantity.
   c. Creating `SubstitutionLink` between `OriginalPart` usage and `SubstitutePart` usage.
5. System evaluates financial impact (price/tax difference) against approval rules.
6. If price increases and is not price-matched, flag the Work Order/line as `PENDING_APPROVAL` and route to any Service Advisor for approval or price match.
7. If a Service Advisor price matches the higher-priced substitute down to the original price, do not require approval.
8. If approval is rejected, cancel the substitution line item (no change applied); maintain audit of the attempt.
9. Emit a single `InventoryAdjusted` event with adjustments for returned `OriginalPart` and consumed `SubstitutePart`.

### Scenario 2: Part Return
1. Trigger: Technician selects an issued part and chooses `Return Unused Part`.
2. System prompts for `returnQuantity`.
3. Validate `returnQuantity` does not exceed consumed quantity.
4. Update usage record by decrementing `consumedQuantity` by `returnQuantity`.
5. Emit `InventoryAdjusted` event for returned quantity.

## Alternate / Error Flows
- **Substitute Unavailable:** If `SubstitutePart` has insufficient inventory, block with error.
- **Substitution Not Allowed:** If policy disallows substitution for `OriginalPart`, block and inform user.
- **Return Exceeds Consumed:** If `returnQuantity` > consumed, reject with error; no event emitted.
- **Invalid Part Selection:** If part was not issued to the Work Order, block action.
- **Approval Rejected:** If price-increase approval is rejected, substitution line is canceled; original part usage remains.

## Business Rules
- Maintain auditable traceability between original and substituted parts via `SubstitutionLink`.
- Emit immutable events for substitutions/returns to support inventory and financial reconciliation.
- Approval policy:
  - Any price increase triggers approval unless a Service Advisor price matches the substitute to the original price.
  - Any Service Advisor may approve or perform price match.
  - Rejection of the price increase cancels the substitution line item (no billing change).

## Data Requirements
- **WorkOrderItemPartUsage:** `workOrderItemId`, `productId`, `issuedQuantity`, `consumedQuantity`, `returnedQuantity`
- **PartSubstitutionLink:** `sourceUsageId`, `substituteUsageId`, `substitutedQuantity`, `reasonCode` (optional), `timestamp`
- **WorkOrder:** `workOrderStatus` (e.g., `IN_PROGRESS`, `PENDING_APPROVAL`)
- **Event: InventoryAdjusted:** `eventId`, `idempotencyKey`, `sourceEntity`, `sourceId`, `adjustments[{productId, quantityDelta, reason}]`

## Acceptance Criteria
**AC1: Successful substitution with price increase ‚Üí approval**
- Given Work Order `IN_PROGRESS` with Part A ($10) consumed
- When substituting one unit with Part B ($15)
- Then new usage for Part B is created, Part A consumed decremented, `SubstitutionLink` recorded
- And Work Order/line is flagged `PENDING_APPROVAL`
- And one `InventoryAdjusted` event emits +1 for Part A, -1 for Part B

**AC2: Price match avoids approval**
- Given Work Order `IN_PROGRESS` with Part A ($10) consumed
- And Service Advisor price matches Part B ($15) down to $10 during substitution
- When substitution is submitted
- Then substitution records are created, `SubstitutionLink` recorded, no `PENDING_APPROVAL` flag, and one `InventoryAdjusted` event emitted

**AC3: Approval rejection cancels substitution**
- Given a substitution is pending approval
- When a Service Advisor rejects the price increase
- Then the substitution line is canceled, original part usage remains, no billing change is applied, and the rejection is audited

**AC4: Return unused parts**
- Given Work Order `IN_PROGRESS` with 5 units of Part C consumed
- When returning 2 units
- Then consumed quantity updates to 3
- And an `InventoryAdjusted` event emits +2 for Part C
- And no approval is required

**AC5: Prevent over-return**
- Given 3 units of Part D consumed
- When attempting to return 4 units
- Then the system rejects the operation; consumed quantity remains 3; no `InventoryAdjusted` event is emitted

**AC6: Event idempotency**
- Given an `InventoryAdjusted` event for a substitution was emitted with an idempotency key
- When a duplicate event with the same key is received
- Then it is ignored and inventory is not double-adjusted

## Audit & Observability
- Audit every substitution/return with event type (`PART_SUBSTITUTION`, `PART_RETURN`), actor `userId`, timestamp, part IDs, quantity change, reason (if provided), and approval outcome (approved, rejected, price-matched).
- Metrics: track substitution rate (% of parts), approval request frequency, and rejection rate.
- Monitor `InventoryAdjusted` event emission success/failure.

## Open Questions
- None. Clarification #323 resolved prior approval policy details.

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #157 ‚Äî [BACKEND] [STORY] Execution: Handle Part Substitutions and Returns

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Execution: Handle Part Substitutions and Returns

**Domain**: user

### Story Description

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
Parts Counter / Technician

## Trigger
A different part is used or unused parts are returned.

## Main Flow
1. User selects a part item and chooses 'Substitute' or 'Return'.
2. System records substitution linking original and substituted part references.
3. System records quantity returned and updates usage totals.
4. If substitution impacts price/tax, system flags for approval if required.
5. System records all events for audit and inventory reconciliation.

## Alternate / Error Flows
- Substitution not allowed by policy ‚Üí block.
- Return would create negative consumed quantity ‚Üí block.

## Business Rules
- Substitutions must preserve traceability to original authorized scope.
- Returns must be reconciled against issued/consumed quantities.
- Price/tax impacts may require customer approval.

## Data Requirements
- Entities: PartUsageEvent, WorkorderItem, SubstitutionLink, ChangeRequest
- Fields: originalProductId, substituteProductId, quantityReturned, eventType, requiresApprovalFlag

## Acceptance Criteria
- [ ] System records substitutions with traceability.
- [ ] Returns reconcile correctly without negative totals.
- [ ] Approval is triggered when substitution changes customer-visible totals (policy).
- [ ] Substituted or returned parts emit a single InventoryAdjusted event
- [ ] Adjustment references the original issued part record
- [ ] Inventory quantities reconcile correctly after adjustment
- [ ] COGS impact (if any) is reversible and auditable
- [ ] Duplicate adjustment events do not double-adjust inventory

## Integrations

### Accounting
- Emits Event: InventoryAdjusted
- Event Type: Non-posting (inventory / COGS correction)
- Source Domain: workexec
- Source Entity: WorkorderPartUsage
- Trigger: Part substitution or return after initial issue
- Idempotency Key: workorderId + originalPartId + adjustedPartId + adjustmentVersion

## Notes for Agents
Substitution is a classic variance driver‚Äîcapture it cleanly for invoice explanations.


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #155: [BACKEND] [STORY] Execution: Apply Role-Based Visibility in Execution UI
LABELS: type:story,domain:workexec,status:needs-review
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:workexec
- status:draft

### Recommended
- agent:workexec
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** workexec-structured
---

## Story Intent
As a **System Administrator**, I want **to configure and apply role-based visibility policies to work order financial data**, so that **sensitive information like costs and pricing is hidden from unauthorized roles (e.g., Mechanics), protecting business margins and simplifying the user interface for technicians.**

## Actors & Stakeholders
- **Mechanic / Technician**: The primary user role whose view of a work order will be restricted.
- **Service Advisor / Back Office User**: User roles that require full visibility into financial data for quoting, invoicing, and reporting.
- **System Administrator**: The user role responsible for configuring the visibility policies that define what each role can see.
- **System**: The software actor responsible for identifying the user's role and enforcing the corresponding visibility policy at the API/data-access layer.
- **Stakeholders**:
    - **Finance Department**: Interested in protecting sensitive margin and cost data.
    - **Service Management**: Interested in operational efficiency and ensuring technicians have a streamlined, role-appropriate user experience.

## Preconditions
- A user is authenticated and has a clearly defined role (e.g., `ROLE_MECHANIC`, `ROLE_SERVICE_ADVISOR`).
- A Work Order exists in the system with associated line items containing financial data (e.g., `unitPrice`, `cost`).
- A source of truth for visibility policies exists, which maps user roles to permissions for viewing specific entities and fields.

## Functional Behavior
1.  **Trigger**: An authenticated user with an assigned role (e.g., `Mechanic`) requests to view a `Workorder` or its `WorkorderItem`s via a UI or API endpoint.
2.  The `Work Execution` service receives the request and identifies the user's role(s) from the security context.
3.  The service consults the authoritative `VisibilityPolicy` source to determine the specific viewing rules applicable to the user's role(s) for financial fields on the `Workorder` and `WorkorderItem` entities.
4.  The service constructs the response DTO (Data Transfer Object), omitting or nullifying any fields restricted by the policy (e.g., `unitPrice`, `extendedPrice`, `cost`, `margin`).
5.  The service returns the filtered work order data to the client (UI or API caller).
6.  The underlying `Workorder` and `WorkorderItem` records in the database remain unchanged, preserving all financial data for authorized processes like invoicing and reporting.

- Policy retrieval and caching from Security service
- Permission scope validation per request
- Dynamic DTO field filtering based on permissions
- Error handling for insufficient permissions

## Alternate / Error Flows
- **Role Misconfiguration / Policy Not Found**: If a visibility policy cannot be found for the user's role, the system **MUST** default to the most restrictive view (hiding all sensitive financial fields). An error **MUST** be logged for administrative review.
- **Unauthorized Direct API Access**: If a user attempts to directly query an API endpoint that is not intended for their role (if separate endpoints exist), the request **MUST** be rejected with a `403 Forbidden` status.

## Business Rules
- Financial data (cost, price, margin) **MUST** be considered sensitive and subject to role-based access control.
- The principle of "least privilege" **MUST** be applied: users should only see the data essential for performing their role-specific duties.
- The visibility policy **MUST** be enforced consistently across all relevant API endpoints and UI screens within the Work Execution domain.
- Hiding a field from view **MUST NOT** alter or remove the underlying data from the system of record. Financial truth must be preserved.
- A default "safe" policy (hide all sensitive fields) **MUST** be applied if a specific role's policy is not configured or fails to load.

### BR-POLICY-1: Security Service as Authoritative Source
The Security/Policy service is the single source of truth for all visibility policies and permission scopes. No other service may define or modify visibility policies. Domain services enforce policies but do not author them.

**Rationale:** Centralized policy management ensures consistency, auditability, and simplifies compliance.

### BR-POLICY-2: Domain Service Enforcement with Caching
Domain services (e.g., Workexec) SHALL:
- Retrieve visibility policies from the Security service via API
- Cache policies locally with a short TTL (recommended: 5-15 minutes)
- Subscribe to policy change events from Security service for immediate cache invalidation
- Perform server-side enforcement on every API request
- NEVER rely solely on client-side filtering for security

**Rationale:** Caching improves performance while short TTL and event-based invalidation ensure policy freshness.

### BR-RBAC-1: Explicit RBAC Scope Pattern
All permission scopes SHALL follow the pattern: `domain:resource:action`

Examples:
- `workexec:workorder:view` - Can view work order basic data
- `workexec:workorder:view-pricing` - Can view pricing fields
- `workexec:workorder:view-cost` - Can view cost fields
- `workexec:workorder:view-labor` - Can view labor details
- `workexec:workorder:edit` - Can edit work order

**Rationale:** Explicit, structured scopes provide fine-grained control and are self-documenting.

### BR-RBAC-2: Role-to-Permission Decoupling
Application code SHALL:
- Check permission scopes (e.g., `hasPermission('workexec:workorder:view-pricing')`)
- NEVER check role names directly (e.g., AVOID `if (role == 'MANAGER')`)

The Security service maintains the mapping: Role ‚Üí List of Permission Scopes.

**Rationale:** Decoupling allows permission changes without code changes and supports flexible role definitions.

### BR-API-1: Single Endpoint with Dynamic Filtering
The Workexec API SHALL use a single endpoint pattern (e.g., `GET /api/workorders/{id}`) that:
- Accepts a standard request format
- Checks the caller's permission scopes
- Returns a DTO with fields filtered based on those scopes
- Omits fields the caller is not authorized to view

**Rationale:** Single endpoint simplifies client code, API versioning, and reduces maintenance burden.

### BR-API-2: Audit Trail Requirements
Every API request that involves visibility filtering SHALL generate an audit event containing:
- **requestId**: Unique identifier for the request
- **userId**: ID of the user making the request
- **timestamp**: UTC timestamp of the request
- **endpoint**: API endpoint accessed
- **resourceId**: ID of the resource accessed (e.g., work order ID)
- **permissionScopes**: List of permission scopes checked
- **fieldsVisible**: List of fields included in the response
- **fieldsFiltered**: List of fields excluded due to permissions
- **result**: SUCCESS or DENIED

**Rationale:** Comprehensive audit trails support compliance, troubleshooting, and security monitoring.

## Data Requirements
- **Entity**: `WorkorderItem`
    - **Fields to be controlled**: `unitPrice`, `extendedPrice`, `cost`, `margin`. These fields must exist on the entity and be populated.
- **Entity (Dependency)**: `User` / `SecurityPrincipal`
    - **Fields required**: `userId`, `roleId` (or an equivalent collection of assigned roles).
- **Entity (Dependency)**: `VisibilityPolicy`
    - **Purpose**: Defines which roles can view which fields on which entities.
    - **Required Attributes (Conceptual)**: `roleId`, `entityName` (e.g., 'WorkorderItem'), `fieldName` (e.g., 'cost'), `canView` (boolean).

- VisibilityPolicy entity (owned by Security service)
- VisibilityPolicyCache entity (in domain service for caching)
- Permission scope definitions (domain:resource:action)
- Audit event structure for visibility filtering

## Data Model Changes

### VisibilityPolicy (Owned by Security Service)
This entity is defined and managed by the Security service, NOT the Workexec domain.

```json
{
  "policyId": "uuid",
  "domain": "workexec",
  "resource": "workorder",
  "action": "view-pricing",
  "scope": "workexec:workorder:view-pricing",
  "description": "Permission to view pricing fields on work orders",
  "fieldMapping": {
    "unitPrice": true,
    "lineTotal": true,
    "tax": true,
    "discount": true
  },
  "effectiveDate": "2026-01-01T00:00:00Z",
  "expirationDate": null,
  "isActive": true,
  "createdAt": "2025-12-01T00:00:00Z",
  "updatedAt": "2025-12-15T00:00:00Z"
}
```

### VisibilityPolicyCache (In Workexec Domain for Caching)
```json
{
  "cacheId": "uuid",
  "policyId": "uuid (from Security service)",
  "scope": "workexec:workorder:view-pricing",
  "fieldMapping": {
    "unitPrice": true,
    "lineTotal": true,
    "tax": true,
    "discount": true
  },
  "cachedAt": "2026-01-11T10:00:00Z",
  "expiresAt": "2026-01-11T10:15:00Z",
  "version": "v1.2.3"
}
```

### VisibilityAuditEvent (In Workexec Domain for Audit Logging)
```json
{
  "eventId": "uuid",
  "requestId": "uuid",
  "userId": "user-123",
  "timestamp": "2026-01-11T10:30:00Z",
  "endpoint": "/api/workorders/wo-456",
  "resourceId": "wo-456",
  "resourceType": "workorder",
  "permissionScopes": [
    "workexec:workorder:view",
    "workexec:workorder:view-labor"
  ],
  "fieldsVisible": [
    "id", "status", "customerName", "vehicleVIN", 
    "laborItems", "laborHours", "mechanicName"
  ],
  "fieldsFiltered": [
    "unitPrice", "cost", "margin", "discount"
  ],
  "result": "SUCCESS"
}
```
## Acceptance Criteria
### AC-1: Mechanic view is restricted
- **Given** a user is logged in with the "Mechanic" role
- **And** a `WorkorderItem` exists with a `unitPrice` of 100, `cost` of 50, and `margin` of 50
- **When** the mechanic requests the details of that `WorkorderItem`
- **Then** the API response data **MUST NOT** contain the `unitPrice`, `cost`, or `margin` fields (or they must be null)
- **And** the underlying database record for the `WorkorderItem` **MUST** still contain the original financial data.

### AC-2: Back Office view is unrestricted
- **Given** a user is logged in with the "Service Advisor" role, which has full visibility
- **And** a `WorkorderItem` exists with a `unitPrice` of 100, `cost` of 50, and `margin` of 50
- **When** the service advisor requests the details of that `WorkorderItem`
- **Then** the API response data **MUST** contain the correct `unitPrice`, `cost`, and `margin` values.

### AC-3: System defaults to secure on misconfiguration
- **Given** a user is logged in with a "New Temporary Role" that has no defined visibility policy
- **And** a `WorkorderItem` exists with cost, price, and margin data
- **When** the user requests the details of that `WorkorderItem`
- **Then** the system **MUST** apply the default restrictive policy
- **And** the API response data **MUST NOT** contain any sensitive financial fields.

### AC-POLICY-1: Security Service Provides Visibility Policies
**Given** a domain service needs to enforce visibility rules  
**When** the service requests visibility policies from the Security service  
**Then** the Security service returns a list of applicable visibility policies for the domain and resource  
**And** each policy includes the permission scope, field mappings, and metadata

### AC-POLICY-2: Domain Service Caches Policies with Short TTL
**Given** the domain service has retrieved visibility policies from the Security service  
**When** the policies are cached locally  
**Then** the cache TTL is set to a configurable short duration (default: 10 minutes)  
**And** subsequent requests within the TTL use the cached policies  
**And** requests after TTL expiry trigger a refresh from the Security service

### AC-POLICY-3: Cache Invalidated on Policy Change Events
**Given** the domain service is subscribed to policy change events from the Security service  
**When** a policy change event is received  
**Then** the relevant cached policies are immediately invalidated  
**And** the next API request fetches fresh policies from the Security service  
**And** the cache invalidation event is logged for audit

### AC-RBAC-1: Permission Scopes Follow domain:resource:action Pattern
**Given** visibility policies are defined in the Security service  
**When** permission scopes are created or validated  
**Then** each scope follows the format `domain:resource:action`  
**And** invalid scope formats are rejected with a validation error  
**And** scope definitions are documented in the API contract

### AC-RBAC-2: Code Checks Permission Scopes, NOT Role Names
**Given** an API request requires authorization  
**When** the authorization check is performed  
**Then** the code verifies the user has the required permission scope(s)  
**And** the code does NOT check role names directly  
**And** the permission-to-role mapping is maintained in the Security service

### AC-API-1: Single Endpoint with Dynamic DTO Filtering
**Given** a user requests a work order via `GET /api/workorders/{id}`  
**When** the user has some but not all permission scopes  
**Then** the API returns HTTP 200 with a DTO containing only authorized fields  
**And** unauthorized fields are omitted from the response (not null, not present)  
**And** the response structure is consistent regardless of permissions

### AC-API-2: HTTP 403 When Minimum Permissions Not Met
**Given** a user requests a work order via `GET /api/workorders/{id}`  
**When** the user lacks the minimum required permission scope (`workexec:workorder:view`)  
**Then** the API returns HTTP 403 Forbidden  
**And** the response includes a message: "Insufficient permissions to view this resource"  
**And** the failed authorization attempt is logged in the audit trail

### AC-API-3: Partial DTO Returned with Accessible Fields Only
**Given** a user with permission `workexec:workorder:view` but NOT `workexec:workorder:view-pricing`  
**When** the user requests a work order  
**Then** the API returns a DTO with:
  - Basic work order fields (id, status, dates)
  - Customer and vehicle information
  - Labor and parts descriptions
  - BUT pricing fields (unitPrice, cost, margin) are OMITTED  
**And** the response is a valid, well-formed DTO

### AC-AUDIT-1: Audit Trail Captures Request, Permissions, Filtered Fields, UTC Timestamp
**Given** any API request that applies visibility filtering  
**When** the request is processed  
**Then** an audit event is created with:
  - Request ID and user ID
  - UTC timestamp
  - Endpoint and resource ID
  - Permission scopes checked
  - List of visible fields
  - List of filtered fields
  - Result (SUCCESS or DENIED)  
**And** the audit event is persisted to the audit log store  
**And** the audit event can be queried for compliance reporting

## Audit & Observability
- **Audit Log**: Any successful request from an authorized role (e.g., "Service Advisor") for a view containing sensitive financial data **SHOULD** generate an audit log entry. The entry should include `userId`, `workorderId`, `timestamp`, and the `endpoint` or `viewName` accessed.
- **Monitoring/Alerting**: An alert **SHOULD** be triggered and sent to an administrative channel when the system defaults to the secure view due to a missing or misconfigured visibility policy. This indicates a configuration error that requires immediate attention.

- Policy cache hits/misses
- Policy cache invalidation events
- Permission check results (allowed/denied)
- Field filtering decisions
- Failed authorization attempts

## Answered Questions
### Question 1: Policy Source of Truth
**Question:** What is the authoritative source for `VisibilityPolicy` data? Is it configured in a database table within the `Workexec` domain, a static configuration file, or managed by a separate `Security` / `People` domain service via an API? This defines the critical integration contract.

**Decision:** Security/Policy service is authoritative for permissions and visibility rules; domain services enforce server-side and cache with short TTL + invalidation events.

**Interpretation:**
- The **Security/Policy service** is the authoritative source for all visibility policies and permissions
- The **Workexec domain service** is responsible for enforcement but NOT policy authorship
- Domain services SHALL cache visibility policies with:
  - Short TTL (Time-To-Live) to ensure freshness
  - Cache invalidation on policy change events from Security service
- Server-side enforcement is REQUIRED; client-side filtering is supplementary only
- API contract SHALL be defined between Security service and domain services

### Question 2: Field Granularity
**Question:** The story mentions specific fields (`unitPrice`, `cost`, etc.). Is this list exhaustive? Is the policy configurable per-field, or is it a single "Can View Financials" flag per role? The Acceptance Criteria assume per-field control is desired.

**Decision:** Configurable; use explicit RBAC scopes (domain:resource:action) decoupled from role names.

**Interpretation:**
- Field-level visibility SHALL be configurable and NOT hardcoded
- RBAC scopes SHALL follow the pattern: `domain:resource:action`
  - Example: `workexec:workorder:view-pricing`
  - Example: `workexec:workorder:view-cost`
- Role names SHALL be decoupled from permissions (role ‚Üí permissions mapping, NOT role-based checks in code)
- Policy SHALL support granular field-level control (not just coarse-grained "financial" flags)
- The Security service SHALL manage the mapping of roles to permission scopes
- Domain services SHALL check permission scopes, NOT role names

### Question 3: API Strategy
**Question:** Should this be implemented using a single endpoint that returns a differently shaped DTO based on role, or should we use separate, role-specific endpoints (e.g., `/api/workorders/{id}/mechanic-view` vs `/api/workorders/{id}/full-view`)? The functional behavior assumes a single endpoint with a filtered DTO, which is the preferred approach unless otherwise specified.

**Decision:** Use standard best practices with explicit contracts, idempotency, audit trails, UTC timestamps, scoped RBAC, configurable defaults.

**Interpretation:**
- Use a **single endpoint** pattern with dynamic DTO filtering based on permissions
- API contract SHALL be explicit and well-documented (OpenAPI/Swagger)
- Idempotency SHALL be implemented for state-changing operations
- Audit trails SHALL capture:
  - Who requested the data
  - What permissions were applied
  - Which fields were filtered/visible
  - Timestamp in UTC
- RBAC scopes SHALL be checked on every request (no session-level caching of permissions)
- Configurable defaults SHALL be provided for common visibility scenarios
- The endpoint SHALL return HTTP 403 Forbidden if the user lacks the minimum required permission scope
- The endpoint SHALL return a filtered DTO (omitting fields) if the user has partial permissions

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #155 ‚Äî [BACKEND] [STORY] Execution: Apply Role-Based Visibility in Execution UI

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Execution: Apply Role-Based Visibility in Execution UI

**Domain**: user

### Story Description

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
System

## Trigger
A mechanic/technician views a workorder during execution.

## Main Flow
1. System identifies viewer role and applicable visibility policy.
2. System hides restricted pricing/cost fields from mechanic views.
3. System continues to store full financial data in the underlying records.
4. Back office views show full pricing/cost data.
5. System logs access to sensitive fields when shown (optional).

## Alternate / Error Flows
- Role misconfiguration ‚Üí default to safer (hide sensitive) behavior and alert admins.

## Business Rules
- Visibility policies must be consistently enforced across screens and APIs.
- Hiding fields must not remove financial truth from the data model.

## Data Requirements
- Entities: VisibilityPolicy, Workorder, WorkorderItem, UserRole
- Fields: roleId, canViewPrices, unitPrice, extendedPrice, cost, margin

## Acceptance Criteria
- [ ] Mechanic views do not display restricted financial fields.
- [ ] Back office views retain full visibility.
- [ ] Financial data remains present for invoicing and reporting.

## Notes for Agents
This is a UI/API policy layer; keep it separate from business calculations.


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #152: [BACKEND] [STORY] Completion: Finalize Billable Scope Snapshot
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:workexec
- status:ready-for-dev

### Recommended
- agent:workexec
- agent:story-authoring

---

**Rewrite Variant:** workexec-structured

---

## Story Intent
**As a** System,
**I want to** create an immutable, versioned snapshot of all billable items from a completed Work Order,
**So that** the Billing domain has a stable and authoritative source of truth for generating an accurate customer invoice, free from any subsequent changes to the live Work Order.

## Actors & Stakeholders
*   **Actors:**
    *   `Service Advisor` (or equivalent role): The user who initiates the finalization of the Work Order.
    *   `System`: The agent responsible for executing the snapshot creation and validation logic.
*   **Stakeholders:**
    *   `Billing Department`: The primary consumer of the `BillableScopeSnapshot`. Their workflow depends on its accuracy and stability.
    *   `Customer`: The end recipient of the invoice generated from the snapshot.
    *   `Shop Manager`: Responsible for the operational and financial outcomes of work performed.
    *   `Auditors`: Require a clear, auditable trail from work performed to amount billed.

## Preconditions
1.  A `WorkOrder` exists and is in a state that permits finalization (e.g., `WorkComplete`, `PendingFinalization`).
2.  The `Service Advisor` initiating the action has the necessary permissions to finalize work orders.
3.  The `WorkOrder` contains at least one `WorkOrderItem`.

## Functional Behavior

### Trigger
A `Service Advisor` triggers the "Finalize for Billing" action for a specific `WorkOrder` via the user interface.

### Main Success Scenario
1.  The System receives the request to finalize the specified `WorkOrder`.
2.  **Validation Phase (before snapshot creation):**
    - The System identifies all `WorkOrderItem`s associated with the `WorkOrder` that have status `Completed` AND `Authorized`.
    - The System validates that no `Completed` items exist without `Authorized` status (see Business Rules).
    - The System detects any price or tax variance (see Business Rules).
    - If either condition blocks finalization, the operation terminates and an error is returned.
3.  The System validates that at least one billable item exists.
4.  **Snapshot Creation Phase:**
    - The System creates a new `BillableScopeSnapshot` entity, linking it to the `WorkOrder`. A version number is assigned (e.g., `v1`).
    - For each valid billable item, the System creates an immutable `BillableScopeSnapshotItem` record, copying all financially relevant details (e.g., description, quantity, unit price, line total, tax rates, fees).
    - The System calculates and stores aggregate totals (subtotal, tax total, fee total, grand total) on the `BillableScopeSnapshot` header.
    - The System records the initiating user's ID and the current timestamp on the snapshot.
5.  **Post-Snapshot State Updates:**
    - The System updates the `WorkOrder` status to `FinalizedForBilling`.
    - The System updates the status of the corresponding `WorkOrderItem`s to `InvoiceReady`.
6.  **Event Emission:**
    - The System emits an event (e.g., `BillableScopeFinalized`) to notify downstream consumers like the Billing system.

### Variance Approval (if needed)
- If a price or tax variance is detected during validation:
  - The user receives error message with variance details
  - User must explicitly approve the variance (requires elevated permission if threshold exceeded)
  - Approval includes: `approverId`, `timestamp`, `reasonCode`
  - Only after approval proceeds finalization to snapshot creation phase

## Alternate / Error Flows

*   **Flow 1: Completed but Unauthorized Items Exist (HARD BLOCK)**
    *   **Trigger**: The System detects `WorkOrderItem`s that are `status: Completed` but not `status: Authorized`.
    *   **Outcome**: Finalization is blocked. No snapshot is created. The System returns an error to the user interface, enumerating which items require authorization before the Work Order can be finalized. User must either obtain authorization for items or remove them from Work Order.

*   **Flow 2: No Billable Items Found**
    *   **Trigger**: The System finds no `WorkOrderItem`s that are both `Completed` and `Authorized`.
    *   **Outcome**: The finalization process is blocked. The System returns an error message stating, "No billable items are available to be finalized."

*   **Flow 3: Price or Tax Variance Detected (HARD STOP with Approval Gate)**
    *   **Trigger**: During validation, the System detects that a current tax rate or item price differs from what was on the original, authorized estimate.
    *   **Outcome**: 
      - Finalization is blocked until variance is explicitly approved
      - User must approve variance (may require elevated permission depending on variance threshold)
      - Error message specifies variance details and required approval level
      - After approval, finalization proceeds to snapshot creation
      - Approved variance is recorded with `approverId`, `timestamp`, `reasonCode`

*   **Flow 4: Post-Finalization Correction (Controlled, Role-Gated)**
    *   **Trigger**: A user with elevated permission (`Manager` or `FinanceManager`) attempts to correct a finalized Work Order.
    *   **Outcome**: 
      - Finalized Work Orders are read-only by default
      - Correction requires explicit "Correction Initiation" action with mandatory `reasonCode`
      - Original snapshot is never modified; creates new corrective snapshot or delta record
      - New snapshot links to original via `correctsSnapshotId`
      - Full audit trail of correction is maintained
      - Note: Detailed correction workflow may be implemented as separate story, but this story enforces permission checks

## Business Rules

*   **BR1: Immutability as Source of Truth:** The `BillableScopeSnapshot` and its line items are immutable once created. All invoicing and financial reporting for the work performed must be derived exclusively from this snapshot.

*   **BR2: Authorization Prerequisite:** Only `WorkOrderItem`s that are explicitly `Authorized` shall be included in the billable scope. This is enforced as a hard block.

*   **BR3: Completion Prerequisite:** Only `WorkOrderItem`s marked as `Completed` shall be included in the billable scope.

*   **BR4: Completed but Unauthorized Hard Block:** If ANY `WorkOrderItem` has `status: Completed` but lacks `status: Authorized`, finalization is **blocked**. No snapshot is created until all completed items are authorized or removed.
    - **Rationale:** Prevents unbilled or disputed work from entering financial record; eliminates revenue leakage and reconciliation complexity; aligns with compliance and audit expectations.

*   **BR5: Price/Tax Variance Hard Stop:** If a price or tax variance is detected (current rates differ from authorized estimate):
    - Finalization is **blocked** until user explicitly acknowledges and approves the variance
    - Approval may require elevated permission depending on variance threshold
    - Variance approval is synchronous (not background review)
    - **Rationale:** Finalization produces immutable financial snapshot; variances must be resolved beforehand; avoids retroactive corrections and audit exceptions; keeps pricing/tax authority explicit and controlled.

*   **BR6: Mandatory Versioning:** Every snapshot generation for a `WorkOrder` must create a new, sequentially versioned record. The previous version (if any) must be marked as `Superseded`.

*   **BR7: Controlled Post-Finalization Corrections:**
    - Finalized Work Orders are **read-only by default**
    - Corrections require explicit "Correction Initiation" action with mandatory `reasonCode`
    - Only authorized roles (`Manager`, `FinanceManager`, or equivalent) can initiate corrections
    - Original snapshot is never modified; corrections create new snapshot/delta record with link to original (`correctsSnapshotId`)
    - All corrections are fully audited and append-only
    - **Rationale:** Preserves immutability of finalized financial records; supports compliance and traceability; prevents silent or ad-hoc edits.

## Data Requirements

*   **`BillableScopeSnapshot` Entity:**
    *   `snapshotId`: Unique identifier (PK).
    *   `workOrderId`: Foreign key to the `WorkOrder`.
    *   `snapshotVersion`: Integer (e.g., 1, 2, 3).
    *   `snapshotStatus`: Enum (`Active`, `Superseded`, `PendingReview`).
    *   `subtotalAmount`: Monetary value.
    *   `taxTotalAmount`: Monetary value.
    *   `feeTotalAmount`: Monetary value.
    *   `grandTotalAmount`: Monetary value.
    *   `hasVariance`: Boolean flag (true if variance was detected and approved).
    *   `varianceApprovedBy`: UUID, nullable (user who approved variance if applicable).
    *   `varianceApprovedAt`: Timestamp, nullable.
    *   `varianceReasonCode`: String, nullable.
    *   `correctsSnapshotId`: UUID, nullable (reference to original if this is a corrective snapshot).
    *   `createdByUserId`: Identifier for the user who initiated the snapshot.
    *   `createdAt`: Timestamp.

*   **`BillableScopeSnapshotItem` Entity:**
    *   `snapshotItemId`: Unique identifier (PK).
    *   `snapshotId`: Foreign key to the `BillableScopeSnapshot`.
    *   `sourceWorkOrderItemId`: Foreign key for traceability.
    *   `description`: Text (copied).
    *   `quantity`: Numeric (copied).
    *   `unitPrice`: Monetary value (copied).
    *   `lineTotal`: Monetary value (copied).
    *   `taxDetails`: JSON or structured data representing taxes applied (copied).
    *   `feeDetails`: JSON or structured data representing fees applied (copied).

*   **State Model Updates:**
    *   `WorkOrder`: The status model must include `FinalizedForBilling` and `ReviewRequired`.
    *   `WorkOrderItem`: The status model must include `InvoiceReady`.

## Acceptance Criteria

### AC1: Successful Snapshot Creation (Happy Path)
*   **Given** a `WorkOrder` is in a `WorkComplete` state with three `WorkOrderItem`s that are all `Completed` and `Authorized`
*   **When** the `Service Advisor` finalizes the `WorkOrder` for billing
*   **Then** a new `BillableScopeSnapshot` with `snapshotVersion: 1` and `snapshotStatus: Active` is created
*   **And** it contains exactly three `BillableScopeSnapshotItem`s corresponding to the source items
*   **And** the `WorkOrder` status is updated to `FinalizedForBilling`
*   **And** the three source `WorkOrderItem`s are updated to `status: InvoiceReady`
*   **And** a `BillableScopeFinalized` event is emitted.

### AC2: Hard Block on Unauthorized Items
*   **Given** a `WorkOrder` has two items: one is `Completed` and `Authorized`, and the other is `Completed` but not `Authorized`
*   **When** the `Service Advisor` attempts to finalize the `WorkOrder`
*   **Then** the operation fails immediately
*   **And** no `BillableScopeSnapshot` is created
*   **And** the system returns an error message identifying the unauthorized item and required actions.

### AC3: Hard Stop on Price/Tax Variance (with Approval Gate)
*   **Given** a `WorkOrder` with `Completed` and `Authorized` items
*   **And** the current system tax rate for a service has changed since the `WorkOrder` estimate was approved
*   **When** the `Service Advisor` attempts to finalize the `WorkOrder`
*   **Then** finalization is blocked
*   **And** the system returns an error detailing the variance and the approval requirement
*   **And** when the user explicitly approves the variance (with elevated permission if threshold exceeded)
*   **Then** a `BillableScopeSnapshot` is created
*   **And** its `hasVariance` flag is set to `true`
*   **And** variance approval details are recorded (`varianceApprovedBy`, `varianceApprovedAt`, `varianceReasonCode`)
*   **And** the `WorkOrder` status is updated to `FinalizedForBilling`.

### AC4: Snapshot Versioning on Correction
*   **Given** a `WorkOrder` has an existing `BillableScopeSnapshot` at `snapshotVersion: 1` with `snapshotStatus: Active`
*   **And** a correction flow is initiated which reverts the `WorkOrder` to an editable state
*   **When** the `Service Advisor` re-finalizes the `WorkOrder` for billing
*   **Then** the original snapshot is updated to `snapshotStatus: Superseded`
*   **And** a new `BillableScopeSnapshot` is created with `snapshotVersion: 2` and `snapshotStatus: Active`
*   **And** the new snapshot has `correctsSnapshotId` pointing to the original snapshot.

### AC5: Reject Correction Without Permission
*   **Given** a `WorkOrder` is in `FinalizedForBilling` status
*   **And** a user with standard `ServiceAdvisor` role (not `Manager` or `FinanceManager`) attempts to initiate correction
*   **When** the system evaluates the permission
*   **Then** the request is rejected with authorization error
*   **And** the original snapshot remains unmodified.

### AC6: Mandatory Reason Code for Correction
*   **Given** a user with elevated permission attempts to initiate a correction of a finalized Work Order
*   **When** the user attempts to proceed without providing a `reasonCode`
*   **Then** the system rejects the action with validation error
*   **And** correction cannot proceed until `reasonCode` is supplied.

## Audit & Observability

*   **Audit Trail:** The creation of every `BillableScopeSnapshot` and variance approval must generate audit log entries containing:
    *   `Event`: `BillableScopeSnapshotCreated` or `VarianceApproved`
    *   `Actor`: `userId` of the initiator
    *   `Target`: `workOrderId`, `snapshotId`
    *   `Timestamp`: Event timestamp
    *   `Details`: Result (e.g., `Success`, `SuccessWithVariance`), version number, variance details if applicable

*   **Logging:**
    *   `INFO`: Log successful snapshot creation, including version number, item count, and totals
    *   `WARN`: Log variance detections with threshold and required approval level
    *   `INFO`: Log variance approvals with approver and reason code
    *   `ERROR`: Log finalization failures (unauthorized items, variance rejection, etc.)

*   **Metrics:**
    *   `billing.snapshot.created.count`: Counter, incremented on successful snapshot creation
    *   `billing.snapshot.variance.count`: Counter, incremented when variance is detected
    *   `billing.snapshot.variance.approved.count`: Counter, incremented when variance is approved
    *   `billing.finalization.blocked.count`: Counter by reason (unauthorized_items, variance_pending, etc.)

## Clarification Resolution

All blocking policy questions have been resolved:

### 1. Policy for Completed but Unauthorized Items
**Decision:** **Option A ‚Äî Strict (Hard Block)**

- **Finalization is blocked** if any **Completed but Unauthorized** items exist
- User must either obtain authorization or remove items from Work Order
- **No snapshot is created** until all completed work is authorized
- **Rationale:** Prevents unbilled or disputed work from entering financial record; eliminates revenue leakage; aligns with compliance and audit expectations

### 2. Policy for Price or Tax Variance Detection
**Decision:** **Option B ‚Äî Hard Stop with Explicit Approval**

- If a price or tax variance is detected, **finalization is blocked**
- User must **explicitly acknowledge and approve** the variance
- Approval may require elevated permission depending on threshold
- Only after approval is **BillableScopeSnapshot** created
- Variance approval recorded with `approverId`, `timestamp`, `reasonCode`
- **Rationale:** Finalization produces immutable financial snapshot; variances must be resolved beforehand; avoids retroactive corrections; keeps pricing/tax authority explicit and controlled

### 3. Correction Workflow (Post-Finalization)
**Decision:** **Controlled correction with elevated permissions and full audit**

**Authorized Roles:**
- `Manager`
- `FinanceManager` (or equivalent)

**Policy:**
- Finalized Work Orders are **read-only by default**
- Corrections require:
  - Explicit **Correction Initiation** action
  - Mandatory **reasonCode**
  - Creation of **Correction Event** (append-only)
- Original snapshot is **never modified**; corrections create:
  - New corrective snapshot or delta record
  - Linkage to original snapshot via `correctsSnapshotId`
- **Rationale:** Preserves immutability of finalized financial records; supports compliance and traceability; prevents silent or ad-hoc edits

**Status:** All policy questions resolved; story is unblocked and ready for implementation.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #152 ‚Äî [BACKEND] [STORY] Completion: Finalize Billable Scope Snapshot

## Current Labels
- backend
- blocked:clarification
- domain:workexec
- status:draft
- story-implementation
- type:story
- user

## Original Scope
This story defines the mechanism for creating an immutable, versioned snapshot of billable items when a Work Order is finalized, ensuring the Billing domain has a stable source of truth for invoice generation.


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #150: [BACKEND] [STORY] Completion: Reopen Completed Workorder (Controlled)
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Current / Intended)

### Required
- type:story
- domain:workexec
- status:ready-for-dev

### Supporting
- backend
- story-implementation

---

## Story Intent
As a Back Office Manager, I need to reopen a completed work order with a mandatory reason, so that I can correct errors before an invoice is generated, while ensuring the action is strictly controlled and audited.

## Actors & Stakeholders
- **Primary Actor:** Back Office Manager (or any user role with the `WORKORDER_REOPEN_COMPLETED` permission).
- **Stakeholders:**
  - Accounting System: Receives a `WorkorderReopened` event to signal the invalidation of any previous completion data.
  - Service Advisor: May need to edit the work order after it has been reopened.

## Preconditions
- A `Workorder` entity exists with a status of `COMPLETED`.
- No `Invoice` associated with this `Workorder` has been `ISSUED` or `FINALIZED`.
- The user initiating the action has the `WORKORDER_REOPEN_COMPLETED` permission granted to their role.

## Functional Behavior
1. **Trigger:** An authorized user selects the "Reopen Work Order" action for a work order in the `COMPLETED` state.
2. **Input:** The system prompts the user to provide a mandatory, non-empty `reopenReason` text.
3. **Validation:**
   - The system verifies the user has the `WORKORDER_REOPEN_COMPLETED` permission.
   - The system confirms the work order status is `COMPLETED`.
   - The system verifies that no `ISSUED` or `FINALIZED` invoice is linked to the work order.
   - The system validates that the `reopenReason` is not null or empty.
4. **State / Flag Update (Clarification #300 applied):** Upon successful validation, the system performs the following state changes atomically:
   - `Workorder.status` remains semantically `COMPLETED`.
   - Sets `Workorder.isReopened = true`.
   - Finds the active `BillableScopeSnapshot` associated with the last completion and transitions its status to `SUPERSEDED` (becomes read-only historical record).
   - Revokes the work order‚Äôs "invoice-ready" flag.
5. **Editability Controls (Clarification #300 applied):** After reopening, fields become editable only according to a configured editability policy (see Data Requirements). Field-level permissions must be enforced.
6. **Auditing & Eventing:**
   - An `AuditEvent` is created, recording the `WorkorderReopened` action, the responsible user, the timestamp, and the `reopenReason`.
   - A `WorkorderReopened` domain event is published to the event bus for downstream consumers like the Accounting domain. The event must be idempotent.
7. **Outcome:** The work order is flagged as reopened (`isReopened=true`), specific fields are unlocked for editing per policy, and it cannot be invoiced until it is taken through the completion workflow again.

## Alternate / Error Flows
- **Error - Unauthorized User:** If the user lacks the `WORKORDER_REOPEN_COMPLETED` permission, the system blocks the action and displays an "Access Denied" error message. No state changes occur.
- **Error - Invalid Work Order State:** If the work order is not in the `COMPLETED` state, the "Reopen" action is unavailable or, if invoked via API, returns an error indicating an invalid state.
- **Error - Invoice Already Issued:** If an invoice has already been issued for the work order, the system blocks the action and returns an error stating, "Cannot reopen a work order that has been invoiced." (credit/rebill workflow is out of scope)
- **Error - Missing Reason:** If the user submits the action without a `reopenReason`, the system displays a validation error and prevents the workflow from proceeding until a reason is provided.

## Business Rules
- **BR1: Permission Gated:** The ability to reopen a completed work order is a privileged action, controlled by the `WORKORDER_REOPEN_COMPLETED` permission.
- **BR2: Invoice Irreversibility:** Once a work order is invoiced, it cannot be reopened through this workflow. A separate credit/rebill process must be used.
- **BR3: Mandatory Justification:** All reopen events must be justified with a non-empty reason to ensure a clear audit trail.
- **BR4: Snapshot Invalidation:** Reopening a work order invalidates the billing snapshot taken at the time of its last completion. A new snapshot must be generated upon subsequent completion.
- **BR5: Re-Completion Required:** A reopened work order must be processed through the standard completion workflow again to become eligible for invoicing.
- **BR6: Policy-Driven Field Editability:** Editable fields after reopening are defined by policy and enforced via field-level permissions. All edits must be auditable with before/after values.

## Data Requirements
- **`Workorder` Entity:**
  - `status`: Remains `COMPLETED`.
  - `isReopened: boolean`: Set true on reopen; set false on subsequent completion.
- **`BillableScopeSnapshot` Entity:**
  - `status`: Transition from `ACTIVE` to `SUPERSEDED` on reopen.
  - `supersededAt`: Timestamp of the reopen action.
  - `supersededBy`: User ID of the actor who reopened.
  - `supersededReason`: The `reopenReason`.
- **`EditabilityPolicy` (config/table) (Clarification #300 applied):**
  - Configurable per work order type and role.
  - Defines `editableFields[]` and `readOnlyFields[]`.
  - Supports effective dating and location scoping.
- **`AuditEvent` Entity:**
  - A new record with `eventType: 'WORKORDER_REOPENED'`, `entityId`, `userId`, `timestamp`, and a `details` field containing `reopenReason`.
  - For subsequent field edits: track before/after values and correlate to the reopen event via `reopenEventId`.
- **`WorkorderReopened` Domain Event (integration):**
  - `eventId`: Unique event identifier.
  - `idempotencyKey`: `workorderId` + a version/timestamp identifier for the reopen action.
  - `workorderId`: The ID of the affected work order.
  - `reopenedAt`: ISO 8601 timestamp.
  - `reopenedBy`: User ID.
  - `reopenReason`: The mandatory justification text.
  - `supersededSnapshotId`: The ID of the now-invalidated billing snapshot.

## Acceptance Criteria
- **AC1: Successful Reopen by Authorized User**
  - **Given** a Back Office Manager with `WORKORDER_REOPEN_COMPLETED` permission
  - **And** a work order exists with status `COMPLETED` and no issued invoice
  - **When** the manager reopens the work order with a valid reason, "Corrected labor hours"
  - **Then** `Workorder.isReopened` is set to `true`
  - **And** the previously active `BillableScopeSnapshot` is marked as `SUPERSEDED`
  - **And** an audit event is created with the correct user, reason, and timestamp
  - **And** a `WorkorderReopened` domain event is published.

- **AC2: Attempted Reopen by Unauthorized User**
  - **Given** a user without `WORKORDER_REOPEN_COMPLETED` permission
  - **And** a work order exists with status `COMPLETED`
  - **When** the user attempts to reopen the work order
  - **Then** the system returns an authorization error
  - **And** the work order remains unchanged.

- **AC3: Attempted Reopen of an Invoiced Work Order**
  - **Given** an authorized Back Office Manager
  - **And** a work order exists with status `COMPLETED`
  - **And** an invoice associated with that work order has been `ISSUED`
  - **When** the manager attempts to reopen the work order
  - **Then** the system returns an error indicating the work order is already invoiced
  - **And** the work order remains unchanged.

- **AC4: Reopen Action Requires a Reason**
  - **Given** an authorized Back Office Manager
  - **And** a work order exists with status `COMPLETED`
  - **When** the manager attempts to reopen the work order without providing a reason
  - **Then** the system displays a validation error
  - **And** the work order remains unchanged.

- **AC5: Field Editability Policy Enforcement**
  - **Given** a reopened work order (`isReopened=true`) and an editability policy configured
  - **When** a user attempts to edit a field
  - **Then** only fields allowed by policy + field-level permissions can be edited
  - **And** all edits are auditable with before/after values.

## Audit & Observability
- **Audit Log:** A structured audit log entry must be created for every successful reopen attempt. It must contain the `workorderId`, `userId`, `reopenReason`, and a timestamp.
- **Metrics:** A counter metric (`workorders.reopened.count`) should be incremented for each successful reopen.
- **Eventing:** The successful publication of the `WorkorderReopened` event must be monitored. Failures to publish should trigger an alert.

## Clarification Resolution
- Clarifications were captured and resolved in issue #300. The resolution is applied in this story body.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #150 ‚Äî [BACKEND] [STORY] Completion: Reopen Completed Workorder (Controlled)

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Completion: Reopen Completed Workorder (Controlled)

**Domain**: user

### Story Description

[Durion_Accounting_Event_Contract_v1.pdf](https://github.com/user-attachments/files/24300018/Durion_Accounting_Event_Contract_v1.pdf)

/kiro
Produce implementation-ready acceptance criteria, validations, and edge cases. Keep Moqui state transitions and audit requirements explicit.

# Functional Requirement

## Classification (confirm labels)
- Type: story
- Layer: functional
- Domain: workexec

## Actor
Back Office Manager

## Trigger
A completed workorder needs correction after completion.

## Main Flow
1. Authorized user selects 'Reopen' and provides a mandatory reason.
2. System records reopen audit event and transitions workorder to Reopened (or InProgress per policy).
3. System unlocks specific editable fields per policy.
4. System marks prior billable scope snapshot as superseded.
5. System requires re-completion and re-snapshot before invoicing.

## Alternate / Error Flows
- User lacks permission ‚Üí block.
- Invoice already issued ‚Üí block reopen or require credit/rebill workflow (out of scope).

## Business Rules
- Reopen is an exception workflow with strict permissions and audit.
- Reopening invalidates invoice-ready snapshot.

## Data Requirements
- Entities: Workorder, BillableScopeSnapshot, AuditEvent
- Fields: status, reopenReason, reopenedBy, reopenedAt, supersededSnapshotVersion

## Acceptance Criteria
- [ ] Only authorized users can reopen completed workorders.
- [ ] Reopen is auditable and requires a reason.
- [ ] Invoice-ready snapshot is invalidated and must be regenerated.
- [ ] Reopen emits a single WorkorderReopened event
- [ ] Any completion-related accounting state is reversible
- [ ] Invoice eligibility is revoked if not yet invoiced
- [ ] Reopen requires authorization and records reason
- [ ] Repeated reopen attempts do not emit duplicate events

## Integrations

### Accounting
- Emits Event: WorkorderReopened
- Event Type: Non-posting (reversal / invalidation signal)
- Source Domain: workexec
- Source Entity: Workorder
- Trigger: Authorized reopen of a completed workorder
- Idempotency Key: workorderId + reopenVersion


## Notes for Agents
Don‚Äôt allow silent edits after completion; reopen is the controlled escape hatch.


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #98: [BACKEND] [STORY] Billing: Enforce PO Requirement During Estimate Approval
LABELS: type:story,domain:workexec,status:ready-for-dev,agent:story-authoring,agent:crm,agent:workexec,agent:billing
BODY:
## Story Intent
As a Service Advisor, I want Estimate approval to enforce a Purchase Order (PO) requirement when the customer‚Äôs CRM BillingRule mandates it, so non-compliant estimates cannot be approved and downstream billing has the PO reference available.

## Actors & Stakeholders
- **Primary actor:** Service Advisor
- **Workflow owner / SoR for Estimate approval + PO reference:** Workorder Execution (`domain:workexec`)
- **Rules/config provider:** CRM (`domain:crm`) provides BillingRule as a versioned read contract
- **Downstream consumer:** Billing (`domain:billing`) consumes PO reference from Workexec (read-only)

## Preconditions
- A Work Order / Estimate exists in `Pending Approval`.
- Work Order is linked to a customer/account identifier usable to query CRM BillingRule.
- Caller is authorized to approve estimates.

## Functional Behavior
### 1) Approve Estimate (Workexec-owned)
- Trigger: Service Advisor invokes `ApproveEstimate` for a Work Order/Estimate.
- Workexec retrieves the effective CRM BillingRule for that customer using a versioned CRM API.
- Workexec evaluates `requirePurchaseOrderOnEstimateApproval`.

### 2) Enforcement when PO is required
- If BillingRule indicates PO is required:
  - Workexec validates `purchaseOrderReference.poNumber` per validation rules below.
  - If `attachmentId` is provided, Workexec validates it as a reference to the attachment/document system (existence + authorization).
  - If any validation fails, approval is blocked and the Estimate remains `Pending Approval`.

### 3) Successful approval
- If PO is not required, or all required PO validation passes:
  - Workexec persists `purchaseOrderReference` on the Estimate/Work Order.
  - Workexec transitions Estimate state to `Approved` atomically with persistence.
  - Workexec publishes `EstimateApproved` including the full `purchaseOrderReference` (if present).

## Alternate / Error Flows
- Missing PO when required ‚Üí block approval; return error code `PurchaseOrderNumberMissing`.
- Invalid PO number format ‚Üí block approval; return `PurchaseOrderNumberInvalidFormat`.
- PO number too long ‚Üí block approval; return `PurchaseOrderNumberTooLong`.
- CRM BillingRule unavailable (timeout/5xx/network) ‚Üí **fail-safe**: block approval; return `503` (or domain error `BillingRuleUnavailable`).
- CRM returns 404 (no BillingRule configured) ‚Üí block approval as configuration error; return `BillingRuleNotConfigured`.
- AttachmentId invalid / not found / unauthorized ‚Üí block approval with `PurchaseOrderAttachmentInvalidId` / `PurchaseOrderAttachmentNotFound` / `PurchaseOrderAttachmentUnauthorized`.

## Business Rules
- **Primary domain ownership (Decision):** Workexec owns the Estimate approval state transition and the enforcement logic that blocks/permits approval.
- **System of record (Decision):** Workexec is the system of record for `PurchaseOrderReference` attached to an Estimate/Work Order.
- **CRM contract (Decision):** Workexec queries CRM via a **versioned HTTP API** for BillingRule.
- **Failure mode (Decision):** fail-safe (block approval) if BillingRule cannot be determined.

## Integration Contract (CRM BillingRule)
- Versioned endpoint example: `GET /api/v1/billing-rules/{customerId}`
- Response includes:
  - `customerId`
  - `requirePurchaseOrderOnEstimateApproval` (boolean)
  - `effectiveFrom` (timestamp)
  - `version` (integer)

## Data Requirements
### Workexec entity
- `purchaseOrderReference` (nullable complex type)
  - `poNumber` (string)
  - `attachmentId` (UUID, optional)

### PO Number validation (Decision)
- Required only when BillingRule requires it.
- Trim whitespace; reject if empty after trim.
- Length: 1..64 characters.
- Allowed characters: A‚ÄìZ, a‚Äìz, 0‚Äì9, space, and `- _ / .`.
  - Regex example: `^[A-Za-z0-9][A-Za-z0-9 _./-]{0,63}$`
- No uniqueness constraints assumed.

### AttachmentId validation (Decision)
- `attachmentId` is a foreign key/reference to the attachment/document system (not free text, not a URI).
- If provided, must be valid UUID format and must exist and be authorized.

## Acceptance Criteria
- **AC-1: PO required and provided ‚Üí approval succeeds**
  - Given BillingRule requires PO
  - When Service Advisor provides a valid `poNumber` and approves
  - Then Estimate transitions to `Approved` and Workexec persists `purchaseOrderReference`.

- **AC-2: PO required and missing ‚Üí approval blocked**
  - Given BillingRule requires PO
  - When approval is attempted without `poNumber`
  - Then approval is rejected, Estimate remains `Pending Approval`, and error `PurchaseOrderNumberMissing` is returned.

- **AC-3: PO not required ‚Üí approval succeeds without PO**
  - Given BillingRule does not require PO
  - When approval is attempted without `poNumber`
  - Then approval succeeds and `purchaseOrderReference` remains null.

- **AC-4: CRM unavailable ‚Üí fail-safe blocks approval**
  - Given approval is attempted
  - When CRM BillingRule cannot be retrieved due to timeout/5xx/network
  - Then approval is blocked and a retryable error is returned.

- **AC-5: Downstream visibility via Workexec**
  - Given an Estimate is approved with `purchaseOrderReference`
  - When a downstream consumer reads the approved Work Order (API/event)
  - Then `purchaseOrderReference` is included in the payload.

## Audit & Observability
- Audit every approval attempt with `workOrderId`, result, and failure reason (e.g., `PO_REQUIRED_BUT_MISSING`, `BILLING_RULE_UNAVAILABLE`).
- Metrics counters for approve attempts and PO validation failures (tagged by reason).
- Publish `EstimateApproved` on success; include `workOrderId`, `customerId`, and `purchaseOrderReference` if present.

## Open Questions
- None. Decisions were supplied in the issue comments (Decision Record generated by `clarification-resolver.sh` on 2026-01-14).

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #98 ‚Äî [BACKEND] [STORY] Billing: Enforce PO Requirement During Estimate Approval

## Current Labels
- backend
- story-implementation
- payment

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Billing: Enforce PO Requirement During Estimate Approval

**Domain**: payment

### Story Description

/kiro
# User Story

## Narrative
As a **Service Advisor**, I want **the system to require a PO when account rules mandate it** so that **billing exceptions are reduced**.

## Details
- PO required triggers validation in Estimate approval step.
- Capture PO number and optional attachment reference.

## Acceptance Criteria
- Approval blocked without PO when required.
- PO stored and visible on invoice.

## Integration Points (Workorder Execution)
- Workorder Execution checks CRM billing rules and enforces PO before approval.

## Data / Entities
- PurchaseOrderRef (WO domain)
- CRM BillingRule reference

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: CRM


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #93: [BACKEND] [STORY] Integration: Emit CRM Reference IDs in Workorder Artifacts
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:workexec
- status:draft

### Recommended
- agent:workexec
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** workexec-structured
---
## Story Intent
As the Workorder Execution System, I want to durably store immutable CRM entity references (`partyId`, `vehicleId`, `contactIds`) within Workorder and Estimate artifacts. This ensures that every work-related record has a permanent, traceable link back to the authoritative CRM records they were created for, enabling reliable reporting and integration even if the original CRM entities are later merged or aliased.

## Actors & Stakeholders
- **Actors**:
  - `Workorder Execution Service`: The primary system responsible for creating, updating, and persisting Workorder and Estimate entities.
  - `CRM Service`: The authoritative System of Record for customer, vehicle, and contact entities and their identifiers.
  - `Client System` (e.g., POS Terminal): The system that initiates the creation of an Estimate or Workorder and supplies the necessary CRM identifiers.

- **Stakeholders**:
  - `Reporting & Analytics System`: Consumes Workorder data and relies on the stable CRM references to join data across domains.
  - `Auditors`: Require a clear, traceable link between work performed and the customer/vehicle it was for.
  - `Integration Partners`: May consume Workorder events or data and use the CRM references to correlate information.

## Preconditions
- A request to create or update a Workorder or Estimate is being processed.
- The request payload from the `Client System` contains validly formatted identifiers for `crmPartyId`, `crmVehicleId`, and `crmContactIds`.
- The `Workorder Execution Service` has network access to its persistence layer (database).

## Functional Behavior
### Scenario: Creating a New Estimate with CRM References
- **Trigger**: The `Workorder Execution Service` receives a `POST /estimates` request from a `Client System`.
- **Process**:
  1. The request payload is deserialized and validated. The validation MUST confirm the presence of `crmPartyId`, `crmVehicleId`, and `crmContactIds`.
  2. The service maps the payload to an internal `Estimate` entity.
  3. The `crmPartyId`, `crmVehicleId`, and `crmContactIds` are stored in their designated fields on the `Estimate` entity.
  4. The service persists the `Estimate` entity to the database.
- **Outcome**: A new Estimate record is created in the database, with the provided CRM reference IDs stored immutably as part of the record. A success response (`201 Created`) is returned to the client.

## Alternate / Error Flows
- **Flow 1: Missing Required CRM Identifiers**
  - **Scenario**: A create/update request is received, but one or more of `crmPartyId` or `crmVehicleId` are null or missing.
  - **Outcome**: The request is rejected with a `400 Bad Request` HTTP status. The response body clearly indicates which required fields were missing.

- **Flow 2: Database Persistence Failure**
  - **Scenario**: The service attempts to save the Workorder/Estimate entity, but the database write operation fails.
  - **Outcome**: The transaction is rolled back. The service returns a `500 Internal Server Error` response.

## Business Rules
- **Rule-1**: All created `Workorder` and `Estimate` entities MUST store a non-null reference to a `crmPartyId` and a `crmVehicleId`.
- **Rule-2**: The `crmContactIds` field may be an empty list but must not be null.
- **Rule-3**: The stored CRM identifiers are point-in-time references. The `Workorder Execution Service` is NOT responsible for updating these IDs if the associated CRM entities change.
- **Rule-4**: The `Workorder Execution Service` is NOT responsible for resolving CRM entity merges or aliases. It stores the IDs as provided. Downstream consumers are responsible for using the `CRM Service`'s resolution capabilities to find the canonical entity for a given ID.

## Data Requirements
- **Affected Entities**: `Estimate`, `Workorder`
- **New Fields/Schema Changes**:
  - `crm_party_id`:
    - **Type**: To be confirmed (e.g., UUID, VARCHAR). See Open Questions.
    - **Constraints**: Non-nullable, Indexed.
  - `crm_vehicle_id`:
    - **Type**: To be confirmed (e.g., UUID, VARCHAR). See Open Questions.
    - **Constraints**: Non-nullable, Indexed.
  - `crm_contact_ids`:
    - **Type**: Array of the contact ID type or JSONB.
    - **Constraints**: Non-nullable (can be an empty array `[]`).

- **Data Source**: The values for these fields are provided in the API request payload from the `Client System`.
- **Data Authority**: The `CRM Service` is the authority for the entities these IDs represent. The `Workorder Execution Service` is the authority for the stored reference copies within its domain.

## Acceptance Criteria
- **AC-1: Successful Estimate Creation**
  - **Given** a valid API request to create a new Estimate containing `crmPartyId: "party-abc"`, `crmVehicleId: "vehicle-123"`, and `crmContactIds: ["contact-x", "contact-y"]`.
  - **When** the `Workorder Execution Service` successfully processes the request.
  - **Then** a new Estimate record is created in the database.
  - **And** the record's `crm_party_id` column contains `"party-abc"`, the `crm_vehicle_id` column contains `"vehicle-123"`, and the `crm_contact_ids` column contains the array `["contact-x", "contact-y"]`.

- **AC-2: Workorder Conversion Preserves IDs**
  - **Given** an existing Estimate with `crmPartyId: "party-abc"` and `crmVehicleId: "vehicle-123"`.
  - **When** that Estimate is converted into a Workorder.
  - **Then** the newly created Workorder record also contains `crm_party_id: "party-abc"` and `crm_vehicle_id: "vehicle-123"`.

- **AC-3: Request Fails with Missing Vehicle ID**
  - **Given** an API request to create an Estimate that is missing the `crmVehicleId` field.
  - **When** the `Workorder Execution Service` receives the request.
  - **Then** the service must reject the request with a `400 Bad Request` status.
  - **And** the API response body must indicate that `crmVehicleId` is a required field.

- **AC-4: Data Integrity for Downstream Traceability**
  - **Given** a Workorder has been stored with `crmPartyId: "party-old-id"`.
  - **And** the `CRM Service` later merges `"party-old-id"` into a canonical `"party-new-id"`.
  - **When** a `Reporting System` queries the Workorder and retrieves the stored `crm_party_id` (`"party-old-id"`).
  - **Then** the `Reporting System` must be able to use a separate `CRM Service` mechanism (e.g., an alias resolution API) to successfully resolve `"party-old-id"` to `"party-new-id"`.

## Audit & Observability
- **Audit Logging**: On successful creation of a Workorder or Estimate, an audit log must be generated containing the `workorderId`/`estimateId` and the associated `crmPartyId` and `crmVehicleId`.
- **Metrics**:
  - `workorder.creation.success`: Counter for successfully created Workorders.
  - `workorder.creation.failure`: Counter for failed Workorder creations, tagged by error type (e.g., `validation`, `database`).
- **Distributed Tracing**: Traces for create/update operations must include the `crmPartyId` and `crmVehicleId` as attributes for easier debugging and analysis.

## Open Questions
- **Q1 (Alias Resolution Contract)**: The original story mentions "CRM provides alias resolution endpoint if needed". What is the specific contract (URL, request/response format) for this endpoint? Does it already exist? We are assuming consumers of Workorder data (like reporting) are responsible for calling this endpoint, not the Workorder service itself. Please confirm this separation of concerns.

- **Q2 (Data Types and Constraints)**: What are the exact data types and formats for `partyId`, `vehicleId`, and `contactId`? Are they UUIDs, `BIGINT`, or formatted strings (e.g., `party-xxxx`)? This is critical for defining the database schema and API contracts.

- **Q3 (Handling of Empty Contacts)**: Is it permissible for `crmContactIds` to be an empty list (`[]`), or must there always be at least one contact associated? The current assumption is that an empty list is valid. Please confirm.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #93 ‚Äî [BACKEND] [STORY] Integration: Emit CRM Reference IDs in Workorder Artifacts

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Integration: Emit CRM Reference IDs in Workorder Artifacts

**Domain**: user

### Story Description

/kiro
# User Story

## Narrative
As a **System**, I want **workorders/estimates to store CRM partyId, vehicleId, and contactIds** so that **traceability and reporting are possible**.

## Details
- Workorder domain stores foreign references to CRM.
- CRM merges must not break references (aliases/redirects).

## Acceptance Criteria
- Estimate/WO persist CRM references.
- References resolvable back to CRM after merges.

## Integration Points (Workorder Execution)
- Workorder Execution persists CRM IDs; CRM provides alias resolution endpoint if needed.

## Data / Entities
- WO/Estimate reference fields
- PartyAlias (optional)

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: CRM


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #85: [BACKEND] [STORY] Timekeeping: Mechanic Clock In/Out
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
STOP: Clarification required before finalization

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:workexec
- status:draft

### Recommended
- agent:workexec
- agent:story-authoring

### Blocking / Risk
- blocked:clarification

---
**Rewrite Variant:** workexec-structured
---

## Story Intent

**As a** Mechanic,
**I want to** clock in when I start my shift and clock out when I end it,
**so that** my work hours are accurately tracked for attendance and payroll purposes.

## Actors & Stakeholders

- **Mechanic (Primary Actor):** The employee performing the clock-in and clock-out actions.
- **Shop Manager (Stakeholder):** Relies on accurate time records for shift management, labor cost tracking, and operational oversight.
- **Payroll System (Downstream Consumer):** Consumes the finalized time entries to process payroll.
- **System (Facilitator):** The POS or shop management system that provides the timekeeping interface and records the data.

## Preconditions

1.  The Mechanic has an active and provisioned employee profile in the system.
2.  The Mechanic is authenticated to a POS terminal or authorized device at a specific shop location.
3.  The system has access to a reliable, synchronized time source (NTP).

## Functional Behavior

### 1. Clock In

1.  **Trigger:** A logged-in Mechanic initiates the "Clock In" action via the system interface.
2.  **System Action:**
    a. The system verifies that the Mechanic is not already in a `CLOCKED_IN` state.
    b. The system validates the Mechanic's eligibility to clock in at the current `LocationID` (See Business Rules & Open Questions).
    c. A new `TimeEntry` record is created.
    d. The record is populated with the `MechanicID`, `LocationID`, the current UTC timestamp as `ClockInTimestamp`, and the local `ClockInTimezone`.
    e. The Mechanic's timekeeping status is set to `CLOCKED_IN`.
3.  **Outcome:** The system confirms a successful clock-in to the Mechanic.

### 2. Clock Out

1.  **Trigger:** A `CLOCKED_IN` Mechanic initiates the "Clock Out" action.
2.  **System Action:**
    a. The system finds the current open `TimeEntry` for that `MechanicID`.
    b. The system updates the record, setting the `ClockOutTimestamp` to the current UTC timestamp and recording the `ClockOutTimezone`.
    c. The Mechanic's timekeeping status is set to `CLOCKED_OUT`.
3.  **Outcome:** The system confirms a successful clock-out to the Mechanic.

## Alternate / Error Flows

- **Attempting to Clock In while already Clocked In:**
  - The system MUST prevent the creation of a new `TimeEntry`.
  - The system MUST display an error message, "You are already clocked in. You must clock out before clocking in again."
- **Attempting to Clock Out while not Clocked In:**
  - The system MUST prevent the action.
  - The system MUST display an error message, "You are not currently clocked in."
- **Mechanic not authorized for location (pending clarification):**
  - If strict location validation is enabled, the system MUST prevent the clock-in/out attempt.
  - The system MUST display an error, "Clock-in failed: You are not authorized for this location."
- **System Failure:**
  - If the database or backend service is unavailable, the action MUST fail gracefully.
  - The system MUST inform the user of a system error and advise them to try again or contact a manager.

## Business Rules

- **BR1: State Exclusivity:** A Mechanic can only be in one timekeeping state (`CLOCKED_IN` or `CLOCKED_OUT`) at any given time. A clock-in action is only valid from a `CLOCKED_OUT` state, and a clock-out action is only valid from a `CLOCKED_IN` state.
- **BR2: Transaction Atomicity:** Each clock-in or clock-out event must be an atomic transaction. If any part of the process fails (e.g., writing to the database), the entire operation must be rolled back.
- **BR3: Timestamp Authority:** All primary timestamps (`ClockInTimestamp`, `ClockOutTimestamp`) MUST be recorded in UTC and sourced from the server to ensure a single source of truth. The local timezone is stored for display and context.
- **BR4: Location Association (Clarification Required):** All time entries must be associated with a specific `LocationID`. The policy for validating if a mechanic is allowed to clock in at a given location needs to be defined. See **OQ1**.

## Data Requirements

The core entity is `TimeEntry`.

| Field               | Type      | Constraints                          | Description                                                               |
| ------------------- | --------- | ------------------------------------ | ------------------------------------------------------------------------- |
| `TimeEntryID`       | UUID      | Primary Key, Not Null                | Unique identifier for the time entry record.                              |
| `MechanicID`        | UUID      | Foreign Key (Employee), Not Null     | The employee this time entry belongs to.                                  |
| `LocationID`        | UUID      | Foreign Key (Location), Not Null     | The shop location where the event occurred.                               |
| `ClockInTimestamp`  | Timestamp | UTC, Not Null                        | The server-generated UTC timestamp of the clock-in event.                 |
| `ClockInTimezone`   | String    | Not Null, IANA Format                | The IANA timezone name of the location at clock-in (e.g., 'America/Chicago'). |
| `ClockOutTimestamp` | Timestamp | UTC, Nullable                        | The server-generated UTC timestamp of the clock-out event.                |
| `ClockOutTimezone`  | String    | Nullable, IANA Format                | The IANA timezone name of the location at clock-out.                      |
| `CreatedAt`         | Timestamp | UTC, Not Null, System-Managed        | Timestamp of when the record was created.                                 |
| `UpdatedAt`         | Timestamp | UTC, Not Null, System-Managed        | Timestamp of the last update to the record.                               |

## Acceptance Criteria

**AC1: Successful Clock-In**
- **Given** a Mechanic is authenticated and is in a `CLOCKED_OUT` state
- **When** the Mechanic initiates the "Clock In" action
- **Then** the system creates a new `TimeEntry` record with a `ClockInTimestamp`
- **And** the Mechanic's status is updated to `CLOCKED_IN`.

**AC2: Successful Clock-Out**
- **Given** a Mechanic is in a `CLOCKED_IN` state with an open `TimeEntry`
- **When** the Mechanic initiates the "Clock Out" action
- **Then** the system updates the existing `TimeEntry` with a `ClockOutTimestamp`
- **And** the Mechanic's status is updated to `CLOCKED_OUT`.

**AC3: Prevent Double Clock-In**
- **Given** a Mechanic is already in a `CLOCKED_IN` state
- **When** the Mechanic attempts to "Clock In" again
- **Then** the system rejects the action
- **And** displays an error message indicating they are already clocked in.

**AC4: Prevent Clock-Out without Clock-In**
- **Given** a Mechanic is in a `CLOCKED_OUT` state
- **When** the Mechanic attempts to "Clock Out"
- **Then** the system rejects the action
- **And** displays an error message indicating they are not currently clocked in.

**AC5: Time Entries are Auditable**
- **Given** a `TimeEntry` has been created or modified
- **When** an authorized user or system queries the data
- **Then** the record must contain the `MechanicID`, `LocationID`, and immutable UTC timestamps for all clock events.

## Audit & Observability

- **Events:**
  - `MechanicClockedIn`: Emitted on successful clock-in. Payload includes `TimeEntryID`, `MechanicID`, `LocationID`, `ClockInTimestamp`.
  - `MechanicClockedOut`: Emitted on successful clock-out. Payload includes `TimeEntryID`, `MechanicID`, `LocationID`, `ClockInTimestamp`, `ClockOutTimestamp`.
  - `TimeEntryCorrectionRequired`: Emitted if a system process detects an anomaly (e.g., a shift open for >24 hours) that requires manual review.
- **Logging:**
  - **INFO:** Log successful clock-in and clock-out events.
  - **WARN:** Log failed business rule validations (e.g., attempt to double clock-in).
  - **ERROR:** Log any system failures during the timekeeping process (e.g., database connection error).

## Open Questions

- **OQ1: Location Validation Policy:** The original story states, "Optional validation that mechanic is assigned to the selected location." This ambiguity must be resolved. What is the definitive business rule?
  - **a) Not enforced:** A mechanic can clock in at any company location.
  - **b) Strict enforcement:** A mechanic can ONLY clock in at their pre-assigned "home" location or a list of explicitly approved locations.
  - **c) Soft enforcement:** A mechanic can clock in at any location, but clock-ins at non-assigned locations are flagged for manager review.
  - **Initial Assumption:** Strict enforcement (b) is the safest default for financial controls, but this requires explicit business confirmation. The implementation of this story is blocked pending a decision.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #85 ‚Äî [BACKEND] [STORY] Timekeeping: Mechanic Clock In/Out

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Timekeeping: Mechanic Clock In/Out

**Domain**: user

### Story Description

/kiro
# User Story

## Narrative
As a **Mechanic**, I want **to clock in and out** so that **my attendance time is recorded accurately**.

## Details
- Capture UTC timestamp and local timezone.
- Optional validation that mechanic is assigned to the selected location.

## Acceptance Criteria
- One-tap clock in/out.
- Prevent double clock-in without clock-out.
- Entries are auditable.

## Integration Points (workexec/shopmgr)
- shopmgr shift can be displayed for context (optional).

## Data / Entities
- TimeEntry (attendance)

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: People Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #82: [BACKEND] [STORY] Integration: Start/Stop Timer Against Assigned Workorder Task
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
## Story Intent
As a **Mechanic**, I want **to start and stop a timer against an assigned work order task**, so that **the system can accurately track my labor time for that task without manual calculation**.

## Actors & Stakeholders
- **Mechanic (Primary Actor)**: Starts/stops timer on assigned work.
- **System (Actor)**: Enforces timer constraints, writes immutable time entries, and flags exceptions.
- **Service Advisor (Stakeholder)**: Reviews labor times for billing accuracy.
- **Billing/Accounting (Downstream)**: Consumes completed time entries for job costing/invoicing.

## Preconditions
1. Mechanic is authenticated.
2. Mechanic has permission to use timers.
3. Work order exists, is in a ‚Äúworkable‚Äù state, and is assigned to the authenticated mechanic.

## Functional Behavior
### 1) Get Active Timer (Support UI + Recovery)
- **Endpoint:** `GET /api/workexec/time-entries/timer/active`
- **Behavior:** returns the current ACTIVE timer(s) for the authenticated mechanic.

### 2) Start Timer
- **Endpoint:** `POST /api/workexec/time-entries/timer/start`
- **Request body:**
```json
{
  "workOrderId": "uuid",
  "workOrderItemId": "uuid|null",
  "laborCode": "string|null"
}
```
- **System actions (single transaction):**
  1. Derive `mechanicId` from the authenticated principal (never from request payload).
  2. Validate permission and assignment:
     - work order exists
     - work order state is workable (default: `IN_PROGRESS`)
     - mechanic is assigned to the work order (or the specific item if `workOrderItemId` is provided)
     - if `workOrderItemId` provided, verify it belongs to `workOrderId`
  3. Enforce active timer constraints (see Business Rules).
  4. Create a new `TimeEntry` with:
     - `status = ACTIVE`
     - `startTime = now (server time, UTC)`
     - link to `workOrderId` and optionally `workOrderItemId` / `laborCode`
  5. Emit audit/event `TimerStarted`.

- **Success response:** `201 Created` with the created time entry summary.

### 3) Stop Timer
- **Endpoint:** `POST /api/workexec/time-entries/timer/stop`
- **Request body:** none.
- **System actions (single transaction):**
  1. Locate ACTIVE timer(s) for the authenticated mechanic.
  2. If none exist, fail (see Alternate/Error Flows).
  3. For each timer being stopped:
     - set `endTime = now (server time, UTC)`
     - compute `durationInSeconds = endTime - startTime`
     - set `status = COMPLETED`
  4. Emit audit/event `TimerStopped`.

- **Success response:** `200 OK` with `stopped[]` containing the final details.

## Alternate / Error Flows
- **Start with existing active timer (single-timer mode):** `409 Conflict` with `error=TIMER_ALREADY_ACTIVE`. Client should call `GET ‚Ä¶/active` to recover.
- **Stop when no timer is active:** `409 Conflict` with `error=NO_ACTIVE_TIMER`.
- **Invalid/unauthorized work order assignment:**
  - `403 Forbidden` if permission missing
  - `404 Not Found` if work order/item not found (avoid leaking existence)
  - `409 Conflict` if not in workable state / not assigned.

## Business Rules
### BR1: Mechanic identity
- `mechanicId` is derived from authentication context only.

### BR2: Active timer constraints
- Default policy is single timer:
  - `allowConcurrentTaskTimers = false`
  - `maxConcurrentTaskTimers = 1`
- Concurrent timers are enabled only by policy + role permission:
  - roles with `timekeeping:timer:concurrent` may run multiple timers up to `maxConcurrentTaskTimersForRole`.

### BR3: Multi-timer stop semantics (v1)
- In concurrent-timer mode, `POST ‚Ä¶/stop` stops **all ACTIVE timers** for the mechanic and returns them in `stopped[]`.

### BR4: Time entry immutability
- Once a timer entry is `COMPLETED` or `AUTO_STOPPED`, it is immutable through start/stop timer APIs.
- Any changes require a separate adjustment workflow (out of scope for this story).

### BR5: Abandoned timers (auto-stop + exception)
- Auto-stop triggers:
  1. **Clock-out handler**: auto-stop ACTIVE timers at clock-out time.
  2. **Scheduled job**: detect ACTIVE timers older than `maxTimerDurationMinutes` (default 720) and auto-stop them.
- Auto-stopped timers are flagged with a `TimeException`:
  - `exceptionCode = ABANDONED_TIMER`
  - `severity = WARNING` unless policy config sets `BLOCKING`
- Policy defaults:
  - `maxTimerDurationMinutes = 720`
  - `autoStopOnClockOut = true`

### BR6: Breaks / pausing
- Timer pausing is **out of scope** for v1.
- Break policy may stop timers based on separate break tracking policy.

## Data Requirements
### Entity: `TimeEntry`
- Fields: `timeEntryId`, `mechanicId`, `workOrderId`, `workOrderItemId?`, `laborCode?`, `startTime (UTC)`, `endTime? (UTC)`, `durationInSeconds?`, `status`.
- Status enum includes:
  - `ACTIVE`
  - `COMPLETED` (user stop)
  - `AUTO_STOPPED` (system stop)

### Entity: `TimeException`
- Fields (minimum): `timeExceptionId`, `timeEntryId`, `exceptionCode`, `severity`, `createdAt`, `notes?`.

### Timekeeping policy configuration
- `allowConcurrentTaskTimers` (bool, default false)
- `maxConcurrentTaskTimers` (int, default 1)
- `maxTimerDurationMinutes` (int, default 720)
- `autoStopOnClockOut` (bool, default true)

## Acceptance Criteria
### AC1: Start + stop timer creates a completed time entry
- Given mechanic is assigned to a valid workable work order and has no active timer (single-timer mode)
- When mechanic starts a timer
- Then a `TimeEntry(status=ACTIVE, startTime=now)` is created
- When mechanic stops the timer
- Then the entry is updated with `endTime`, `durationInSeconds`, and `status=COMPLETED`.

### AC2: Prevent second timer in default single-timer mode
- Given mechanic already has an ACTIVE timer
- When mechanic starts another timer
- Then API returns `409 TIMER_ALREADY_ACTIVE` and no new entry is created.

### AC3: Stop fails when none active
- Given mechanic has no ACTIVE timers
- When mechanic stops
- Then API returns `409 NO_ACTIVE_TIMER`.

### AC4: Auto-stop on clock-out
- Given mechanic clocks out with an ACTIVE timer
- When clock-out is processed
- Then timer is auto-stopped with `status=AUTO_STOPPED`
- And a `TimeException(ABANDONED_TIMER)` is created.

### AC5: Auto-stop on duration threshold
- Given an ACTIVE timer runs longer than `maxTimerDurationMinutes`
- When the scheduled job detects it
- Then timer is auto-stopped with `status=AUTO_STOPPED`
- And a `TimeException(ABANDONED_TIMER)` is created.

## Audit & Observability
- Emit audit/event records (or equivalent) for:
  - `TimerStarted`
  - `TimerStopped`
  - `TimerStartFailed` (include reason code)
  - `TimerAutoStopped` (include stopReason: `CLOCK_OUT|MAX_DURATION_EXCEEDED`)
- Metrics:
  - Gauge: active timers count
  - Counters: start/stop rate, failure rate by reason, abandoned timers detected

## Open Questions
None.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #82 ‚Äî [BACKEND] [STORY] Integration: Start/Stop Timer Against Assigned Workorder Task

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Integration: Start/Stop Timer Against Assigned Workorder Task

**Domain**: user

### Story Description

/kiro
# User Story

## Narrative
As a **Mechanic**, I want **to start and stop a job timer for a workorder task** so that **I can accurately capture job time without manual calculations**.

## Details
- Timer references workOrderId and optional workOrderItemId/laborCode.
- Enforce one active timer per mechanic (default).

## Acceptance Criteria
- Start/stop timer produces a job time entry.
- Prevent multiple active timers unless configured.
- Audited.

## Integration Points (workexec)
- Inbound: WorkOrderAssigned for context.

## Data / Entities
- TimeEntry (job)
- JobLink

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: People Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #81: [BACKEND] [STORY] Integration: Submit Job Time to workexec as Labor Performed (Idempotent)
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
**Rewrite Variant:** integration-idempotent
**Status:** Ready-for-dev (clarification #402 applied)

## Story Intent
As the system, I want to idempotently submit a mechanic‚Äôs finalized job time (`TimeEntry`) to Work Execution (`workexec`) as `LaborPerformed`, so that billable labor is recorded against the correct Work Order without duplication.

## Actors & Stakeholders
- **System (People / Job-Time Capture)**: Tracks mechanic time entries and initiates submission to `workexec`.
- **Work Execution System (`pos-workexec`)**: Authoritative system of record for Work Orders and Labor Performed.
- **Mechanic/Technician**: Performs the work; finalization of time is the upstream trigger.

## Preconditions
1. A `TimeEntry` exists and has reached `FINALIZED`.
2. `timeEntryId` is unique, persistent, and safe for idempotency usage.
3. The associated WorkOrder exists in `workexec` and can be referenced by `workOrderId`.
4. Service-to-service authentication to `workexec` is configured.

## Functional Behavior
### Trigger + Delivery
- Trigger on `TimeEntry` transition to `FINALIZED`.
- Use **transactional outbox + async worker**:
  - Write an outbox/retry record in the same DB transaction as finalization.
  - Background worker delivers to `workexec` and applies retry/backoff.

### Submission (Workexec contract ‚Äî resolved by clarification #402)
1. Build a `LaborPerformed` submission request mapped from `TimeEntry`.
2. Call:
   - `POST /api/workexec/labor-performed`
3. Always send required headers:
   - `Idempotency-Key: <timeEntryId>` (required)
   - `Content-Type: application/json`
   - `X-Correlation-Id` (optional; generated if missing)
4. Request payload (minimum canonical schema):

```json
{
  "workOrderId": "uuid",
  "technicianId": "uuid",
  "performedAt": "2026-01-15T17:30:00Z",
  "labor": {
    "quantity": 1.50,
    "unit": "HOURS"
  },
  "source": {
    "system": "people",
    "sourceReferenceId": "uuid"
  }
}
```

5. Interpret response (idempotency-aware):
   - `201 Created` ‚Üí first successful record for the given idempotency key.
   - `200 OK` + `Idempotency-Replayed: true` ‚Üí idempotent replay; treat as success.
   - `409 Conflict` ‚Üí **never** replay; always terminal business conflict (see error taxonomy).

### Local Status Updates
- `FINALIZED` ‚Üí `SUBMISSION_QUEUED` (optional but recommended)
- On success (`201` or `200` replay): `SUBMITTED_TO_WORKEXEC`
- On terminal failure: `SUBMISSION_FAILED`

## Alternate / Error Flows
### Terminal failures (no retry)
- Any `409` from this endpoint is terminal (mark `SUBMISSION_FAILED`, no retry).
- Validation/auth/not-found/business-invalid errors are terminal (see taxonomy below).

### Transient failures (retriable)
Retry for: HTTP `408`, `429`, `5xx`, and network timeouts/connection resets.

## Business Rules
### BR1: Idempotency
- All submissions MUST include `Idempotency-Key = timeEntryId`.
- Replay is signaled as **success**:
  - HTTP `200 OK`
  - Header `Idempotency-Replayed: true`
  - Response contains the existing `laborPerformedId` and canonical fields.

### BR2: External reference (traceability + conflict detection)
- `source.system = "people"`
- `source.sourceReferenceId = timeEntryId`
- Workexec enforces `UNIQUE(source.system, source.sourceReferenceId)`.

### BR3: Authoritative WorkOrder blocking states + retry policy (from Clarification #263)
- Workexec rejects labor submission when WorkOrder is in blocking states:
  - `CANCELLED`, `CLOSED`, `INVOICED`, `VOIDED`, `ARCHIVED`
  - `ON_HOLD`, `LOCKED_FOR_REVIEW`
  - `COMPLETED` (unless reopened)
- `REOPENED` (or any state returning to active execution) allows submissions again.

Retry classification:
- Retry only transient failures: HTTP `408`, `429`, `5xx`, network timeouts/connection resets.
- Do NOT retry terminal failures: HTTP `400`, `401`, `403`, `404`, `422`, and any `409` business conflict.
- Retry schedule:
  - Max attempts: 6 total (1 initial + 5 retries)
  - Backoff: exponential with jitter, base 250ms, cap 30s
  - After exhaustion: park in durable retry table/queue and alert if backlog age exceeds SLA (e.g., > 1 hour)

### BR4: Logging and redaction
- Log request/response with redaction (exclude credentials/tokens).
- Use structured logs keyed by `timeEntryId`, `workOrderId`, `attemptCount`, `statusCode`, `workexecErrorCode`.

## Data Requirements
### Outbox / Retry Record
- `timeEntryId` (idempotency key)
- `attemptCount`
- `nextAttemptAt`
- `lastStatusCode`
- `lastError`
- `lastResponseBody` (if safe/redacted)
- `createdAt`
- `alertedAt` (nullable)

### Submission Payload (minimum)
- `workOrderId`
- `technicianId`
- `performedAt` (ISO-8601)
- `labor.quantity` (decimal hours)
- `labor.unit` (`HOURS`)
- `source.system` (`people`)
- `source.sourceReferenceId` (`timeEntryId`)

## Acceptance Criteria
### AC1: Success path
- Given a finalized `TimeEntry`
- When it is delivered to `POST /api/workexec/labor-performed`
- Then workexec records `LaborPerformed`
- And local status becomes `SUBMITTED_TO_WORKEXEC`.

### AC2: Idempotent replay
- Given the same `timeEntryId` is submitted again with the same `Idempotency-Key`
- When workexec returns `200 OK` with header `Idempotency-Replayed: true`
- Then the system treats it as success and does not create duplicates.

### AC3: Blocking WorkOrder state
- Given WorkOrder is in a blocking state (per BR3)
- When submission is attempted
- Then workexec returns `409` with stable `WORKEXEC_CONFLICT_WORKORDER_STATE`
- And local status becomes `SUBMISSION_FAILED` and no retry occurs.

### AC4: Transient failure retry
- Given workexec returns a transient failure (`408`, `429`, `5xx`)
- When submission is retried with bounded backoff
- Then it retries up to 6 total attempts and parks with alerting on exhaustion.

## Audit & Observability
- Log each attempt with correlation id and idempotency key.
- Metrics:
  - success/failure counts by `workexec` error code
  - retry attempt counts
  - outbox/retry queue size and age
  - call latency

## Resolved Questions
From clarification #402:
- Endpoint: `POST /api/workexec/labor-performed`
- Idempotency:
  - Required `Idempotency-Key: timeEntryId`
  - Replay returns `200` + `Idempotency-Replayed: true` (treat as success)
  - First-time returns `201`
  - `409` is never replay; always terminal business conflict with stable `WORKEXEC_CONFLICT_*` codes
- External reference supported via `source.sourceReferenceId` and uniqueness enforced per `source.system`.
- Stable error envelope + terminal vs retriable classification defined.

From clarification #263:
- Blocking workorder states and retry policy.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #81 ‚Äî [BACKEND] [STORY] Integration: Submit Job Time to workexec as Labor Performed (Idempotent)

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Integration: Submit Job Time to workexec as Labor Performed (Idempotent)

**Domain**: user

### Story Description

/kiro
# User Story

## Narrative
As a **Mechanic**, I want **to submit my job time to workexec** so that **labor performed lines are created/updated accurately**.

## Details
- Idempotent posting using timeEntryId as reference.
- Reject with actionable errors when workorder state disallows.

## Acceptance Criteria
- Posting creates or updates labor-performed without duplication.
- Failures provide stable error codes.
- Audit includes workorder reference.

## Integration Points (workexec)
- Outbound: JobTimePosted event and/or API call.

## Data / Entities
- LaborPerformed (workexec)
- TimeEntry (job)

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: People Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #75: [BACKEND] [STORY] Scheduling: Create Appointment with CRM Customer and Vehicle
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
**Rewrite Variant:** integration-conservative  
**Status:** Ready-for-dev

## Story Intent
As a **Service Advisor**, I need to create a new service appointment by selecting an existing customer and their vehicle from the CRM system, so that work can be scheduled accurately with pre-verified customer context and preserved historical appointment details.

## Actors & Stakeholders
- **Primary actor:** Service Advisor
- **Work Execution (`domain:workexec`):** System of Record (SoR) for the `Appointment` entity and its lifecycle
- **CRM (`durion-crm`, external system):** SoR for customer + vehicle identity and association
- **Downstream consumers:** Notifications, estimating/billing, analytics/reporting

## Preconditions
- Caller is authenticated and authorized to create appointments (authorization enforcement is required; specific permission naming is out of scope for this story).
- CRM is reachable for validation at appointment creation time.

## Functional Behavior
1) **Request received**
- The system receives a create request containing at minimum:
  - `crmCustomerId`
  - `crmVehicleId`
  - requested services (one or more)
  - scheduled time (`startAt` + `endAt`, or equivalent)
  - notes (optional)

2) **Validate against CRM (required before create)**
- Validate:
  - `crmCustomerId` exists
  - `crmVehicleId` exists
  - vehicle is associated with customer

3) **Create Appointment (workexec owns lifecycle)**
- Persist a new `Appointment` in Work Execution.
- Persist CRM references (`crmCustomerId`, `crmVehicleId`).
- Snapshot key customer/vehicle fields for historical accuracy and read-time resilience.

4) **Initial status**
- When customer + vehicle are confirmed and time is provided/valid, create the appointment in **`SCHEDULED`** status.
- **Draft behavior is out of scope** for this story.

5) **Publish `AppointmentCreated` event (mandatory)**
- On successful creation of a **`SCHEDULED`** appointment, publish `AppointmentCreated`.
- Delivery: **at-least-once** using an outbox (or equivalent) so event publication is consistent with DB commit.
- Consumers must be idempotent.

## Alternate / Error Flows
- **CRM unavailable:** If CRM is unreachable or returns 5xx/timeout, reject creation with `503 Service Unavailable`.
- **Customer not found:** Reject with `404 Not Found` and error code `CUSTOMER_NOT_FOUND`.
- **Vehicle not found:** Reject with `404 Not Found` and `VEHICLE_NOT_FOUND`.
- **Vehicle/customer mismatch:** Reject with `409 Conflict` and `VEHICLE_CUSTOMER_MISMATCH`.
- **Invalid input:** Reject missing/invalid fields with `400 Bad Request`.

## Business Rules
- Appointment cannot be created without validated `crmCustomerId` and `crmVehicleId` association.
- Appointment snapshots are immutable for historical accuracy (do not rewrite snapshots when CRM data changes).
- `AppointmentCreated` must be emitted for scheduled appointments; consumers must be idempotent.

## Data Requirements
### Appointment
- `appointmentId`: UUID (PK)
- `crmCustomerId`: string/UUID (indexed)
- `crmVehicleId`: string/UUID (indexed)
- `status`: enum (includes `SCHEDULED`)
- `notes`: text
- `startAt`, `endAt` (or `durationMinutes`)
- `customerSnapshot`: JSON/structured snapshot captured-at-create
- `vehicleSnapshot`: JSON/structured snapshot captured-at-create
- `createdAt`, `updatedAt`

**Snapshot minimum (recommended):**
- Customer: `fullName` (or `firstName`/`lastName`), `phone`, `email` (and optionally address/preferred contact)
- Vehicle: `year`, `make`, `model`, `trim`, `vin` (if available), `licensePlate` (if available)

### AppointmentServiceRequest
- `serviceRequestId`: UUID (PK)
- `appointmentId`: UUID (FK)
- `description` (or service code/id as applicable)

## Acceptance Criteria
### Scenario 1: Successful Appointment Creation
- Given CRM is available
- And a valid `crmCustomerId` exists
- And a valid `crmVehicleId` exists and is associated to the customer
- When the Service Advisor creates an appointment with required fields (including time)
- Then the system creates an Appointment with status `SCHEDULED`
- And the Appointment stores CRM IDs and snapshots
- And the system returns `201 Created` with `appointmentId`.

### Scenario 2: Vehicle Not Associated with Customer
- Given CRM is available
- And `crmCustomerId` exists
- And `crmVehicleId` exists but is not associated with that customer
- When the create request is submitted
- Then the API returns `409 Conflict` with error `VEHICLE_CUSTOMER_MISMATCH`.

### Scenario 3: CRM Unavailable
- Given CRM is unavailable
- When the create request is submitted
- Then the API returns `503 Service Unavailable`
- And no Appointment is created.

### Scenario 4: AppointmentCreated Event Emitted
- Given a `SCHEDULED` appointment is created successfully
- When the transaction commits
- Then an `AppointmentCreated` event is published (at-least-once)
- And the payload includes `appointmentId`, `crmCustomerId`, `crmVehicleId`, scheduled time, and a snapshot subset.

## Audit & Observability
- Audit log entry on successful appointment creation (who/what/when).
- Correlation ID propagated/logged for create + CRM validation.
- Metrics:
  - `appointments.created.count`
  - `crm.validation.latency`
  - `crm.validation.errors.count` partitioned by failure type

## Resolved Decisions (from issue comments)
- **SoR:** `domain:workexec` owns `Appointment` lifecycle; CRM owns customer/vehicle identity + association.
- **Initial status:** `SCHEDULED` when customer+vehicle+time are confirmed (draft out of scope here).
- **Snapshotting:** store CRM IDs + immutable snapshots at create time.
- **Events:** `AppointmentCreated` is mandatory for scheduled appointments; at-least-once via outbox; consumers idempotent.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #75 ‚Äî [BACKEND] [STORY] Scheduling: Create Appointment with CRM Customer and Vehicle

## Current Labels
- backend
- story-implementation
- payment

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Scheduling: Create Appointment with CRM Customer and Vehicle

**Domain**: payment

### Story Description

/kiro
# User Story
## Narrative
As a **Service Advisor**, I want to create an appointment selecting customer and vehicle from durion-crm so that the shop has accurate context for service and billing.

## Details
- Capture: crmCustomerId, crmVehicleId, requested services, notes, preferred time window, contact hints.

## Acceptance Criteria
- Appointment created with status Draft/Scheduled.
- Customer/vehicle references validated.
- Audited.

## Integrations
- CRM lookup/snapshot.
- Optional AppointmentCreated event.

## Data / Entities
- Appointment, AppointmentServiceRequest, CRM references

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Shop Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #74: [BACKEND] [STORY] Scheduling: View Schedule by Location and Resource
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
**Rewrite Variant:** workexec-structured  
**Status:** Ready-for-dev

## Story Intent
As a **Dispatcher**, I want to query and view a daily schedule organized by location, bay, and mobile resources (and person lanes if modeled), so I can manage shop capacity, assign work, and proactively identify and resolve scheduling conflicts.

## Actors & Stakeholders
- **Primary actor:** Dispatcher
- **Scheduling Service:** backend microservice responsible for constructing the daily schedule view
- **Secondary stakeholders:** Service Advisor, Shop Manager
- **Optional integration:** HR/People system for availability overlay

## Preconditions
1. Dispatcher is authenticated and authorized to view schedules for the requested location.
2. Location resources (bays, mobile resources, and optionally people/technicians) exist with operating hours.
3. Scheduled events exist (appointments/work orders/time blocks) for the requested date.

## API Contract
**Endpoint:** `GET /api/v1/schedules/view`

**Required query params**
- `locationId`
- `date` (`YYYY-MM-DD`) ‚Äî interpreted in the **location‚Äôs timezone**

**Optional query params**
- `resourceType` = `BAY | MOBILE_TECHNICIAN | PERSON` (omit `PERSON` if not supported)
- `resourceId` = filter to a single resource
- `includeAvailabilityOverlay` = `true|false` (default `false`)
- `range` = `LOCATION_HOURS | FULL_DAY` (default `LOCATION_HOURS`)
- (future, not required for v1) `startAt`, `endAt` for custom windows

**Time representation rules**
- `dayStartAt/dayEndAt` are computed from location operating hours in the location timezone, then serialized as **UTC instants** (`...Z`).
- All event timestamps (`startTime/endTime`) are returned as **UTC instants**.

## Functional Behavior
1) Validate inputs and authorization.
2) Resolve the day window:
- Default: `[location.openTime, location.closeTime)` in location timezone.
- Fallback if hours missing: fixed window 06:00‚Äì18:00 local time.
- `range=FULL_DAY` expands window to 00:00‚Äì24:00 local time.
3) Query event sources for the window (see Data Sources).
4) Normalize all sources into `ScheduleEvent` items per resource.
5) Run conflict detection using the defined conflict policies.
6) If `includeAvailabilityOverlay=true`, call HR overlay (soft dependency) and merge best-effort.
7) Return `ScheduleView`.

## Policies & Business Rules
### Data Sources & Normalization (v1)
- Include: `Appointment`, `WorkOrder` (only if it has scheduled start/end), `TimeBlock`.
- Normalize to a single `ScheduleEvent` shape:
  - `eventId` (stable, prefixed by source: `APT-`, `WO-`, `TB-` recommended)
  - `eventType` (at minimum: `APPOINTMENT | WORK_ORDER | TIME_BLOCK`)
  - `subType` (recommended): `NOTE_BLOCK | SOFT_HOLD | BUFFER | TRAINING_SHADOW | ON_CALL | ...`
  - `startTime`, `endTime` (UTC)
  - `title`
  - `hasConflict`, `severity`, `conflictDetails.conflictingEventIds`

### Filtering & Resource List
- No filters: return **all schedulable resources** at the location for the date.
- `resourceType`: return **all resources of that type** at the location.
- `resourceId`:
  - If not found or not associated to location ‚Üí `404 Not Found`
  - Otherwise return only that resource in `resources[]`

**Resource ordering (stable)**
- Bays: `displayOrder` then name
- Mobile: name
- People: name (if applicable)

### Conflict Detection
- Use half-open intervals: `[startAt, endAt)`.
- Any overlap **‚â• 1 minute** counts as a conflict.
- Conflict dimensions:
  - **Resource conflicts (hard):** same bay/mobile resource overlaps
  - **Person conflicts (hard):** same mechanic/person overlaps (based on assignments)
- Allowed co-existence (no conflict): `NOTE_BLOCK`, `SOFT_HOLD`, `BUFFER`
- Conditional (configurable):
  - `TRAINING_SHADOW` may overlap only if it does not consume an additional bay/resource
  - `ON_CALL` may overlap with any event
- Severity:
  - `BLOCKING`: hard overlaps (person/bay/mobile)
  - `WARNING`: overlaps involving soft holds/buffers, training shadow overlaps

### Off-hours Behavior
- Return only events that intersect the returned window `[dayStartAt, dayEndAt)`.
- If an event partially overlaps the window: include original times; UI can infer off-hours by comparing to dayStart/dayEnd (optional future: add `isOffHours` flag).

### HR Availability Overlay (Soft Dependency)
- Only when `includeAvailabilityOverlay=true`.
- Call: `GET /people/v1/availability/overlay?locationId=...&date=YYYY-MM-DD`
- Timeout: **200 ms**.
- On timeout/error:
  - Return `200 OK` with schedule view
  - `availabilityOverlayStatus = UNAVAILABLE`
  - `warnings += ["HR_SYSTEM_UNAVAILABLE"]`
- On success:
  - `availabilityOverlayStatus = AVAILABLE`
  - Merge overlay by `personId` onto person resources if people are modeled as resources (recommended).

### Error Handling
- `400 Bad Request`: missing/invalid `locationId`, missing/invalid `date`, invalid enum values for `resourceType`/`range`.
- `403 Forbidden`: not authorized for `locationId`.
- `404 Not Found`: `locationId` not found; `resourceId` not found or not associated to location.

### Performance SLA
- P50 ‚â§ 150 ms, P95 ‚â§ 400 ms, P99 ‚â§ 800 ms.
- Scope: single location/day view (locationId + date + resourceType filter), warm cache assumed, excludes HR overlay.
- Implementation expectations:
  - Avoid N+1 queries (resources in 1 query; events in 1‚Äì3 queries)
  - Conflict detection O(n log n) per resource (sort + sweep)
  - Indexes (minimum): appointments/time blocks by `(location_id, start_at)` and assignment tables by `(person_id, start_at)` if needed for person conflicts

## Data Requirements (ScheduleView Read Model)
```json
{
  "locationId": "LOC-123",
  "date": "2024-07-29",
  "viewGeneratedAt": "2024-07-29T10:00:00Z",
  "dayStartAt": "2024-07-29T07:00:00Z",
  "dayEndAt": "2024-07-29T19:00:00Z",
  "warnings": ["HR_SYSTEM_UNAVAILABLE"],
  "availabilityOverlayStatus": "UNAVAILABLE",
  "resources": [
    {
      "resourceId": "BAY-01",
      "resourceType": "BAY",
      "resourceName": "Bay 1",
      "events": [
        {
          "eventId": "APT-456",
          "eventType": "APPOINTMENT",
          "startTime": "2024-07-29T09:00:00Z",
          "endTime": "2024-07-29T11:00:00Z",
          "title": "Brake Inspection - John Doe",
          "severity": "BLOCKING",
          "hasConflict": true,
          "conflictDetails": { "conflictingEventIds": ["APT-457"] }
        }
      ]
    }
  ]
}
```

## Acceptance Criteria
1) Retrieve a schedule for a location returns `200 OK` with correct events within SLA.
2) Overlapping appointments for the same bay (or person) set `hasConflict=true` with `severity=BLOCKING` and include mutual `conflictingEventIds`.
3) Invalid location/date ‚Üí `400` or `404` as specified; unauthorized ‚Üí `403`.
4) HR overlay failure still returns `200 OK` with `availabilityOverlayStatus=UNAVAILABLE` and warning.
5) Day window respects location hours (fallback 06:00‚Äì18:00 if not configured).

## Audit & Observability
- Log (INFO): userId, request params, response time, result counts (#resources, #events).
- Log (WARN): HR overlay failure (timeout vs non-timeout).
- Avoid per-conflict spam at INFO; emit summary at DEBUG or as a structured event.
- Metrics:
  - `schedule.view.requests.count{locationId}`
  - `schedule.view.response.latency{locationId, overlayRequested}`
  - `schedule.view.error.rate{errorType}`
  - `schedule.view.conflicts.detected{dimension=resource|person, severity}`

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #74 ‚Äî [BACKEND] [STORY] Scheduling: View Schedule by Location and Resource

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Scheduling: View Schedule by Location and Resource

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Dispatcher**, I want a daily schedule view by location/bay/mobile so that I can manage capacity and avoid conflicts.

## Details
- Views: location calendar, bay lanes, mobile list.
- Conflict highlighting and filters.

## Acceptance Criteria
- Filter by date/location/resource.
- Conflicts flagged.
- Loads within SLA.

## Integrations
- Optional HR availability overlay.

## Data / Entities
- ScheduleView(read model), ConflictFlag

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Shop Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #70: [BACKEND] [STORY] Dispatch: Assign Mechanic and Resource (Bay/Mobile) to Appointment
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
## Story Intent
**As a** Dispatcher,
**I want** to assign mechanic(s) and a primary resource (bay/mobile unit) to a scheduled appointment,
**so that** work is properly allocated, scheduled without conflicts, audited, and can be executed.

## Actors & Stakeholders
- **Dispatcher**: creates/reassigns assignments.
- **Mechanic(s)**: assigned personnel with skills/availability.
- **Workshop/Operations Manager**: oversight of utilization and exceptions.
- **System**: enforces constraints, persists assignments, emits events.

## Preconditions
- `Appointment` exists and is in `SCHEDULED` state.
- Appointment has `scheduledStartAt` and `scheduledEndAt`.
- Mechanic roster + skills exist (imported from HR per Issue #72).
- Resource roster exists (bays/mobile units) with availability derived from assignments.
- AuthZ:
  - Base create: `workexec.assignment.create`
  - Override create (if used): `dispatch:assignment:override_create`

## Functional Behavior
### Core operation: create assignment
1. Dispatcher selects an appointment and invokes ‚ÄúAssign‚Äù.
2. Request includes:
   - `resourceId` (single primary resource)
   - `mechanics[]` (one or more mechanics; roles optional for single mechanic)
   - optional `override` block
3. System resolves time window from the appointment: `[scheduledStartAt, scheduledEndAt)`.
4. System validates:
   - appointment is `SCHEDULED` (hard block)
   - roles (see Business Rules)
   - skills coverage (see Business Rules)
   - availability conflicts (mechanics + resource) using assignment overlap (see Availability)
   - override requirements/permissions if override is used
5. On success, system persists:
   - `Assignment` (status `CONFIRMED`, `version=1`)
   - join rows for mechanics + roles
   - audit log entry
6. After commit, system emits `AssignmentCreated`.

### Availability model (SoT)
- **Assignments are the source of truth** for booked time blocks.
- Availability checks query for overlapping assignments within blocking statuses.

### Reassignment
- Allowed, but only **one active assignment per appointment** at a time.
- Reassignment creates a new `Assignment` row and marks the prior active assignment `CANCELLED` (or `SUPERSEDED`) for auditability.
- Emit `AssignmentUpdated` on reassign/cancel/status changes; maintain monotonic `version`.

## Alternate / Error Flows
- Availability conflict ‚Üí reject with `409 Conflict` + code `MECHANIC_UNAVAILABLE` or `RESOURCE_UNAVAILABLE`.
- Skill mismatch / invalid role set ‚Üí reject with `422 Unprocessable Entity` + code `SKILL_MISMATCH` or `INVALID_ROLE_SET`.
- Missing permissions ‚Üí `403 Forbidden` (+ `OVERRIDE_NOT_PERMITTED` when override is attempted).
- Malformed request / missing required fields ‚Üí `400 Bad Request`.

## Business Rules
### Assignment constraints
- Assignment links to exactly one appointment.
- Exactly one primary resource is persisted on `Assignment.resourceId`.
- Appointment must be `SCHEDULED` (hard block; not overrideable).

### Assignment statuses
- `CONFIRMED` (blocks availability)
- `IN_PROGRESS` (blocks availability)
- `COMPLETED` (does not block)
- `CANCELLED` (does not block)

### One active assignment per appointment
- Enforce: only one assignment with status in `(CONFIRMED, IN_PROGRESS)` per `appointmentId`.

### Mechanic roles
- If exactly one mechanic is assigned, role may be omitted; backend defaults to `LEAD`.
- If more than one mechanic is assigned:
  - each mechanic must have a role
  - exactly one mechanic must be `LEAD`
  - role enum: `LEAD`, `ASSIST`

### Skill validation (team coverage with optional lead constraint)
Let `requiredSkills = {(skillId, level, leadRequiredFlag)}`.
Validation passes if:
1. For every required skill where `leadRequiredFlag=true`: the lead mechanic has the skill at required level.
2. For every required skill where `leadRequiredFlag=false`: at least one assigned mechanic has the skill at required level.

### Override policy
**Overrideable categories**:
- `MECHANIC_AVAILABILITY`
- `RESOURCE_AVAILABILITY`
- `SKILL_MISMATCH`
- `LOCATION_MISMATCH`
- `POLICY_CONSTRAINT`

**Hard blocks (not overrideable)**:
- appointment not `SCHEDULED`
- appointment cancelled
- work order closed/invoiced (if linked)
- safety/regulatory constraint flag (if present)

**Override requirements**:
- `override.used=true` requires:
  - `overrideReasonCode` (enum)
  - `overrideNotes` (required)
  - `overriddenChecks[]` non-empty
- Requires permission `dispatch:assignment:override_create`.

Recommended reason codes (v1):
- `CUSTOMER_WAITING`, `EMERGENCY_SERVICE`, `MANAGER_DIRECTIVE`, `SHORT_STAFFED`, `TRAINING_SUPERVISED_WORK`, `SYSTEM_DATA_INCORRECT`

## Data Requirements
### Entities
- `Assignment`
  - `assignmentId` (UUID)
  - `appointmentId`
  - `resourceId`
  - `status` (`CONFIRMED|IN_PROGRESS|COMPLETED|CANCELLED`)
  - `version` (monotonic; create = 1)
  - override fields: `isOverridden`, `overrideReasonCode`, `overrideNotes`, `overriddenChecks[]`, `approvedBy?`
- `AssignmentMechanic` (join)
  - `assignmentId`, `mechanicId`, `role (LEAD|ASSIST)`

### Indexes/constraints (minimum)
- Unique ‚Äúactive assignment‚Äù constraint per `appointmentId` for statuses `(CONFIRMED, IN_PROGRESS)`.

## API (Minimum)
- `POST /appointments/{appointmentId}/assignments` (create)
- `GET /appointments/{appointmentId}/assignments` (history + active)
- Optional (can be deferred if out of scope): `PATCH /assignments/{assignmentId}` for status transitions / reassign

Create request example:
```json
{
  "resourceId": "UUID",
  "mechanics": [{ "mechanicId": "UUID", "role": "LEAD|ASSIST" }],
  "override": {
    "used": false,
    "overriddenChecks": [],
    "reasonCode": null,
    "notes": null
  }
}
```

## Concurrency & Correctness
- Prevent double-booking using DB-enforced correctness:
  - transaction + row locks (`SELECT ... FOR UPDATE`) on involved mechanic/resource rows (or schedule rows if present)
  - re-check overlap after locks
  - enforce unique active assignment per appointment

## Audit & Observability
- Always write audit entry for create/update/cancel.
- Override usage produces a high-priority audit entry.
- Emit events after commit:
  - `AssignmentCreated` on create
  - `AssignmentUpdated` on reassign/status changes

Metrics (minimum):
- `assignments.created.count`
- `assignments.failed.count` (tagged by reason)
- `assignments.overridden.count`

## Resolved Questions / Decisions Applied
- Clarification Issue #253 decisions applied: availability source-of-truth, reassign rules, statuses, time window source, resource/role rules, override policy, concurrency strategy, API surface, error codes, and event topic/schema.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #70 ‚Äî [BACKEND] [STORY] Dispatch: Assign Mechanic and Resource (Bay/Mobile) to Appointment

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Dispatch: Assign Mechanic and Resource (Bay/Mobile) to Appointment

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Dispatcher**, I want to assign mechanics and a resource to an appointment so that work can be executed efficiently.

## Details
- Validate mechanic/resource availability + required skills.
- Support team assignment (lead/helper).

## Acceptance Criteria
- Assignment created only if checks pass (or override).
- Changes audited.
- Schedule updated.

## Integrations
- Emit AssignmentCreated/Updated to workexec when linked.

## Data / Entities
- Assignment, AssignmentRole, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Shop Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #68: [BACKEND] [STORY] Timekeeping: Start/Stop Work Session for Assigned Work
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
## Story Intent
**As a** Mechanic,
**I want** to start and stop a work session for an assigned work order task,
**so that** labor time is captured accurately for operational execution and job costing, and can be consumed downstream (e.g., payroll) via events.

## Actors & Stakeholders
- **Mechanic (Primary Actor)**: starts/stops sessions and records breaks.
- **Workexec Service (SoR)**: owns `WorkSession` lifecycle and invariants.
- **Payroll / HR (Downstream Consumer)**: consumes work session events for payroll processing; does not mutate sessions.
- **Job Costing (Downstream Consumer)**: consumes labor actuals.
- **Service Manager / Admin (Approver)**: approves/locks sessions post-completion.

## System Boundary / Ownership
- **Decision (resolved):** `workexec` is the system of record for `WorkSession` and owns full lifecycle (create/start/stop/complete/lock).
- Downstream domains treat emitted events as source data and derive their own artifacts (pay periods, totals, etc.).

## Preconditions
- Mechanic is authenticated and authorized.
- `WorkOrder` and `WorkOrderTask` exist and are assigned to the mechanic.
- `WorkOrderTask` is in a state that permits starting work (e.g., `READY_FOR_WORK`).
- By default, mechanic has no other `IN_PROGRESS` work session.

## Functional Behavior
### Start work session
- Mechanic triggers ‚ÄúStart Work‚Äù on a specific assigned `WorkOrderTask`.
- System validates:
  - task is startable
  - overlap policy (see Business Rules)
- System creates `WorkSession`:
  - sets `startAt = now()` (UTC)
  - sets `status = IN_PROGRESS`
  - links `mechanicId`, `workOrderId`, `workOrderTaskId`, `locationId` (and optionally `resourceId` if relevant)
- Emit `workexec.WorkSessionStarted` after commit.

### Stop work session
- Mechanic triggers ‚ÄúStop Work‚Äù.
- System finds the single active session for mechanic (or the active session for the given task, per API choice).
- System updates session:
  - sets `endAt = now()` (UTC)
  - sets `status = COMPLETED`
  - computes payable duration: `(endAt - startAt) - sum(breakDurations)`
- Emit `workexec.WorkSessionStopped` (or `workexec.WorkSessionCompleted`) after commit.

### Breaks
- Breaks are captured as explicit, manual `BreakSegment`s inside a `WorkSession`.
- Break rules:
  - break segments must be fully contained within the session window
  - break segments must not overlap each other
  - break segments become immutable once session is locked/approved

### Approval / Locking (state model support)
- Approval is manager-driven and locks the session.
- Minimal state model:
  - `IN_PROGRESS` ‚Üí `COMPLETED` (mechanic stops)
  - `COMPLETED` ‚Üí `APPROVED` (manager approves)
  - `APPROVED` implies `locked=true` (no edits)
- This story enforces ‚Äúno edits when locked‚Äù; the dedicated approval endpoint/story may follow.

## Alternate / Error Flows
- Start while another session is `IN_PROGRESS` and overlap is not allowed ‚Üí reject with conflict.
- Stop when no session is `IN_PROGRESS` ‚Üí reject.
- Start on task not in valid state (ON_HOLD/COMPLETED/etc.) ‚Üí reject.
- Attempt to edit session/breaks when locked/approved ‚Üí reject.

## Business Rules
### Domain ownership
- `workexec` owns and persists work sessions; downstream consumers must not mutate them.

### Overlap policy
- **Default:** overlapping `WorkSession`s are not allowed.
- **Overlap is only allowed when all are true:**
  1. Config enabled: `company.timekeeping.allowOverlappingSessions = true` (or location-level equivalent)
  2. Actor has permission `timekeeping:overlap_override`
  3. Overlap is created via explicit override path and is fully audited (`overrideReason`, `overriddenByUserId`, timestamp)

### Time recording
- All timestamps recorded in UTC.

### Immutability
- Sessions and break segments are immutable when `locked=true` (typically status `APPROVED`).

## Data Requirements
### WorkSession
- `workSessionId` (UUID, PK)
- `mechanicId` (UUID)
- `workOrderId` (UUID)
- `workOrderTaskId` (UUID)
- `locationId` (UUID)
- `resourceId?` (UUID, optional)
- `startAt` (UTC timestamp)
- `endAt?` (UTC timestamp)
- `status` (`IN_PROGRESS`, `COMPLETED`, `APPROVED`, `REJECTED`)
- `locked` (boolean)
- `totalDurationSeconds` (int)
- Approval support fields (for next story but persisted now):
  - `approvedAt?`, `approvedByUserId?`, `approvalNotes?`, `lockedAt?`
- Overlap override audit fields (when used):
  - `overlapOverrideUsed` (bool), `overrideReason`, `overriddenByUserId`, `overrideAt`

### BreakSegment
- `breakSegmentId` (UUID, PK)
- `workSessionId` (UUID, FK)
- `breakStartAt` (UTC timestamp)
- `breakEndAt` (UTC timestamp)
- `breakType?` (enum: `MEAL`, `REST`, `OTHER`)
- `notes?`

## API (Minimum)
- `POST /work-sessions/start` (or task-scoped start endpoint)
- `POST /work-sessions/stop`
- Break management (can be separate endpoints):
  - `POST /work-sessions/{id}/breaks/start`
  - `POST /work-sessions/{id}/breaks/stop`

## Acceptance Criteria
- Start creates `WorkSession` in `IN_PROGRESS` with UTC `startAt`.
- Stop updates same session to `COMPLETED` with UTC `endAt` and computed duration net of breaks.
- Default overlap prevention blocks starting a session when another is in progress.
- Overlap is only possible with config + permission + explicit override/audit.
- Breaks are manual segments, non-overlapping, contained, and immutable once locked.
- Locked/approved sessions reject any mutation.

## Audit & Observability
- Emit events after commit:
  - `workexec.WorkSessionStarted`
  - `workexec.WorkSessionStopped` (or `workexec.WorkSessionCompleted`)
  - future: `workexec.WorkSessionApproved` / `workexec.WorkSessionLocked`
- Log all state transitions with correlation IDs.
- Metrics (minimum):
  - active sessions gauge
  - completed session duration histogram
  - overlap override count

## Open Questions
None.

## Resolved Questions / Decisions Applied
- Decision record in issue comments resolves the prior STOP/domain conflict:
  - `workexec` is SoR for `WorkSession`
  - overlap policy (default deny; allow only with config + permission + explicit override)
  - breaks are manual `BreakSegment`s
  - approval/locking is manager-driven; enforce immutability when locked

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #68 ‚Äî [BACKEND] [STORY] Timekeeping: Start/Stop Work Session for Assigned Work

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Timekeeping: Start/Stop Work Session for Assigned Work

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Mechanic**, I want to start/stop a work session tied to a workorder/task so that time is captured for payroll and costing.

## Details
- Work session includes mechanicId, workorderId, location/resource, start/end, breaks.
- Prevent overlap unless permitted.

## Acceptance Criteria
- Start/stop supported.
- Overlaps prevented.
- Lock after approval.

## Integrations
- Shopmgr‚ÜíHR WorkSession events/API.
- Optional: Workexec consumes labor actuals.

## Data / Entities
- WorkSession, BreakSegment, ApprovalStatus

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Shop Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #67: [BACKEND] [STORY] Timekeeping: Capture Mobile Travel Time Separately
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:workexec
- status:ready-for-dev

### Recommended
- agent:workexec
- agent:story-authoring

---
**Rewrite Variant:** workexec-structured
---
## Story Intent
**As a** Mobile Lead,
**I want to** accurately record travel time segments associated with a mobile work assignment,
**So that** technician availability is correctly blocked in the scheduling system and payroll calculations are accurate.

This story establishes the core capability to capture and manage the lifecycle of travel time for off-site work, ensuring it is treated as a first-class component of a mobile assignment.

## Actors & Stakeholders
- **Mobile Technician**: The primary actor who performs the travel and whose time is being recorded.
- **Mobile Lead / Service Advisor**: The actor responsible for overseeing mobile assignments and ensuring time is logged correctly. May have permissions to review or correct entries.
- **Scheduler**: A stakeholder who consumes technician availability data to plan future work.
- **Payroll System**: A downstream system that consumes travel time data to process compensation.
- **System**: The POS/Shop Management platform itself.

## Preconditions
1. A valid, scheduled `MobileWorkAssignment` exists in the system.
2. A `MobileTechnician` is assigned to the `MobileWorkAssignment`.
3. The system has a defined set of `TravelSegment` types (e.g., DEPART_FROM_SHOP, ARRIVE_AT_CUSTOMER, DEPART_FROM_CUSTOMER, ARRIVE_AT_SHOP).

## Functional Behavior
1. **Initiate Travel**: The assigned Mobile Technician can initiate a "travel" activity against the active Mobile Work Assignment.
2. **Select Segment Type**: The system will prompt the technician to select the type of travel segment they are starting (e.g., "Depart from Shop to Customer").
3. **Start Travel Segment**: Upon selection, the system creates a new `TravelSegment` record associated with the `MobileWorkAssignment`.
    - The `startTime` is recorded as the current timestamp.
    - The status of the segment is set to `InProgress`.
    - The technician's availability status is updated to `InTransit`.
4. **End Travel Segment**: When the technician completes a travel leg (e.g., arrives at the customer's location), they end the current travel segment.
    - The system records the `endTime` on the `TravelSegment` record.
    - The status is updated to `Completed`.
    - The technician's availability status is updated (e.g., to `OnSite` or `Available`).
5. **System Integration**: Upon successful completion of a `TravelSegment`, the system will generate and publish a `TravelTimeRecorded` event to be consumed by downstream systems, such as the Payroll System.

## Alternate / Error Flows
- **Invalid State Transition**: If a technician attempts to start a travel segment when one is already `InProgress` for the same assignment, the system will return an error indicating an active travel leg must be completed first.
- **Non-Mobile Assignment**: If a user attempts to log travel time against a work assignment that is not designated as "mobile," the system will reject the request with an informative error.
- **Authorization Failure**: If a user other than the assigned technician or an authorized lead attempts to modify a travel segment, the request will be denied.

## Business Rules
- Travel time is considered billable and/or paid time, as per company policy.
- A technician's availability MUST be blocked and reflected as `InTransit` on the scheduling calendar for the duration of any `InProgress` or `Completed` travel segment.
- The creation, start, and end of travel segments must be auditable events.
- Business rules for applying automatic time buffers (e.g., adding 15 minutes before departure) must be configurable but are not defined for this story. See Resolved Questions.

## Data Requirements
**Entity: `TravelSegment`**
- `travelSegmentId`: (UUID, PK) Unique identifier for the segment.
- `mobileWorkAssignmentId`: (UUID, FK) Reference to the parent work assignment.
- `technicianId`: (UUID, FK) Reference to the assigned technician.
- `segmentType`: (Enum) The type of travel (e.g., `DEPART_SHOP_TO_CUSTOMER`, `DEPART_CUSTOMER_TO_SHOP`).
- `startTime`: (Timestamp with Timezone) The recorded start of the travel segment.
- `endTime`: (Timestamp with Timezone, Nullable) The recorded end of the travel segment.
- `durationMinutes`: (Integer, Calculated) Calculated duration upon completion.
- `status`: (Enum) `InProgress`, `Completed`, `Cancelled`.

**Event: `TravelTimeRecorded`**
- `eventId`: (UUID)
- `eventTimestamp`: (Timestamp)
- `payload`:
    - `travelSegmentId`: (UUID)
    - `mobileWorkAssignmentId`: (UUID)
    - `technicianId`: (UUID)
    - `startTime`: (Timestamp)
    - `endTime`: (Timestamp)
    - `durationMinutes`: (Integer)

## Acceptance Criteria
**Scenario 1: Successfully Record a Travel Segment**
- **Given** a Mobile Technician is assigned to an active Mobile Work Assignment
- **When** the technician initiates a "Depart from Shop" travel segment
- **And** they later end that segment upon arrival at the customer location
- **Then** the system must create a `TravelSegment` record with a `segmentType` of `DEPART_SHOP_TO_CUSTOMER`.
- **And** the record must have an accurate `startTime` and `endTime`.
- **And** the technician's availability in the scheduling system for that time block must show as `InTransit`.

**Scenario 2: Downstream System is Notified of Travel Time**
- **Given** a `TravelSegment` has been successfully completed with a start and end time
- **When** the system processes the completion of the segment
- **Then** a `TravelTimeRecorded` event must be published to the designated integration point (e.g., message queue or webhook).
- **And** the event payload must contain the `technicianId`, `startTime`, `endTime`, and `durationMinutes`.

**Scenario 3: Attempt to Log Travel for a Non-Mobile Job**
- **Given** a technician is assigned to a standard, in-shop Work Order
- **When** the technician attempts to start any type of travel segment against that order
- **Then** the system must reject the request with an error message stating "Travel time can only be logged for mobile assignments."

## Audit & Observability
- All state changes to a `TravelSegment` (create, start, complete, cancel) must be recorded in an immutable audit log, including the acting user and timestamp.
- The publication of the `TravelTimeRecorded` event must be logged, and system monitoring should include alerts for repeated publication failures to the HR/Payroll integration endpoint.
- Metrics should be captured for the average duration of travel segments to help with future scheduling estimates.

## Resolved Questions

### RQ1 (Travel Segment Types)
**Question:** What is the definitive, enumerated list of travel segment types we must support?

**Resolution:** The following travel segment types are definitive for **v1**:

**Required Segment Types (v1):**
1. **`DEPART_SHOP`** - Technician leaving shop/base location to travel
2. **`ARRIVE_CUSTOMER_SITE`** - Technician arriving at customer location
3. **`DEPART_CUSTOMER_SITE`** - Technician leaving customer location
4. **`ARRIVE_SHOP`** - Technician returning to shop/base location
5. **`TRAVEL_BETWEEN_SITES`** - Direct travel from one customer site to another (no return to shop)
6. **`DEADHEAD`** - Travel not directly tied to customer/work order (e.g., repositioning vehicle, moving between territories)

**Each Segment Records:**
- `startAt`: Timestamp (required)
- `endAt`: Timestamp (required when completed)
- `fromLocationId`: UUID (nullable for customer sites without location records)
- `toLocationId`: UUID (nullable for customer sites)
- `workOrderId`: UUID (optional, for customer-specific travel; not applicable to DEADHEAD)

**Optional Future Segment Types (NOT required for v1):**
- `FUEL_STOP` - Stop for vehicle refueling
- `PARTS_RUN` - Emergency parts pickup during mobile assignment

**Typical Flow Examples:**
- **Single Customer Visit:** `DEPART_SHOP` ‚Üí `ARRIVE_CUSTOMER_SITE` ‚Üí `DEPART_CUSTOMER_SITE` ‚Üí `ARRIVE_SHOP`
- **Multi-Customer Route:** `DEPART_SHOP` ‚Üí `ARRIVE_CUSTOMER_SITE` ‚Üí `DEPART_CUSTOMER_SITE` ‚Üí `TRAVEL_BETWEEN_SITES` ‚Üí `ARRIVE_CUSTOMER_SITE` ‚Üí `DEPART_CUSTOMER_SITE` ‚Üí `ARRIVE_SHOP`
- **Repositioning:** `DEPART_SHOP` ‚Üí `DEADHEAD` ‚Üí `ARRIVE_SHOP`

**Rationale:** This comprehensive set covers the full lifecycle of mobile operations while maintaining simplicity. The six types enable accurate tracking for scheduling (availability blocking), payroll (compensable travel time), and analytics (route efficiency). Future segment types can be added without breaking existing data model.

---

### RQ2 (Buffer Policies)
**Question:** What are the specific policies for automatically applying time buffers? Who defines them?

**Resolution:** Buffer policies are **policy-driven, owned by domain:people / timekeeping (HR policy)**, and configurable per location.

**Required Policies (v1):**
1. **Minimum Travel Rounding Increment**
   - Purpose: Round travel time to nearest increment for payroll
   - Example: Round to nearest 5 minutes
   - Config: `roundingIncrementMinutes` (default: 5)

2. **Minimum Billable Travel Floor**
   - Purpose: Minimum compensable travel time per segment
   - Example: If travel > 0 minutes, minimum 10 minutes paid
   - Config: `minTravelMinutes` (default: 0, can be set to 5, 10, 15)

3. **Standard Prep/Close Buffer**
   - Purpose: Auto-add time for first departure and last return of day
   - Example: +5 minutes at day start (loading tools), +5 at day end (unloading)
   - Config: `dayStartBufferMinutes` (0-5), `dayEndBufferMinutes` (0-5)

4. **Inter-Site Travel Buffer**
   - Purpose: Account for customer site parking, access delays
   - Example: +2 minutes for `TRAVEL_BETWEEN_SITES`
   - Config: `betweenSitesBufferMinutes` (0-2)

**Configuration Data Model:**
```json
{
  "locationId": "uuid",
  "policyVersion": "v1.2",
  "effectiveFrom": "2025-01-01T00:00:00Z",
  "roundingIncrementMinutes": 5,
  "minTravelMinutes": 0,
  "dayStartBufferMinutes": 5,
  "dayEndBufferMinutes": 5,
  "betweenSitesBufferMinutes": 2
}
```

**Policy Management:**
- Owned by: HR / Payroll administrator role
- Configured via: People / Timekeeping admin UI or API
- Versioned: Changes create new policy version (for audit)
- Applied at: Time approval or daily rollup (not real-time during capture)

**Application Timing:**
- Raw travel time captured exactly as recorded by technician
- Buffers applied during:
  1. Daily time summary calculation
  2. Approval workflow (visible to manager)
  3. Export to HR/Payroll system
- Store both: `rawMinutes` and `bufferedMinutes` for audit

**Rationale:** Policy-driven approach allows business rules to evolve without code changes. Per-location configuration accommodates different union agreements, state laws, or business practices. Explicit versioning and separate raw/buffered fields maintain full audit trail and transparency.

---

### RQ3 (HR/Payroll Integration Contract)
**Question:** What is the precise data schema and transport mechanism for sending travel time to the HR system?

**Resolution:** **Asynchronous, fire-and-forget event** via message queue. No synchronous HR response required for operational workflow.

**Integration Pattern:**
- **Transport:** Message queue topic: `timekeeping.travel.approved.v1`
- **Delivery:** At-least-once (HR must handle idempotency by `eventId`)
- **Timing:** Event published when travel segments are approved (not on every segment completion)

**Event Schema - TravelTimeApproved:**
```json
{
  "eventId": "uuid",
  "eventType": "TravelTimeApproved",
  "schemaVersion": "1.0.0",
  "occurredAt": "2025-01-15T18:30:00Z",
  "payload": {
    "personId": "uuid",
    "workDate": "2025-01-15",
    "locationId": "uuid",
    "segments": [
      {
        "travelSegmentId": "uuid",
        "type": "DEPART_SHOP",
        "startAt": "2025-01-15T08:00:00Z",
        "endAt": "2025-01-15T08:25:00Z",
        "minutes": 25,
        "workOrderId": "WO-123"
      },
      {
        "travelSegmentId": "uuid",
        "type": "ARRIVE_CUSTOMER_SITE",
        "startAt": "2025-01-15T08:25:00Z",
        "endAt": "2025-01-15T08:27:00Z",
        "minutes": 2,
        "workOrderId": "WO-123"
      }
    ],
    "totals": {
      "rawMinutes": 167,
      "bufferedMinutes": 180,
      "policyVersion": "v1.2"
    },
    "approval": {
      "approvedBy": "uuid",
      "approvedAt": "2025-01-15T18:30:00Z"
    }
  }
}
```

**Key Fields:**
- `segments[]`: Array of all travel segments for the day (detailed breakdown)
- `rawMinutes`: Total travel time as recorded (before buffers)
- `bufferedMinutes`: Total travel time after policy buffers applied
- `policyVersion`: Which buffer policy was applied (for audit)
- `approvedBy` / `approvedAt`: Approval metadata

**Excluded from Event:**
- ‚ùå Pay rates (HR/Payroll owns compensation rules)
- ‚ùå Dollar amounts (Timekeeping provides minutes only)
- ‚ùå Tax implications (Payroll responsibility)

**Error Handling:**
- Timekeeping: Logs event publication, retries on transient failures
- HR/Payroll: Consumes asynchronously, handles own retry/DLQ
- **No synchronous acknowledgment required** - operational workflow not blocked

**Ingestion Guarantee:**
- HR system must handle duplicate events (idempotency by `eventId`)
- HR system responsible for its own error recovery

**Rationale:** Async integration prevents operational workflow (travel capture, approval) from being blocked by HR system downtime. Clean domain separation: Timekeeping tracks time worked; HR/Payroll handles compensation. Including both raw and buffered minutes provides transparency for audits and dispute resolution.

---

### RQ4 (Permissions)
**Question:** Can a Mobile Lead or Service Advisor create, edit, or delete travel segments on behalf of a technician? Under what conditions?

**Resolution:** Yes, **on-behalf edits are allowed** under strict conditions with full audit trail.

**Permission Model:**
- **Technician:** `timekeeping:travel_segment:create`, `timekeeping:travel_segment:edit_self`, `timekeeping:travel_segment:delete_self`
- **Mobile Lead / Service Advisor:** `timekeeping:travel_segment:create_any`, `timekeeping:travel_segment:edit_any`, `timekeeping:travel_segment:delete_any`

**Conditions for On-Behalf Edits:**
1. **Status Restriction:** On-behalf edits allowed only when segment `status = DRAFT` or `SUBMITTED`
   - NOT allowed when `status = APPROVED`
2. **Scope Restriction:** Editor's role must have scope covering the technician's assigned location
   - Example: Mobile Lead at Location A cannot edit segments for technician at Location B
3. **Audit Requirement:** Every on-behalf action MUST record:
   - `actedByUserId`: ID of the person making the change
   - `actedForPersonId`: ID of the technician whose time is being changed
   - `reasonCode`: Required enum (e.g., `TECHNICIAN_UNAVAILABLE`, `FORGOT_TO_CLOCK`, `DATA_ENTRY_ERROR`)
   - `timestamp`: When the on-behalf action occurred

**Approved Segment Edits (Post-Approval):**
If a segment is already `APPROVED` and needs correction:
- **Cannot** directly edit/delete the segment
- **Must** create an `TravelSegmentAdjustment` record (similar to TimeEntryAdjustment pattern)
- Adjustment requires:
  - Manager approval
  - Explicit audit reason
  - Links to original segment
- Original segment remains unchanged for audit trail

**Data Model Extension:**
```
TravelSegment {
  // ... existing fields ...
  createdBy: UUID
  lastModifiedBy: UUID
  lastModifiedAt: Timestamp
  actedByUserId: UUID (nullable, populated for on-behalf edits)
  actedForPersonId: UUID (nullable, populated for on-behalf edits)
  onBehalfReasonCode: Enum (nullable)
}
```

**UI Indicators:**
- Display badge/indicator when segment was created/edited on-behalf
- Show "Edited by [Name] on behalf of [Technician]" in audit trail
- Require reason selection for all on-behalf actions

**Rationale:** On-behalf editing addresses real operational needs:
- Technicians forget to clock travel segments
- Technical issues prevent mobile app access
- Data entry corrections needed before approval

Strict conditions and full audit trail prevent abuse while enabling operational flexibility. Post-approval correction via adjustment records maintains immutable audit trail for compliance and dispute resolution.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #67 ‚Äî [BACKEND] [STORY] Timekeeping: Capture Mobile Travel Time Separately

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Timekeeping: Capture Mobile Travel Time Separately

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Mobile Lead**, I want to record travel time for a mobile appointment so that availability and payroll are accurate.

## Details
- Travel segments depart/arrive/return.
- Policies may auto-apply buffers.

## Acceptance Criteria
- Segments recorded.
- Sent to HR.
- Availability blocked during travel.

## Integrations
- Shopmgr‚ÜíHR TravelTime events/API.

## Data / Entities
- TravelSegment, MobileAssignmentRef

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Shop Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #66: [BACKEND] [STORY] Timekeeping: Approve Submitted Time for a Day/Workorder
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:workexec
- status:ready-for-dev

### Recommended
- agent:workexec
- agent:story-authoring

---
**Rewrite Variant:** workexec-structured
---

## Story Intent
**As a** Shop Manager,
**I want to** review, approve, or reject submitted time entries for a given work order or day,
**so that** employee hours are finalized and locked for accurate payroll processing.

## Actors & Stakeholders
- **Shop Manager (Primary Actor):** The user responsible for reviewing and approving time submissions. They hold the authority to lock time entries.
- **Mechanic / Service Advisor (Indirect Actor):** The user who initially submits their time entries for approval.
- **Payroll / HR System (Downstream System):** A system that consumes the final, approved time data to process payroll.
- **System (Actor):** The POS system which enforces business rules and records state changes.

## Preconditions
1. The Shop Manager is authenticated and has the necessary permissions (`TimeEntry:Approve`, `TimeEntry:Reject`) to manage time entries.
2. There are one or more employee time entries in a `PENDING_APPROVAL` state associated with a specific Work Order or date range.
3. The system can access the relevant Work Order and Employee records.

## Functional Behavior

### 1. Approve Time Entry
- **Trigger:** The Shop Manager selects one or more time entries in a `PENDING_APPROVAL` state and triggers the "Approve" action.
- **System Action:**
    1. The system validates that the Shop Manager has the required permissions.
    2. The system validates that each selected time entry is in the `PENDING_APPROVAL` state.
    3. For each entry, the system transitions its state from `PENDING_APPROVAL` to `APPROVED`.
    4. The system records the ID of the approving manager and the UTC timestamp of the approval.
    5. The system locks the `APPROVED` time entry, making it immutable to further changes from this workflow.
    6. A `TimeEntryApproved` event is emitted for downstream consumers (e.g., HR/Payroll System).

### 2. Reject Time Entry
- **Trigger:** The Shop Manager selects one or more time entries in a `PENDING_APPROVAL` state and triggers the "Reject" action, providing a mandatory reason for rejection.
- **System Action:**
    1. The system validates that the Shop Manager has the required permissions.
    2. The system validates that each selected time entry is in the `PENDING_APPROVAL` state.
    3. For each entry, the system transitions its state from `PENDING_APPROVAL` to `REJECTED`.
    4. The system records the ID of the rejecting manager, the UTC timestamp of the rejection, and the provided rejection reason.
    5. The `REJECTED` time entry is unlocked for the original submitter to correct and resubmit.

## Alternate / Error Flows
- **Error - Insufficient Permissions:** If the user lacks `TimeEntry:Approve` or `TimeEntry:Reject` permissions, the system denies the action and returns an authorization error.
- **Error - Invalid State:** If any selected time entry is not in the `PENDING_APPROVAL` state (e.g., it is already `APPROVED` or `DRAFT`), the system rejects the batch operation for that entry and returns an error specifying the invalid state conflict.
- **Error - Rejection without Reason:** If the "Reject" action is triggered without a reason, the system prevents the state change and returns a validation error requiring a reason.

## Business Rules
- Only users with the 'Shop Manager' role (or equivalent permissions) can approve or reject time entries.
- Time entries in the `APPROVED` state are considered immutable and cannot be altered, deleted, or rejected. Any changes require a separate, audited adjustment process (see Resolved Questions).
- A reason is mandatory for all rejections to provide feedback to the employee.
- Approval and rejection actions must be recorded in an audit log, including the actor, timestamp, and target time entry.

## Data Requirements
**Time Entry Entity**
- `timeEntryId`: Unique identifier for the time entry.
- `workOrderId`: Foreign key to the associated work order.
- `employeeId`: Foreign key to the employee who performed the work.
- `startTimeUtc`: Start time of the work period.
- `endTimeUtc`: End time of the work period.
- `status`: State of the entry (e.g., `DRAFT`, `PENDING_APPROVAL`, `APPROVED`, `REJECTED`).
- `submittedAtUtc`: Timestamp of when the entry was submitted for approval.
- `decisionByUserId`: ID of the manager who approved/rejected the entry.
- `decisionAtUtc`: Timestamp of the approval/rejection.
- `rejectionReason`: Text field, populated only if `status` is `REJECTED`.

**Time Entry Approval Event** (`TimeEntryApproved`)
- `eventId`: Unique event ID.
- `timestamp`: Event creation timestamp.
- `timeEntryId`: The ID of the approved time entry.
- `workOrderId`: The associated work order ID.
- `employeeId`: The associated employee ID.
- `approvedHours`: The calculated total hours for the entry.
- `approvedByUserId`: The ID of the approving manager.

## Acceptance Criteria

### AC1: Successful Approval of a Time Entry
- **Given** a time entry exists with status `PENDING_APPROVAL`.
- **And** I am logged in as a Shop Manager with approval permissions.
- **When** I execute the "Approve" action on that time entry.
- **Then** the system must set the time entry's status to `APPROVED`.
- **And** the `decisionByUserId` and `decisionAtUtc` fields must be populated.
- **And** the time entry becomes read-only.
- **And** a `TimeEntryApproved` event is published.

### AC2: Successful Rejection of a Time Entry
- **Given** a time entry exists with status `PENDING_APPROVAL`.
- **And** I am logged in as a Shop Manager with rejection permissions.
- **When** I execute the "Reject" action on that time entry and provide a reason "Incorrect work order".
- **Then** the system must set the time entry's status to `REJECTED`.
- **And** the `rejectionReason` field must be populated with "Incorrect work order".
- **And** the `decisionByUserId` and `decisionAtUtc` fields must be populated.

### AC3: Attempting to Approve an Already Approved Entry
- **Given** a time entry exists with status `APPROVED`.
- **And** I am logged in as a Shop Manager with approval permissions.
- **When** I attempt to execute the "Approve" action on that time entry.
- **Then** the system must reject the request with an error indicating the entry is in an invalid state.
- **And** the time entry's state must remain `APPROVED`.

## Audit & Observability
- **Audit Log:** Every state transition (`PENDING_APPROVAL` -> `APPROVED` / `REJECTED`) for a `TimeEntry` must be logged. The log entry must include:
    - `timeEntryId`
    - `previousState`
    - `newState`
    - `timestamp`
    - `actorUserId` (The Shop Manager's ID)
    - `rejectionReason` (if applicable)
- **Metrics:** Monitor the count of approved vs. rejected time entries per day.
- **Alerts:** Consider an alert if the average time from submission-to-approval exceeds a defined threshold (e.g., 48 hours).

## Resolved Questions

### RQ1 (Adjustments)
**Question:** How does the adjustment process work for approved time entries? Can managers directly edit time entries before approving them?

**Resolution:** Use **Option B: Separate Adjustment Record** approach. Managers do not directly edit original time entries.

**Data Model - TimeEntry (Immutable once approved):**
```
TimeEntry {
  timeEntryId: UUID
  personId: UUID
  workOrderId: UUID
  startAt: Timestamp
  endAt: Timestamp
  status: Enum (DRAFT, SUBMITTED, APPROVED, REJECTED)
  submittedAt: Timestamp
  approvedBy: UUID (nullable)
  approvedAt: Timestamp (nullable)
}
```

**Data Model - TimeEntryAdjustment:**
```
TimeEntryAdjustment {
  adjustmentId: UUID
  timeEntryId: UUID (FK to TimeEntry)
  requestedBy: UUID (Manager/Technician who proposed adjustment)
  reasonCode: Enum (CLOCK_IN_MISSED, CLOCK_OUT_MISSED, INCORRECT_WORKORDER, etc.)
  notes: String (optional free-text explanation)
  
  // Delta fields - use EITHER proposed times OR minute delta
  proposedStartAt: Timestamp (nullable, preferred approach)
  proposedEndAt: Timestamp (nullable, preferred approach)
  minutesDelta: Integer (nullable, alternative approach)
  
  status: Enum (PROPOSED, APPROVED, REJECTED)
  approvedBy: UUID (nullable)
  approvedAt: Timestamp (nullable)
  createdAt: Timestamp
}
```

**Workflow:**
1. Manager identifies time entry needing correction during review
2. Manager creates `TimeEntryAdjustment` record with:
   - Link to original `TimeEntry`
   - Proposed corrected `startAt` and/or `endAt` times
   - Required `reasonCode` and optional `notes`
   - Status: `PROPOSED`
3. Adjustment requires explicit approval (either by same manager or higher authority, per policy)
4. Once adjustment is `APPROVED`:
   - Original TimeEntry remains unchanged (audit trail)
   - System computes **effective time** from TimeEntry + approved adjustments
5. When querying for payroll/reporting:
   - Join TimeEntry with approved TimeEntryAdjustments
   - Calculate: `effectiveStartAt`, `effectiveEndAt`, `effectiveMinutes`

**Benefits:**
- ‚úÖ Immutable audit trail (original time preserved)
- ‚úÖ Supports multiple adjustments over time
- ‚úÖ Clear approval/rejection workflow
- ‚úÖ Explicit reasoning for all changes

**Rationale:** This approach maintains full auditability while allowing corrections. It answers questions like "What time did the technician originally clock?" and "Why was it adjusted?" which are critical for dispute resolution and labor compliance.

---

### RQ2 (Exceptions)
**Question:** What are the business rules and criteria that define an "Exception"? How should exceptions be flagged and managed?

**Resolution:** Exceptions are **rule-based flags** attached to time entries or day summaries that must be explicitly resolved during approval.

**Exception Criteria (Minimum v1):**
1. **Overlapping Entries:** Same person has overlapping time entries for different work orders
2. **Missing Clock-Out:** Time entry has `startAt` but no `endAt` (open-ended entry)
3. **Exceeds Daily Hours Threshold:** Total daily hours > 12 hours (configurable)
4. **Overtime Threshold:** Weekly hours > 40 hours (configurable, jurisdiction-dependent)
5. **Time Against Closed Work Order:** Time logged to work order with status `CLOSED` or `CANCELLED`
6. **Time During PTO/Unavailable:** Time logged when person marked as PTO or unavailable
7. **Location Mismatch:** Time logged to work order at different location than person's assigned location

**Data Model - TimeException:**
```
TimeException {
  exceptionId: UUID
  timeEntryId: UUID (nullable if exception is for day summary)
  personId: UUID
  workDate: Date
  exceptionCode: Enum (OVERLAPPING_ENTRIES, MISSING_CLOCKOUT, DAILY_HOURS_EXCEEDED, etc.)
  severity: Enum (WARNING, BLOCKING)
  detectedAt: Timestamp
  detectedBy: String (system rule name)
  status: Enum (OPEN, ACKNOWLEDGED, RESOLVED, WAIVED)
  resolvedBy: UUID (nullable)
  resolvedAt: Timestamp (nullable)
  resolutionNotes: String (nullable)
  relatedEntityId: UUID (nullable, for related work order/adjustment)
}
```

**Exception Lifecycle:**
1. **Detection:** Automatic on time entry submission or daily rollup
2. **Status: OPEN** ‚Üí Exception flagged, visible to manager during approval workflow
3. **Manager Actions:**
   - **ACKNOWLEDGED:** Manager sees it but doesn't block approval (for `WARNING` severity)
   - **RESOLVED:** Manager takes corrective action (e.g., creates adjustment, splits entry)
   - **WAIVED:** Manager explicitly waives with justification (requires `resolutionNotes`)
4. **Approval Rules:**
   - `WARNING` severity: Can approve with acknowledgment
   - `BLOCKING` severity: MUST be RESOLVED or WAIVED before approval allowed

**UI Integration:**
- Display exception badge/indicator on time entries in approval queue
- Require manager to click through and review each exception
- Force explicit action (resolve/waive with notes) for BLOCKING exceptions

**Rationale:** Structured exception handling prevents payroll errors, ensures labor law compliance, and provides clear audit trail of manager decisions. Severity levels balance strictness with operational flexibility.

---

### RQ3 (HR Integration Contract)
**Question:** What is the precise data contract for the integration with the HR system? Is it push/pull? What specific fields are required?

**Resolution:** **Push-based async events** via message queue. HR/Payroll system consumes events; Timekeeping does not require HR response for operational workflow.

**Integration Pattern:**
- **Type:** Asynchronous event push (fire-and-forget from Timekeeping perspective)
- **Transport:** Message queue topic: `timekeeping.daily_totals.approved.v1`
- **Reliability:** At-least-once delivery; HR must handle idempotency

**Event Schema - DailyTimeApproved:**
```json
{
  "eventId": "uuid",
  "eventType": "DailyTimeApproved",
  "schemaVersion": "1.0.0",
  "occurredAt": "2025-01-15T18:30:00Z",
  "payload": {
    "personId": "uuid",
    "locationId": "uuid",
    "workDate": "2025-01-15",
    "totals": {
      "totalMinutes": 480,
      "regularMinutes": 450,
      "overtimeMinutes": 30,
      "breakMinutes": 30
    },
    "byWorkOrder": [
      {
        "workOrderId": "WO-123",
        "minutes": 240
      },
      {
        "workOrderId": "WO-456",
        "minutes": 210
      }
    ],
    "approval": {
      "approvedBy": "uuid",
      "approvedAt": "2025-01-15T18:30:00Z"
    }
  }
}
```

**Critical Fields:**
- ‚úÖ `personId`, `workDate`, `locationId` - Core identifiers
- ‚úÖ `totalMinutes` - Total approved time
- ‚úÖ `regularMinutes`, `overtimeMinutes` - Split for OT calculations
- ‚úÖ `byWorkOrder[]` - Allocation breakdown for job costing
- ‚úÖ `approvedBy`, `approvedAt` - Audit metadata

**Excluded from v1:**
- ‚ùå **Pay Rates:** HR/Payroll owns rate data and pay rules
- ‚ùå **Dollar Amounts:** Timekeeping provides hours/minutes only
- ‚ùå **Tax Withholdings:** Payroll system responsibility
- ‚ùå **Benefits/Deductions:** Payroll system responsibility

**Timekeeping System Responsibilities:**
- Capture time worked (hours/minutes)
- Categorize time (regular, OT, break)
- Allocate time to work orders
- Provide approval metadata

**HR/Payroll System Responsibilities:**
- Apply pay rates
- Calculate gross pay
- Apply tax rules
- Process benefits/deductions
- Generate paychecks

**Error Handling:**
- Timekeeping logs event publication success
- HR consumes asynchronously; failures are HR's responsibility to handle (retry, DLQ)
- No synchronous ACK required from HR to complete approval workflow

**Rationale:** Async integration prevents operational workflow (time approval) from being blocked by HR system downtime. Clean separation of concerns: Timekeeping tracks time, HR/Payroll handles compensation. This follows microservices best practices and maintains domain boundaries.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #66 ‚Äî [BACKEND] [STORY] Timekeeping: Approve Submitted Time for a Day/Workorder

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Timekeeping: Approve Submitted Time for a Day/Workorder

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Shop Manager**, I want to approve time submissions so that time becomes locked for payroll.

## Details
- Approve/reject with reason.
- Adjustments via delta entry.

## Acceptance Criteria
- Approved locked.
- Adjustments tracked.
- Exceptions list supported.

## Integrations
- HR receives approval state and totals.

## Data / Entities
- TimeApproval, AdjustmentEntry, ExceptionFlag

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Shop Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #63: [BACKEND] [STORY] Workexec: Update Appointment Status from Workexec Events
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:workexec
- status:ready-for-dev

### Recommended
- agent:story-authoring
- agent:workexec

---
**Rewrite Variant:** workexec-structured
---

## Story Intent

As the Work Execution System, I want to publish work order status changes via events, so that the Shop Management System can consume these events to update the corresponding Appointment status in real-time, providing accurate and timely visibility to Dispatchers and Service Advisors.

## Actors & Stakeholders

- **System Actors**:
    - `Work Execution System`: The source system of record for work order status; publishes events.
    - `Shop Management System`: The consuming system that owns the Appointment entity; subscribes to and processes events.
    - `Message Broker / Event Bus`: The infrastructure responsible for event transport.
- **Human Actors**:
    - `Dispatcher`: Primary beneficiary who needs real-time visibility into work progress to manage shop capacity and scheduling.
    - `Service Advisor`: Secondary beneficiary who communicates appointment status to customers.

## Preconditions

- An `Appointment` entity exists in the Shop Management System.
- A corresponding `Work Order` exists in the Work Execution System, which is logically linked to the `Appointment`.
- The Shop Management System has an active and correctly configured event subscription to the `WorkorderStatusChanged` and `InvoiceIssued` topics/queues from the Work Execution System.

## Functional Behavior

1.  The `Work Execution System` performs an action that changes the state of a work order (e.g., work started, work completed, invoice issued).
2.  It publishes a corresponding event (`WorkorderStatusChanged` or `InvoiceIssued`) to the message broker. The event payload contains, at a minimum, the `workOrderId`, the `newStatus`, and a `timestamp`.
3.  The `Shop Management System`'s event consumer receives the event.
4.  The system identifies the target `Appointment` associated with the `workOrderId` from the event payload.
5.  The system translates the incoming `Workexec` status to the corresponding `Appointment` status using a predefined mapping table.
6.  The system updates the `Appointment.status` field with the newly translated status.
7.  A new entry containing the new status, a timestamp, and the source event identifier is appended to the `Appointment.statusTimeline` collection.
8.  The event processing must be idempotent. If the same event is processed more than once, the `Appointment`'s state must be identical to its state after the first successful processing, with no duplicate timeline entries.

## Alternate / Error Flows

- **Reopened Work Order**: If an event is received indicating the work order has been "reopened," the system must update the `Appointment.status` and set the `Appointment.reopenFlag` to `true`.
- **Appointment Not Found**: If an event is received for a `workOrderId` that does not correspond to an existing `Appointment`, the event is acknowledged, an error is logged to a dead-letter queue (DLQ) or equivalent, and a high-priority alert is generated for operational investigation.
- **Invalid Status Mapping**: If the status from the `Workexec` event does not have a defined mapping to an `Appointment` status, the event processing fails. The event is moved to a DLQ and a high-priority alert is generated.

## Business Rules

- **BR1: Status Mapping Authority**: A definitive, non-ambiguous mapping between all possible `Workexec` statuses and `Appointment` statuses must exist and be maintained as a configurable business rule. (See Resolved Questions)
- **BR2: Idempotency Required**: All event handlers for status updates must be idempotent. The system should gracefully handle duplicate event delivery without causing data corruption or invalid state transitions.
- **BR3: Reopen Flag Logic**: The `reopenFlag` on an `Appointment` indicates that its associated work order was reopened at least once. The specific logic for when this flag can be cleared (if ever) must be defined. (See Resolved Questions)
- **BR4: Immutable Timeline**: The `statusTimeline` is an append-only log of status changes for an `Appointment`. Entries must not be modified or deleted after being recorded.

## Data Requirements

- **Event Payload Contract (`WorkorderStatusChanged`, `InvoiceIssued`)**:
    - `eventId`: `UUID` (Unique identifier for the event instance)
    - `workOrderId`: `String | UUID` (Identifier for the work order)
    - `newStatus`: `String | Enum` (The new status from the Work Execution System)
    - `eventTimestamp`: `ISO 8601 UTC` (Timestamp of when the event occurred)
    - `correlationId`: `UUID` (For tracing across systems)
- **Target Entity (`Appointment`) Fields to be Modified**:
    - `status`: `String | Enum` (The current status of the appointment)
    - `reopenFlag`: `Boolean` (Defaults to `false`)
    - `statusTimeline`: `List` (A collection of status change records)
- **Data Structure (`StatusTimelineEntry`)**:
    - `status`: `String | Enum` (The status that was set)
    - `changeTimestamp`: `ISO 8601 UTC` (Timestamp of when the status was changed in this system)
    - `sourceEventId`: `UUID` (The ID of the event that triggered this change)

## Acceptance Criteria

**AC1: Successful Status Update**
- **Given** an Appointment exists with a `workOrderId` of "WO-123" and its status is "Scheduled".
- **When** a `WorkorderStatusChanged` event is received for "WO-123" with a `newStatus` of "InProgress".
- **Then** the `Appointment`'s status is updated to the corresponding "Work In Progress" status.
- **And** a new entry is added to the `statusTimeline` for the "Work In Progress" status, including a timestamp and the event ID.

**AC2: Idempotent Event Processing**
- **Given** the Appointment for "WO-123" has its status set to "Work In Progress" from an event with ID "event-abc".
- **When** the system re-processes the exact same `WorkorderStatusChanged` event with ID "event-abc".
- **Then** the `Appointment`'s status remains "Work In Progress".
- **And** no duplicate entry is added to the `statusTimeline`.

**AC3: Reopen Work Order**
- **Given** an Appointment for "WO-456" has a status of "Work Complete".
- **When** a `WorkorderStatusChanged` event is received for "WO-456" with a `newStatus` indicating it has been "Reopened".
- **Then** the `Appointment`'s status is updated to the corresponding "Work In Progress" status.
- **And** the `reopenFlag` on the `Appointment` is set to `true`.
- **And** a new "Work In Progress" entry is added to the `statusTimeline`.

**AC4: Event for Non-Existent Appointment**
- **Given** the system is subscribed to work order events.
- **When** a `WorkorderStatusChanged` event is received for a `workOrderId` of "WO-999" which has no corresponding `Appointment`.
- **Then** an error is logged.
- **And** an alert is triggered for "Orphaned Work Order Event".
- **And** the event is moved to a dead-letter queue.

## Audit & Observability

- **Audit Trail**: The `Appointment.statusTimeline` field, with its `sourceEventId`, serves as a complete audit trail for all status changes triggered by this integration.
- **Logging**:
    - `INFO`: Successful consumption and processing of each event, including `workOrderId` and status change.
    - `ERROR`: Failures in processing, such as "Appointment Not Found" or "Invalid Status Mapping," including the full event payload for debugging.
- **Metrics**:
    - `events.processed.count`: Counter for successfully processed events, tagged by event type.
    - `events.processing.latency`: Histogram measuring the time from event receipt to completion of processing.
    - `events.failed.count`: Counter for failed events, tagged by failure reason (e.g., `appointment_not_found`, `invalid_status`).
- **Alerting**:
    - `CRITICAL`: Alert when the rate of failed events exceeds a defined threshold.
    - `CRITICAL`: Alert for any "Invalid Status Mapping" error, as it indicates a contract mismatch between systems.

## Resolved Questions

### RQ1 (Status Mapping Definition)
**Question:** What is the definitive, exhaustive mapping of all possible `Workexec` statuses to their corresponding `Appointment` statuses?

**Resolution:** The comprehensive status mapping table is as follows:

#### Appointment Status Enum (10 statuses):
1. `SCHEDULED` - Appointment booked but work not started
2. `CHECKED_IN` - Customer arrived, checked in at service desk
3. `WORK_IN_PROGRESS` - Active work being performed
4. `WAITING_FOR_PARTS` - Work paused pending parts arrival
5. `QUALITY_CHECK` - Work complete, undergoing inspection
6. `READY_FOR_PICKUP` - All work complete, awaiting customer pickup
7. `COMPLETED` - Customer picked up vehicle, appointment closed
8. `CANCELLED` - Appointment cancelled before or during work
9. `INVOICED` - Invoice generated and sent to customer
10. `REOPENED` - Previously completed work reopened for additional service

#### Workexec ‚Üí Appointment Status Mapping:

| Workexec Status | Appointment Status | Notes |
|----------------|-------------------|-------|
| `CREATED` | `SCHEDULED` | Initial work order creation |
| `PENDING` | `SCHEDULED` | Awaiting resource allocation |
| `ASSIGNED` | `SCHEDULED` | Mechanic assigned but not started |
| `CUSTOMER_ARRIVED` | `CHECKED_IN` | Customer check-in event |
| `CHECKED_IN` | `CHECKED_IN` | Explicit check-in status |
| `IN_PROGRESS` | `WORK_IN_PROGRESS` | Work actively being performed |
| `STARTED` | `WORK_IN_PROGRESS` | Work begun |
| `PARTS_PENDING` | `WAITING_FOR_PARTS` | Waiting for parts arrival |
| `ON_HOLD` | `WAITING_FOR_PARTS` | Default hold reason |
| `PARTS_ORDERED` | `WAITING_FOR_PARTS` | Parts ordered from supplier |
| `INSPECTING` | `QUALITY_CHECK` | Quality inspection in progress |
| `QC_IN_PROGRESS` | `QUALITY_CHECK` | Formal QC process |
| `WORK_COMPLETE` | `READY_FOR_PICKUP` | All work done, awaiting pickup |
| `AWAITING_CUSTOMER` | `READY_FOR_PICKUP` | Ready for customer |
| `CLOSED` | `COMPLETED` | Fully closed and customer departed |
| `DELIVERED` | `COMPLETED` | Vehicle delivered to customer |
| `CUSTOMER_PICKUP` | `COMPLETED` | Customer picked up vehicle |
| `CANCELLED` | `CANCELLED` | Cancellation at any stage |
| `ABANDONED` | `CANCELLED` | Customer did not return |
| `INVOICE_GENERATED` | `INVOICED` | Invoice created |
| `INVOICED` | `INVOICED` | Invoice sent to customer |
| `REOPENED` | `REOPENED` | Previously closed work reopened |
| `REWORK_REQUIRED` | `REOPENED` | Quality issue requires rework |

#### Precedence Rules:
1. `CANCELLED` is terminal - once cancelled, no further status updates except explicit reopen
2. `INVOICED` supersedes `COMPLETED` - if both events received, `INVOICED` wins
3. `REOPENED` supersedes any terminal status (`COMPLETED`, `CANCELLED`) until resolved
4. Multiple events with same Appointment status = idempotent (no duplicate timeline entries)

**Rationale:** This mapping covers the full lifecycle of shop operations including edge cases (holds, cancellations, reopens). Precedence rules ensure consistent state even with out-of-order event delivery.

---

### RQ2 (Reopen Flag Permanence)
**Question:** Once the `reopenFlag` is set to `true`, can it ever be reset to `false`?

**Resolution:** The `reopenFlag` is **permanent once set to `true`**. It must never be reset to `false`.

**Semantics:**
- `reopenFlag = true` means: "This appointment was reopened at least once during its lifecycle"
- This is a permanent indicator of appointment history, not current state
- The flag answers the question: "Was this appointment ever reopened?" (not "Is it currently reopened?")

**Alternative Field (if needed):**
For tracking whether an appointment is **currently** in a reopened state:
- Add separate field: `isCurrentlyReopened` (boolean)
- OR track `reopenCount` (integer) 
- OR rely solely on `status == REOPENED` for current state

**Rationale:** Permanent flags provide valuable historical insight for:
- Quality analysis (which appointments required rework?)
- Customer satisfaction tracking
- Process improvement (why are appointments being reopened?)
- Billing disputes (did we charge for rework?)

This follows audit log principles where historical facts are immutable.

---

### RQ3 (Appointment Identification)
**Question:** How is the `Appointment` identified from the incoming event? Is there a direct `appointmentId` in the event payload, or must the system perform a lookup?

**Resolution:** **Primary linkage uses `workOrderId` lookup**. Events must include `workOrderId`, and the Appointment service maintains a mapping table.

**Required Architecture:**
1. **Workexec Events** must always include `workOrderId` in payload
2. **Appointment Service** maintains mapping table:
   - Table: `WorkOrderAppointmentMapping`
   - Columns: `workOrderId (PK/FK)`, `appointmentId (FK)`, `createdAt`, `status`
3. **Event Handler** resolves `appointmentId` by lookup:
   ```sql
   SELECT appointmentId 
   FROM WorkOrderAppointmentMapping 
   WHERE workOrderId = :eventWorkOrderId
   ```
4. **Mapping Lifecycle:**
   - Created when Appointment creates/links to Work Order
   - Never deleted (for audit trail)
   - Indexed on `workOrderId` for fast lookup

**Optional Optimization (future):**
- If Workexec events start including `appointmentId` directly in payload:
  - Use `appointmentId` if present (skip lookup)
  - Fall back to `workOrderId` lookup if `appointmentId` absent
  - This supports gradual migration and backward compatibility

**Error Handling:**
- If `workOrderId` lookup fails ‚Üí move event to DLQ, alert "Orphaned Work Order"
- If multiple appointments map to same `workOrderId` ‚Üí log error, use most recent

**Rationale:** Using `workOrderId` as the integration key respects domain boundaries:
- Workexec owns Work Order concept
- Appointment owns Appointment concept  
- Mapping table maintains the relationship
This prevents tight coupling and allows Appointment to exist independently of Workexec's internal IDs.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #63 ‚Äî [BACKEND] [STORY] Workexec: Update Appointment Status from Workexec Events

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Workexec: Update Appointment Status from Workexec Events

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **System**, I want appointments to reflect workexec status so that dispatch has real-time visibility.

## Details
- Map workexec states to appointment states.
- Handle reopen as exception.

## Acceptance Criteria
- Status updates idempotent.
- Reopen flagged.
- Timeline stored.

## Integrations
- Workexec‚ÜíShopmgr WorkorderStatusChanged/InvoiceIssued events.

## Data / Entities
- AppointmentStatus, StatusTimeline, ExceptionFlag

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Shop Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #60: [BACKEND] [STORY] Reporting: Daily Dispatch Board Dashboard
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:workexec
- status:ready-for-dev

---

## Story Intent
**As a** Shop Manager,
**I want to** view a real-time dashboard showing daily work orders, mechanic availability, and resource conflicts,
**so that** I can dispatch jobs efficiently and avoid over-scheduling bays or mechanics.

## Actors & Stakeholders
- **Primary Actor:** `Shop Manager` (views dashboard, makes dispatch decisions).
- **Supporting Actors:** `Dispatch Coordinator` (may assist with scheduling).
- **Indirect Users:** `Mechanics` (their availability is displayed).
- **Stakeholder:** `Shop Owner` (depends on dispatch efficiency).

## Preconditions
- The system has active work orders for today (or selected date).
- Mechanic schedule and availability data is current.
- Service bays are registered with availability status.

## Functional Behavior
1. **Load Dashboard:** Shop Manager opens the Dispatch Board dashboard for a selected date (default: today).
2. **Display Data:**
   - List of pending/in-progress work orders.
   - Available mechanics and their current status (clocked in, on break, on job, etc.).
   - Available service bays and their current occupancy.
   - Visual conflict indicators (color-coded warnings or blocks).
3. **Refresh Data:**
   - Dashboard polls the backend every 30 seconds to fetch updated data.
   - Manager can manually refresh data at any time (button).
   - Optional future enhancement (v2): WebSocket push notifications for real-time events (job start, clock-out, bay change).
4. **Conflict Detection:** The system continuously evaluates conflicts and displays them with severity levels (WARNING vs. BLOCKING).
5. **Dispatch Action:** Manager selects a work order and a mechanic, confirming the assignment. The system validates conflicts before assignment.

## Alternate / Error Flows
- **Stale Data:** If polling data is older than 2 minutes, the dashboard displays a visual indicator (e.g., "Last updated 5 minutes ago").
- **Offline Mode:** If the backend is unreachable, the dashboard displays a warning and retains cached data (read-only).

## Business Rules
- **Availability Source of Truth:** The `People` service owns the real-time availability signal (status, clock-in/out, PTO, schedule).
- **Conflict Severity:** Some conflicts are WARNING (planner can proceed); others are BLOCKING (must be resolved before assignment).
- **No Auto-Resolution:** The system does NOT automatically reassign or cancel conflicting jobs. Decisions are human.
- **Same-Location Only:** Dispatch logic currently assumes all jobs and mechanics are in the same location (single-location dispatch; multi-location is future enhancement).

## Data Requirements
### Dashboard Query Data (Read from multiple services)
| Source | Data | Purpose |
|---|---|---|
| Work Execution | Work Orders (date-filtered), line items, labor summary | Display pending jobs, estimated duration |
| People | Mechanic roster, real-time status, schedule, PTO | Display availability, flags, conflicts |
| Shop Management | Service bays, occupancy, availability | Display bay conflicts |
| Pricing (Optional) | Estimated labor cost per job | Display labor cost, priority by profitability |

### Conflict Definition (8 Enumerated Conditions)
See **Resolved Questions** section for detailed definitions.

## Acceptance Criteria
**AC-1: Dashboard Loads with SLA Performance**
- **Given** I am a Shop Manager
- **When** I open the Dispatch Board for today
- **Then** the initial data load completes within 1 second (P50) and 2 seconds (P95)
- **And** the dashboard displays all work orders, mechanics, and bay status.

**AC-2: Polling Refresh Every 30 Seconds**
- **Given** the Dispatch Board is open
- **When** 30 seconds have elapsed
- **Then** the system automatically fetches updated data from the backend
- **And** the display refreshes with any changes in mechanic status, job status, or bay occupancy.

**AC-3: Manual Refresh Button**
- **Given** the Dispatch Board is open
- **When** I click the "Refresh Now" button
- **Then** the system immediately fetches the latest data
- **And** the display updates.

**AC-4: Conflict Detection and Display**
- **Given** a mechanic is already assigned to a job
- **And** the dispatch planner attempts to assign the same mechanic to another overlapping job
- **Then** the system detects the conflict (BLOCKING: "Mechanic double-booked")
- **And** displays a clear warning preventing the assignment.

**AC-5: HR Availability Integration**
- **Given** a mechanic's shift ends at 5 PM
- **And** an open PTO entry exists for tomorrow 8 AM‚Äì12 PM
- **When** I view the Dispatch Board
- **Then** I see the mechanic as "AVAILABLE" today (clocked in)
- **And** see a future PTO indicator for tomorrow.

**AC-6: Break Overlap Grace Period**
- **Given** a mechanic is on a 15-minute break (expected to return 3:00 PM)
- **And** a job is assigned to start at 2:50 PM (10 minutes overlap)
- **When** the system detects this conflict
- **Then** it marks it as WARNING (not BLOCKING), with message: "Job overlaps with expected break time‚Äîproceed with caution."

---

## Resolved Questions

### Question 1: SLA Definition (RESOLVED)

**Question:** What is the performance target (SLA) for the Dispatch Board load time?

**Answer:** **P95<2.0s, P50<1.0s, P99<3.5s** for initial load (API gateway receipt ‚Üí full JSON response)

**Assumptions (SLA Valid Under These Conditions):**
- Warm caches (no cold-start)
- Same-location data only
- Same-day work orders and schedule (no historical lookback)
- One location at a time

**Rationale:**
- Dispatch boards are **operational tools**‚Äîdelays above 2 seconds feel broken.
- These targets are aggressive but achievable with proper indexing and caching.

**Implementation Notes:**
- Cache mechanic roster (invalidate on clock event, hire/fire, schedule change).
- Cache bay status (invalidate on occupancy change).
- Index work orders by `scheduledDate` and `location`.

### Question 2: Data Refresh Policy (RESOLVED)

**Question:** Should the dashboard use polling, push (WebSocket), or both?

**Answer:** **Hybrid model: Polling every 30 seconds (v1) + optional event-driven push (v2)**

**Version 1 (MVP) ‚Äî Polling:**
- Backend exposes a single `GET /dashboard/v1/today` endpoint.
- Frontend polls this endpoint every 30 seconds.
- Manual "Refresh Now" button allows immediate refresh.
- Acceptable delay: displayed data may be up to 30 seconds stale.

**Version 2+ (Optional Enhancement) ‚Äî Event-Driven Push:**
- Emit WebSocket events for high-urgency signals only:
  - Mechanic clock-in / clock-out
  - Job start / job completion
  - Bay status change (occupied ‚Üí available)
  - Conflict detection
- Push replaces or supplements polling.
- Does NOT attempt full real-time streaming of minor status changes.

**Explicit Non-Goals:**
- Full real-time (millisecond) updates (not needed for dispatch).
- Streaming API for every state change.
- Multi-location merge (each load targets one location).

### Question 3: HR Integration Contract (RESOLVED)

**Question:** What is the contract with the People/HR service for mechanic availability?

**Answer:** **Structured availability signal via GET** `/people/v1/availability` 

**Request:**
```http
GET /people/v1/availability
  ?locationId=LOC-123
  &date=2023-11-01
  &includeSchedule=true
```

**Response Schema:**
```json
{
  "asOf": "2023-11-01T14:30:00Z",
  "location": "LOC-123",
  "people": [
    {
      "personId": "MECH-001",
      "firstName": "John",
      "lastName": "Doe",
      "currentStatus": "ON_JOB",
      "clock": {
        "clockedIn": true,
        "clockedInAt": "2023-11-01T08:00:00Z"
      },
      "break": {
        "onBreak": true,
        "breakStartedAt": "2023-11-01T12:00:00Z",
        "expectedReturnAt": "2023-11-01T13:00:00Z"
      },
      "pto": [
        {
          "ptoId": "PTO-456",
          "start": "2023-11-02T08:00:00Z",
          "end": "2023-11-02T12:00:00Z",
          "ptoType": "VACATION"
        }
      ],
      "scheduledAvailability": [
        {
          "scheduleId": "SCHED-789",
          "start": "2023-11-01T08:00:00Z",
          "end": "2023-11-01T17:00:00Z",
          "shift": "DAY"
        }
      ]
    }
  ]
}
```

**Field Semantics:**
- **`currentStatus`** (required): One of `CLOCKED_OUT`, `AVAILABLE`, `ON_JOB`, `ON_BREAK`, `PTO`.
  - Authoritative for "now"‚Äîuse this to determine if mechanic can accept a new job.
- **`clock`** (conditional): Present if clocked in; shows when and if they are currently on the clock.
- **`break`** (conditional): Present if currently on break; shows expected return time.
- **`pto`** (array): Future PTO entries; advisory for planning.
- **`scheduledAvailability`** (array): Scheduled shifts; advisory for planning (non-binding‚Äîhuman breaks, changes, etc.).

**Contract Guarantees:**
- Response is **current as of `asOf` timestamp** (not stale beyond 30 seconds if cached).
- `currentStatus` reflects the most recent event (clock, job, break).
- PTO and schedule data are **advisory only**; do not use to block/prevent dispatch decisions. Use `currentStatus` for enforcement.

### Question 4: Conflict Rules (RESOLVED)

**Question:** What are the enumerated conflict conditions, and which are WARNING vs. BLOCKING?

**Answer:** **8 enumerated conditions across 4 categories**

#### Category 1: Mechanic Conflicts (4 conditions)

| # | Condition | Detection | Severity | Message |
|---|---|---|---|---|
| 1a | **Double-Booked Mechanic** | Mechanic already assigned to job J1 (time T1..T2); dispatcher attempts J2 (time T1'..T2') with overlap. | üî¥ BLOCKING | "Mechanic [Name] is already assigned to job [WO-ID] during this time." |
| 1b | **Job Overlaps PTO** | Mechanic has confirmed PTO; dispatcher assigns job during PTO window. | üî¥ BLOCKING | "Mechanic [Name] has scheduled PTO from [start] to [end]." |
| 1c | **Job Overlaps Break (Grace Period)** | Job assigned overlaps with expected break by <15 min; break is confirmed (e.g., lunch approval). | üü° WARNING | "Job overlaps with expected break time [start-end]‚Äîproceed with caution." |
| 1d | **Clock-Out Mismatch** | Mechanic clocked in for one job, dispatcher assigns a different job without clock-out. | üü° WARNING | "Mechanic currently clocked in for job [WO-ID]‚Äîclock out before assigning new job?" |

#### Category 2: Resource Conflicts (2 conditions)

| # | Condition | Detection | Severity | Message |
|---|---|---|---|---|
| 2a | **Service Bay Double-Booked** | Bay B1 is assigned to job J1 (time T1..T2); dispatcher assigns J2 (time T1'..T2') with overlap. | üî¥ BLOCKING | "Bay [Name] is already assigned to job [WO-ID] during this time." |
| 2b | **Service Bay Unavailable** | Bay B1 is marked as unavailable (maintenance, broken), but dispatcher attempts assignment. | üî¥ BLOCKING | "Bay [Name] is currently unavailable (reason: [Maintenance/Broken])." |

#### Category 3: Location & Skill Conflicts (2 conditions)

| # | Condition | Detection | Severity | Message |
|---|---|---|---|---|
| 3a | **Location Mismatch** | Job located at LOC-A; mechanic's current location is LOC-B. | üü° WARNING | "Mechanic is currently at [Location B]‚Äîjob is at [Location A]." |
| 3b | **Skill Mismatch (Soft)** | Job requires skill `Electric` (high-voltage work); mechanic's certified skills do not include `Electric`. | üü° WARNING | "Mechanic [Name] may not have required skill [Skill]‚Äîproceed with caution." |

---

**Severity Semantics:**

- **üü° WARNING:** The planner is shown the alert but **can proceed** with the assignment. Useful for soft constraints (breaks, location distance, skill gaps).
- **üî¥ BLOCKING:** The assignment is **rejected**. The planner **cannot proceed** without resolving the conflict. Used for hard constraints (double-booking, PTO, unavailable resources).

**Validation Rules:**

- Perform conflict checks **at dispatch time** (when mechanic/bay is assigned to a job).
- Display all applicable conflicts (a job may have multiple).
- If any BLOCKING conflict exists, reject the assignment with a clear message.
- Allow the planner to override WARNINGs with an optional comment (audit trail).

---

## Audit & Observability
- **Audit Trail:** All dispatch assignments and conflict detections must be logged with:
  - `workOrderId`, `mechanicId`, `bayId`
  - Conflicts detected and severity
  - User who made the assignment
  - Timestamp
- **Logging:** Structured logs for all dashboard queries and data refreshes.
- **Metrics:**
  - `dashboard.load.latency.ms` (histogram; track P50, P95, P99)
  - `dashboard.poll.frequency` (count of polls per hour)
  - `conflicts.detected.count` (by severity level)
  - `conflicts.user_override.count` (WARNINGs overridden by dispatcher)

---

## Original Story (Unmodified ‚Äì For Traceability)
## [STORY] Reporting: Daily Dispatch Board Dashboard

**Description:**
A real-time dashboard for Shop Managers to view daily work orders, mechanic availability, and conflicts. The dashboard polls for updates every 30 seconds and detects scheduling conflicts (double-booked mechanics, bay conflicts, skill gaps, etc.) to help prevent overbooking and optimize dispatching.

**Domain**: Work Execution

**Actors:**
- Shop Manager
- Dispatch Coordinator (optional)

**Narrative:**
As a **Shop Manager**, I want a real-time dashboard showing pending work orders, available mechanics, and scheduling conflicts, so that I can make informed dispatch decisions and avoid over-scheduling.

**Acceptance Criteria (Initial):**
1. ‚úÖ Dashboard shows today's pending work orders
2. ‚úÖ Mechanic availability is current (real-time status, PTO, schedule)
3. ‚úÖ Service bay occupancy is visible
4. ‚úÖ Conflicts are detected and flagged with severity (WARNING vs. BLOCKING)
5. ‚úÖ Data auto-refreshes every 30 seconds (polling)
6. ‚úÖ Manual "Refresh Now" button available
7. ‚úÖ Performance target: P95<2.0s load time
8. ‚úÖ Conflict rules are 8 enumerated conditions (mechanic, resource, location/skill)

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #59: [BACKEND] [STORY] CrossDomain: Workexec Displays Operational Context in Workorder View
LABELS: type:story,domain:workexec,status:ready-for-dev,agent:story-authoring,agent:workexec
BODY:
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- domain:workexec
- status:ready-for-dev

### Recommended
- agent:workexec
- agent:story-authoring

---
**Rewrite Variant:** workexec-strict
---

## Story Intent
**As a** Mechanic or Shop Manager,
**I want** the Workorder Execution (Workexec) system to display the current operational context of a work order,
**so that** I understand who is assigned, which bay is in use, and the current schedule before starting work or making changes.

## Actors & Stakeholders
- **Mechanic (Primary Actor)**: The individual who will perform the work. Needs to see assignments, bay location, and schedule constraints.
- **Shop Manager (Primary Actor)**: The individual responsible for overseeing shop operations. Needs to see operational context to make dispatch decisions, resolve conflicts, and handle exceptions.
- **Workexec System (System Actor)**: The system responsible for executing work, tracking labor time, and capturing completion data.
- **Shopmgr System (Integration / System of Record)**: The authoritative source for operational context (location, bay, dispatch schedule, assigned mechanics, resources, constraints).
- **Dispatch System (Stakeholder)**: The system that creates and updates work order assignments. Workexec needs to faithfully reflect the current dispatch state.

## Preconditions
1.  The work order exists in the system and is in a state where work can be performed (e.g., `ASSIGNED`, `IN_PROGRESS`).
2.  The user (Mechanic or Shop Manager) is authenticated and has permission to view work orders.
3.  Shopmgr is the system of record and has published or made available the latest operational context for the work order.

## Functional Behavior
1.  The user opens or refreshes a view of a work order in the Workexec system.
2.  Workexec requests the latest operational context from Shopmgr (via REST API or consumes a recently-published event).
3.  Workexec displays the following operational context elements to the user (where available):
    -   **Location**: The name/identifier of the location where the work is to be performed.
    -   **Bay Assignment**: The bay identifier where the vehicle is or should be placed.
    -   **Dispatch Schedule**: The scheduled start and end times for the work (if known).
    -   **Assigned Mechanics**: A list of mechanics assigned to the work order, including primary and supporting roles.
    -   **Assigned Resources**: Any resources (e.g., equipment, specialized tools) allocated to the work.
    -   **Constraints**: Any operational constraints (e.g., "Bay must be vacated by 3:00 PM", "Requires lift").
4.  The system presents this information in a read-only view, indicating that Shopmgr is the authoritative source.
5.  If the Mechanic or Shop Manager has the appropriate permissions, the system may provide a mechanism to request a change or override to the operational context (which would result in a request to Shopmgr or a direct privileged update).

## Alternate / Error Flows
- **Error Flow 1: Operational Context Not Available**
    -   If the operational context cannot be retrieved from Shopmgr (e.g., due to a network error or an upstream system outage), Workexec displays a message indicating the context is temporarily unavailable.
    -   The user can still view the work order details, but the operational context panel is marked as stale or unavailable.
- **Error Flow 2: Unauthorized Access**
    -   If the user attempts to view a work order they do not have permission to access, the system returns a `403 Forbidden` error.
- **Alternate Flow 1: Manager Override**
    -   If a Shop Manager needs to override the operational context (e.g., reassign a bay, adjust timing due to an emergency), they invoke a privileged "Override Operational Context" action.
    -   This action triggers a call to a special Shopmgr endpoint (or emits a domain event) requesting a change in context (see Resolved Questions RQ1).
    -   The new operational context is reflected in Workexec once Shopmgr confirms the change.

## Business Rules
- **BR1: System of Record:** Shopmgr is the authoritative system for operational context. Workexec MUST NOT store or maintain a writable, independent copy of this data. It may cache the context for display purposes, but must treat the cache as read-only and subject to invalidation.
- **BR2: Context Immutability During Execution:** Once work has started on a work order (i.e., the work order transitions to `IN_PROGRESS`), the operational context version associated with that work start event is locked for the purposes of audit and tracking. This does not prevent Shopmgr from updating the context (e.g., for a future work session), but the locked version represents the conditions under which the work was initiated.
- **BR3: Required Context Elements:** At a minimum, Workexec must display the location, assigned mechanic(s), and the current work order status. Bay assignment, dispatch schedule, and resources are highly desirable but may be optional if not yet populated by Shopmgr.

## Data Requirements
- **OperationalContext (from Shopmgr)**
    -   `workOrderId` (FK)
    -   `version` (Optimistic Lock / Version Number)
    -   `locationId`
    -   `locationName`
    -   `bayId` (Nullable)
    -   `bayName` (Nullable)
    -   `scheduledStartAt` (Timestamp, Nullable)
    -   `scheduledEndAt` (Timestamp, Nullable)
    -   `assignedMechanics` (List of Mechanic assignments with role)
    -   `assignedResources` (List of Resource assignments)
    -   `constraints` (List of Operational Constraint objects)
    -   `lastUpdatedAt` (Timestamp)
    -   `lockedAtWorkStart` (Boolean; true if this version was in effect when work started)
- **WorkorderExecution (in Workexec)**
    -   `workOrderId` (PK/FK)
    -   `status` (Enum: `NOT_STARTED`, `IN_PROGRESS`, `COMPLETED`, etc.)
    -   `workStartedAt` (Timestamp)
    -   `operationalContextVersion` (Integer; the version of the context in effect when work started)

## Acceptance Criteria
- **AC1: Display Complete Operational Context**
    -   **Given** a work order with a fully populated operational context in Shopmgr,
    -   **When** a Mechanic views the work order in Workexec,
    -   **Then** Workexec must display the location name, bay assignment, scheduled start/end times, all assigned mechanics, assigned resources, and any operational constraints,
    -   **And** the display must indicate the source of this data is Shopmgr (e.g., "Operational context provided by Shop Management System").
- **AC2: Display Partial Context (Graceful Degradation)**
    -   **Given** a work order with only a location and one assigned mechanic defined (no bay or schedule yet),
    -   **When** a Mechanic views the work order in Workexec,
    -   **Then** Workexec must display the available location and mechanic information,
    -   **And** indicate which fields (bay, schedule) are not yet available,
    -   **And** the work order must still be actionable (e.g., mechanic can start work if permissions allow).
- **AC3: Lock Context Version on Work Start**
    -   **Given** a work order with operational context version 5,
    -   **When** a Mechanic starts work on that work order (transitions to `IN_PROGRESS`),
    -   **Then** the Workexec system must record `operationalContextVersion=5` and `workStartedAt` timestamp,
    -   **And** this locked version must be immutable for the duration of that work session,
    -   **And** any subsequent updates to the operational context in Shopmgr must not retroactively change the recorded context for this work session.
- **AC4: Context Unavailable Handling**
    -   **Given** Workexec is unable to retrieve operational context from Shopmgr due to a network error,
    -   **When** a Mechanic views the work order,
    -   **Then** Workexec must display a clear message that the operational context is currently unavailable,
    -   **And** the user must still be able to view other work order details (e.g., work order ID, vehicle information, requested services).
- **AC5: Manager Override Triggers Context Update**
    -   **Given** a Shop Manager has permission to override operational context,
    -   **When** they submit a request to change the bay assignment for a work order,
    -   **Then** Workexec must invoke Shopmgr's override endpoint with the proposed change,
    -   **And** if the override is accepted, the new operational context must be reflected in Workexec within a reasonable timeframe (e.g., <2 seconds),
    -   **And** the system must emit an audit event capturing the before/after context and the reason for the override.

## Audit & Observability
- **Audit Trail:** Any display of operational context must be logged (at DEBUG level or higher) to facilitate troubleshooting. This includes the work order ID, the version of the context retrieved, and the timestamp.
- **Events:** Workexec should log or emit events when:
    -   Operational context is successfully retrieved from Shopmgr.
    -   Operational context retrieval fails (for alerting and diagnostics).
    -   A Manager override request is submitted to Shopmgr.
- **Metrics:**
    -   Latency of operational context retrieval calls to Shopmgr.
    -   Frequency of context retrieval failures.
    -   Frequency of Manager override requests.

## Resolved Questions

From **Clarification Issue #256**, the following answers were incorporated:

### RQ1: Manager Override Process

**Decision**: Manager override is a **privileged, explicit action** requiring a separate endpoint and permissions.

**Not**: In-line field edits that would overwrite Shopmgr's current view.

**Mechanism**:
- Separate privileged endpoint: `POST /workexec/v1/workorders/{workOrderId}/operational-context:override`
- Permission: `workexec:operational_context:override`
- Request body:
  ```json
  {
    "overrides": {
      "bayId": "uuid",
      "scheduledStartAt": "2025-01-24T10:00:00Z"
    },
    "reason": "Emergency vehicle arrival; bay 3 required",
    "actorId": "uuid"
  }
  ```

**System behavior**:
1. Workexec validates permission and business rules
2. Creates new operational context version with updates
3. Uses optimistic concurrency control (`version` field)
4. Emits `OperationalContextOverridden` event with before/after and reason
5. Updates display in Workexec with new context

**Audit**: All overrides captured in immutable audit log.

### RQ2: Integration Contract

**Decision**: **Shopmgr is system of record**; Workexec consumes via REST API with optional event push for cache invalidation.

**REST endpoint (definitive)**:
```
GET /shopmgr/v1/workorders/{workOrderId}/operational-context
```

**Response schema**:
```json
{
  "workOrderId": "uuid",
  "version": 7,
  "location": {
    "locationId": "uuid",
    "locationName": "Main Shop - Bay Area 1"
  },
  "bay": {
    "bayId": "uuid",
    "bayName": "Bay 3",
    "bayType": "LIFT"
  },
  "dispatchSchedule": {
    "scheduledStartAt": "2025-01-24T10:00:00Z",
    "scheduledEndAt": "2025-01-24T12:00:00Z"
  },
  "assignedMechanics": [
    {
      "mechanicId": "uuid",
      "name": "John Doe",
      "role": "LEAD",
      "assignedAt": "2025-01-24T09:00:00Z"
    }
  ],
  "assignedResources": [
    {
      "resourceId": "uuid",
      "resourceType": "TIRE_MACHINE",
      "resourceName": "TireMaster Pro"
    }
  ],
  "constraints": [
    {
      "constraintType": "BAY_VACATE_BY",
      "value": "15:00:00"
    }
  ],
  "metadata": {
    "lastUpdatedAt": "2025-01-24T09:30:00Z",
    "lastUpdatedBy": "dispatch-service"
  }
}
```

**Event push (optional)**:
- Shopmgr publishes `OperationalContextChanged` event when context updates
- Workexec subscribes to invalidate local cache
- Workexec re-fetches via REST on next view

**Contract stability**: Schema versioned; backward-compatible changes preferred.

### RQ3: Work Start Event

**Decision**: **Explicit work start command** triggers context lock.

**Mechanism**:
- Endpoint: `POST /workexec/v1/workorders/{workOrderId}:start`
- Transitions work order to `IN_PROGRESS`
- Records `workStartedAt` timestamp
- Locks `operationalContextVersion` (current version at time of start)

**Lifecycle**:
- `NOT_STARTED` ‚Üí `IN_PROGRESS` (first start)
- `PAUSED` ‚Üí `IN_PROGRESS` (resume)

**Event emitted**: `WorkorderStatusChanged` with `lockedContextVersion`

**Business rule**: Locked version represents conditions under which work began; immutable for that session (future context updates do not retroactively alter locked version).

### RQ4: Status Egress

**Decision**: **Event stream** is the primary egress mechanism for work order status changes.

**Event topic**: `workexec.workorder.status.changed.v1`

**Payload schema**:
```json
{
  "eventId": "uuid",
  "eventType": "WorkorderStatusChanged",
  "occurredAt": "2025-01-24T10:00:00Z",
  "workOrderId": "uuid",
  "previousStatus": "NOT_STARTED",
  "newStatus": "IN_PROGRESS",
  "lockedOperationalContextVersion": 7,
  "locationId": "uuid",
  "actor": {
    "actorId": "uuid",
    "actorType": "MECHANIC"
  },
  "reason": "Work started by mechanic",
  "metadata": {
    "source": "workexec-service",
    "version": "1.2.3"
  }
}
```

**Consumers**:
- Shopmgr (for real-time shop floor visibility)
- Reporting (for labor utilization, cycle time tracking)
- Dispatch (for constraint enforcement and replanning)

**Delivery guarantees**:
- At-least-once delivery
- Idempotent consumption required (use `eventId` as deduplication key)
- Non-blocking (does not halt work execution)

**Fallback**: REST polling endpoint available but not recommended for real-time use.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #59 ‚Äî [BACKEND] [STORY] CrossDomain: Workexec Displays Operational Context

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] CrossDomain: Workexec Displays Operational Context

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Mechanic**, I want to see the current operational context (who assigned, which bay, etc.) in Workexec, so I know what's in effect before I start work.

## Details
- Fetch location, bay, dispatch schedule, assigned resources from Shopmgr.
- Shopmgr is system-of-record for operational context; Workexec displays read-only view.

## Acceptance Criteria
- Operational context displayed in Workexec UI.
- Data sourced from Shopmgr REST or events.

## Integrations
- Shopmgr provides context; Workexec consumes and displays it; any override triggers update back to Shopmgr.

## Data / Entities
- OperationalContext (Shopmgr), WorkorderExecution (Workexec)

## Classification (confirm labels)
- Type: Story
- Layer: Integration
- Domain: Shop Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #49: [BACKEND] [STORY] Workexec: Handle Substitution Pricing for Part Substitutions
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:workexec
- status:ready-for-dev

### Recommended
- agent:workexec
- agent:story-authoring

---
**Rewrite Variant:** workexec-structured
---

## Story Intent
As a Service Advisor, I need the system to automatically retrieve and price authorized part substitutes when an original part is unavailable. This ensures that work can proceed without delay, eliminates manual price lookups and calculations, and maintains estimate accuracy.

## Actors & Stakeholders
- **Actors:**
    - **Service Advisor:** The primary user who initiates the substitution process on a Work Order or Estimate.
    - **System:** The POS backend that orchestrates the queries for substitutes, availability, and pricing, and updates the Work Order.
- **Stakeholders:**
    - **Parts Manager:** Defines the part substitution policies (e.g., which substitutes are allowed for a given part).
    - **Service Manager:** Concerned with the efficiency of the service workflow and the accuracy of job costing.
    - **Customer:** Receives a timely and accurate estimate/invoice reflecting the parts actually used.

## Preconditions
1. A Work Order (or Estimate) exists in an open state.
2. The Work Order has a line item for a specific part.
3. The original part on the line item has been determined to be unavailable by the Inventory system.
4. Part substitution policies are configured in the Parts/Inventory domain.

## Functional Behavior
1.  **Trigger:** The Service Advisor initiates a "Find Substitutes" action for a specific part line item on the Work Order.
2.  **Request Substitutes:** The system sends a request to the Inventory/Parts domain, providing the original part number.
3.  **Receive Candidates:** The Inventory/Parts domain returns a list of authorized substitute part numbers, based on pre-configured substitution policies. This response should include availability status for each candidate.
4.  **Request Pricing:** For each *available* substitute candidate, the system requests a price from the Pricing domain. The request must include context necessary for accurate pricing (e.g., Customer ID, Contract ID).
5.  **Present Options:** The system presents the Service Advisor with a list of available, priced substitutes. Each option must display:
    - Substitute Part Number
    - Part Description
    - Final Customer Price
    - Availability Information (e.g., "In Stock")
    - Any relevant policy flags (e.g., "OEM", "Aftermarket")
6.  **Capture Selection:** The Service Advisor selects one of the substitute parts from the list.
7.  **Update Work Order:** The system updates the Work Order line item to reflect the selected substitute. The line item now contains the substitute part's number, description, and the quoted price. The original part number must be preserved on the line item for traceability.

## Alternate / Error Flows
- **No Substitutes Found:** If the Inventory/Parts domain returns no authorized substitutes for the original part, the system shall display a message to the Service Advisor: "No authorized substitutes found."
- **No Substitutes Available:** If substitutes exist but none are currently in stock, the system shall display a message: "No substitutes are currently available."
- **Pricing Service Failure:** If the Pricing domain fails to return a price for an available substitute, display the substitute with "Price Unavailable" status (do not exclude it from the list).
- **User Cancels Action:** The Service Advisor can cancel the substitution process at any time before confirming a selection, leaving the original line item unchanged.

## Business Rules
- The list of substitutes must be filtered according to centrally-managed substitution policies.
- The price displayed and applied must be the final, calculated price for the specific customer context, not a generic list price.
- The original part number and the fact that a substitution was made must be stored on the modified Work Order line item for reporting, auditing, and warranty purposes.
- Price is locked at time of selection; repricing only allowed via explicit, auditable action with permission.

## Data Requirements
- **Input to Process:**
    - `workOrderId`
    - `lineItemId`
    - `originalPartNumber`
    - `customerId` (for pricing context)
- **Data from Secondary Domains:**
    - **Inventory:** List of `SubstituteCandidate { partNumber, availabilityStatus, policyFlags }`
    - **Pricing:** `PriceQuote { partNumber, finalPrice, currency, priceStatus }`
- **State Changes:**
    - The target `WorkOrderLineItem` entity is updated with:
        - `partNumber` (set to the substitute's number)
        - `description` (set to the substitute's description)
        - `price` (set to the substitute's quoted price)
        - `lockedUnitPrice`, `currency`, `priceSource`, `priceListId`, `policyVersion`, `pricedAt`
        - `priceLockStatus = LOCKED`
        - `isSubstituted` (flag set to true)
- **Substitution History:**
    - `WorkOrderPartSubstitution` entity (1-to-many per line):
        - `substitutionId`
        - `workOrderId`
        - `workOrderLineItemId`
        - `originalProductId`
        - `originalPartNumberSnapshot`
        - `substituteProductId`
        - `substitutePartNumberSnapshot`
        - `selectedBy`
        - `selectedAt`
        - `reasonCode`
        - `pricingSnapshot`
        - `status` (APPLIED | REVERSED | SUPERSEDED)

## Acceptance Criteria
**Scenario 1: Successful Substitution**
- **Given** a Work Order line item for part `ABC-123` which is unavailable
- **And** part `XYZ-789` is an authorized and available substitute with a price of $50.00
- **When** the Service Advisor requests substitutes for `ABC-123`
- **And** selects `XYZ-789` from the presented list
- **Then** the Work Order line item is updated to show part `XYZ-789` with a locked price of $50.00
- **And** the line item retains a record that the original part was `ABC-123`
- **And** a `WorkOrderPartSubstitution` history record is created.

**Scenario 2: No Authorized Substitutes Exist**
- **Given** a Work Order line item for part `ABC-123` which is unavailable
- **And** there are no authorized substitutes configured for `ABC-123`
- **When** the Service Advisor requests substitutes
- **Then** the system displays a message "No authorized substitutes found."
- **And** the original Work Order line item remains unchanged.

**Scenario 3: Substitutes Exist But Are Not Available**
- **Given** a Work Order line item for part `ABC-123` which is unavailable
- **And** part `XYZ-789` is an authorized substitute but is not in stock
- **When** the Service Advisor requests substitutes
- **Then** the system displays a message "No substitutes are currently available."
- **And** the original Work Order line item remains unchanged.

**Scenario 4: Pricing Service Fails for a Substitute**
- **Given** a Work Order line item for part `ABC-123` which is unavailable
- **And** part `XYZ-789` is an authorized and available substitute
- **And** the Pricing service fails to return a price for `XYZ-789`
- **When** the Service Advisor requests substitutes
- **Then** the system displays `XYZ-789` with `priceStatus = UNAVAILABLE` and `unitPrice = null`
- **And** the Service Advisor can view it but cannot finalize selection/commit without a resolved price (unless they have `ENTER_MANUAL_PRICE` permission).

## Audit & Observability
- **Audit Log:** A structured log event must be created upon successful substitution, capturing `workOrderId`, `lineItemId`, `originalPartNumber`, `selectedSubstitutePartNumber`, `price`, and the `userId` of the Service Advisor.
- **Domain Event:** The system shall emit a `workexec.WorkOrder.PartSubstituted` event upon successful substitution.
- **Metrics:** The system should instrument counters to track the frequency of part substitutions (successes and failures).

## Resolved Questions

### Question 1: Pricing Service Failure for a Substitute

**Question:** What is the expected system behavior if the Pricing service is unavailable or returns an error for a specific, available substitute part?

**Answer:** **Display the substitute with "Price Unavailable"**, do not exclude it.

**Rules:**
- If Inventory/availability indicates the substitute is available but Pricing fails:
  - Include the substitute in results with:
    - `priceStatus = UNAVAILABLE`
    - `unitPrice = null`
    - `pricingErrorCode` (optional, non-sensitive)
- Advisor can **view** it but cannot **finalize** selection/commit without a resolved price, unless they have manual price permission.

**Guardrails:**
Selection/commit requires either:
- successful Pricing response, or
- manual price entry with permission `ENTER_MANUAL_PRICE` and audit reason.

This preserves decision-making while preventing silent incorrect pricing.

### Question 2: Traceability Storage (Preserve Original Part Number)

**Question:** What is the preferred data model for preserving the original part number?

**Answer:** Use a **separate related entity** for substitution history (authoritative), plus an optional convenience field on the line item.

**Data Model:**
- `WorkOrderLineItem`
  - `currentProductId`
  - `currentPartNumber` (derived/denormalized OK)
  - optional `originalProductId` (only if you want quick access)

- `WorkOrderPartSubstitution` (new entity, 1-to-many per line)
  - `substitutionId`
  - `workOrderId`
  - `workOrderLineItemId`
  - `originalProductId`
  - `originalPartNumberSnapshot`
  - `substituteProductId`
  - `substitutePartNumberSnapshot`
  - `selectedBy`
  - `selectedAt`
  - `reasonCode`
  - `pricingSnapshot`
  - `status` (APPLIED | REVERSED | SUPERSEDED)

**Rationale:** A single field loses multiple substitutions over time, reversal history, who/when/why, and audit defensibility.

### Question 3: Price Locking Policy for Substitutes

**Question:** When a substitute is selected and its price is applied to the Work Order line, is that price considered locked?

**Answer:** **Lock price at time of selection**, with an explicit controlled "reprice" action.

**Default Behavior:**
When substitute is selected and applied:
- store `lockedUnitPrice`, `currency`, `priceSource`, `priceListId`, `policyVersion`, `pricedAt`
- mark `priceLockStatus = LOCKED`

**When Repricing is Allowed:**
Only via explicit user action and permission:
- `REPRICE_WORKORDER_LINE`
- Reprice is allowed until invoicing is finalized, but it must:
  - create an audit event (`LINE_REPRICED`)
  - optionally require manager approval above thresholds

**Why Lock by Default:**
- Prevents surprises for customers and advisors
- Keeps estimate/approval traceability intact
- Avoids retroactive policy changes affecting in-flight work

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #49 ‚Äî [BACKEND] [STORY] Workexec: Handle Substitution Pricing for Part Substitutions

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Workexec: Handle Substitution Pricing for Part Substitutions

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **Service Advisor**, I want substitutes priced when originals are unavailable so that work continues without manual math.

## Details
- Return substitute candidates with availability + prices.
- Enforce allowed substitution types.

## Acceptance Criteria
- Candidates returned with policy flags.
- Selection captured on estimate/WO line.

## Integrations
- Workexec integrates with substitution + availability queries.

## Data / Entities
- SubstituteLink, SubstitutePolicy, PriceQuoteResponse

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Product / Parts Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #21: [BACKEND] [STORY] Order: Create Sales Order Cart and Add Items
LABELS: type:story,domain:workexec,status:ready-for-dev
BODY:
# Story Refinement Complete

## üè∑Ô∏è Labels (Proposed)

### Required
- type:story
- domain:workexec
- status:ready-for-dev

### Recommended
- agent:story-authoring
- agent:workexec

---
**Rewrite Variant:** workexec-structured
---

## Story Intent

As a POS Clerk, I need a robust mechanism to initiate a sales transaction by creating a persistent sales cart and populating it with specific products and services for a customer, so that I can accurately build an order for quoting and final sale.

## Actors & Stakeholders

- **POS Clerk (Primary Actor):** The user operating the POS terminal to serve a customer.
- **System (Primary System):** The Point of Sale system responsible for managing the sales order lifecycle.
- **Pricing Service (Secondary Domain):** An external service that provides authoritative pricing information for SKUs and service codes.
- **Inventory Service (Secondary Domain):** An external service that provides stock availability information for SKUs.
- **CRM Service (Secondary Domain):** A service providing customer and vehicle context.

## Preconditions

1. The POS Clerk is authenticated and has the necessary permissions to create sales orders.
2. The POS terminal is active and connected to the network.
3. A customer and/or vehicle context has been established in the session (or an anonymous session is explicitly permitted).

## Functional Behavior

1.  **Cart Initialization:**
    - The POS Clerk triggers the "Create New Order" action.
    - The System generates a new, unique `SalesOrder` entity with an initial state of `DRAFT`.
    - The `SalesOrder` is associated with the current customer/vehicle context (if provided) or allows anonymous cart creation.
    - The System presents the newly created empty cart to the Clerk.

2.  **Adding Items:**
    - The Clerk provides a product SKU or service code and a desired quantity.
    - The System sends a request to the **Pricing Service** to retrieve the current unit price for the given item.
    - The System (optionally, based on configuration) sends a request to the **Inventory Service** to check availability.
    - The System adds a new `SalesOrderLine` to the `SalesOrder` containing the SKU, quantity, and the retrieved unit price.
    - The System recalculates the `SalesOrder` subtotal (excluding taxes and discounts, which are handled by other processes).
    - The updated cart and its new total are displayed to the Clerk.

3.  **Linking Estimate/Workorder (Optional):**
    - The Clerk may link an existing estimate or workorder to the cart.
    - When linked, the System **merges** items from the source document into the current cart.
    - **Merge Rules:**
      - Items with the same SKU/service code and same unit price have their quantities merged.
      - Items with the same SKU/service code but different price or attributes are added as separate line items.
      - The System preserves source references: `sourceType` (ESTIMATE | WORKORDER), `sourceId`, and `sourceLineId`.
      - Re-linking the same source document is idempotent (no duplicate re-adds).

4.  **Updating & Removing Items:**
    - The Clerk can select an existing `SalesOrderLine` to change its quantity or remove it entirely.
    - The System updates or deletes the line item and recalculates the order subtotal accordingly.

## Alternate / Error Flows

- **Invalid SKU/Service Code:** If the Clerk enters an identifier that is not found by the Pricing Service, the System must reject the addition and display a "Product not found" error.
- **Pricing Service Unavailable:** 
  - **Primary Behavior:** If the Pricing Service does not respond, the System attempts to use a cached price if available within TTL (60 seconds).
  - **Cache Policy:** Cached prices are marked as `STALE` when served from cache. Cache key: `productId + customerAccountId + priceListId + currency`.
  - **Manual Fallback:** If no valid cached price exists, the System allows manual price entry for users with `ENTER_MANUAL_PRICE` permission. Manual prices must be flagged (`priceSource = MANUAL`), include a `reasonCode`, and are audited.
  - **Blocked Behavior:** Silent fallback to zero or last-known price without marking `STALE` is explicitly disallowed.
- **Inventory Insufficient:** 
  - **Default Behavior:** When Inventory reports insufficient stock, the System allows the item to be added to the cart.
  - The System sets `fulfillmentStatus = BACKORDER` on the line item.
  - The System displays a clear warning to the Clerk: "Insufficient stock ‚Äî item will be backordered."
  - **Configuration:** The system supports a configuration policy `inventoryInsufficientPolicy = BLOCK | WARN_AND_BACKORDER` (default: `WARN_AND_BACKORDER`).
  - Per-item override is allowed (e.g., regulated items may be configured to `BLOCK`).

## Business Rules

- Each `SalesOrder` must have a globally unique identifier (`orderId`).
- The price on a `SalesOrderLine` is captured at the moment it is added (`price-at-time-of-add`). It is not dynamically updated unless the item is explicitly refreshed or re-added by the user.
- The `SalesOrder` subtotal must be the deterministic sum of (`line.quantity` * `line.unitPrice`) for all lines.
- The system must not allow a `SalesOrder` to be created without a valid context (e.g., Clerk ID, Terminal ID).
- **Anonymous Carts:** Anonymous carts (without `customerId`) are valid with the following restrictions:
  - **Allowed:** Add/remove items, inventory checks, pricing display (best-effort), backorder flags, link estimate/workorder (if accessible).
  - **Restricted until customer is set:** Promotions requiring customer eligibility, charge account/invoicing, tax finalization, credit/PO enforcement, order submission.
  - **Transition Rule:** Setting `customerId` later re-evaluates pricing, taxes, promotions, and policies.

## Data Requirements

**`SalesOrder` Entity (owned by `domain:workexec`)**
- `orderId`: string (PK, unique)
- `customerId`: string (FK, nullable - supports anonymous carts)
- `vehicleId`: string (FK, nullable)
- `clerkId`: string (FK)
- `terminalId`: string (FK)
- `status`: enum (`DRAFT`, `QUOTED`, `COMPLETED`, `VOIDED`)
- `subtotal`: decimal
- `createdAt`: timestamp
- `updatedAt`: timestamp

**`SalesOrderLine` Entity (owned by `domain:workexec`)**
- `orderLineId`: string (PK, unique)
- `orderId`: string (FK)
- `itemSku`: string
- `itemDescription`: string
- `quantity`: integer
- `unitPrice`: decimal (Price captured at time of add)
- `fulfillmentStatus`: enum (`AVAILABLE`, `BACKORDER`) - tracks inventory availability
- `priceSource`: enum (`PRICING_SERVICE`, `CACHE`, `MANUAL`) - tracks where price came from
- `reasonCode`: string (nullable, required when priceSource = MANUAL)
- `sourceType`: enum (`ESTIMATE`, `WORKORDER`, nullable) - for linked items
- `sourceId`: string (nullable) - reference to source document
- `sourceLineId`: string (nullable) - reference to source line item

## Acceptance Criteria

**Scenario 1: Create a new, empty sales cart**
- **Given** I am a logged-in POS Clerk
- **When** I initiate a "Create New Order" action
- **Then** the System creates a new `SalesOrder` with a unique `orderId` and a status of `DRAFT`
- **And** the order's subtotal is 0.00
- **And** the `customerId` may be null (anonymous cart).

**Scenario 2: Add a valid and available item to the cart**
- **Given** I have a `DRAFT` sales order
- **When** I add quantity `2` of a valid SKU `ABC-123` with a unit price of `10.50`
- **Then** the System adds a `SalesOrderLine` to the order for SKU `ABC-123` with quantity `2` and unit price `10.50`
- **And** the `SalesOrder` subtotal is recalculated to `21.00`.

**Scenario 3: Attempt to add an item with an invalid SKU**
- **Given** I have a `DRAFT` sales order
- **When** I attempt to add an item with an invalid SKU `INVALID-SKU`
- **Then** the System prevents the item from being added
- **And** displays an error message "Product not found"
- **And** the `SalesOrder` and its subtotal remain unchanged.

**Scenario 4: Update the quantity of an existing item**
- **Given** my cart contains a `SalesOrderLine` for SKU `ABC-123` with quantity `2` and a subtotal of `21.00`
- **When** I update the quantity for SKU `ABC-123` to `3`
- **Then** the corresponding `SalesOrderLine` quantity is updated to `3`
- **And** the `SalesOrder` subtotal is recalculated to `31.50`.

**Scenario 5: Add item with insufficient inventory (backorder)**
- **Given** I have a `DRAFT` sales order
- **When** I add an item for which Inventory Service reports insufficient stock
- **Then** the System adds the item to the cart
- **And** sets `fulfillmentStatus = BACKORDER` on the line item
- **And** displays a warning "Insufficient stock ‚Äî item will be backordered"
- **And** the item is included in the subtotal calculation.

**Scenario 6: Merge items from estimate into cart**
- **Given** I have a `DRAFT` sales order with SKU `TIRE-001` quantity 2 at price $100
- **And** an estimate exists with SKU `TIRE-001` quantity 3 at price $100 and SKU `OIL-001` quantity 1 at price $25
- **When** I link the estimate to the cart
- **Then** the quantity for `TIRE-001` is merged to 5 (2 + 3)
- **And** `OIL-001` is added as a new line item
- **And** both lines have `sourceType = ESTIMATE`, `sourceId = <estimateId>`, and `sourceLineId` populated.

**Scenario 7: Price unavailable - use cached price**
- **Given** the Pricing Service is unavailable
- **And** a valid cached price exists for SKU `ABC-123` within the 60-second TTL
- **When** I add SKU `ABC-123` to the cart
- **Then** the System uses the cached price
- **And** marks the line item with `priceSource = CACHE`
- **And** displays a warning that the price is from cache (marked STALE).

**Scenario 8: Price unavailable - manual entry with permission**
- **Given** the Pricing Service is unavailable
- **And** no valid cached price exists for SKU `ABC-123`
- **And** I have the `ENTER_MANUAL_PRICE` permission
- **When** I manually enter a price for SKU `ABC-123` with a `reasonCode`
- **Then** the System adds the item with the manual price
- **And** marks the line item with `priceSource = MANUAL`
- **And** logs the manual price entry for audit.

**Scenario 9: Anonymous cart restrictions**
- **Given** I have created an anonymous cart (no `customerId`)
- **When** I attempt to apply a customer-specific promotion
- **Then** the System prevents the promotion from being applied
- **And** displays a message requiring customer assignment for promotions.

## Audit & Observability

- **Event:** `SalesOrderCreated`
  - **Payload:** `orderId`, `clerkId`, `terminalId`, `customerId`, `timestamp`
- **Event:** `SalesOrderLineAdded`
  - **Payload:** `orderId`, `orderLineId`, `itemSku`, `quantity`, `unitPrice`, `priceSource`, `fulfillmentStatus`, `timestamp`
- **Event:** `SalesOrderLineUpdated`
  - **Payload:** `orderId`, `orderLineId`, `newQuantity`, `oldQuantity`, `timestamp`
- **Event:** `SalesOrderLineRemoved`
  - **Payload:** `orderId`, `orderLineId`, `timestamp`
- **Event:** `EstimateLinked`
  - **Payload:** `orderId`, `sourceType`, `sourceId`, `itemsMerged`, `timestamp`
- **Event:** `ManualPriceEntered`
  - **Payload:** `orderId`, `orderLineId`, `itemSku`, `manualPrice`, `reasonCode`, `userId`, `timestamp`

## Resolved Business Decisions

The following decisions were made in response to clarification issue #221:

### 1. Inventory Policy (Insufficient Stock)
**Decision:** **(c) Allow the addition and flag the item for backorder**
- When Inventory reports insufficient stock, the item is added to the cart with `fulfillmentStatus = BACKORDER`.
- A clear warning is displayed to the Clerk.
- Downstream fulfillment steps are blocked until inventory is available.
- **Configuration:** `inventoryInsufficientPolicy = BLOCK | WARN_AND_BACKORDER` (default: `WARN_AND_BACKORDER`).
- Per-item overrides are supported (e.g., regulated items may use `BLOCK`).

### 2. Work Order Linking Behavior
**Decision:** **(b) Merge items into the current cart**
- Items from the source document (estimate/workorder) are added to the existing cart.
- **Duplicate Detection:** Same SKU/service + same unit price ‚Üí merge quantities.
- **Different Price/Attributes:** Same SKU but different price ‚Üí add as separate line item.
- **Source References:** Preserve `sourceType`, `sourceId`, and `sourceLineId` on merged lines.
- **Idempotency:** Re-linking the same source is idempotent (no duplicate re-adds).

### 3. Anonymous Cart Support
**Decision:** **Yes, anonymous carts are valid**
- **Allowed Actions:** Add/remove items, inventory checks, pricing display, backorder flags, link estimate/workorder.
- **Restricted Actions:** Customer-specific promotions, charge accounts, invoicing, tax finalization, credit/PO enforcement, order submission.
- **Transition Rule:** Setting `customerId` later triggers re-evaluation of pricing, taxes, promotions, and policies.

### 4. Pricing Service Dependency
**Decision:** **Soft dependency with bounded fallback**
- **Primary:** Use Pricing Service when available.
- **Fallback (TTL 60s):** Use cached price if available within TTL. Mark price as `STALE`.
- **Cache Key:** `productId + customerAccountId + priceListId + currency`.
- **Manual Entry:** If no cache available, allow manual price entry with `ENTER_MANUAL_PRICE` permission. Requires `reasonCode` and audit logging. Price flagged as `priceSource = MANUAL`.
- **Disallowed:** Silent fallback to zero or last-known price without marking `STALE`.

---

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #21 ‚Äî [BACKEND] [STORY] Order: Create Sales Order Cart and Add Items

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Order: Create Sales Order Cart and Add Items

**Domain**: user

### Story Description

/kiro
# User Story

## Narrative
As a **POS Clerk**, I want to create a cart and add products/services so that I can quote and sell efficiently at the counter.

## Details
- Create cart for a customer/vehicle context.
- Add items by SKU/service code; set quantities.
- Support linking to an existing estimate/workorder as the source of items (optional).

## Acceptance Criteria
- Cart created with unique orderId.
- Items can be added/updated/removed.
- Totals recalc deterministically.
- Audit changes.

## Integrations
- Pull product pricing from product/pricing service; optionally check availability from inventory.

## Data / Entities
- PosOrder, PosOrderLine, PriceQuote, TaxQuote (hook), AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Experience
- domain :  Point of Sale

### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #15: [BACKEND] [STORY] Workexec: Retrieve and Display Estimates for Customer/Vehicle
LABELS: type:story,domain:workexec,status:ready-for-dev,agent:story-authoring,agent:workexec
BODY:
## üè∑Ô∏è Labels (Applied)

- type:story
- domain:workexec
- agent:workexec
- agent:story-authoring
- status:ready-for-dev

---

## Story Intent

Enable Service Advisors to retrieve and display open/draft/approved estimates for a specific customer or vehicle, showing estimate summaries with totals, status, and last updated time. This supports the workflow from quote to appointment creation or checkout, allowing advisors to review work scope and customer approval before proceeding.

---

## Summary of Decisions (from comments)

- Workexec defines a canonical estimate state machine and is authoritative for estimate status and transitions.
- Canonical statuses: `DRAFT`, `OPEN`, `PENDING_CUSTOMER`, `APPROVED`, `DECLINED`, `EXPIRED`, `SCHEDULED`, `INVOICED`, `CANCELLED`, `ARCHIVED`.
- Editable states: `DRAFT`, `OPEN`, `PENDING_CUSTOMER`; locked states: `APPROVED`, `SCHEDULED`, `INVOICED`, `CANCELLED`, `ARCHIVED`.
- Validity: default 30 days (configurable per location); expired estimates block conversion actions; managers can extend validity with permission.
- Clone: deep copy with repricing; clone creates new `estimateId` and `DRAFT` status.
- Cardinality: default one active appointment per estimate (unique `linkedAppointmentId`).
- Approval: customer approval is primary; staff may record approval on behalf with evidence + permission; manager-level approval required above configured thresholds.
- Invoice creation: billing controls invoicing; estimates typically transition to `INVOICED` when billing links the invoice (normal path at/after work completion).
- Duration: `estimatedDurationMinutes` is a scheduling hint derived from line items; appointment may override planned duration without mutating estimate.
- Sync: event-driven updates (SSE) preferred; polling fallback with acceptable staleness ‚â§60s; server-side caches must invalidate on events.

---

## Acceptance Criteria

1. **Given** Service Advisor searches for customer by name, **When** query executes, **Then** all estimates for that customer in viewable states (DRAFT, OPEN, PENDING_CUSTOMER, APPROVED, QUOTED) are displayed within 2 seconds as a sortable/filterable list showing estimate ID, status, service description, grand total, and last updated date.

2. **Given** Service Advisor searches for vehicle by VIN or license plate, **When** query resolves vehicle, **Then** all estimates linked to that vehicle are displayed with vehicle context (year/make/model/VIN/license plate) at top and grouped by customer or displayed flat as selected.

3. **Given** Service Advisor clicks on estimate in list to view details, **When** detail panel opens, **Then** full estimate information is displayed including customer info, vehicle info, itemized service lines with unit prices and line totals, subtotal, tax breakdown by tax type, fee breakdown, grand total, service notes, validity date, approval status, and related appointments/invoices.

4. **Given** Estimate has passed validity date, **When** detail panel displays, **Then** warning banner shows "Estimate expired on [date]" and "Create Appointment" button is disabled. "Clone Estimate" option is available to create new estimate.

5. **Given** Service Advisor applies filters (status, date range, amount range, approval status), **When** filters are applied, **Then** estimate list is updated within 1 second showing only matching estimates and count of filtered vs. total results is displayed.

6. **Given** Estimate status changes externally (e.g., customer approves via portal), **When** Service Advisor is viewing estimate list, **Then** estimate row updates within 5 seconds showing new status, and notification is optional but recommended (e.g., "Estimate #123 approved").

7. **Given** Service Advisor clicks "Create Appointment" on APPROVED/QUOTED estimate, **When** appointment creation flow initiates, **Then** form is pre-populated with customer info, vehicle info, service description, estimated duration, and service cost from estimate. Estimate ID is captured as reference link. Estimated duration validation and conflict detection proceed as normal appointment creation.

8. **Given** Estimate requires manager-level approval (amount ‚â• configured threshold), **When** Service Advisor opens estimate detail, **Then** warning displays "Estimate exceeds approval threshold; requires manager approval" and "Create Appointment" action is disabled until approved.

9. **Given** Service Advisor has view permission for only one location but searches for estimate, **When** query executes, **Then** only estimates from permitted location are displayed. Attempt to view estimate from other location shows permission denial message.

10. **Given** Work Execution Service becomes unavailable, **When** Service Advisor attempts to load estimates, **Then** error message displays "Unable to load estimates; service temporarily unavailable" with option to "Retry Now" or "View cached estimates from [timestamp]" if recent cache available.

---

## Implementation Notes / Suggested Endpoints

- `GET /estimates?customerId={id}&status=OPEN,APPROVED,PENDING_CUSTOMER` -> returns `EstimateSummary[]` (paginated)
- `GET /estimates?vehicleId={id}` -> returns `EstimateSummary[]` for vehicle
- `GET /estimates/{estimateId}` -> returns `EstimateDetail` with `lineItems`, `taxDetails`, `auditLog`
- SSE endpoint: `/events/estimates?locationId={id}` -> emits `EstimateCreated`, `EstimateUpdated`, `EstimateStatusChanged` events
- Materialized read model recommended for low-latency list reads; invalidate on events

---

## Next Steps

- Remove `blocked:clarification`, add `status:ready-for-dev`, assign domain and agent labels.
- Create follow-up implementation tasks: list endpoint, detail endpoint, SSE subscription support, clone/clone-with-reprice flow, permission checks for recording approvals, and tests.
- Hand off to backend dev with this issue as canonical source.


‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #14: [BACKEND] [STORY] Workexec: Display Work In Progress Status for Active Workorders
LABELS: type:story,domain:workexec,status:ready-for-dev,agent:story-authoring,agent:workexec
BODY:
## üè∑Ô∏è Labels (Applied)

- type:story
- domain:workexec
- agent:workexec
- agent:story-authoring
- status:ready-for-dev

---

## Story Intent

Enable Counter Associates to view work-in-progress (WIP) status for active workorders in real-time, showing individual order status (waiting, in progress, parts pending, ready, completed), assigned mechanic and location, and estimated completion time. This supports accurate customer inquiries and order tracking.

---

## Actors & Stakeholders

- **Counter Associate** (Primary User): Queries WIP status to provide customer updates, manage customer expectations, escalate delays
- **Mechanic** (Work Executor): Executes work, updates work order status through Work Execution Service
- **Shop Manager / Dispatcher** (Resource Owner): Manages bay/mobile unit assignments, oversees shop floor operations, handles exceptions
- **Work Execution Service** (Authoritative Source): Owns work order status lifecycle, emits StatusChanged events
- **Shop Management Service** (Assignment Authority): Owns bay/mechanic assignment context, provides location/assignment details
- **Notification Service** (Integration): Delivers status change notifications (optional, if real-time push required)
- **Counter Management System** (UI Container): Front-end application hosting WIP view
- **Audit Service** (Compliance): Records all status views and state transitions

---

## Summary of Decisions (from comments)

- Default to real-time subscription via SSE with polling fallback (30s) and staleness indicator (>60s).
- Shop Management is authoritative for mechanic assignments; WIP shows UNASSIGNED and queue position when applicable.
- Canonical statuses are stored in Workexec; display labels are configurable per location (Shopmgmt).
- In AWAITING_PARTS state, show full part breakdown (Inventory is SoR; Workexec supplies blocking parts list).
- Escalation is notification/tasking only; Counter Associate cannot force state changes.
- No automatic customer notifications in this story; manual "Send update" is permitted (permissioned) and WIP emits events for downstream Notification Service.
- Default view is single-location; multi-location visibility enabled via permission `WIP_VIEW_ALL_LOCATIONS`.

---

## Acceptance Criteria

1. **Given** Counter Associate has opened WIP dashboard, **When** page loads, **Then** all active workorders (status in SCHEDULED, WAITING, IN_PROGRESS, AWAITING_PARTS, READY_FOR_PICKUP) are displayed within 2 seconds with current status, assigned mechanic, and location visible for each order.

2. **Given** Counter Associate is viewing WIP dashboard with real-time subscription active, **When** mechanic updates workorder status (e.g., "In Progress" ‚Üí "Parts Pending"), **Then** UI updates within 5 seconds with new status, reason, and estimated completion time highlighted.

3. **Given** Counter Associate is viewing WIP dashboard with polling enabled, **When** 30 seconds elapse, **Then** data is automatically refreshed from Work Execution Service and any status changes are reflected in UI with "Last updated X seconds ago" timestamp visible.

4. **Given** Counter Associate clicks on a workorder row in WIP list, **When** detail panel opens, **Then** full workorder information is displayed including customer name/phone, vehicle info (year/make/model/VIN), service description, full status history with timestamps, assigned mechanic with photo/certifications, assigned bay/location, estimated completion time, parts status, and internal notes.

5. **Given** Counter Associate is viewing detail panel for unassigned workorder, **When** panel loads, **Then** status shows "Not yet assigned" with expected assignment time, available mechanic options are displayed with skill match indicators, and Counter Associate can see estimated wait time until assignment.

6. **Given** Counter Associate is viewing WIP dashboard, **When** applying filters (by mechanic, bay, status, or date), **Then** list is filtered correctly and count of visible/total workorders is displayed accurately.

7. **Given** Work Execution Service becomes unavailable, **When** WIP view detects service timeout after 3 retries, **Then** display shows cached data with red warning banner "Real-time updates unavailable; last updated [timestamp]", polling pauses, and "Retry Connection" button is available. When service recovers, automatic reconnect occurs within 10 seconds.

8. **Given** Multiple workorders exist for same customer vehicle, **When** Counter Associate views WIP list, **Then** workorders are displayed as separate rows with option to group by customer or vehicle, and "Compare Status" view can be toggled to show side-by-side details.

9. **Given** Mechanic updates status while Counter Associate has detail panel open, **When** status change event is received, **Then** detail panel is refreshed automatically with changed fields highlighted, and notification indicates "Status updated while viewing".

10. **Given** Counter Associate has location/role-based permission restrictions, **When** WIP dashboard loads, **Then** only permitted workorders are visible (filtered by location and/or role), restricted actions (escalate, notify, mark ready) are disabled, and explanation message is displayed for hidden workorders.

---

## Open Questions (answered)

- Q1 (Real-time vs Polling): Real-time (SSE) default with 30s polling fallback; staleness >60s.
- Q2 (Assignment Authority): Shop Management authoritative; display UNASSIGNED and queue position.
- Q3 (Status Mapping): Canonical statuses in Workexec; display mapping from Shop Management per location.
- Q4 (Parts Data): Inventory owns detailed parts data; Workexec provides blockingParts[]; WIP resolves details from Inventory.
- Q5 (Escalation): Notification/task only; default SLA triggers defined; Counter Associate cannot change state.
- Q6 (Customer Notifications): Manual send only in this story; automatic notifications out of scope.
- Q7 (Multi-location): Default single-location; multi-location via `WIP_VIEW_ALL_LOCATIONS` permission.

---

## Audit & Observability (required events + key metrics)

(omitted here for brevity ‚Äî original content preserved in comments and previous body)

---

## Implementation Notes / Suggested Endpoints

- `GET /wip?locationId={id}&status=IN_PROGRESS,AWAITING_PARTS&includeAssignments=true` -> returns `WorkorderStatusView[]` (paginated)
- `GET /wip/{workorderId}` -> returns `WorkorderStatusView` with `statusHistory`, `partsConsumption`, `assignmentContext`
- SSE endpoint: `/events/wip?locationId={id}` -> emits `WorkorderStatusChanged` events
- Materialized Read Model recommended: `wip_view` updated by Workexec + Inventory + Shopmgmt sync for low-latency reads

---

## Next Steps

- Remove `blocked:clarification`, add `status:ready-for-dev`, assign domain and agent labels.
- Create follow-up implementation tasks: API endpoints, read-model migration, SSE gateway integration, access control checks, and tests.
- Hand off to backend dev with this issue as canonical source.



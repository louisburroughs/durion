‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #87: [BACKEND] [STORY] Location: Create/Update Location (pos-location) Including Timezone
LABELS: type:story,domain:location,status:needs-review,status:ready-for-dev
BODY:
STOP: Conflicting domain guidance detected
STOP: Clarification required before finalization
## üè∑Ô∏è Labels (Proposed)
### Required
- type:story
- status:needs-review
- blocked:domain-conflict
- blocked:clarification

### Recommended
- agent:location
- agent:people
- agent:story-authoring

### Blocking / Risk
- blocked:domain-conflict
- blocked:clarification

**Rewrite Variant:** integration-conservative

---
## ‚ö†Ô∏è Domain Conflict Summary
- **Candidate Primary Domains:** `domain:location`, `domain:people`
- **Why conflict was detected:** The story's primary action (Create/Update Location) belongs to the `domain:location`. However, a key acceptance criterion ("Inactive locations prevent new staffing assignments") defines enforcement logic that belongs to a consuming domain, such as `domain:people` or a scheduling service. This couples the implementation and testing of two distinct domains into a single story.
- **What must be decided:**
    1. Which domain is responsible for the full scope of this story as written?
    2. Should the cross-domain enforcement rule be defined in a separate story owned by the consuming domain (e.g., `domain:people`)?
- **Recommended split:** Yes. This story should be split.
    1. **Story 1 (domain:location):** Focus exclusively on the CRUD (Create, Read, Update, Delete) operations for the `Location` entity, including managing its `status` field.
    2. **Story 2 (domain:people/workexec):** Focus on the business logic of *consuming* location data, including how to handle `INACTIVE` locations when creating staffing assignments or work orders.

---

## Story Intent
As an Admin, I need to create and manage the lifecycle of business locations, so that dependent systems like scheduling, staffing, and timekeeping have an accurate, authoritative source for site-specific context, particularly timezones and operational status.

## Actors & Stakeholders
- **Admin:** A user with permissions to create and manage business locations.
- **System (Location Service):** The microservice responsible for owning and managing the `Location` entity as the system of record.
- **Stakeholders (People Service, Work Execution Service):** Downstream systems that consume location data to perform their functions (e.g., scheduling staff, assigning work orders). These systems rely on the accuracy and status of location data.

## Preconditions
- The Admin user is authenticated and authorized with `location:manage` permissions.
- The system's infrastructure (database, service runtime) is operational.

## Functional Behavior
### 1. Create a New Location
- **Trigger:** An Admin submits a `POST` request to the `/v1/locations` endpoint with valid location data.
- **Behavior:**
    - The system validates the request payload against the data requirements.
    - It verifies that the provided `code` is unique across all locations.
    - It ensures the `timezone` is a valid IANA Time Zone Database name (e.g., "America/New_York").
    - If a `parentLocationId` is provided, it validates that the parent location exists.
    - The system persists a new `Location` record in the database with a default status of `ACTIVE`.
    - It returns a `201 Created` response containing the full representation of the newly created location, including the system-generated `locationId`.
- **Outcome:** A new location is created and available for use by other systems.

### 2. Update an Existing Location
- **Trigger:** An Admin submits a `PUT` request to the `/v1/locations/{locationId}` endpoint with valid location data.
- **Behavior:**
    - The system locates the existing location by its `locationId`.
    - It validates the request payload. The `code` field cannot be changed after creation.
    - The system updates the specified fields (e.g., `name`, `address`, `timezone`, `status`, `parentLocationId`) for the location.
    - It returns a `200 OK` response with the full, updated representation of the location.
- **Outcome:** An existing location's attributes are updated. Changing the status to `INACTIVE` signals to consuming systems that it should not be used for new operational activities.

## Alternate / Error Flows
- **Invalid Data:** If required fields are missing or data formats are incorrect (e.g., invalid timezone string), the system rejects the request with a `400 Bad Request` and a descriptive error message.
- **Duplicate Location Code:** If an attempt is made to create a location with a `code` that already exists, the system rejects the request with a `409 Conflict`.
- **Location Not Found:** If an update request is made for a `locationId` that does not exist, the system returns a `404 Not Found`.
- **Unauthorized Access:** If the user lacks the required permissions, the system returns a `403 Forbidden`.

## Business Rules
- A `Location.code` must be unique and is immutable after creation.
- A `Location.timezone` must be a valid IANA Time Zone Database name.
- The `parentLocationId`, if provided, must reference the `locationId` of an existing Location.
- **[CONFLICT]** The business rule "Inactive locations prevent new staffing assignments" is a cross-domain concern. The `Location Service` is responsible for setting the `status`, but the enforcement of this rule belongs in the consuming service (e.g., `People Service`).

## Data Requirements
### `Location` Entity
| Field              | Type                | Constraints                                     | Description                                                    |
| ------------------ | ------------------- | ----------------------------------------------- | -------------------------------------------------------------- |
| `locationId`       | UUID                | Primary Key, Not Null                           | Unique system-generated identifier for the location.           |
| `code`             | String              | Not Null, Unique, Immutable                     | A user-defined, human-readable unique code for the location.   |
| `name`             | String              | Not Null                                        | The display name of the location.                              |
| `address`          | JSONB / Object      | -                                               | Structured address data (street, city, state, postal code).    |
| `timezone`         | String              | Not Null, IANA Format                           | The IANA timezone name (e.g., "Europe/London").                |
| `status`           | Enum (`ACTIVE`, `INACTIVE`) | Not Null, Default: `ACTIVE`               | The operational status of the location.                        |
| `parentLocationId` | UUID                | Nullable, Foreign Key -> `Location.locationId`  | The ID of the parent location, for hierarchical structures.    |
| `createdAt`        | Timestamp           | Not Null                                        | Timestamp of when the record was created.                      |
| `updatedAt`        | Timestamp           | Not Null                                        | Timestamp of when the record was last updated.                 |

## Acceptance Criteria
### Scope: `domain:location` (Recommended for this Story)
1.  **Given** an authorized Admin
    **When** they submit a `POST` request to `/v1/locations` with a valid name, a unique code, and a valid timezone
    **Then** the system shall create a new location, assign it a unique `locationId`, set its `status` to `ACTIVE`, and return a `201 Created` response with the new location's data.

2.  **Given** an existing location with `locationId` "loc-123"
    **When** an authorized Admin submits a `PUT` request to `/v1/locations/loc-123` to change the `status` to `INACTIVE`
    **Then** the system shall update the location's status to `INACTIVE` and return a `200 OK` response with the updated location data.

3.  **Given** a location with the code "MAIN-WH" already exists
    **When** an authorized Admin submits a `POST` request to create a new location with the code "MAIN-WH"
    **Then** the system shall reject the request and return a `409 Conflict` error.

4.  **When** an authorized Admin submits a request to update a location with a non-existent `locationId` "loc-999"
    **Then** the system shall return a `404 Not Found` error.

### Scope: Cross-Domain Enforcement (Requires Clarification & Likely a Separate Story)
5.  **Given** a location with `status` = `INACTIVE`
    **When** a user in the scheduling system attempts to create a new staff assignment for that location
    **Then** the scheduling system shall reject the request with an error indicating the location is not active.

## Audit & Observability
- **Audit Logs:** All create and update operations on locations must be logged, capturing the `adminId`, `locationId`, the changes made (diff), and a timestamp.
- **Domain Events:**
    - On successful location creation, the system shall emit a `pos.location.v1.LocationCreated` event.
    - On successful location update, the system shall emit a `pos.location.v1.LocationUpdated` event. This event must clearly indicate if the `status` changed.

## Open Questions
1.  **Domain Ownership & Story Splitting:** This story mixes responsibilities. Should this story be narrowed to *only* the `domain:location` CRUD functionality? (Recommendation: Yes). If so, a new story must be created for `domain:people` to handle the enforcement logic described in AC #5.
2.  **Enforcement of Inactive Rule:** Where exactly should the business rule "Inactive locations prevent new staffing assignments" be enforced? In the `Location Service` itself, or in the consuming `People`/`Scheduling` service? (The standard microservice pattern suggests the consuming service is responsible for this validation).
3.  **Parent Location Hierarchy:** What are the business rules for the `parentLocationId` hierarchy? Is there a maximum depth? Does changing a parent's status to `INACTIVE` automatically cascade to its children, or is that a separate business process?
4.  **Default Status:** Does creating a new location always default its status to `ACTIVE`, or should the `status` be an optional field in the creation payload?

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #87 ‚Äî [BACKEND] [STORY] Location: Create/Update Location (pos-location) Including Timezone

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Location: Create/Update Location (pos-location) Including Timezone

**Domain**: user

### Story Description

/kiro
# User Story

## Narrative
As an **Admin**, I want **to create and update locations** so that **staffing, scheduling, and timekeeping are anchored to the correct site and timezone**.

## Details
- Location fields: code, name, address, timezone, status, optional parent.

## Acceptance Criteria
- Location can be created/updated.
- Inactive locations prevent new staffing assignments.

## Integration Points (workexec/shopmgr)
- shopmgr schedules are tied to locationId.
- workexec workorders reference a service location.

## Data / Entities
- Location

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: People Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #78: [BACKEND] [STORY] Locations: Create and Maintain Shop Locations
LABELS: type:story,domain:location,status:ready-for-dev,agent:story-authoring,agent:location
BODY:
**Rewrite Variant:** inventory-flexible

## Story Intent
**As an** Admin,
**I want to** create, manage, and deactivate shop locations, including their addresses, operating hours, timezones, holiday closures, and appointment buffers,
**so that** customer-facing systems and internal operations (like scheduling and work execution) have an accurate and authoritative source of location information.

## Actors & Stakeholders
- **Admin**: Manages shop location data.
- **System**: POS backend service responsible for validation, persistence, and auditing.
- **Work Execution System (Consumer)**: References `locationId` on Estimates/Work Orders/Invoices and must validate location status.
- **HR System (Consumer)**: Filters staff availability/scheduling by location affiliation.

## Preconditions
- The Admin is authenticated and authorized for location management.
- The system supports validating IANA time zone IDs.
- Global default buffer configuration exists (system-wide defaults), with per-location overrides supported.

## Functional Behavior

### API Endpoints (Contract)
- `POST /locations`
  - Creates a new `Location` with `status=ACTIVE`
  - Returns `201 Created` with the full resource payload
- `GET /locations/{locationId}`
  - Returns `200 OK` with the full resource payload (including `status`)
  - Returns `404 Not Found` if the location does not exist
- `GET /locations?status=ACTIVE|INACTIVE|ALL` (default `ACTIVE`)
  - Returns a list of locations; by default only ACTIVE locations are returned
- `PUT /locations/{locationId}`
  - Full update (idempotent)
  - Returns `200 OK`
- `PATCH /locations/{locationId}`
  - Partial update
  - Returns `200 OK`
  - Used for soft-deactivation by setting `{ "status": "INACTIVE" }` (preferred over a dedicated `/deactivate` endpoint)

### 1. Create a New Shop Location
- The Admin submits location details.
- The System validates all provided data.
- If valid, the System persists the record as `ACTIVE` and generates a unique `locationId`.

### 2. Update an Existing Shop Location
- The Admin submits a full (`PUT`) or partial (`PATCH`) update.
- The System validates the update.
- If valid, the System persists the updated record.

### 3. Deactivate a Shop Location (Soft Deactivate)
- The Admin requests deactivation via `PATCH /locations/{locationId}` with `{ "status": "INACTIVE" }`.
- The System enforces the allowed transition `ACTIVE -> INACTIVE`.
- The location remains readable but is excluded from the active-only list by default.

## Alternate / Error Flows
- **Validation Failure**: Return `400 Bad Request` with a structured error containing `code`, `message`, and `field` where applicable.
  - Example codes: `INVALID_TIMEZONE`, `INVALID_OPERATING_HOURS`
- **Permission Denied**: Return `403 Forbidden`.
- **Not Found**: Return `404 Not Found` when `{locationId}` does not exist.
- **Name Uniqueness Conflict**: Return `409 Conflict` with code `LOCATION_NAME_TAKEN`.
- **Optimistic Lock Failure**: Return `409 Conflict` with code `OPTIMISTIC_LOCK_FAILED` for stale updates.

## Business Rules
- **Uniqueness**: `name` is unique across all locations regardless of status.
- **Normalization for uniqueness**: uniqueness is case-insensitive and trimmed.
  - `normalizedName = lower(trim(name))`
  - Unique constraint/index enforced on `normalized_name`.
- **Timezone**: `timezone` must be a valid IANA time zone ID (validated with `ZoneId.of(timezone)`).
- **Operating Hours**:
  - Hours are local times (`HH:mm`) in the location‚Äôs timezone.
  - Closed days are represented by *omitting* that day from `operatingHours`.
  - No duplicate day entries.
  - Overnight ranges (e.g., `22:00‚Äì02:00`) are not supported in v1.
  - For each day entry: `open < close` (strict).
- **Holiday Closures**:
  - Stored as `[{ date: "YYYY-MM-DD", reason?: string }]`.
  - No duplicate `date` entries per location.
- **Status**:
  - No hard deletes.
  - Allowed deactivation transition: `ACTIVE -> INACTIVE`.
- **Buffers**:
  - `checkInBufferMinutes` and `cleanupBufferMinutes` are integer minutes, `>= 0`.
  - Fields are nullable per-location overrides; effective values fall back to global defaults when null.

## Data Requirements
The `Location` resource contains:

| Field Name | Data Type | Description | Constraints |
|---|---|---|---|
| `locationId` | UUID | System-generated identifier | PK, not null |
| `name` | String | Display name | not null |
| `normalizedName` | String | Normalized name for uniqueness | not null, unique |
| `status` | Enum | Location status | not null (`ACTIVE`, `INACTIVE`) |
| `address` | JSONB / Object | Structured address | not null |
| `timezone` | String | IANA timezone ID | not null |
| `operatingHours` | JSONB / Array | Weekly hours entries | not null (empty list allowed) |
| `holidayClosures` | JSONB / Array | Date-only closures | nullable |
| `checkInBufferMinutes` | Integer | Per-location override | nullable, `>= 0` |
| `cleanupBufferMinutes` | Integer | Per-location override | nullable, `>= 0` |
| `version` | Integer/Long | Optimistic lock version | not null |
| `createdAt` | Timestamp | Created timestamp | not null |
| `updatedAt` | Timestamp | Updated timestamp | not null |

## Acceptance Criteria

### Scenario 1: Create Location (Happy Path)
- Given I am an authenticated Admin with permission to manage locations
- When I call `POST /locations` with valid name, address, timezone, and operating hours
- Then the system returns `201 Created` and the created location is `ACTIVE`

### Scenario 2: Update Location (Happy Path)
- Given an existing location
- When I call `PUT /locations/{locationId}` or `PATCH /locations/{locationId}` with valid updates
- Then the system returns `200 OK` and the stored data reflects the update

### Scenario 3: Deactivate Location
- Given an existing `ACTIVE` location
- When I call `PATCH /locations/{locationId}` with `{ "status": "INACTIVE" }`
- Then the system returns `200 OK` and the location is excluded from `GET /locations` default results

### Scenario 4: Reject Invalid Operating Hours
- Given I am an authenticated Admin with permission to manage locations
- When I submit operating hours where `close <= open`, duplicate days, or overnight hours
- Then the system returns `400 Bad Request` with code `INVALID_OPERATING_HOURS`

### Scenario 5: Reject Duplicate Name
- Given an existing location named "Downtown Auto Repair"
- When I create or rename another location to "  downtown auto repair  "
- Then the system returns `409 Conflict` with code `LOCATION_NAME_TAKEN`

### Scenario 6: Optimistic Lock Prevents Lost Update
- Given two clients load the same location version
- When one client updates the location and the other submits a stale update
- Then the stale update is rejected with `409 Conflict` and code `OPTIMISTIC_LOCK_FAILED`

### Scenario 7: Buffers Applied Correctly (Consumer Rule)
- Given a location has effective buffers of 10 minutes check-in and 10 minutes cleanup
- When an appointment is scheduled at 09:00 for 2 hours
- Then the effective resource occupancy is from 08:50 to 11:10

## Audit & Observability
- Emit an audit event for:
  - `LOCATION_CREATED`
  - `LOCATION_UPDATED`
  - `LOCATION_DEACTIVATED`
- Audit payload includes: `eventType`, `locationId`, `actorUserId`, `occurredAt`, and `before`/`after` (diff preferred; full snapshots acceptable).
- Expose metrics counters for locations created/updated/deactivated.

## Open Questions (if any)
- None.

## Resolved Questions

From Clarification Issue #261, the following answers were incorporated:

### RQ1: Buffer Specifics (Definitions, Data Type, Scope)

**Business Definitions**:
- **Check-in buffer**: A fixed time window **before the scheduled service start** reserved for customer arrival, vehicle intake, paperwork, and pre-service checks.
- **Cleanup buffer**: A fixed time window **after the scheduled service end** reserved for bay cleanup, tool reset, paperwork close-out, and vehicle staging.

**Data Type**: Buffers are durations in minutes (integers, `>= 0`)

**Scope & Override Model**: System-wide defaults with per-location nullable overrides

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #78 ‚Äî [BACKEND] [STORY] Locations: Create and Maintain Shop Locations

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Locations: Create and Maintain Shop Locations

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As an **Admin**, I want to create/edit shop locations with address, hours, and timezone so that appointments and scheduling rules are correct per site.

## Details
- Store location name/address/timezone/operating hours/holiday closures.
- Defaults: check-in and cleanup buffers.

## Acceptance Criteria
- Create/update/deactivate location.
- Hours/timezone validated.
- Changes audited.

## Integrations
- Workexec stores locationId on Estimate/WO/Invoice context.
- HR availability can be filtered by location affiliation.

## Data / Entities
- Location, OperatingHours, AuditLog

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Shop Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #77: [BACKEND] [STORY] Locations: Create Bays with Constraints and Capacity
LABELS: type:story,domain:location,status:ready-for-dev,agent:story-authoring,agent:location
BODY:
**Rewrite Variant:** inventory-flexible

## Story Intent
**As a** Shop Administrator,
**I want to** define and manage service bays within a location, including their capabilities, constraints, capacity, and operational status,
**so that** scheduling and dispatch can assign work to an appropriate and available bay and avoid incorrect assignments.

## Actors & Stakeholders
- **Shop Administrator**: Configures bays and maintains bay status/constraints.
- **Scheduler/Dispatch (Consumer)**: Queries bays (and constraints) to select suitable bays for jobs.
- **Service Advisor / Shop Manager**: Uses accurate bay configuration to manage throughput and customer expectations.
- **Technician**: Relies on the assigned bay having the required equipment/capabilities.

## Preconditions
- Parent `Location` exists.
- Shop Administrator is authenticated and authorized to manage bays for the target location.
- Service Catalog domain and People/Skills domain provide authoritative IDs for services/capabilities and skills.

## Functional Behavior

### API Endpoints (Contract)
- `POST /locations/{locationId}/bays`
  - Create a new bay under the location.
  - Returns `201 Created` with the full bay payload.
- `GET /locations/{locationId}/bays`
  - List bays for admin use.
  - Supports filters: `status` (e.g., `ACTIVE`, `OUT_OF_SERVICE`), `bayType`.
- `GET /locations/{locationId}/bays?status=ACTIVE`
  - Scheduler/dispatch query shape: returns only ACTIVE bays.
- `GET /locations/{locationId}/bays/{bayId}`
  - Get bay details including constraints/capacity.
- `PATCH /locations/{locationId}/bays/{bayId}`
  - Update mutable fields (see Business Rules).

### Create Bay
- The Shop Administrator submits required bay details and optional constraints.
- The System validates:
  - Required fields are present.
  - Location exists.
  - Constraint references (service IDs / skill IDs) exist in their authoritative domains.
- If valid, the System persists the Bay and its constraint relationships.

### Update Bay
- The Shop Administrator submits a partial update.
- The System validates updates and persists changes.

### Availability Semantics
- A bay with `status=OUT_OF_SERVICE` is not considered available for new work assignments.
- Scheduler/dispatch must filter for available bays using `status=ACTIVE`.

## Alternate / Error Flows
- **Duplicate Bay Name in Location**: creating or renaming a bay to a name that already exists within the same location is rejected with `409 Conflict`.
- **Invalid Location**: creating/updating a bay under a non-existent location returns `404 Not Found`.
- **Missing/Invalid Fields**: validation failures return `400 Bad Request` with field-level errors.
- **Unknown Constraint References**: if any referenced `supportedServiceIds` or `skillId` values do not exist, return `400 Bad Request` including the invalid IDs.
- **Unauthorized**: not authenticated ‚Üí `401`; authenticated but not authorized ‚Üí `403`.

## Business Rules
- **Name uniqueness**: bay `name` must be unique within its parent `Location` (case-insensitive recommended).
- **Status**:
  - `ACTIVE` or `OUT_OF_SERVICE`.
  - `OUT_OF_SERVICE` bays must be excluded from availability queries.
- **Bay type**: fixed enum in v1 (see Resolved Questions).
- **Constraints are references (no free-text)**:
  - `supportedServiceIds[]` reference Service Catalog domain entities.
  - `requiredSkillRequirements[]` reference People/Skills domain entities (`{ skillId, minLevel? }`).
- **Capacity**:
  - Stored as a structured object with required `maxConcurrentVehicles` and optional physical constraints.
  - Only `maxConcurrentVehicles` is enforced in v1; other fields are stored for future/advisory use.
- **Mutability**:
  - Mutable: `name`, `status`, `bayType`, `capacity`, `supportedServiceIds`, `requiredSkillRequirements`.
  - Immutable: `bayId`, `locationId`, `createdAt`.

## Data Requirements

### Bay
| Field | Type | Constraints |
| --- | --- | --- |
| `bayId` | UUID | PK |
| `locationId` | UUID | not null (FK to Location) |
| `name` | String | not null, unique per `locationId` (case-insensitive recommended) |
| `bayType` | Enum | not null |
| `status` | Enum | not null (`ACTIVE`, `OUT_OF_SERVICE`), default `ACTIVE` |
| `capacity` | JSON / JSONB | must include `maxConcurrentVehicles` |
| `createdAt` | Timestamp | not null |
| `updatedAt` | Timestamp | not null |

### Constraint relationships
- `bay_service_capability(bay_id, service_id)`
- `bay_skill_requirement(bay_id, skill_id, min_level)`

## Acceptance Criteria

### Scenario 1: Create Bay (Happy Path)
- Given a location exists and I am authorized to manage bays
- When I call `POST /locations/{locationId}/bays` with a valid name, bayType, status, and capacity
- Then the system returns `201 Created` and the bay is associated with the location

### Scenario 2: Reject Duplicate Bay Name Within Location
- Given a bay named "Alignment Rack 1" exists under the location
- When I create or rename another bay under that same location to "Alignment Rack 1"
- Then the system returns `409 Conflict`

### Scenario 3: OUT_OF_SERVICE Bays Are Not Returned For Availability
- Given a bay has `status=OUT_OF_SERVICE`
- When Scheduler calls `GET /locations/{locationId}/bays?status=ACTIVE`
- Then the response does not include that bay

### Scenario 4: Constraints Are Returned Via API
- Given a bay is configured with `supportedServiceIds` and `requiredSkillRequirements`
- When I call `GET /locations/{locationId}/bays/{bayId}`
- Then the response includes the constraints and capacity

### Scenario 5: Reject Unknown Service/Skill References
- Given I submit `supportedServiceIds` or `skillId` values that do not exist
- When I create/update a bay
- Then the system returns `400 Bad Request` including which IDs were invalid

## Audit & Observability
- Audit create/update/status change for Bay resources and include: `bayId`, `locationId`, action, timestamp, actor identity, and before/after (diff preferred).
- Metrics:
  - Bay count per location (gauge or derivable at scrape time)
  - Bay count by status (`ACTIVE`, `OUT_OF_SERVICE`)
- Standard HTTP metrics for latency, error rate, and request volume.

## Open Questions (if any)
- None.

## Resolved Questions

From Clarification Issue #260, the following answers were incorporated:

### RQ1: Source of Truth for Constraints
Constraints are foreign-key references (authoritative IDs from Service Catalog and People/Skills domains), not free-text.

### RQ2: Capacity Structure
`capacity` is a structured object; `maxConcurrentVehicles` is required and enforced in v1.

### RQ3: Bay Type Enum
Fixed enum in v1:
- `GENERAL_SERVICE`
- `ALIGNMENT`
- `TIRE_SERVICE`
- `HEAVY_DUTY`
- `INSPECTION`
- `WASH_DETAIL`

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #77 ‚Äî [BACKEND] [STORY] Locations: Create Bays with Constraints and Capacity

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Locations: Create Bays with Constraints and Capacity

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As an **Admin**, I want to define bays with constraints (lift/equipment) so that scheduler assigns the right work to the right bay.

## Details
- Bay attributes: type (lift/alignment), supported services, capacity, required skills, status (active/out-of-service).

## Acceptance Criteria
- Bay created under a location.
- Out-of-service blocks assignments.
- Constraints queryable.

## Integrations
- Dispatch validates assignments against bay constraints.
- Workexec displays bay context during execution.

## Data / Entities
- Resource(Bay), ResourceConstraint, ResourceStatus

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Shop Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #76: [BACKEND] [STORY] Locations: Create Mobile Units and Coverage Rules
LABELS: type:story,domain:location,status:ready-for-dev
BODY:
**Rewrite Variant:** inventory-flexible  
**Status:** Ready-for-dev (clarification #404 applied)

## Story Intent
As a **Shop Administrator**, I need to configure Mobile Service Units as distinct operational resources (capabilities, geographic coverage, and travel buffer policies), so that the Work Execution system can accurately schedule mobile appointments and account for travel logistics.

## Actors & Stakeholders
- **Shop Administrator**: configures mobile units, coverage, and policies.
- **Work Execution System (`workexec` domain)**: consumes mobile unit eligibility + policy data for scheduling.
- **Product/Service Catalog (`product/service-catalog` domain)**: authoritative source of `ServiceCapability`.

## Preconditions
- Caller is authenticated and authorized.
- A base location exists in the Location system (`pos-location`), referenced by `baseLocationId`.
- Service Catalog is reachable for capability validation.

## Functional Behavior
1) **Manage Mobile Units**
- Create, view, and update Mobile Units.
- Status lifecycle is controlled via status (no hard delete in v1).

2) **Assign Capabilities**
- Mobile Units reference capabilities by ID only.
- On create/update, the service validates capability IDs against Service Catalog.

3) **Define Coverage**
- Coverage is defined by linking Mobile Units to one or more Service Areas.
- Coverage rules support priority and effective date ranges.
- Coverage replacement should be atomic to avoid partial/inconsistent config.

4) **Define Service Areas**
- Service Areas are defined as **postal-code sets** (no polygons/geofencing in v1).

5) **Define Travel Buffer Policies**
- Support policy types:
  - `FIXED_MINUTES`
  - `DISTANCE_TIER`

For `DISTANCE_TIER`:
- Policy configuration stores **numeric distance tiers** (not a discrete class).
- Tier selection input is provided by the caller as `estimatedDistanceKm` (preferred) or `estimatedDistanceMi` (allowed, normalized internally to km).
- Location service stores/validates/returns the configuration; it does **not** compute distance for v1.

6) **Eligibility Query for Scheduling**
- Provide an eligibility query by postal code and timestamp:
  - Finds ServiceArea(s) containing the postal code.
  - Returns **ACTIVE** Mobile Units with an effective coverage rule at the timestamp.
  - Does not compute calendar availability (workexec owns that).

## Alternate / Error Flows
- **Invalid base location**: reject if `baseLocationId` does not exist (`400 Bad Request`).
- **Missing required fields**: reject with `400 Bad Request`.
- **Duplicate name (within scope)**: reject with `409 Conflict`.
- **Unknown capability IDs**: reject with `400 Bad Request`.
- **Service catalog unavailable during validation**: reject with `503 Service Unavailable`.
- **Invalid effective window**: reject if `effectiveEndAt <= effectiveStartAt` (`400 Bad Request`).
- **Invalid DISTANCE_TIER configuration**: reject with `400 Bad Request` (see rules below).

## Business Rules
- A Mobile Unit is schedulable only when `status = ACTIVE`.
- A Mobile Unit must be associated with exactly one base location.
- `maxDailyJobs` is a hard constraint for scheduling.
- `INACTIVE` and `OUT_OF_SERVICE` units are not schedulable.
- Service capabilities are **structured entities** owned by Service Catalog (not free-text tags).
- Service areas are **postal-code sets** (not polygons/geofencing) in v1.
- For v1, authorization is location-scoped (see ‚ÄúData Requirements / scoping‚Äù and ‚ÄúSecurity‚Äù).

`DISTANCE_TIER` rules:
- Tiers are ordered by ascending `maxDistance` (null means catch-all/infinity).
- Tier selection chooses the **first** tier where `distanceKm <= maxDistance`; otherwise falls through to the `maxDistance=null` tier (required).
- Validation: `bufferMinutes >= 0`; `maxDistance` must be strictly increasing where not null; at least one tier must exist; the catch-all tier must exist.

Ownership rule:
- Location service is the system of record for the **policy configuration**.
- The caller (workexec/scheduling) is responsible for supplying the operational distance input used to apply the policy.

## Data Requirements
### Identifier + scoping conventions (confirmed from repo)
- The existing Location API in this repo (`pos-location`) uses `Location.id` as `Long`.
- No `orgId/tenantId` convention was found in backend code; authorization/scoping patterns in `pos-security-service` use `locationId`.

### Entities
- **MobileUnit**
  - `mobileUnitId`: UUID (PK)
  - `name`: string (required)
  - `status`: enum (`ACTIVE`, `INACTIVE`, `OUT_OF_SERVICE`) (required)
  - `baseLocationId`: Long (required; references `pos-location` Location)
  - `travelBufferPolicyId`: UUID (required when `ACTIVE`, optional otherwise)
  - `maxDailyJobs`: integer (required, >= 0)
  - `createdAt`, `updatedAt`

- **MobileUnitCapability** (join table)
  - `mobileUnitId`, `capabilityId`

- **ServiceArea**
  - `serviceAreaId`: UUID (PK)
  - `name`: string (required)
  - `countryCode`: ISO 3166-1 alpha-2 (required)
  - `postalCodes[]`: strings (normalize into child table preferred)
  - `cities[]`: optional display-only

- **MobileUnitCoverageRule**
  - `coverageRuleId`: UUID (PK)
  - `mobileUnitId`: UUID (FK)
  - `serviceAreaId`: UUID (FK)
  - `priority`: integer (lower = higher priority)
  - `effectiveStartAt`: timestamp (nullable = immediate)
  - `effectiveEndAt`: timestamp (nullable = indefinite)

- **TravelBufferPolicy**
  - `travelBufferPolicyId`: UUID (PK)
  - `name`: string (required)
  - `policyType`: enum (`FIXED_MINUTES`, `DISTANCE_TIER`) (required)
  - `policyConfiguration`: JSONB (required; validated by type)

`DISTANCE_TIER` policyConfiguration shape (stored in `pos-location`):

```json
{
  "unit": "KM",
  "tiers": [
    { "maxDistance": 5,  "bufferMinutes": 10 },
    { "maxDistance": 15, "bufferMinutes": 20 },
    { "maxDistance": 30, "bufferMinutes": 35 },
    { "maxDistance": null, "bufferMinutes": 50 }
  ]
}
```

## Acceptance Criteria
### Scenario 1: Successful Mobile Unit Creation
- Given I am authenticated with `location.mobile-unit.manage`
- And a base location with ID `1` exists
- When I `POST /v1/mobile-units` with a valid payload including `name`, `baseLocationId`, `maxDailyJobs`, and valid capability IDs
- Then the API returns `201 Created`
- And the response contains a `mobileUnitId`
- And the Mobile Unit is persisted.

### Scenario 2: Prevent Duplicate Name Within Base Location
- Given a Mobile Unit named `Mobile Van 1` already exists for `baseLocationId = 1`
- When I create another Mobile Unit with the same name for `baseLocationId = 1`
- Then the API returns `409 Conflict`.

### Scenario 3: Eligibility Query Returns ACTIVE Covered Units
- Given a ServiceArea exists containing postal code `12345` in country `US`
- And Mobile Unit `A` is `ACTIVE` and has an effective coverage rule for that ServiceArea at time `T`
- When workexec calls `GET /v1/mobile-units:eligible?postalCode=12345&countryCode=US&at=T`
- Then the response includes Mobile Unit `A`
- And results are ordered by `priority` ascending.

### Scenario 4: Create and Read a DISTANCE_TIER Travel Buffer Policy
- Given I am authenticated with `location.mobile-unit.manage`
- When I `POST /v1/travel-buffer-policies` with `policyType = DISTANCE_TIER` and a valid tier configuration (including a catch-all tier)
- Then the API returns `201 Created`
- And `GET /v1/travel-buffer-policies/{id}` returns the same tier configuration.

### Scenario 5: Reject Invalid DISTANCE_TIER Configuration
- Given I am authenticated with `location.mobile-unit.manage`
- When I `POST /v1/travel-buffer-policies` with `policyType = DISTANCE_TIER` and tiers that are not strictly increasing by `maxDistance` (or missing the catch-all tier)
- Then the API returns `400 Bad Request`.

### Scenario 6: Out-of-Scope (TravelTimeApproved Event)
- The `TravelTimeApproved` event contract is defined in ‚ÄúResolved Questions‚Äù for cross-domain integration.
- Emitting that event is owned by the travel-capture/approval workflow (workexec/timekeeping), not by this story‚Äôs location configuration APIs.

## Audit & Observability
- Emit audit events for create/update/status-change on Mobile Units, coverage replacement, and travel buffer policy create/update.
- Include `X-Correlation-Id` on logs (generate if missing).
- Metrics: `mobile_units.total` partitioned by status.

## Resolved Questions
From clarification #259:

### RQ1: Travel Buffer Policy (Initial Types)
**Decision:** Support `FIXED_MINUTES` and `DISTANCE_TIER` in v1. No third-party traffic/mapping integration required.

### RQ2: Service Capabilities (Authoritative Source & Model)
**Decision:** Capabilities are structured and owned by Service Catalog; location stores only capability IDs.

### RQ3: Service Areas (Definition, Storage, Query)
**Decision:** Service areas use ZIP/postal-code sets in v1 (no polygons/geofencing).

### RQ4: HR Integration Contract (Travel Time Exchange)
**Decision:** Event-driven push to HR on approval; topic `timekeeping.travel.approved.v1`. (Contract preserved for downstream alignment; emission not in scope of this story.)

From clarification #404:

### RQ5: DISTANCE_TIER TravelBufferPolicy distance input + ownership
**Decision:** Tier selection uses a **numeric distance** input (`estimatedDistanceKm` preferred; `estimatedDistanceMi` allowed, normalized internally), supplied by the **caller (workexec/scheduling)**.

**System-of-record split (v1):**
- Location service stores/validates/returns policy configuration (tiers).
- Caller computes/provides operational distance input and applies policy when scheduling.

## Original Story (Unmodified ‚Äì For Traceability)
# Issue #76 ‚Äî [BACKEND] [STORY] Locations: Create Mobile Units and Coverage Rules

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Locations: Create Mobile Units and Coverage Rules

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As an **Admin**, I want to define mobile units with service capabilities and coverage so that mobile appointments can be scheduled with travel buffers.
## Details
- Mobile unit attributes: capabilities, base location, service area tags, travel buffer policy, max daily jobs.

## Acceptance Criteria
- Mobile unit created and assignable.
- Coverage/buffers configurable.
- Out-of-service blocks scheduling.

## Integrations
- HR receives travel time.
- Workexec stores mobileUnitId context for mobile workorders.

## Data / Entities
- Resource(MobileUnit), CoverageRule, TravelBufferPolicy

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Shop Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #53: [BACKEND] [STORY] StorePrice: Sync Locations from durion-hr for Pricing Scope
LABELS: type:story,domain:location,status:ready-for-dev
BODY:
## Story Intent
Ensure pricing rules and other business logic are applied only to valid, active business locations by synchronizing a local representation of location data from the authoritative `durion-hr` system.

## Actors & Stakeholders
- **Primary Actor:** `System (Location Service)` ‚Äî executes synchronization and maintains the local location store.
- **Data Source:** `durion-hr System` ‚Äî authoritative source of truth for company location data.
- **Key Consumer:** `Pricing Service` ‚Äî validates and scopes pricing overrides using synchronized location data.
- **Stakeholder:** `System Administrators` ‚Äî monitor sync health.

## Preconditions
1. Network path and credentials for the Location Service to access `durion-hr` API/event stream are securely configured.
2. Data contract (API schema or event structure) for location data from `durion-hr` is defined and available.
3. Local database schema for `Location` and `SyncLog` entities is deployed.

## Functional Behavior
A recurring or event-driven process synchronizes location data from `durion-hr`.
1. **Trigger:** Sync starts via schedule (e.g., nightly) or by subscribing to location change events.
2. **Extraction:** Fetch all relevant location records from `durion-hr`.
3. **Transformation & Loading:** For each source record:
   - Use `locationId` to find an existing local `Location` record.
   - **If local exists:** Update fields (`name`, `status`, `region`, `tags`) from source.
   - **If local missing:** Create a new `Location` record with source data.
4. **Missing from feed:** If a previously known location is absent from the source feed, set the local record to `INACTIVE` indefinitely (no hard delete) to preserve referential integrity and signal ineligibility for pricing scope.
5. **Logging:** Log outcome (success/failure) and counts (created/updated/skipped) into `SyncLog`.
6. **Idempotency:** Running the sync with unchanged source data does not create duplicates or unintended changes.

## Alternate / Error Flows
- **Source System Unavailable:** If `durion-hr` is unreachable, log the failure, alert administrators after configurable consecutive failures, and leave local data unchanged.
- **Invalid Data Received:** If a record is missing required fields (`locationId`, `status`) or malformed, skip it, log the error with `locationId`, and continue.

## Business Rules
- `durion-hr` is the source of truth for location identity and status; local data is a replica.
- No hard deletes on local `Location` records; historical references must remain intact.
- If a location is absent from the `durion-hr` feed, mark the local record `INACTIVE` indefinitely (do not delete).
- A location with status `INACTIVE` (or any non-`ACTIVE` status) is invalid for new pricing overrides.
- Existing pricing overrides for a location that becomes `INACTIVE` must be disabled so they cannot be applied.

## Data Requirements
### `Location` Entity
- `locationId` (String, PK)
- `name` (String)
- `status` (Enum: `ACTIVE`, `INACTIVE`, etc.)
- `region` (String, Nullable)
- `tags` (List, Nullable)
- `createdAt` (Timestamp)
- `updatedAt` (Timestamp)

### `SyncLog` Entity
- `syncId` (UUID, PK)
- `syncStartedAt` (Timestamp)
- `syncFinishedAt` (Timestamp)
- `status` (Enum: `SUCCESS`, `PARTIAL_FAILURE`, `FAILURE`)
- `recordsProcessed` (Integer)
- `recordsCreated` (Integer)
- `recordsUpdated` (Integer)
- `recordsSkipped` (Integer)
- `notes` (Text, Nullable)

## Acceptance Criteria
**AC1: Sync new and existing locations**
- Given `durion-hr` has Location A (`id:"loc-1"`, `name:"Main St"`, `status:"ACTIVE"`) not in local DB and Location B (`id:"loc-2"`, `name:"Old Name"`, `status:"ACTIVE"`) already local
- And source data for Location B is now (`id:"loc-2"`, `name:"Central Hub"`, `status:"INACTIVE"`)
- When the sync runs successfully
- Then local DB contains Location A with `status:"ACTIVE"`
- And local Location B is updated to `name:"Central Hub"`, `status:"INACTIVE"`

**AC2: Idempotent sync**
- Given a successful sync completed and source data unchanged
- When sync runs again
- Then `updatedAt` remains unchanged for existing records
- And `SyncLog` reports 0 created / 0 updated

**AC3: New overrides rejected for INACTIVE locations**
- Given a local location `id:"loc-deactivated"` has `status:"INACTIVE"`
- When an external system attempts to create a price override for `loc-deactivated`
- Then the request is rejected because the location is not valid for new overrides

**AC4: Sync failure handled**
- Given `durion-hr` is unreachable
- When sync runs
- Then no local location data changes
- And a `SyncLog` entry is recorded with `status:"FAILURE"` and connection error details

**AC5: Missing-from-feed locations become INACTIVE**
- Given a local location `id:"loc-3"` exists from prior syncs
- And the current `durion-hr` feed no longer contains `loc-3`
- When sync processes the feed
- Then the local `loc-3` record is set to `status:"INACTIVE"` and retained (no deletion)

**AC6: Existing overrides disabled when location becomes INACTIVE**
- Given a location `id:"loc-override"` has active price overrides
- And `loc-override` is synchronized with `status:"INACTIVE"` (either explicitly from source or due to missing-from-feed handling)
- When sync completes
- Then all price overrides linked to `loc-override` are disabled so they cannot be applied until the location returns to `ACTIVE`

## Audit & Observability
- **Logging:** Log sync start/completion/outcome at `INFO`; record-level errors at `WARN`/`ERROR` with `locationId`.
- **Metrics:**
  - `location_sync_duration_seconds`
  - `location_sync_total_runs` (counter with status tag)
  - `locations_processed_total` (counter)
- **Alerting:** Alert when sync fails for 3 consecutive runs.

## Open Questions
- None. Clarification #244 resolved prior questions.

---
## Original Story (Unmodified ‚Äì For Traceability)
# Issue #53 ‚Äî [BACKEND] [STORY] StorePrice: Sync Locations from durion-hr for Pricing Scope

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] StorePrice: Sync Locations from durion-hr for Pricing Scope

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As a **System**, I want to sync location identifiers from durion-hr so that store pricing can be scoped to valid locations.

## Details
- Import locationId, name, status.
- Optional region/tags.

## Acceptance Criteria
- Locations present in product domain.
- Deactivated locations cannot receive new overrides.
- Sync idempotent.

## Integrations
- HR ‚Üí Product location roster API/events.

## Data / Entities
- LocationRef, SyncLog

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Product / Parts Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ISSUE #38: [BACKEND] [STORY] Configuration: Define Default Staging and Quarantine Storage Locations for a Site
LABELS: type:story,domain:inventory,domain:location,status:ready-for-dev
BODY:
# [BACKEND] [STORY] Configuration: Define Default Staging and Quarantine Storage Locations for a Site

## üè∑Ô∏è Labels (Applied)

### Required
- type:story
- status:ready-for-dev
- domain:location
- domain:inventory

### Recommended
- agent:story-authoring

---

## ‚úÖ Clarification Resolutions Applied

**Clarification Issue**: #235
**Resolved Date**: 2026-01-12
**Resolved By**: @louisburroughs

### Resolution Summary

1. **Story Split Confirmed**: This story now focuses ONLY on configuration. A separate story for receiving workflow execution has been created (see Related Stories below).

2. **Uniqueness Rule Confirmed**: A `StorageLocation` cannot be designated as both default Staging and default Quarantine. This is enforced via validation.

3. **Permission Model Confirmed**: Permission definition and enforcement for quarantine moves is out of scope for this story and belongs to `domain:security` and `domain:inventory` execution stories.

---

## Story Intent

As an **Inventory Manager**, I want to configure default staging and quarantine storage locations for each site, so that all receiving workflows are standardized, consistent, and adhere to inventory handling policies.

## Actors & Stakeholders

- **Primary Actor:**
  - **Inventory Manager:** Responsible for configuring and maintaining the operational topology and policies of a warehouse or site.

- **Secondary Actors & Stakeholders:**
  - **System:** The POS/WMS system that must persist and expose the configured defaults.
  - **`domain:workexec`:** A key stakeholder and consumer of this configuration (consuming story: see Related Stories).
  - **`domain:audit`:** Requires events to be published when these critical site configurations are modified.

## Preconditions

1. The system has a concept of a `Site` or `Location` which represents a distinct physical or logical facility (e.g., a warehouse).
2. The system has a concept of a `StorageLocation` which represents a specific place within a `Site` where inventory can be held (e.g., a bin, a rack, or an area).
3. An authentication and authorization system is in place, capable of granting permissions to the `Inventory Manager` role to modify `Site` configurations.

## Functional Behavior

This story focuses **exclusively** on the **configuration** of the default locations. The consumption of these settings by receiving or other processes is handled in separate stories.

1. **Trigger:** An authorized `Inventory Manager` uses an API to update the default location settings for a specific `Site`.

2. **Behavior:**
   - The manager provides the unique identifier for a `Site`.
   - The manager provides the unique identifier of an existing `StorageLocation` to be designated as the **Default Staging Location**.
   - The manager provides the unique identifier of an existing `StorageLocation` to be designated as the **Default Quarantine Location**.

3. **Outcome:**
   - The system validates that both provided `StorageLocation` identifiers are:
     - Valid
     - Distinct (not the same location)
     - Belong to the specified `Site`
   - The system persists these two references against the `Site`'s configuration.
   - The system emits a `SiteDefaultsUpdated` event with the old and new values for auditing purposes.

## Alternate / Error Flows

1. **Unauthorized Access:** If the user does not have the required permissions to modify the `Site` configuration, the system rejects the request with a `403 Forbidden` error.

2. **Invalid `Site` ID:** If the specified `Site` does not exist, the system rejects the request with a `404 Not Found` error.

3. **Invalid `StorageLocation` ID:** If either the staging or quarantine `StorageLocation` ID does not exist or does not belong to the specified `Site`, the system rejects the request with a `400 Bad Request` or `422 Unprocessable Entity` validation error.

4. **Duplicate Location Assignment (Business Rule Violation):** If the same `StorageLocation` ID is provided for both staging and quarantine roles, the system rejects the request with a `400 Bad Request` validation error with error code `DEFAULT_LOCATION_ROLE_CONFLICT`.

## Business Rules

1. Each `Site` MUST be configurable with exactly one `Default Staging Location`.
2. Each `Site` MUST be configurable with exactly one `Default Quarantine Location`.
3. **The `Default Staging Location` and `Default Quarantine Location` for a single `Site` MUST be two distinct `StorageLocation`s.** (Enforced to prevent operational ambiguity and ensure physical/procedural separation.)
4. Inventory placed in a `Quarantine Location` is considered non-available stock. The permission model for moving items **out of** quarantine (e.g., `inventory.move.from_quarantine`) is defined and enforced by separate security and inventory execution stories. This story only marks the location as quarantine.

## Data Requirements

- The `Site` (or `Location`) entity/resource requires two new fields, both of which are references to a `StorageLocation`:
  - `defaultStagingLocationId: UUID`
  - `defaultQuarantineLocationId: UUID`

- An API endpoint must be created or updated to manage these settings:
  - **Example:** `PUT /api/v1/sites/{siteId}/default-locations`
  - **Example Payload:**
    ```json
    {
      "defaultStagingLocationId": "f47ac10b-58cc-4372-a567-0e02b2c3d479",
      "defaultQuarantineLocationId": "6ec0bd7f-11c0-43da-975e-2a8ad9ebae0b"
    }
    ```

## Acceptance Criteria

### AC1: Configure Defaults Successfully
- **Given** I am an authenticated `Inventory Manager`
- **And** Site "WH-1" exists with Storage Locations "STAGING-A" and "QUARANTINE-B"
- **When** I submit a request to set "STAGING-A" as the default staging location and "QUARANTINE-B" as the default quarantine location for "WH-1"
- **Then** the system returns a `200 OK` success response
- **And** a subsequent GET request for the configuration of "WH-1" shows the correct IDs for the default locations.

### AC2: Reject Invalid Storage Location
- **Given** I am an authenticated `Inventory Manager`
- **And** Site "WH-1" exists
- **When** I submit a request to set a non-existent Storage Location "FAKE-ID" as the default staging location
- **Then** the system returns a client error response (e.g., `400 Bad Request` or `422 Unprocessable Entity`) with a descriptive error message.

### AC3: Reject Duplicate Role Assignment (Business Rule Enforcement)
- **Given** I am an authenticated `Inventory Manager`
- **And** Site "WH-1" exists with Storage Location "COMMON-AREA"
- **When** I submit a request to set "COMMON-AREA" as both the default staging and default quarantine location
- **Then** the system returns a `400 Bad Request` validation error with error code `DEFAULT_LOCATION_ROLE_CONFLICT`
- **And** the error message states that the locations must be distinct.

### AC4: Reject Unauthorized Request
- **Given** I am an authenticated user without `Inventory Manager` permissions
- **When** I attempt to update the default locations for Site "WH-1"
- **Then** the system returns a `403 Forbidden` error.

### AC5: Validate Storage Location Belongs to Site
- **Given** I am an authenticated `Inventory Manager`
- **And** Site "WH-1" exists
- **And** Storage Location "STAGING-X" belongs to Site "WH-2" (different site)
- **When** I submit a request to set "STAGING-X" as the default staging location for "WH-1"
- **Then** the system returns a `400 Bad Request` or `422 Unprocessable Entity` error
- **And** the error message indicates the storage location does not belong to the specified site.

## Audit & Observability

- **Event Emission:** A `SiteDefaultsUpdated` event MUST be emitted to a message bus (e.g., Kafka, RabbitMQ) upon any successful change.

- **Event Payload:** The event should include:
  - `siteId`
  - `updatedByUserId`
  - `timestamp`
  - Previous values: `previousDefaultStagingLocationId`, `previousDefaultQuarantineLocationId`
  - New values: `newDefaultStagingLocationId`, `newDefaultQuarantineLocationId`

- **Logging:** A structured log entry at the `INFO` level should be created, capturing the user, site, and changes made for traceability.

## Related Stories

### Dependency (This Story Must Be Completed First)
This story is a prerequisite for:

- **[NEW STORY]**: "[BACKEND] [STORY] Receiving: Use Site-Default Staging Location"
  - Domain: `domain:workexec`
  - Description: Receiving workflow consumes the site-default staging and quarantine locations configured in this story.

## Original Story (Unmodified ‚Äì For Traceability)

# Issue #38 ‚Äî [BACKEND] [STORY] Topology: Define Default Staging and Quarantine Locations for Receiving

## Current Labels
- backend
- story-implementation
- user

## Current Body
## Backend Implementation for Story

**Original Story**: [STORY] Topology: Define Default Staging and Quarantine Locations for Receiving

**Domain**: user

### Story Description

/kiro
# User Story
## Narrative
As an **Inventory Manager**, I want default receiving staging and quarantine locations so that receiving workflows are consistent.

## Details
- Each site can define staging and quarantine locations.
- Quarantine requires approval to move into available stock.

## Acceptance Criteria
- Staging/quarantine configured per location.
- Receiving uses staging by default.
- Quarantine moves require permission.

## Integrations
- Distributor receiving may land in staging; quality hold uses quarantine.

## Data / Entities
- ReceivingPolicy, StorageLocationRef, PermissionCheck

## Classification (confirm labels)
- Type: Story
- Layer: Domain
- Domain: Inventory Management


### Backend Requirements

- Implement Spring Boot microservices
- Create REST API endpoints
- Implement business logic and data access
- Ensure proper security and validation

### Technical Stack

- Spring Boot 3.2.6
- Java 21
- Spring Data JPA
- PostgreSQL/MySQL

---
*This issue was automatically created by the Durion Workspace Agent*



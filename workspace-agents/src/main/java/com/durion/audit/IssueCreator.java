package com.durion.audit;

import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

/**
 * Automated GitHub Issue Creator for Missing Issues Audit System
 * 
 * Creates GitHub issues for missing frontend and backend implementation issues
 * using the same title and body format as the original processing system.
 * 
 * Requirements: 4.1, 4.2, 4.3, 4.4, 4.5
 */
public class IssueCreator {

    private final GitHubIssueCreator githubIssueCreator;
    private final AuditLogger logger;

    // Repository configuration
    private static final String FRONTEND_REPO = "louisburroughs/durion-moqui-frontend";
    private static final String BACKEND_REPO = "louisburroughs/durion-positivity-backend";

    // Issue template constants
    private static final String ISSUE_TEMPLATE = """
            ## ü§ñ Implementation Issue - Created by Durion Workspace Agent

            ### Original Story
            **Story**: #{storyNumber} - {storyTitle}
            **URL**: {storyUrl}
            **Domain**: {domain}

            ### Implementation Requirements
            This issue was automatically created by the Missing Issues Audit System to address a gap in the automated story processing workflow.

            The original story processing may have failed due to:
            - Rate limiting during automated processing
            - Network connectivity issues
            - Temporary GitHub API unavailability
            - Processing system interruption

            ### Implementation Notes
            - Review the original story requirements at the URL above
            - Ensure implementation aligns with the story acceptance criteria
            - Follow established patterns for {repositoryType} development
            - Coordinate with corresponding {oppositeType} implementation if needed

            ### Technical Requirements
            {technicalRequirements}

            ### Notes for Agents
            - This issue was created automatically by the Missing Issues Audit System
            - Original story processing may have failed due to rate limits or network issues
            - Ensure this implementation aligns with the original story requirements
            - {agentNotes}

            ### Labels Applied
            - `type:story` - Indicates this is a story implementation
            - `layer:functional` - Functional layer implementation
            - `kiro` - Created by Kiro automation
            - `domain:{domain}` - Business domain classification
            - `story-implementation` - Implementation of a story issue
            - `{repositoryType}` - Implementation type

            ---
            *Generated by Missing Issues Audit System - {timestamp}*
            """;

    public IssueCreator(GitHubIssueCreator githubIssueCreator, AuditLogger logger) {
        this.githubIssueCreator = githubIssueCreator;
        this.logger = logger;
    }

    /**
     * Creates a missing frontend implementation issue
     * 
     * @param missingIssue The missing issue details
     * @return The created GitHub issue
     * @throws IOException          if issue creation fails
     * @throws InterruptedException if the operation is interrupted
     */
    public GitHubIssue createFrontendIssue(MissingIssue missingIssue)
            throws IOException, InterruptedException {

        System.out.println("Creating frontend issue for story #" + missingIssue.getStoryNumber());

        String title = formatIssueTitle(missingIssue, "FRONTEND");
        String body = formatIssueBody(missingIssue, "frontend");
        List<String> labels = generateLabels(missingIssue, "frontend");

        try {
            GitHubIssue createdIssue = githubIssueCreator.createIssue(FRONTEND_REPO, title, body, labels);
            System.out.println("Successfully created frontend issue: " + createdIssue.getUrl());
            logger.logIssueCreation(missingIssue, true, null);
            return createdIssue;
        } catch (IOException e) {
            String errorMsg = "Failed to create frontend issue for story #" + missingIssue.getStoryNumber();
            logger.logError("createFrontendIssue", e, errorMsg);
            logger.logIssueCreation(missingIssue, false, e.getMessage());
            throw e;
        }
    }

    /**
     * Creates a missing backend implementation issue
     * 
     * @param missingIssue The missing issue details
     * @return The created GitHub issue
     * @throws IOException          if issue creation fails
     * @throws InterruptedException if the operation is interrupted
     */
    public GitHubIssue createBackendIssue(MissingIssue missingIssue)
            throws IOException, InterruptedException {

        System.out.println("Creating backend issue for story #" + missingIssue.getStoryNumber());

        String title = formatIssueTitle(missingIssue, "BACKEND");
        String body = formatIssueBody(missingIssue, "backend");
        List<String> labels = generateLabels(missingIssue, "backend");

        try {
            GitHubIssue createdIssue = githubIssueCreator.createIssue(BACKEND_REPO, title, body, labels);
            System.out.println("Successfully created backend issue: " + createdIssue.getUrl());
            logger.logIssueCreation(missingIssue, true, null);
            return createdIssue;
        } catch (IOException e) {
            String errorMsg = "Failed to create backend issue for story #" + missingIssue.getStoryNumber();
            logger.logError("createBackendIssue", e, errorMsg);
            logger.logIssueCreation(missingIssue, false, e.getMessage());
            throw e;
        }
    }

    /**
     * Creates both frontend and backend issues for a missing issue with enhanced
     * error handling
     * 
     * @param missingIssue The missing issue details
     * @return IssueCreationResult containing both created issues and status
     */
    public IssueCreationResult createBothIssues(MissingIssue missingIssue) {
        List<String> errors = new ArrayList<>();
        GitHubIssue frontendIssue = null;
        GitHubIssue backendIssue = null;

        System.out.println("üî® Creating issues for story #" + missingIssue.getStoryNumber());

        // Create frontend issue if needed
        if ("frontend".equals(missingIssue.getRepositoryType()) || "both".equals(missingIssue.getRepositoryType())) {
            frontendIssue = createIssueWithRetry(missingIssue, "frontend", errors);
        }

        // Create backend issue if needed
        if ("backend".equals(missingIssue.getRepositoryType()) || "both".equals(missingIssue.getRepositoryType())) {
            backendIssue = createIssueWithRetry(missingIssue, "backend", errors);
        }

        boolean success = (frontendIssue != null || backendIssue != null);
        String message = generateResultMessage(frontendIssue, backendIssue, errors);

        return new IssueCreationResult(frontendIssue, backendIssue, success, message, errors);
    }

    /**
     * Creates an issue with retry logic and comprehensive error handling
     * 
     * @param missingIssue   The missing issue details
     * @param repositoryType The repository type (frontend or backend)
     * @param errors         List to collect any errors encountered
     * @return The created GitHubIssue or null if creation failed
     */
    private GitHubIssue createIssueWithRetry(MissingIssue missingIssue, String repositoryType, List<String> errors) {
        final int MAX_RETRIES = 3;
        final long RETRY_DELAY_MS = 5000; // 5 seconds
        final long RATE_LIMIT_DELAY_MS = 60000; // 60 seconds for rate limit

        for (int attempt = 1; attempt <= MAX_RETRIES; attempt++) {
            try {
                System.out.println("üì§ Attempt " + attempt + "/" + MAX_RETRIES + " - Creating " + repositoryType
                        + " issue for story #" + missingIssue.getStoryNumber());

                GitHubIssue createdIssue;
                if ("frontend".equals(repositoryType)) {
                    createdIssue = createFrontendIssue(missingIssue);
                } else {
                    createdIssue = createBackendIssue(missingIssue);
                }

                System.out.println("‚úÖ Successfully created " + repositoryType + " issue on attempt " + attempt);
                return createdIssue;

            } catch (IOException e) {
                String errorMsg = "Attempt " + attempt + " failed for " + repositoryType + " issue: " + e.getMessage();
                System.out.println("‚ö†Ô∏è " + errorMsg);

                // Check if this is a rate limit error
                if (isRateLimitError(e)) {
                    System.out.println("üö¶ Rate limit detected - waiting " + (RATE_LIMIT_DELAY_MS / 1000)
                            + " seconds before retry");
                    logger.logError("createIssueWithRetry", e, "Rate limit encountered on attempt " + attempt
                            + " for story #" + missingIssue.getStoryNumber());

                    if (attempt < MAX_RETRIES) {
                        try {
                            Thread.sleep(RATE_LIMIT_DELAY_MS);
                        } catch (InterruptedException ie) {
                            Thread.currentThread().interrupt();
                            String interruptMsg = "Thread interrupted during rate limit wait for " + repositoryType
                                    + " issue";
                            errors.add(interruptMsg);
                            logger.logError("createIssueWithRetry", ie, interruptMsg);
                            break;
                        }
                    }
                } else if (isRetryableError(e)) {
                    // Network or temporary errors - retry with shorter delay
                    System.out.println("üîÑ Retryable error detected - waiting " + (RETRY_DELAY_MS / 1000)
                            + " seconds before retry");
                    logger.logError("createIssueWithRetry", e,
                            "Retryable error on attempt " + attempt + " for story #" + missingIssue.getStoryNumber());

                    if (attempt < MAX_RETRIES) {
                        try {
                            Thread.sleep(RETRY_DELAY_MS);
                        } catch (InterruptedException ie) {
                            Thread.currentThread().interrupt();
                            String interruptMsg = "Thread interrupted during retry wait for " + repositoryType
                                    + " issue";
                            errors.add(interruptMsg);
                            logger.logError("createIssueWithRetry", ie, interruptMsg);
                            break;
                        }
                    }
                } else {
                    // Non-retryable error - fail immediately
                    System.out.println("‚ùå Non-retryable error - failing immediately");
                    errors.add(errorMsg);
                    logger.logError("createIssueWithRetry", e,
                            "Non-retryable error for story #" + missingIssue.getStoryNumber());
                    logger.logIssueCreation(missingIssue, false, e.getMessage());
                    break;
                }

                // If this is the last attempt, record the failure
                if (attempt == MAX_RETRIES) {
                    errors.add("Failed to create " + repositoryType + " issue after " + MAX_RETRIES + " attempts: "
                            + e.getMessage());
                    logger.logIssueCreation(missingIssue, false,
                            "Failed after " + MAX_RETRIES + " attempts: " + e.getMessage());
                }

            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                String interruptMsg = "Issue creation interrupted for " + repositoryType + " issue";
                errors.add(interruptMsg);
                logger.logError("createIssueWithRetry", e, interruptMsg);
                break;

            } catch (Exception e) {
                // Unexpected error - log and fail
                String unexpectedMsg = "Unexpected error creating " + repositoryType + " issue: " + e.getMessage();
                errors.add(unexpectedMsg);
                logger.logError("createIssueWithRetry", e,
                        "Unexpected error for story #" + missingIssue.getStoryNumber());
                logger.logIssueCreation(missingIssue, false, e.getMessage());
                break;
            }
        }

        return null; // All attempts failed
    }

    /**
     * Determines if an IOException is a rate limit error
     * 
     * @param e The IOException to check
     * @return true if this is a rate limit error
     */
    private boolean isRateLimitError(IOException e) {
        String message = e.getMessage().toLowerCase();
        return message.contains("rate limit") ||
                message.contains("403") ||
                message.contains("too many requests") ||
                message.contains("secondary rate limit");
    }

    /**
     * Determines if an IOException is retryable (network/temporary issues)
     * 
     * @param e The IOException to check
     * @return true if this error should be retried
     */
    private boolean isRetryableError(IOException e) {
        String message = e.getMessage().toLowerCase();
        return message.contains("timeout") ||
                message.contains("connection") ||
                message.contains("network") ||
                message.contains("502") ||
                message.contains("503") ||
                message.contains("504") ||
                message.contains("bad gateway") ||
                message.contains("service unavailable") ||
                message.contains("gateway timeout");
    }

    /**
     * Generates a descriptive result message based on creation outcomes
     * 
     * @param frontendIssue The created frontend issue (or null)
     * @param backendIssue  The created backend issue (or null)
     * @param errors        List of errors encountered
     * @return Descriptive message about the creation results
     */
    private String generateResultMessage(GitHubIssue frontendIssue, GitHubIssue backendIssue, List<String> errors) {
        if (frontendIssue != null && backendIssue != null) {
            return "Both frontend and backend issues created successfully";
        } else if (frontendIssue != null) {
            return "Frontend issue created successfully" + (errors.isEmpty() ? "" : ", but backend creation failed");
        } else if (backendIssue != null) {
            return "Backend issue created successfully" + (errors.isEmpty() ? "" : ", but frontend creation failed");
        } else {
            return "Failed to create any issues" + (errors.isEmpty() ? "" : ": " + String.join("; ", errors));
        }
    }

    /**
     * Creates multiple issues in batch with resilient error handling
     * 
     * @param missingIssues List of missing issues to create
     * @return BatchCreationResult containing all results and statistics
     */
    public BatchCreationResult createIssuesBatch(List<MissingIssue> missingIssues) {
        System.out.println("üöÄ Starting batch issue creation for " + missingIssues.size() + " missing issues");

        List<IssueCreationResult> results = new ArrayList<>();
        int successCount = 0;
        int failureCount = 0;
        List<String> batchErrors = new ArrayList<>();

        for (int i = 0; i < missingIssues.size(); i++) {
            MissingIssue missingIssue = missingIssues.get(i);

            System.out.println("üìã Processing " + (i + 1) + "/" + missingIssues.size() + " - Story #"
                    + missingIssue.getStoryNumber());

            try {
                IssueCreationResult result = createBothIssues(missingIssue);
                results.add(result);

                if (result.isSuccess()) {
                    successCount++;
                    System.out.println("‚úÖ Story #" + missingIssue.getStoryNumber() + " - " + result.getMessage());
                } else {
                    failureCount++;
                    System.out.println("‚ùå Story #" + missingIssue.getStoryNumber() + " - " + result.getMessage());
                    batchErrors.addAll(result.getErrors());
                }

                // Add delay between issues to avoid overwhelming the API
                if (i < missingIssues.size() - 1) { // Don't delay after the last issue
                    try {
                        Thread.sleep(2000); // 2 second delay between issues
                    } catch (InterruptedException e) {
                        Thread.currentThread().interrupt();
                        System.out.println("‚ö†Ô∏è Batch processing interrupted");
                        break;
                    }
                }

            } catch (Exception e) {
                failureCount++;
                String error = "Unexpected error processing story #" + missingIssue.getStoryNumber() + ": "
                        + e.getMessage();
                batchErrors.add(error);
                logger.logError("createIssuesBatch", e,
                        "Batch processing error for story #" + missingIssue.getStoryNumber());

                // Create a failure result for this issue
                results.add(new IssueCreationResult(null, null, false, error, List.of(error)));
            }
        }

        System.out
                .println("üèÅ Batch creation completed: " + successCount + " successes, " + failureCount + " failures");

        return new BatchCreationResult(results, successCount, failureCount, batchErrors);
    }

    /**
     * Creates multiple issues in batch with resilient error handling and report
     * updates
     * 
     * @param missingIssues List of missing issues to create
     * @param reportUpdater Optional report updater for updating reports after
     *                      creation
     * @return BatchCreationResult containing all results and statistics
     */
    public BatchCreationResult createIssuesBatchWithReporting(List<MissingIssue> missingIssues,
            ReportUpdater reportUpdater) {
        System.out.println(
                "üöÄ Starting batch issue creation with reporting for " + missingIssues.size() + " missing issues");

        BatchCreationResult batchResult = createIssuesBatch(missingIssues);

        // Update reports if report updater is provided
        if (reportUpdater != null) {
            try {
                System.out.println("üìä Updating reports with creation results...");

                // Generate creation status report
                String statusReportPath = reportUpdater.createCreationStatusReport(batchResult, missingIssues);
                System.out.println("‚úÖ Creation status report generated: " + statusReportPath);

                // Generate creation summary
                String summaryPath = reportUpdater.generateCreationSummary(batchResult, missingIssues);
                System.out.println("‚úÖ Creation summary generated: " + summaryPath);

            } catch (Exception e) {
                System.out.println("‚ö†Ô∏è Failed to update reports: " + e.getMessage());
                logger.logError("createIssuesBatchWithReporting", e, "Report update failed after batch creation");
            }
        }

        return batchResult;
    }

    /**
     * Formats the issue title using the same pattern as the original processing
     * system
     * 
     * @param missingIssue The missing issue details
     * @param prefix       The prefix (FRONTEND or BACKEND)
     * @return Formatted issue title
     */
    private String formatIssueTitle(MissingIssue missingIssue, String prefix) {
        return String.format("[%s] %s", prefix, missingIssue.getStoryTitle());
    }

    /**
     * Formats the issue body using the established template
     * 
     * @param missingIssue   The missing issue details
     * @param repositoryType The repository type (frontend or backend)
     * @return Formatted issue body
     */
    private String formatIssueBody(MissingIssue missingIssue, String repositoryType) {
        String oppositeType = "frontend".equals(repositoryType) ? "backend" : "frontend";

        String technicalRequirements = generateTechnicalRequirements(repositoryType);
        String agentNotes = generateAgentNotes(repositoryType);

        return ISSUE_TEMPLATE
                .replace("{storyNumber}", String.valueOf(missingIssue.getStoryNumber()))
                .replace("{storyTitle}", missingIssue.getStoryTitle())
                .replace("{storyUrl}", missingIssue.getStoryUrl())
                .replace("{domain}", "general")
                .replace("{repositoryType}", repositoryType)
                .replace("{oppositeType}", oppositeType)
                .replace("{technicalRequirements}", technicalRequirements)
                .replace("{agentNotes}", agentNotes)
                .replace("{timestamp}", LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));
    }

    /**
     * Generates appropriate labels for the issue
     * 
     * @param missingIssue   The missing issue details
     * @param repositoryType The repository type (frontend or backend)
     * @return List of labels to apply
     */
    private List<String> generateLabels(MissingIssue missingIssue, String repositoryType) {
        List<String> labels = new ArrayList<>();

        // Standard labels
        labels.add("type:story");
        labels.add("layer:functional");
        labels.add("kiro");
        labels.add("story-implementation");

        // Repository type label
        labels.add(repositoryType);

        return labels;
    }

    /**
     * Generates technical requirements based on repository type
     * 
     * @param repositoryType The repository type (frontend or backend)
     * @return Technical requirements text
     */
    private String generateTechnicalRequirements(String repositoryType) {
        if ("frontend".equals(repositoryType)) {
            return """
                    **Frontend Implementation Requirements:**
                    - Use Vue.js 3 with Composition API
                    - Follow TypeScript best practices
                    - Implement using Quasar UI framework components
                    - Ensure responsive design and accessibility (WCAG 2.1)
                    - Handle loading states and error conditions gracefully
                    - Implement proper form validation where applicable
                    - Follow established routing and state management patterns
                    """;
        } else {
            return """
                    **Backend Implementation Requirements:**
                    - Use Spring Boot with Java 21
                    - Implement RESTful API endpoints following established patterns
                    - Include proper request/response validation
                    - Implement business logic with appropriate error handling
                    - Ensure database operations are transactional where needed
                    - Include comprehensive logging for debugging
                    - Follow security best practices for authentication/authorization
                    """;
        }
    }

    /**
     * Generates agent-specific notes based on repository type
     * 
     * @param repositoryType The repository type (frontend or backend)
     * @return Agent notes text
     */
    private String generateAgentNotes(String repositoryType) {
        if ("frontend".equals(repositoryType)) {
            return "Frontend agents: Focus on Vue.js 3 components, TypeScript, Quasar UI framework. " +
                    "Coordinate with backend implementation for API contracts.";
        } else {
            return "Backend agents: Focus on Spring Boot microservices, Java 21, REST APIs, PostgreSQL. " +
                    "Ensure API contracts align with frontend requirements.";
        }
    }

    /**
     * Result of issue creation operations
     */
    public static class IssueCreationResult {
        private final GitHubIssue frontendIssue;
        private final GitHubIssue backendIssue;
        private final boolean success;
        private final String message;
        private final List<String> errors;

        public IssueCreationResult(GitHubIssue frontendIssue, GitHubIssue backendIssue,
                boolean success, String message, List<String> errors) {
            this.frontendIssue = frontendIssue;
            this.backendIssue = backendIssue;
            this.success = success;
            this.message = message;
            this.errors = new ArrayList<>(errors);
        }

        public GitHubIssue getFrontendIssue() {
            return frontendIssue;
        }

        public GitHubIssue getBackendIssue() {
            return backendIssue;
        }

        public boolean isSuccess() {
            return success;
        }

        public String getMessage() {
            return message;
        }

        public List<String> getErrors() {
            return new ArrayList<>(errors);
        }

        @Override
        public String toString() {
            return String.format("IssueCreationResult{success=%s, message='%s', errors=%d}",
                    success, message, errors.size());
        }
    }

    /**
     * Result of batch issue creation operations
     */
    public static class BatchCreationResult {
        private final List<IssueCreationResult> results;
        private final int successCount;
        private final int failureCount;
        private final List<String> batchErrors;

        public BatchCreationResult(List<IssueCreationResult> results, int successCount,
                int failureCount, List<String> batchErrors) {
            this.results = new ArrayList<>(results);
            this.successCount = successCount;
            this.failureCount = failureCount;
            this.batchErrors = new ArrayList<>(batchErrors);
        }

        public List<IssueCreationResult> getResults() {
            return new ArrayList<>(results);
        }

        public int getSuccessCount() {
            return successCount;
        }

        public int getFailureCount() {
            return failureCount;
        }

        public int getTotalCount() {
            return successCount + failureCount;
        }

        public List<String> getBatchErrors() {
            return new ArrayList<>(batchErrors);
        }

        public boolean isAllSuccessful() {
            return failureCount == 0;
        }

        public double getSuccessRate() {
            int total = getTotalCount();
            return total > 0 ? (double) successCount / total : 0.0;
        }

        @Override
        public String toString() {
            return String.format("BatchCreationResult{total=%d, success=%d, failure=%d, rate=%.1f%%}",
                    getTotalCount(), successCount, failureCount, getSuccessRate() * 100);
        }
    }
}